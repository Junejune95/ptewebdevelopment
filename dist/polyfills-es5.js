(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["polyfills-es5"], {
  /***/
  "./$$_lazy_route_resource lazy recursive":
  /*!******************************************************!*\
    !*** ./$$_lazy_route_resource lazy namespace object ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function $$_lazy_route_resourceLazyRecursive(module, exports, __webpack_require__) {
    var map = {
      "@app/modules/ai-store/ai-store.module": ["./src/app/modules/ai-store/ai-store.module.ts", "default~app-modules-ai-store-ai-store-module~app-modules-manage-individual-mock-individual-mock-modu~1abf45b8", "common", "app-modules-ai-store-ai-store-module"],
      "@app/modules/manage/individual-mock/individual-mock.module": ["./src/app/modules/manage/individual-mock/individual-mock.module.ts", "default~app-modules-ai-store-ai-store-module~app-modules-manage-individual-mock-individual-mock-modu~1abf45b8", "common", "app-modules-manage-individual-mock-individual-mock-module"],
      "@app/modules/manage/manage-questions/manage-questions.module": ["./src/app/modules/manage/manage-questions/manage-questions.module.ts", "default~app-modules-ai-store-ai-store-module~app-modules-manage-individual-mock-individual-mock-modu~1abf45b8", "common", "app-modules-manage-manage-questions-manage-questions-module"],
      "@app/modules/manage/manage-questions/question-create/question-create.module": ["./src/app/modules/manage/manage-questions/question-create/question-create.module.ts", "default~app-modules-ai-store-ai-store-module~app-modules-manage-individual-mock-individual-mock-modu~1abf45b8", "common", "app-modules-manage-manage-questions-question-create-question-create-module"],
      "@app/modules/manage/packages/packages.module": ["./src/app/modules/manage/packages/packages.module.ts", "default~app-modules-ai-store-ai-store-module~app-modules-manage-individual-mock-individual-mock-modu~1abf45b8", "common", "app-modules-manage-packages-packages-module"],
      "@app/modules/manage/practise/practise.module": ["./src/app/modules/manage/practise/practise.module.ts", "default~app-modules-ai-store-ai-store-module~app-modules-manage-individual-mock-individual-mock-modu~1abf45b8", "common", "app-modules-manage-practise-practise-module"],
      "@app/modules/manage/predictions/predictions.module": ["./src/app/modules/manage/predictions/predictions.module.ts", "default~app-modules-ai-store-ai-store-module~app-modules-manage-individual-mock-individual-mock-modu~1abf45b8", "common", "app-modules-manage-predictions-predictions-module"],
      "@app/modules/manage/study-plans/study-plans.module": ["./src/app/modules/manage/study-plans/study-plans.module.ts", "default~app-modules-ai-store-ai-store-module~app-modules-manage-individual-mock-individual-mock-modu~1abf45b8", "common", "app-modules-manage-study-plans-study-plans-module"],
      "@app/modules/manage/users/user.module": ["./src/app/modules/manage/users/user.module.ts", "default~app-modules-ai-store-ai-store-module~app-modules-manage-individual-mock-individual-mock-modu~1abf45b8", "common", "app-modules-manage-users-user-module"],
      "@app/modules/myaccount/myaccount.module": ["./src/app/modules/myaccount/myaccount.module.ts", "default~app-modules-ai-store-ai-store-module~app-modules-manage-individual-mock-individual-mock-modu~1abf45b8", "common", "app-modules-myaccount-myaccount-module"],
      "@app/modules/other-evaluate/other-evaluate.module": ["./src/app/modules/other-evaluate/other-evaluate.module.ts", "default~app-modules-ai-store-ai-store-module~app-modules-manage-individual-mock-individual-mock-modu~1abf45b8", "default~app-modules-other-evaluate-other-evaluate-module~app-modules-other-question-module-other-que~ba6936d6", "common", "app-modules-other-evaluate-other-evaluate-module"],
      "@app/modules/other-question-module/other-question-module.module": ["./src/app/modules/other-question-module/other-question-module.module.ts", "default~app-modules-ai-store-ai-store-module~app-modules-manage-individual-mock-individual-mock-modu~1abf45b8", "default~app-modules-other-evaluate-other-evaluate-module~app-modules-other-question-module-other-que~ba6936d6", "common", "app-modules-other-question-module-other-question-module-module"],
      "@app/modules/practise-evaluate/practise-evaluate.module": ["./src/app/modules/practise-evaluate/practise-evaluate.module.ts", "default~app-modules-ai-store-ai-store-module~app-modules-manage-individual-mock-individual-mock-modu~1abf45b8", "default~app-modules-other-evaluate-other-evaluate-module~app-modules-other-question-module-other-que~ba6936d6", "common", "app-modules-practise-evaluate-practise-evaluate-module"],
      "@app/modules/question-evaluate/question-evaluate.module": ["./src/app/modules/question-evaluate/question-evaluate.module.ts", "default~app-modules-ai-store-ai-store-module~app-modules-manage-individual-mock-individual-mock-modu~1abf45b8", "default~app-modules-other-evaluate-other-evaluate-module~app-modules-other-question-module-other-que~ba6936d6", "common", "app-modules-question-evaluate-question-evaluate-module"],
      "@modules/full-mock-test/full-mock-test.module": ["./src/app/modules/full-mock-test/full-mock-test.module.ts", "default~app-modules-ai-store-ai-store-module~app-modules-manage-individual-mock-individual-mock-modu~1abf45b8", "common", "modules-full-mock-test-full-mock-test-module"],
      "@modules/home/home.module": ["./src/app/modules/home/home.module.ts", "default~app-modules-ai-store-ai-store-module~app-modules-manage-individual-mock-individual-mock-modu~1abf45b8", "common", "modules-home-home-module"],
      "@modules/mainView/main-view.module": ["./src/app/modules/mainView/main-view.module.ts", "default~app-modules-ai-store-ai-store-module~app-modules-manage-individual-mock-individual-mock-modu~1abf45b8", "common", "modules-mainView-main-view-module"],
      "@modules/manage/manage.module": ["./src/app/modules/manage/manage.module.ts", "default~app-modules-ai-store-ai-store-module~app-modules-manage-individual-mock-individual-mock-modu~1abf45b8", "common", "modules-manage-manage-module"],
      "@modules/manage/mock-test/mock-test.module": ["./src/app/modules/manage/mock-test/mock-test.module.ts", "default~app-modules-ai-store-ai-store-module~app-modules-manage-individual-mock-individual-mock-modu~1abf45b8", "common", "modules-manage-mock-test-mock-test-module"],
      "@modules/questions/questions.module": ["./src/app/modules/questions/questions.module.ts", "default~app-modules-ai-store-ai-store-module~app-modules-manage-individual-mock-individual-mock-modu~1abf45b8", "common", "modules-questions-questions-module"]
    };

    function webpackAsyncContext(req) {
      if (!__webpack_require__.o(map, req)) {
        return Promise.resolve().then(function () {
          var e = new Error("Cannot find module '" + req + "'");
          e.code = 'MODULE_NOT_FOUND';
          throw e;
        });
      }

      var ids = map[req],
          id = ids[0];
      return Promise.all(ids.slice(1).map(__webpack_require__.e)).then(function () {
        return __webpack_require__(id);
      });
    }

    webpackAsyncContext.keys = function webpackAsyncContextKeys() {
      return Object.keys(map);
    };

    webpackAsyncContext.id = "./$$_lazy_route_resource lazy recursive";
    module.exports = webpackAsyncContext;
    /***/
  },

  /***/
  "./node_modules/@angular-devkit/build-angular/src/angular-cli-files/models/es5-jit-polyfills.js":
  /*!******************************************************************************************************!*\
    !*** ./node_modules/@angular-devkit/build-angular/src/angular-cli-files/models/es5-jit-polyfills.js ***!
    \******************************************************************************************************/

  /*! no exports provided */

  /***/
  function node_modulesAngularDevkitBuildAngularSrcAngularCliFilesModelsEs5JitPolyfillsJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony import */


    var core_js_es_reflect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! core-js/es/reflect */
    "./node_modules/core-js/es/reflect/index.js");
    /* harmony import */


    var core_js_es_reflect__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_es_reflect__WEBPACK_IMPORTED_MODULE_0__);
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /***/

  },

  /***/
  "./node_modules/@angular-devkit/build-angular/src/angular-cli-files/models/es5-polyfills.js":
  /*!**************************************************************************************************!*\
    !*** ./node_modules/@angular-devkit/build-angular/src/angular-cli-files/models/es5-polyfills.js ***!
    \**************************************************************************************************/

  /*! no exports provided */

  /***/
  function node_modulesAngularDevkitBuildAngularSrcAngularCliFilesModelsEs5PolyfillsJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony import */


    var core_js_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! core-js/es/symbol */
    "./node_modules/core-js/es/symbol/index.js");
    /* harmony import */


    var core_js_es_symbol__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_es_symbol__WEBPACK_IMPORTED_MODULE_0__);
    /* harmony import */


    var core_js_modules_es_function_bind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! core-js/modules/es.function.bind */
    "./node_modules/core-js/modules/es.function.bind.js");
    /* harmony import */


    var core_js_modules_es_function_bind__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_function_bind__WEBPACK_IMPORTED_MODULE_1__);
    /* harmony import */


    var core_js_modules_es_function_name__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! core-js/modules/es.function.name */
    "./node_modules/core-js/modules/es.function.name.js");
    /* harmony import */


    var core_js_modules_es_function_name__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_function_name__WEBPACK_IMPORTED_MODULE_2__);
    /* harmony import */


    var core_js_modules_es_function_has_instance__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! core-js/modules/es.function.has-instance */
    "./node_modules/core-js/modules/es.function.has-instance.js");
    /* harmony import */


    var core_js_modules_es_function_has_instance__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_function_has_instance__WEBPACK_IMPORTED_MODULE_3__);
    /* harmony import */


    var core_js_modules_es_object_create__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! core-js/modules/es.object.create */
    "./node_modules/core-js/modules/es.object.create.js");
    /* harmony import */


    var core_js_modules_es_object_create__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_create__WEBPACK_IMPORTED_MODULE_4__);
    /* harmony import */


    var core_js_modules_es_object_define_property__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! core-js/modules/es.object.define-property */
    "./node_modules/core-js/modules/es.object.define-property.js");
    /* harmony import */


    var core_js_modules_es_object_define_property__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_define_property__WEBPACK_IMPORTED_MODULE_5__);
    /* harmony import */


    var core_js_modules_es_object_define_properties__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! core-js/modules/es.object.define-properties */
    "./node_modules/core-js/modules/es.object.define-properties.js");
    /* harmony import */


    var core_js_modules_es_object_define_properties__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_define_properties__WEBPACK_IMPORTED_MODULE_6__);
    /* harmony import */


    var core_js_modules_es_object_get_own_property_descriptor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
    /*! core-js/modules/es.object.get-own-property-descriptor */
    "./node_modules/core-js/modules/es.object.get-own-property-descriptor.js");
    /* harmony import */


    var core_js_modules_es_object_get_own_property_descriptor__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_get_own_property_descriptor__WEBPACK_IMPORTED_MODULE_7__);
    /* harmony import */


    var core_js_modules_es_object_get_prototype_of__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
    /*! core-js/modules/es.object.get-prototype-of */
    "./node_modules/core-js/modules/es.object.get-prototype-of.js");
    /* harmony import */


    var core_js_modules_es_object_get_prototype_of__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_get_prototype_of__WEBPACK_IMPORTED_MODULE_8__);
    /* harmony import */


    var core_js_modules_es_object_keys__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
    /*! core-js/modules/es.object.keys */
    "./node_modules/core-js/modules/es.object.keys.js");
    /* harmony import */


    var core_js_modules_es_object_keys__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_keys__WEBPACK_IMPORTED_MODULE_9__);
    /* harmony import */


    var core_js_modules_es_object_get_own_property_names__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
    /*! core-js/modules/es.object.get-own-property-names */
    "./node_modules/core-js/modules/es.object.get-own-property-names.js");
    /* harmony import */


    var core_js_modules_es_object_get_own_property_names__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_get_own_property_names__WEBPACK_IMPORTED_MODULE_10__);
    /* harmony import */


    var core_js_modules_es_object_freeze__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
    /*! core-js/modules/es.object.freeze */
    "./node_modules/core-js/modules/es.object.freeze.js");
    /* harmony import */


    var core_js_modules_es_object_freeze__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_freeze__WEBPACK_IMPORTED_MODULE_11__);
    /* harmony import */


    var core_js_modules_es_object_seal__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(
    /*! core-js/modules/es.object.seal */
    "./node_modules/core-js/modules/es.object.seal.js");
    /* harmony import */


    var core_js_modules_es_object_seal__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_seal__WEBPACK_IMPORTED_MODULE_12__);
    /* harmony import */


    var core_js_modules_es_object_prevent_extensions__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(
    /*! core-js/modules/es.object.prevent-extensions */
    "./node_modules/core-js/modules/es.object.prevent-extensions.js");
    /* harmony import */


    var core_js_modules_es_object_prevent_extensions__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_prevent_extensions__WEBPACK_IMPORTED_MODULE_13__);
    /* harmony import */


    var core_js_modules_es_object_is_frozen__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(
    /*! core-js/modules/es.object.is-frozen */
    "./node_modules/core-js/modules/es.object.is-frozen.js");
    /* harmony import */


    var core_js_modules_es_object_is_frozen__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_is_frozen__WEBPACK_IMPORTED_MODULE_14__);
    /* harmony import */


    var core_js_modules_es_object_is_sealed__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(
    /*! core-js/modules/es.object.is-sealed */
    "./node_modules/core-js/modules/es.object.is-sealed.js");
    /* harmony import */


    var core_js_modules_es_object_is_sealed__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_is_sealed__WEBPACK_IMPORTED_MODULE_15__);
    /* harmony import */


    var core_js_modules_es_object_is_extensible__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(
    /*! core-js/modules/es.object.is-extensible */
    "./node_modules/core-js/modules/es.object.is-extensible.js");
    /* harmony import */


    var core_js_modules_es_object_is_extensible__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_is_extensible__WEBPACK_IMPORTED_MODULE_16__);
    /* harmony import */


    var core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(
    /*! core-js/modules/es.object.assign */
    "./node_modules/core-js/modules/es.object.assign.js");
    /* harmony import */


    var core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_assign__WEBPACK_IMPORTED_MODULE_17__);
    /* harmony import */


    var core_js_modules_es_object_is__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(
    /*! core-js/modules/es.object.is */
    "./node_modules/core-js/modules/es.object.is.js");
    /* harmony import */


    var core_js_modules_es_object_is__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_is__WEBPACK_IMPORTED_MODULE_18__);
    /* harmony import */


    var core_js_modules_es_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(
    /*! core-js/modules/es.object.set-prototype-of */
    "./node_modules/core-js/modules/es.object.set-prototype-of.js");
    /* harmony import */


    var core_js_modules_es_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_set_prototype_of__WEBPACK_IMPORTED_MODULE_19__);
    /* harmony import */


    var core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(
    /*! core-js/modules/es.object.to-string */
    "./node_modules/core-js/modules/es.object.to-string.js");
    /* harmony import */


    var core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_20__);
    /* harmony import */


    var core_js_modules_es_array_concat__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(
    /*! core-js/modules/es.array.concat */
    "./node_modules/core-js/modules/es.array.concat.js");
    /* harmony import */


    var core_js_modules_es_array_concat__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_concat__WEBPACK_IMPORTED_MODULE_21__);
    /* harmony import */


    var core_js_modules_es_array_is_array__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(
    /*! core-js/modules/es.array.is-array */
    "./node_modules/core-js/modules/es.array.is-array.js");
    /* harmony import */


    var core_js_modules_es_array_is_array__WEBPACK_IMPORTED_MODULE_22___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_is_array__WEBPACK_IMPORTED_MODULE_22__);
    /* harmony import */


    var core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(
    /*! core-js/modules/es.array.from */
    "./node_modules/core-js/modules/es.array.from.js");
    /* harmony import */


    var core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_23___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_from__WEBPACK_IMPORTED_MODULE_23__);
    /* harmony import */


    var core_js_modules_es_array_of__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(
    /*! core-js/modules/es.array.of */
    "./node_modules/core-js/modules/es.array.of.js");
    /* harmony import */


    var core_js_modules_es_array_of__WEBPACK_IMPORTED_MODULE_24___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_of__WEBPACK_IMPORTED_MODULE_24__);
    /* harmony import */


    var core_js_modules_es_array_join__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(
    /*! core-js/modules/es.array.join */
    "./node_modules/core-js/modules/es.array.join.js");
    /* harmony import */


    var core_js_modules_es_array_join__WEBPACK_IMPORTED_MODULE_25___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_join__WEBPACK_IMPORTED_MODULE_25__);
    /* harmony import */


    var core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(
    /*! core-js/modules/es.array.slice */
    "./node_modules/core-js/modules/es.array.slice.js");
    /* harmony import */


    var core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_26___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_slice__WEBPACK_IMPORTED_MODULE_26__);
    /* harmony import */


    var core_js_modules_es_array_splice__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(
    /*! core-js/modules/es.array.splice */
    "./node_modules/core-js/modules/es.array.splice.js");
    /* harmony import */


    var core_js_modules_es_array_splice__WEBPACK_IMPORTED_MODULE_27___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_splice__WEBPACK_IMPORTED_MODULE_27__);
    /* harmony import */


    var core_js_modules_es_array_sort__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(
    /*! core-js/modules/es.array.sort */
    "./node_modules/core-js/modules/es.array.sort.js");
    /* harmony import */


    var core_js_modules_es_array_sort__WEBPACK_IMPORTED_MODULE_28___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_sort__WEBPACK_IMPORTED_MODULE_28__);
    /* harmony import */


    var core_js_modules_es_array_for_each__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(
    /*! core-js/modules/es.array.for-each */
    "./node_modules/core-js/modules/es.array.for-each.js");
    /* harmony import */


    var core_js_modules_es_array_for_each__WEBPACK_IMPORTED_MODULE_29___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_for_each__WEBPACK_IMPORTED_MODULE_29__);
    /* harmony import */


    var core_js_modules_es_array_map__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(
    /*! core-js/modules/es.array.map */
    "./node_modules/core-js/modules/es.array.map.js");
    /* harmony import */


    var core_js_modules_es_array_map__WEBPACK_IMPORTED_MODULE_30___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_map__WEBPACK_IMPORTED_MODULE_30__);
    /* harmony import */


    var core_js_modules_es_array_filter__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(
    /*! core-js/modules/es.array.filter */
    "./node_modules/core-js/modules/es.array.filter.js");
    /* harmony import */


    var core_js_modules_es_array_filter__WEBPACK_IMPORTED_MODULE_31___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_filter__WEBPACK_IMPORTED_MODULE_31__);
    /* harmony import */


    var core_js_modules_es_array_some__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(
    /*! core-js/modules/es.array.some */
    "./node_modules/core-js/modules/es.array.some.js");
    /* harmony import */


    var core_js_modules_es_array_some__WEBPACK_IMPORTED_MODULE_32___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_some__WEBPACK_IMPORTED_MODULE_32__);
    /* harmony import */


    var core_js_modules_es_array_every__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(
    /*! core-js/modules/es.array.every */
    "./node_modules/core-js/modules/es.array.every.js");
    /* harmony import */


    var core_js_modules_es_array_every__WEBPACK_IMPORTED_MODULE_33___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_every__WEBPACK_IMPORTED_MODULE_33__);
    /* harmony import */


    var core_js_modules_es_array_reduce__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(
    /*! core-js/modules/es.array.reduce */
    "./node_modules/core-js/modules/es.array.reduce.js");
    /* harmony import */


    var core_js_modules_es_array_reduce__WEBPACK_IMPORTED_MODULE_34___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_reduce__WEBPACK_IMPORTED_MODULE_34__);
    /* harmony import */


    var core_js_modules_es_array_reduce_right__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(
    /*! core-js/modules/es.array.reduce-right */
    "./node_modules/core-js/modules/es.array.reduce-right.js");
    /* harmony import */


    var core_js_modules_es_array_reduce_right__WEBPACK_IMPORTED_MODULE_35___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_reduce_right__WEBPACK_IMPORTED_MODULE_35__);
    /* harmony import */


    var core_js_modules_es_array_index_of__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(
    /*! core-js/modules/es.array.index-of */
    "./node_modules/core-js/modules/es.array.index-of.js");
    /* harmony import */


    var core_js_modules_es_array_index_of__WEBPACK_IMPORTED_MODULE_36___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_index_of__WEBPACK_IMPORTED_MODULE_36__);
    /* harmony import */


    var core_js_modules_es_array_last_index_of__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(
    /*! core-js/modules/es.array.last-index-of */
    "./node_modules/core-js/modules/es.array.last-index-of.js");
    /* harmony import */


    var core_js_modules_es_array_last_index_of__WEBPACK_IMPORTED_MODULE_37___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_last_index_of__WEBPACK_IMPORTED_MODULE_37__);
    /* harmony import */


    var core_js_modules_es_array_copy_within__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(
    /*! core-js/modules/es.array.copy-within */
    "./node_modules/core-js/modules/es.array.copy-within.js");
    /* harmony import */


    var core_js_modules_es_array_copy_within__WEBPACK_IMPORTED_MODULE_38___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_copy_within__WEBPACK_IMPORTED_MODULE_38__);
    /* harmony import */


    var core_js_modules_es_array_fill__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(
    /*! core-js/modules/es.array.fill */
    "./node_modules/core-js/modules/es.array.fill.js");
    /* harmony import */


    var core_js_modules_es_array_fill__WEBPACK_IMPORTED_MODULE_39___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_fill__WEBPACK_IMPORTED_MODULE_39__);
    /* harmony import */


    var core_js_modules_es_array_find__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(
    /*! core-js/modules/es.array.find */
    "./node_modules/core-js/modules/es.array.find.js");
    /* harmony import */


    var core_js_modules_es_array_find__WEBPACK_IMPORTED_MODULE_40___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_find__WEBPACK_IMPORTED_MODULE_40__);
    /* harmony import */


    var core_js_modules_es_array_find_index__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(
    /*! core-js/modules/es.array.find-index */
    "./node_modules/core-js/modules/es.array.find-index.js");
    /* harmony import */


    var core_js_modules_es_array_find_index__WEBPACK_IMPORTED_MODULE_41___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_find_index__WEBPACK_IMPORTED_MODULE_41__);
    /* harmony import */


    var core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(
    /*! core-js/modules/es.array.iterator */
    "./node_modules/core-js/modules/es.array.iterator.js");
    /* harmony import */


    var core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_42___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_42__);
    /* harmony import */


    var core_js_modules_es_string_from_code_point__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(
    /*! core-js/modules/es.string.from-code-point */
    "./node_modules/core-js/modules/es.string.from-code-point.js");
    /* harmony import */


    var core_js_modules_es_string_from_code_point__WEBPACK_IMPORTED_MODULE_43___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_from_code_point__WEBPACK_IMPORTED_MODULE_43__);
    /* harmony import */


    var core_js_modules_es_string_raw__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(
    /*! core-js/modules/es.string.raw */
    "./node_modules/core-js/modules/es.string.raw.js");
    /* harmony import */


    var core_js_modules_es_string_raw__WEBPACK_IMPORTED_MODULE_44___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_raw__WEBPACK_IMPORTED_MODULE_44__);
    /* harmony import */


    var core_js_modules_es_string_trim__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(
    /*! core-js/modules/es.string.trim */
    "./node_modules/core-js/modules/es.string.trim.js");
    /* harmony import */


    var core_js_modules_es_string_trim__WEBPACK_IMPORTED_MODULE_45___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_trim__WEBPACK_IMPORTED_MODULE_45__);
    /* harmony import */


    var core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(
    /*! core-js/modules/es.string.iterator */
    "./node_modules/core-js/modules/es.string.iterator.js");
    /* harmony import */


    var core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_46___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_46__);
    /* harmony import */


    var core_js_modules_es_string_code_point_at__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(
    /*! core-js/modules/es.string.code-point-at */
    "./node_modules/core-js/modules/es.string.code-point-at.js");
    /* harmony import */


    var core_js_modules_es_string_code_point_at__WEBPACK_IMPORTED_MODULE_47___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_code_point_at__WEBPACK_IMPORTED_MODULE_47__);
    /* harmony import */


    var core_js_modules_es_string_ends_with__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(
    /*! core-js/modules/es.string.ends-with */
    "./node_modules/core-js/modules/es.string.ends-with.js");
    /* harmony import */


    var core_js_modules_es_string_ends_with__WEBPACK_IMPORTED_MODULE_48___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_ends_with__WEBPACK_IMPORTED_MODULE_48__);
    /* harmony import */


    var core_js_modules_es_string_includes__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(
    /*! core-js/modules/es.string.includes */
    "./node_modules/core-js/modules/es.string.includes.js");
    /* harmony import */


    var core_js_modules_es_string_includes__WEBPACK_IMPORTED_MODULE_49___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_includes__WEBPACK_IMPORTED_MODULE_49__);
    /* harmony import */


    var core_js_modules_es_string_repeat__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(
    /*! core-js/modules/es.string.repeat */
    "./node_modules/core-js/modules/es.string.repeat.js");
    /* harmony import */


    var core_js_modules_es_string_repeat__WEBPACK_IMPORTED_MODULE_50___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_repeat__WEBPACK_IMPORTED_MODULE_50__);
    /* harmony import */


    var core_js_modules_es_string_starts_with__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(
    /*! core-js/modules/es.string.starts-with */
    "./node_modules/core-js/modules/es.string.starts-with.js");
    /* harmony import */


    var core_js_modules_es_string_starts_with__WEBPACK_IMPORTED_MODULE_51___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_starts_with__WEBPACK_IMPORTED_MODULE_51__);
    /* harmony import */


    var core_js_modules_es_string_anchor__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(
    /*! core-js/modules/es.string.anchor */
    "./node_modules/core-js/modules/es.string.anchor.js");
    /* harmony import */


    var core_js_modules_es_string_anchor__WEBPACK_IMPORTED_MODULE_52___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_anchor__WEBPACK_IMPORTED_MODULE_52__);
    /* harmony import */


    var core_js_modules_es_string_big__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(
    /*! core-js/modules/es.string.big */
    "./node_modules/core-js/modules/es.string.big.js");
    /* harmony import */


    var core_js_modules_es_string_big__WEBPACK_IMPORTED_MODULE_53___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_big__WEBPACK_IMPORTED_MODULE_53__);
    /* harmony import */


    var core_js_modules_es_string_blink__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(
    /*! core-js/modules/es.string.blink */
    "./node_modules/core-js/modules/es.string.blink.js");
    /* harmony import */


    var core_js_modules_es_string_blink__WEBPACK_IMPORTED_MODULE_54___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_blink__WEBPACK_IMPORTED_MODULE_54__);
    /* harmony import */


    var core_js_modules_es_string_bold__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(
    /*! core-js/modules/es.string.bold */
    "./node_modules/core-js/modules/es.string.bold.js");
    /* harmony import */


    var core_js_modules_es_string_bold__WEBPACK_IMPORTED_MODULE_55___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_bold__WEBPACK_IMPORTED_MODULE_55__);
    /* harmony import */


    var core_js_modules_es_string_fixed__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(
    /*! core-js/modules/es.string.fixed */
    "./node_modules/core-js/modules/es.string.fixed.js");
    /* harmony import */


    var core_js_modules_es_string_fixed__WEBPACK_IMPORTED_MODULE_56___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_fixed__WEBPACK_IMPORTED_MODULE_56__);
    /* harmony import */


    var core_js_modules_es_string_fontcolor__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(
    /*! core-js/modules/es.string.fontcolor */
    "./node_modules/core-js/modules/es.string.fontcolor.js");
    /* harmony import */


    var core_js_modules_es_string_fontcolor__WEBPACK_IMPORTED_MODULE_57___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_fontcolor__WEBPACK_IMPORTED_MODULE_57__);
    /* harmony import */


    var core_js_modules_es_string_fontsize__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(
    /*! core-js/modules/es.string.fontsize */
    "./node_modules/core-js/modules/es.string.fontsize.js");
    /* harmony import */


    var core_js_modules_es_string_fontsize__WEBPACK_IMPORTED_MODULE_58___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_fontsize__WEBPACK_IMPORTED_MODULE_58__);
    /* harmony import */


    var core_js_modules_es_string_italics__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(
    /*! core-js/modules/es.string.italics */
    "./node_modules/core-js/modules/es.string.italics.js");
    /* harmony import */


    var core_js_modules_es_string_italics__WEBPACK_IMPORTED_MODULE_59___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_italics__WEBPACK_IMPORTED_MODULE_59__);
    /* harmony import */


    var core_js_modules_es_string_link__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(
    /*! core-js/modules/es.string.link */
    "./node_modules/core-js/modules/es.string.link.js");
    /* harmony import */


    var core_js_modules_es_string_link__WEBPACK_IMPORTED_MODULE_60___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_link__WEBPACK_IMPORTED_MODULE_60__);
    /* harmony import */


    var core_js_modules_es_string_small__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(
    /*! core-js/modules/es.string.small */
    "./node_modules/core-js/modules/es.string.small.js");
    /* harmony import */


    var core_js_modules_es_string_small__WEBPACK_IMPORTED_MODULE_61___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_small__WEBPACK_IMPORTED_MODULE_61__);
    /* harmony import */


    var core_js_modules_es_string_strike__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(
    /*! core-js/modules/es.string.strike */
    "./node_modules/core-js/modules/es.string.strike.js");
    /* harmony import */


    var core_js_modules_es_string_strike__WEBPACK_IMPORTED_MODULE_62___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_strike__WEBPACK_IMPORTED_MODULE_62__);
    /* harmony import */


    var core_js_modules_es_string_sub__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(
    /*! core-js/modules/es.string.sub */
    "./node_modules/core-js/modules/es.string.sub.js");
    /* harmony import */


    var core_js_modules_es_string_sub__WEBPACK_IMPORTED_MODULE_63___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_sub__WEBPACK_IMPORTED_MODULE_63__);
    /* harmony import */


    var core_js_modules_es_string_sup__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(
    /*! core-js/modules/es.string.sup */
    "./node_modules/core-js/modules/es.string.sup.js");
    /* harmony import */


    var core_js_modules_es_string_sup__WEBPACK_IMPORTED_MODULE_64___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_sup__WEBPACK_IMPORTED_MODULE_64__);
    /* harmony import */


    var core_js_modules_es_string_match__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(
    /*! core-js/modules/es.string.match */
    "./node_modules/core-js/modules/es.string.match.js");
    /* harmony import */


    var core_js_modules_es_string_match__WEBPACK_IMPORTED_MODULE_65___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_match__WEBPACK_IMPORTED_MODULE_65__);
    /* harmony import */


    var core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(
    /*! core-js/modules/es.string.replace */
    "./node_modules/core-js/modules/es.string.replace.js");
    /* harmony import */


    var core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_66___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_replace__WEBPACK_IMPORTED_MODULE_66__);
    /* harmony import */


    var core_js_modules_es_string_search__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(
    /*! core-js/modules/es.string.search */
    "./node_modules/core-js/modules/es.string.search.js");
    /* harmony import */


    var core_js_modules_es_string_search__WEBPACK_IMPORTED_MODULE_67___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_search__WEBPACK_IMPORTED_MODULE_67__);
    /* harmony import */


    var core_js_modules_es_string_split__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(
    /*! core-js/modules/es.string.split */
    "./node_modules/core-js/modules/es.string.split.js");
    /* harmony import */


    var core_js_modules_es_string_split__WEBPACK_IMPORTED_MODULE_68___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_split__WEBPACK_IMPORTED_MODULE_68__);
    /* harmony import */


    var core_js_modules_es_parse_int__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(
    /*! core-js/modules/es.parse-int */
    "./node_modules/core-js/modules/es.parse-int.js");
    /* harmony import */


    var core_js_modules_es_parse_int__WEBPACK_IMPORTED_MODULE_69___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_parse_int__WEBPACK_IMPORTED_MODULE_69__);
    /* harmony import */


    var core_js_modules_es_parse_float__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(
    /*! core-js/modules/es.parse-float */
    "./node_modules/core-js/modules/es.parse-float.js");
    /* harmony import */


    var core_js_modules_es_parse_float__WEBPACK_IMPORTED_MODULE_70___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_parse_float__WEBPACK_IMPORTED_MODULE_70__);
    /* harmony import */


    var core_js_es_number__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(
    /*! core-js/es/number */
    "./node_modules/core-js/es/number/index.js");
    /* harmony import */


    var core_js_es_number__WEBPACK_IMPORTED_MODULE_71___default = /*#__PURE__*/__webpack_require__.n(core_js_es_number__WEBPACK_IMPORTED_MODULE_71__);
    /* harmony import */


    var core_js_es_math__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(
    /*! core-js/es/math */
    "./node_modules/core-js/es/math/index.js");
    /* harmony import */


    var core_js_es_math__WEBPACK_IMPORTED_MODULE_72___default = /*#__PURE__*/__webpack_require__.n(core_js_es_math__WEBPACK_IMPORTED_MODULE_72__);
    /* harmony import */


    var core_js_es_date__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(
    /*! core-js/es/date */
    "./node_modules/core-js/es/date/index.js");
    /* harmony import */


    var core_js_es_date__WEBPACK_IMPORTED_MODULE_73___default = /*#__PURE__*/__webpack_require__.n(core_js_es_date__WEBPACK_IMPORTED_MODULE_73__);
    /* harmony import */


    var core_js_modules_es_regexp_constructor__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(
    /*! core-js/modules/es.regexp.constructor */
    "./node_modules/core-js/modules/es.regexp.constructor.js");
    /* harmony import */


    var core_js_modules_es_regexp_constructor__WEBPACK_IMPORTED_MODULE_74___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_constructor__WEBPACK_IMPORTED_MODULE_74__);
    /* harmony import */


    var core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(
    /*! core-js/modules/es.regexp.to-string */
    "./node_modules/core-js/modules/es.regexp.to-string.js");
    /* harmony import */


    var core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_75___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_75__);
    /* harmony import */


    var core_js_modules_es_regexp_flags__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(
    /*! core-js/modules/es.regexp.flags */
    "./node_modules/core-js/modules/es.regexp.flags.js");
    /* harmony import */


    var core_js_modules_es_regexp_flags__WEBPACK_IMPORTED_MODULE_76___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_flags__WEBPACK_IMPORTED_MODULE_76__);
    /* harmony import */


    var core_js_modules_es_map__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(
    /*! core-js/modules/es.map */
    "./node_modules/core-js/modules/es.map.js");
    /* harmony import */


    var core_js_modules_es_map__WEBPACK_IMPORTED_MODULE_77___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_map__WEBPACK_IMPORTED_MODULE_77__);
    /* harmony import */


    var core_js_modules_es_weak_map__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(
    /*! core-js/modules/es.weak-map */
    "./node_modules/core-js/modules/es.weak-map.js");
    /* harmony import */


    var core_js_modules_es_weak_map__WEBPACK_IMPORTED_MODULE_78___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_weak_map__WEBPACK_IMPORTED_MODULE_78__);
    /* harmony import */


    var core_js_modules_es_set__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(
    /*! core-js/modules/es.set */
    "./node_modules/core-js/modules/es.set.js");
    /* harmony import */


    var core_js_modules_es_set__WEBPACK_IMPORTED_MODULE_79___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_set__WEBPACK_IMPORTED_MODULE_79__);
    /* harmony import */


    var core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(
    /*! core-js/modules/web.dom-collections.for-each */
    "./node_modules/core-js/modules/web.dom-collections.for-each.js");
    /* harmony import */


    var core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_80___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_for_each__WEBPACK_IMPORTED_MODULE_80__);
    /* harmony import */


    var core_js_modules_web_dom_collections_iterator__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(
    /*! core-js/modules/web.dom-collections.iterator */
    "./node_modules/core-js/modules/web.dom-collections.iterator.js");
    /* harmony import */


    var core_js_modules_web_dom_collections_iterator__WEBPACK_IMPORTED_MODULE_81___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_iterator__WEBPACK_IMPORTED_MODULE_81__);
    /* harmony import */


    var core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(
    /*! core-js/modules/es.promise */
    "./node_modules/core-js/modules/es.promise.js");
    /* harmony import */


    var core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_82___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_promise__WEBPACK_IMPORTED_MODULE_82__);
    /* harmony import */


    var core_js_modules_es_json_to_string_tag__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(
    /*! core-js/modules/es.json.to-string-tag */
    "./node_modules/core-js/modules/es.json.to-string-tag.js");
    /* harmony import */


    var core_js_modules_es_json_to_string_tag__WEBPACK_IMPORTED_MODULE_83___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_json_to_string_tag__WEBPACK_IMPORTED_MODULE_83__);
    /* harmony import */


    var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(
    /*! regenerator-runtime/runtime */
    "./node_modules/regenerator-runtime/runtime.js");
    /* harmony import */


    var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_84___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_84__);
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // ES2015 symbol capabilities
    // ES2015 function capabilities
    // ES2015 object capabilities
    // ES2015 array capabilities
    // ES2015 string capabilities

    /***/

  },

  /***/
  "./node_modules/@angular-devkit/build-angular/src/angular-cli-files/models/jit-polyfills.js":
  /*!**************************************************************************************************!*\
    !*** ./node_modules/@angular-devkit/build-angular/src/angular-cli-files/models/jit-polyfills.js ***!
    \**************************************************************************************************/

  /*! no exports provided */

  /***/
  function node_modulesAngularDevkitBuildAngularSrcAngularCliFilesModelsJitPolyfillsJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony import */


    var core_js_proposals_reflect_metadata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! core-js/proposals/reflect-metadata */
    "./node_modules/core-js/proposals/reflect-metadata.js");
    /* harmony import */


    var core_js_proposals_reflect_metadata__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_proposals_reflect_metadata__WEBPACK_IMPORTED_MODULE_0__);
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /***/

  },

  /***/
  "./node_modules/@angular/core/fesm2015/core.js":
  /*!*****************************************************!*\
    !*** ./node_modules/@angular/core/fesm2015/core.js ***!
    \*****************************************************/

  /*! exports provided: ɵangular_packages_core_core_q, ɵangular_packages_core_core_n, ɵangular_packages_core_core_o, ɵangular_packages_core_core_p, ɵangular_packages_core_core_r, ɵangular_packages_core_core_f, ɵangular_packages_core_core_l, ɵangular_packages_core_core_m, ɵangular_packages_core_core_k, ɵangular_packages_core_core_j, ɵangular_packages_core_core_b, ɵangular_packages_core_core_a, ɵangular_packages_core_core_c, ɵangular_packages_core_core_d, ɵangular_packages_core_core_e, ɵangular_packages_core_core_i, ɵangular_packages_core_core_s, ɵangular_packages_core_core_u, ɵangular_packages_core_core_t, ɵangular_packages_core_core_x, ɵangular_packages_core_core_v, ɵangular_packages_core_core_w, ɵangular_packages_core_core_ba, ɵangular_packages_core_core_bb, ɵangular_packages_core_core_bc, ɵangular_packages_core_core_bd, ɵangular_packages_core_core_be, ɵangular_packages_core_core_bm, ɵangular_packages_core_core_bl, ɵangular_packages_core_core_g, ɵangular_packages_core_core_h, ɵangular_packages_core_core_bg, ɵangular_packages_core_core_bk, ɵangular_packages_core_core_bh, ɵangular_packages_core_core_bi, ɵangular_packages_core_core_bn, ɵangular_packages_core_core_y, ɵangular_packages_core_core_z, createPlatform, assertPlatform, destroyPlatform, getPlatform, PlatformRef, ApplicationRef, createPlatformFactory, NgProbeToken, enableProdMode, isDevMode, APP_ID, PACKAGE_ROOT_URL, PLATFORM_INITIALIZER, PLATFORM_ID, APP_BOOTSTRAP_LISTENER, APP_INITIALIZER, ApplicationInitStatus, DebugElement, DebugEventListener, DebugNode, asNativeElements, getDebugNode, Testability, TestabilityRegistry, setTestabilityGetter, TRANSLATIONS, TRANSLATIONS_FORMAT, LOCALE_ID, MissingTranslationStrategy, ApplicationModule, wtfCreateScope, wtfLeave, wtfStartTimeRange, wtfEndTimeRange, Type, EventEmitter, ErrorHandler, Sanitizer, SecurityContext, Attribute, ANALYZE_FOR_ENTRY_COMPONENTS, ContentChild, ContentChildren, Query, ViewChild, ViewChildren, Component, Directive, HostBinding, HostListener, Input, Output, Pipe, NgModule, CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA, ViewEncapsulation, Version, VERSION, InjectFlags, ɵɵdefineInjectable, defineInjectable, ɵɵdefineInjector, forwardRef, resolveForwardRef, Injectable, Injector, ɵɵinject, inject, INJECTOR, ReflectiveInjector, ResolvedReflectiveFactory, ReflectiveKey, InjectionToken, Inject, Optional, Self, SkipSelf, Host, NgZone, ɵNoopNgZone, RenderComponentType, Renderer, Renderer2, RendererFactory2, RendererStyleFlags2, RootRenderer, COMPILER_OPTIONS, Compiler, CompilerFactory, ModuleWithComponentFactories, ComponentFactory, ɵComponentFactory, ComponentRef, ComponentFactoryResolver, ElementRef, NgModuleFactory, NgModuleRef, NgModuleFactoryLoader, getModuleFactory, QueryList, SystemJsNgModuleLoader, SystemJsNgModuleLoaderConfig, TemplateRef, ViewContainerRef, EmbeddedViewRef, ViewRef, ChangeDetectionStrategy, ChangeDetectorRef, DefaultIterableDiffer, IterableDiffers, KeyValueDiffers, SimpleChange, WrappedValue, platformCore, ɵALLOW_MULTIPLE_PLATFORMS, ɵAPP_ID_RANDOM_PROVIDER, ɵdefaultIterableDiffers, ɵdefaultKeyValueDiffers, ɵdevModeEqual, ɵisListLikeIterable, ɵChangeDetectorStatus, ɵisDefaultChangeDetectionStrategy, ɵConsole, ɵsetCurrentInjector, ɵgetInjectableDef, ɵAPP_ROOT, ɵDEFAULT_LOCALE_ID, ɵivyEnabled, ɵCodegenComponentFactoryResolver, ɵclearResolutionOfComponentResourcesQueue, ɵresolveComponentResources, ɵReflectionCapabilities, ɵRenderDebugInfo, ɵ_sanitizeHtml, ɵ_sanitizeStyle, ɵ_sanitizeUrl, ɵglobal, ɵlooseIdentical, ɵstringify, ɵmakeDecorator, ɵisObservable, ɵisPromise, ɵclearOverrides, ɵinitServicesIfNeeded, ɵoverrideComponentView, ɵoverrideProvider, ɵNOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, ɵgetLocalePluralCase, ɵfindLocaleData, ɵLOCALE_DATA, ɵLocaleDataIndex, ɵɵattribute, ɵɵattributeInterpolate1, ɵɵattributeInterpolate2, ɵɵattributeInterpolate3, ɵɵattributeInterpolate4, ɵɵattributeInterpolate5, ɵɵattributeInterpolate6, ɵɵattributeInterpolate7, ɵɵattributeInterpolate8, ɵɵattributeInterpolateV, ɵɵdefineBase, ɵɵdefineComponent, ɵɵdefineDirective, ɵɵdefinePipe, ɵɵdefineNgModule, ɵdetectChanges, ɵrenderComponent, ɵRender3ComponentFactory, ɵRender3ComponentRef, ɵɵdirectiveInject, ɵɵinjectAttribute, ɵɵinjectPipeChangeDetectorRef, ɵɵgetFactoryOf, ɵɵgetInheritedFactory, ɵɵsetComponentScope, ɵɵsetNgModuleScope, ɵɵtemplateRefExtractor, ɵɵProvidersFeature, ɵɵInheritDefinitionFeature, ɵɵNgOnChangesFeature, ɵLifecycleHooksFeature, ɵRender3NgModuleRef, ɵmarkDirty, ɵNgModuleFactory, ɵNO_CHANGE, ɵɵcontainer, ɵɵnextContext, ɵɵelementStart, ɵɵnamespaceHTML, ɵɵnamespaceMathML, ɵɵnamespaceSVG, ɵɵelement, ɵɵlistener, ɵɵtext, ɵɵtextInterpolate, ɵɵtextInterpolate1, ɵɵtextInterpolate2, ɵɵtextInterpolate3, ɵɵtextInterpolate4, ɵɵtextInterpolate5, ɵɵtextInterpolate6, ɵɵtextInterpolate7, ɵɵtextInterpolate8, ɵɵtextInterpolateV, ɵɵembeddedViewStart, ɵɵprojection, ɵɵpipeBind1, ɵɵpipeBind2, ɵɵpipeBind3, ɵɵpipeBind4, ɵɵpipeBindV, ɵɵpureFunction0, ɵɵpureFunction1, ɵɵpureFunction2, ɵɵpureFunction3, ɵɵpureFunction4, ɵɵpureFunction5, ɵɵpureFunction6, ɵɵpureFunction7, ɵɵpureFunction8, ɵɵpureFunctionV, ɵɵgetCurrentView, ɵgetDirectives, ɵgetHostElement, ɵɵrestoreView, ɵɵcontainerRefreshStart, ɵɵcontainerRefreshEnd, ɵɵqueryRefresh, ɵɵviewQuery, ɵɵstaticViewQuery, ɵɵstaticContentQuery, ɵɵloadViewQuery, ɵɵcontentQuery, ɵɵloadContentQuery, ɵɵelementEnd, ɵɵhostProperty, ɵɵproperty, ɵɵpropertyInterpolate, ɵɵpropertyInterpolate1, ɵɵpropertyInterpolate2, ɵɵpropertyInterpolate3, ɵɵpropertyInterpolate4, ɵɵpropertyInterpolate5, ɵɵpropertyInterpolate6, ɵɵpropertyInterpolate7, ɵɵpropertyInterpolate8, ɵɵpropertyInterpolateV, ɵɵupdateSyntheticHostBinding, ɵɵcomponentHostSyntheticListener, ɵɵprojectionDef, ɵɵreference, ɵɵenableBindings, ɵɵdisableBindings, ɵɵallocHostVars, ɵɵelementContainerStart, ɵɵelementContainerEnd, ɵɵelementContainer, ɵɵstyling, ɵɵstyleMap, ɵɵstyleSanitizer, ɵɵclassMap, ɵɵclassMapInterpolate1, ɵɵclassMapInterpolate2, ɵɵclassMapInterpolate3, ɵɵclassMapInterpolate4, ɵɵclassMapInterpolate5, ɵɵclassMapInterpolate6, ɵɵclassMapInterpolate7, ɵɵclassMapInterpolate8, ɵɵclassMapInterpolateV, ɵɵstyleProp, ɵɵstylePropInterpolate1, ɵɵstylePropInterpolate2, ɵɵstylePropInterpolate3, ɵɵstylePropInterpolate4, ɵɵstylePropInterpolate5, ɵɵstylePropInterpolate6, ɵɵstylePropInterpolate7, ɵɵstylePropInterpolate8, ɵɵstylePropInterpolateV, ɵɵstylingApply, ɵɵclassProp, ɵɵelementHostAttrs, ɵɵselect, ɵɵtextBinding, ɵɵtemplate, ɵɵembeddedViewEnd, ɵstore, ɵɵload, ɵɵpipe, ɵwhenRendered, ɵɵi18n, ɵɵi18nAttributes, ɵɵi18nExp, ɵɵi18nStart, ɵɵi18nEnd, ɵɵi18nApply, ɵɵi18nPostprocess, ɵi18nConfigureLocalize, ɵɵi18nLocalize, ɵsetLocaleId, ɵsetClassMetadata, ɵɵresolveWindow, ɵɵresolveDocument, ɵɵresolveBody, ɵcompileComponent, ɵcompileDirective, ɵcompileNgModule, ɵcompileNgModuleDefs, ɵpatchComponentDefWithScope, ɵresetCompiledComponents, ɵflushModuleScopingQueueAsMuchAsPossible, ɵtransitiveScopesFor, ɵcompilePipe, ɵɵsanitizeHtml, ɵɵsanitizeStyle, ɵɵdefaultStyleSanitizer, ɵɵsanitizeScript, ɵɵsanitizeUrl, ɵɵsanitizeResourceUrl, ɵɵsanitizeUrlOrResourceUrl, ɵbypassSanitizationTrustHtml, ɵbypassSanitizationTrustStyle, ɵbypassSanitizationTrustScript, ɵbypassSanitizationTrustUrl, ɵbypassSanitizationTrustResourceUrl, ɵgetLContext, ɵNG_ELEMENT_ID, ɵNG_COMPONENT_DEF, ɵNG_DIRECTIVE_DEF, ɵNG_PIPE_DEF, ɵNG_MODULE_DEF, ɵNG_BASE_DEF, ɵNG_INJECTABLE_DEF, ɵNG_INJECTOR_DEF, ɵcompileNgModuleFactory__POST_R3__, ɵisBoundToModule__POST_R3__, ɵSWITCH_COMPILE_COMPONENT__POST_R3__, ɵSWITCH_COMPILE_DIRECTIVE__POST_R3__, ɵSWITCH_COMPILE_PIPE__POST_R3__, ɵSWITCH_COMPILE_NGMODULE__POST_R3__, ɵgetDebugNode__POST_R3__, ɵSWITCH_COMPILE_INJECTABLE__POST_R3__, ɵSWITCH_IVY_ENABLED__POST_R3__, ɵSWITCH_CHANGE_DETECTOR_REF_FACTORY__POST_R3__, ɵCompiler_compileModuleSync__POST_R3__, ɵCompiler_compileModuleAsync__POST_R3__, ɵCompiler_compileModuleAndAllComponentsSync__POST_R3__, ɵCompiler_compileModuleAndAllComponentsAsync__POST_R3__, ɵSWITCH_ELEMENT_REF_FACTORY__POST_R3__, ɵSWITCH_TEMPLATE_REF_FACTORY__POST_R3__, ɵSWITCH_VIEW_CONTAINER_REF_FACTORY__POST_R3__, ɵSWITCH_RENDERER2_FACTORY__POST_R3__, ɵgetModuleFactory__POST_R3__, ɵregisterNgModuleType, ɵpublishGlobalUtil, ɵpublishDefaultGlobalUtils, ɵcreateInjector, ɵINJECTOR_IMPL__POST_R3__, ɵregisterModuleFactory, ɵEMPTY_ARRAY, ɵEMPTY_MAP, ɵand, ɵccf, ɵcmf, ɵcrt, ɵdid, ɵeld, ɵgetComponentViewDefinitionFactory, ɵinlineInterpolate, ɵinterpolate, ɵmod, ɵmpd, ɵncd, ɵnov, ɵpid, ɵprd, ɵpad, ɵpod, ɵppd, ɵqud, ɵted, ɵunv, ɵvid */

  /***/
  function node_modulesAngularCoreFesm2015CoreJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_q", function () {
      return APPLICATION_MODULE_PROVIDERS;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_n", function () {
      return _iterableDiffersFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_o", function () {
      return _keyValueDiffersFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_p", function () {
      return _localeFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_r", function () {
      return zoneSchedulerFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_f", function () {
      return _appIdRandomProviderFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_l", function () {
      return DefaultIterableDifferFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_m", function () {
      return DefaultKeyValueDifferFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_k", function () {
      return DebugElement__PRE_R3__;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_j", function () {
      return DebugNode__PRE_R3__;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_b", function () {
      return NullInjector;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_a", function () {
      return injectInjectorOnly;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_c", function () {
      return ReflectiveInjector_;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_d", function () {
      return ReflectiveDependency;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_e", function () {
      return resolveReflectiveProviders;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_i", function () {
      return getModuleFactory__PRE_R3__;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_s", function () {
      return wtfEnabled;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_u", function () {
      return createScope;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_t", function () {
      return detectWTF;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_x", function () {
      return endTimeRange;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_v", function () {
      return leave;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_w", function () {
      return startTimeRange;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_ba", function () {
      return SCHEDULER;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_bb", function () {
      return injectAttributeImpl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_bc", function () {
      return getLView;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_bd", function () {
      return getPreviousOrParentTNode;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_be", function () {
      return nextContextImpl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_bm", function () {
      return getRootContext;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_bl", function () {
      return loadInternal;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_g", function () {
      return createElementRef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_h", function () {
      return createTemplateRef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_bg", function () {
      return getUrlSanitizer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_bk", function () {
      return noSideEffects;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_bh", function () {
      return makeParamDecorator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_bi", function () {
      return makePropDecorator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_bn", function () {
      return getClosureSafeProperty;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_y", function () {
      return _def;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵangular_packages_core_core_z", function () {
      return DebugContext;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "createPlatform", function () {
      return createPlatform;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "assertPlatform", function () {
      return assertPlatform;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "destroyPlatform", function () {
      return destroyPlatform;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "getPlatform", function () {
      return getPlatform;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "PlatformRef", function () {
      return PlatformRef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ApplicationRef", function () {
      return ApplicationRef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "createPlatformFactory", function () {
      return createPlatformFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NgProbeToken", function () {
      return NgProbeToken;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "enableProdMode", function () {
      return enableProdMode;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isDevMode", function () {
      return isDevMode;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "APP_ID", function () {
      return APP_ID;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "PACKAGE_ROOT_URL", function () {
      return PACKAGE_ROOT_URL;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "PLATFORM_INITIALIZER", function () {
      return PLATFORM_INITIALIZER;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "PLATFORM_ID", function () {
      return PLATFORM_ID;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "APP_BOOTSTRAP_LISTENER", function () {
      return APP_BOOTSTRAP_LISTENER;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "APP_INITIALIZER", function () {
      return APP_INITIALIZER;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ApplicationInitStatus", function () {
      return ApplicationInitStatus;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DebugElement", function () {
      return DebugElement;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DebugEventListener", function () {
      return DebugEventListener;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DebugNode", function () {
      return DebugNode$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "asNativeElements", function () {
      return asNativeElements;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "getDebugNode", function () {
      return getDebugNode;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Testability", function () {
      return Testability;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TestabilityRegistry", function () {
      return TestabilityRegistry;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "setTestabilityGetter", function () {
      return setTestabilityGetter;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TRANSLATIONS", function () {
      return TRANSLATIONS$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TRANSLATIONS_FORMAT", function () {
      return TRANSLATIONS_FORMAT;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "LOCALE_ID", function () {
      return LOCALE_ID$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "MissingTranslationStrategy", function () {
      return MissingTranslationStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ApplicationModule", function () {
      return ApplicationModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "wtfCreateScope", function () {
      return wtfCreateScope;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "wtfLeave", function () {
      return wtfLeave;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "wtfStartTimeRange", function () {
      return wtfStartTimeRange;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "wtfEndTimeRange", function () {
      return wtfEndTimeRange;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Type", function () {
      return Type;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "EventEmitter", function () {
      return EventEmitter;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ErrorHandler", function () {
      return ErrorHandler;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Sanitizer", function () {
      return Sanitizer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SecurityContext", function () {
      return SecurityContext;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Attribute", function () {
      return Attribute;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ANALYZE_FOR_ENTRY_COMPONENTS", function () {
      return ANALYZE_FOR_ENTRY_COMPONENTS;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ContentChild", function () {
      return ContentChild;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ContentChildren", function () {
      return ContentChildren;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Query", function () {
      return Query;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ViewChild", function () {
      return ViewChild;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ViewChildren", function () {
      return ViewChildren;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Component", function () {
      return Component;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Directive", function () {
      return Directive;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "HostBinding", function () {
      return HostBinding;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "HostListener", function () {
      return HostListener;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Input", function () {
      return Input;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Output", function () {
      return Output;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Pipe", function () {
      return Pipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NgModule", function () {
      return NgModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CUSTOM_ELEMENTS_SCHEMA", function () {
      return CUSTOM_ELEMENTS_SCHEMA;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NO_ERRORS_SCHEMA", function () {
      return NO_ERRORS_SCHEMA;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ViewEncapsulation", function () {
      return ViewEncapsulation;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Version", function () {
      return Version;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "VERSION", function () {
      return VERSION;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "InjectFlags", function () {
      return InjectFlags;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵdefineInjectable", function () {
      return ɵɵdefineInjectable;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "defineInjectable", function () {
      return defineInjectable;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵdefineInjector", function () {
      return ɵɵdefineInjector;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "forwardRef", function () {
      return forwardRef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "resolveForwardRef", function () {
      return resolveForwardRef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Injectable", function () {
      return Injectable;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Injector", function () {
      return Injector;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵinject", function () {
      return ɵɵinject;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "inject", function () {
      return inject;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "INJECTOR", function () {
      return INJECTOR;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ReflectiveInjector", function () {
      return ReflectiveInjector;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ResolvedReflectiveFactory", function () {
      return ResolvedReflectiveFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ReflectiveKey", function () {
      return ReflectiveKey;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "InjectionToken", function () {
      return InjectionToken;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Inject", function () {
      return Inject;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Optional", function () {
      return Optional;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Self", function () {
      return Self;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SkipSelf", function () {
      return SkipSelf;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Host", function () {
      return Host;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NgZone", function () {
      return NgZone;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵNoopNgZone", function () {
      return NoopNgZone;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RenderComponentType", function () {
      return RenderComponentType;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Renderer", function () {
      return Renderer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Renderer2", function () {
      return Renderer2;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RendererFactory2", function () {
      return RendererFactory2;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RendererStyleFlags2", function () {
      return RendererStyleFlags2;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RootRenderer", function () {
      return RootRenderer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "COMPILER_OPTIONS", function () {
      return COMPILER_OPTIONS;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Compiler", function () {
      return Compiler;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CompilerFactory", function () {
      return CompilerFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ModuleWithComponentFactories", function () {
      return ModuleWithComponentFactories;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ComponentFactory", function () {
      return ComponentFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵComponentFactory", function () {
      return ComponentFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ComponentRef", function () {
      return ComponentRef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ComponentFactoryResolver", function () {
      return ComponentFactoryResolver;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ElementRef", function () {
      return ElementRef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NgModuleFactory", function () {
      return NgModuleFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NgModuleRef", function () {
      return NgModuleRef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NgModuleFactoryLoader", function () {
      return NgModuleFactoryLoader;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "getModuleFactory", function () {
      return getModuleFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "QueryList", function () {
      return QueryList;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SystemJsNgModuleLoader", function () {
      return SystemJsNgModuleLoader;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SystemJsNgModuleLoaderConfig", function () {
      return SystemJsNgModuleLoaderConfig;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TemplateRef", function () {
      return TemplateRef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ViewContainerRef", function () {
      return ViewContainerRef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "EmbeddedViewRef", function () {
      return EmbeddedViewRef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ViewRef", function () {
      return ViewRef$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ChangeDetectionStrategy", function () {
      return ChangeDetectionStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ChangeDetectorRef", function () {
      return ChangeDetectorRef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DefaultIterableDiffer", function () {
      return DefaultIterableDiffer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "IterableDiffers", function () {
      return IterableDiffers;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "KeyValueDiffers", function () {
      return KeyValueDiffers;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SimpleChange", function () {
      return SimpleChange;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "WrappedValue", function () {
      return WrappedValue;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "platformCore", function () {
      return platformCore;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵALLOW_MULTIPLE_PLATFORMS", function () {
      return ALLOW_MULTIPLE_PLATFORMS;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵAPP_ID_RANDOM_PROVIDER", function () {
      return APP_ID_RANDOM_PROVIDER;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdefaultIterableDiffers", function () {
      return defaultIterableDiffers;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdefaultKeyValueDiffers", function () {
      return defaultKeyValueDiffers;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdevModeEqual", function () {
      return devModeEqual$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵisListLikeIterable", function () {
      return isListLikeIterable$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵChangeDetectorStatus", function () {
      return ChangeDetectorStatus;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵisDefaultChangeDetectionStrategy", function () {
      return isDefaultChangeDetectionStrategy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵConsole", function () {
      return Console;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵsetCurrentInjector", function () {
      return setCurrentInjector;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵgetInjectableDef", function () {
      return getInjectableDef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵAPP_ROOT", function () {
      return APP_ROOT;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵDEFAULT_LOCALE_ID", function () {
      return DEFAULT_LOCALE_ID;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵivyEnabled", function () {
      return ivyEnabled;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵCodegenComponentFactoryResolver", function () {
      return CodegenComponentFactoryResolver;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵclearResolutionOfComponentResourcesQueue", function () {
      return clearResolutionOfComponentResourcesQueue;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵresolveComponentResources", function () {
      return resolveComponentResources;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵReflectionCapabilities", function () {
      return ReflectionCapabilities;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵRenderDebugInfo", function () {
      return RenderDebugInfo;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵ_sanitizeHtml", function () {
      return _sanitizeHtml;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵ_sanitizeStyle", function () {
      return _sanitizeStyle;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵ_sanitizeUrl", function () {
      return _sanitizeUrl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵglobal", function () {
      return _global;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵlooseIdentical", function () {
      return looseIdentical;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵstringify", function () {
      return stringify;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵmakeDecorator", function () {
      return makeDecorator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵisObservable", function () {
      return isObservable;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵisPromise", function () {
      return isPromise;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵclearOverrides", function () {
      return clearOverrides;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵinitServicesIfNeeded", function () {
      return initServicesIfNeeded;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵoverrideComponentView", function () {
      return overrideComponentView;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵoverrideProvider", function () {
      return overrideProvider;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵNOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR", function () {
      return NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵgetLocalePluralCase", function () {
      return getLocalePluralCase;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵfindLocaleData", function () {
      return findLocaleData;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵLOCALE_DATA", function () {
      return LOCALE_DATA;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵLocaleDataIndex", function () {
      return LocaleDataIndex;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵattribute", function () {
      return ɵɵattribute;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵattributeInterpolate1", function () {
      return ɵɵattributeInterpolate1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵattributeInterpolate2", function () {
      return ɵɵattributeInterpolate2;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵattributeInterpolate3", function () {
      return ɵɵattributeInterpolate3;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵattributeInterpolate4", function () {
      return ɵɵattributeInterpolate4;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵattributeInterpolate5", function () {
      return ɵɵattributeInterpolate5;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵattributeInterpolate6", function () {
      return ɵɵattributeInterpolate6;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵattributeInterpolate7", function () {
      return ɵɵattributeInterpolate7;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵattributeInterpolate8", function () {
      return ɵɵattributeInterpolate8;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵattributeInterpolateV", function () {
      return ɵɵattributeInterpolateV;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵdefineBase", function () {
      return ɵɵdefineBase;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵdefineComponent", function () {
      return ɵɵdefineComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵdefineDirective", function () {
      return ɵɵdefineDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵdefinePipe", function () {
      return ɵɵdefinePipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵdefineNgModule", function () {
      return ɵɵdefineNgModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdetectChanges", function () {
      return detectChanges;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵrenderComponent", function () {
      return renderComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵRender3ComponentFactory", function () {
      return ComponentFactory$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵRender3ComponentRef", function () {
      return ComponentRef$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵdirectiveInject", function () {
      return ɵɵdirectiveInject;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵinjectAttribute", function () {
      return ɵɵinjectAttribute;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵinjectPipeChangeDetectorRef", function () {
      return ɵɵinjectPipeChangeDetectorRef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵgetFactoryOf", function () {
      return ɵɵgetFactoryOf;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵgetInheritedFactory", function () {
      return ɵɵgetInheritedFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵsetComponentScope", function () {
      return ɵɵsetComponentScope;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵsetNgModuleScope", function () {
      return ɵɵsetNgModuleScope;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵtemplateRefExtractor", function () {
      return ɵɵtemplateRefExtractor;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵProvidersFeature", function () {
      return ɵɵProvidersFeature;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵInheritDefinitionFeature", function () {
      return ɵɵInheritDefinitionFeature;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵNgOnChangesFeature", function () {
      return ɵɵNgOnChangesFeature;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵLifecycleHooksFeature", function () {
      return LifecycleHooksFeature;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵRender3NgModuleRef", function () {
      return NgModuleRef$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵmarkDirty", function () {
      return markDirty;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵNgModuleFactory", function () {
      return NgModuleFactory$1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵNO_CHANGE", function () {
      return NO_CHANGE;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵcontainer", function () {
      return ɵɵcontainer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵnextContext", function () {
      return ɵɵnextContext;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵelementStart", function () {
      return ɵɵelementStart;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵnamespaceHTML", function () {
      return ɵɵnamespaceHTML;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵnamespaceMathML", function () {
      return ɵɵnamespaceMathML;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵnamespaceSVG", function () {
      return ɵɵnamespaceSVG;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵelement", function () {
      return ɵɵelement;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵlistener", function () {
      return ɵɵlistener;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵtext", function () {
      return ɵɵtext;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵtextInterpolate", function () {
      return ɵɵtextInterpolate;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵtextInterpolate1", function () {
      return ɵɵtextInterpolate1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵtextInterpolate2", function () {
      return ɵɵtextInterpolate2;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵtextInterpolate3", function () {
      return ɵɵtextInterpolate3;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵtextInterpolate4", function () {
      return ɵɵtextInterpolate4;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵtextInterpolate5", function () {
      return ɵɵtextInterpolate5;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵtextInterpolate6", function () {
      return ɵɵtextInterpolate6;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵtextInterpolate7", function () {
      return ɵɵtextInterpolate7;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵtextInterpolate8", function () {
      return ɵɵtextInterpolate8;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵtextInterpolateV", function () {
      return ɵɵtextInterpolateV;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵembeddedViewStart", function () {
      return ɵɵembeddedViewStart;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵprojection", function () {
      return ɵɵprojection;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵpipeBind1", function () {
      return ɵɵpipeBind1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵpipeBind2", function () {
      return ɵɵpipeBind2;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵpipeBind3", function () {
      return ɵɵpipeBind3;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵpipeBind4", function () {
      return ɵɵpipeBind4;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵpipeBindV", function () {
      return ɵɵpipeBindV;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵpureFunction0", function () {
      return ɵɵpureFunction0;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵpureFunction1", function () {
      return ɵɵpureFunction1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵpureFunction2", function () {
      return ɵɵpureFunction2;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵpureFunction3", function () {
      return ɵɵpureFunction3;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵpureFunction4", function () {
      return ɵɵpureFunction4;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵpureFunction5", function () {
      return ɵɵpureFunction5;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵpureFunction6", function () {
      return ɵɵpureFunction6;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵpureFunction7", function () {
      return ɵɵpureFunction7;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵpureFunction8", function () {
      return ɵɵpureFunction8;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵpureFunctionV", function () {
      return ɵɵpureFunctionV;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵgetCurrentView", function () {
      return ɵɵgetCurrentView;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵgetDirectives", function () {
      return getDirectives;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵgetHostElement", function () {
      return getHostElement;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵrestoreView", function () {
      return ɵɵrestoreView;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵcontainerRefreshStart", function () {
      return ɵɵcontainerRefreshStart;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵcontainerRefreshEnd", function () {
      return ɵɵcontainerRefreshEnd;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵqueryRefresh", function () {
      return ɵɵqueryRefresh;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵviewQuery", function () {
      return ɵɵviewQuery;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵstaticViewQuery", function () {
      return ɵɵstaticViewQuery;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵstaticContentQuery", function () {
      return ɵɵstaticContentQuery;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵloadViewQuery", function () {
      return ɵɵloadViewQuery;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵcontentQuery", function () {
      return ɵɵcontentQuery;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵloadContentQuery", function () {
      return ɵɵloadContentQuery;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵelementEnd", function () {
      return ɵɵelementEnd;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵhostProperty", function () {
      return ɵɵhostProperty;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵproperty", function () {
      return ɵɵproperty;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵpropertyInterpolate", function () {
      return ɵɵpropertyInterpolate;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵpropertyInterpolate1", function () {
      return ɵɵpropertyInterpolate1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵpropertyInterpolate2", function () {
      return ɵɵpropertyInterpolate2;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵpropertyInterpolate3", function () {
      return ɵɵpropertyInterpolate3;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵpropertyInterpolate4", function () {
      return ɵɵpropertyInterpolate4;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵpropertyInterpolate5", function () {
      return ɵɵpropertyInterpolate5;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵpropertyInterpolate6", function () {
      return ɵɵpropertyInterpolate6;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵpropertyInterpolate7", function () {
      return ɵɵpropertyInterpolate7;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵpropertyInterpolate8", function () {
      return ɵɵpropertyInterpolate8;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵpropertyInterpolateV", function () {
      return ɵɵpropertyInterpolateV;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵupdateSyntheticHostBinding", function () {
      return ɵɵupdateSyntheticHostBinding;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵcomponentHostSyntheticListener", function () {
      return ɵɵcomponentHostSyntheticListener;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵprojectionDef", function () {
      return ɵɵprojectionDef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵreference", function () {
      return ɵɵreference;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵenableBindings", function () {
      return ɵɵenableBindings;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵdisableBindings", function () {
      return ɵɵdisableBindings;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵallocHostVars", function () {
      return ɵɵallocHostVars;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵelementContainerStart", function () {
      return ɵɵelementContainerStart;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵelementContainerEnd", function () {
      return ɵɵelementContainerEnd;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵelementContainer", function () {
      return ɵɵelementContainer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵstyling", function () {
      return ɵɵstyling;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵstyleMap", function () {
      return ɵɵstyleMap;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵstyleSanitizer", function () {
      return ɵɵstyleSanitizer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵclassMap", function () {
      return ɵɵclassMap;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵclassMapInterpolate1", function () {
      return ɵɵclassMapInterpolate1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵclassMapInterpolate2", function () {
      return ɵɵclassMapInterpolate2;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵclassMapInterpolate3", function () {
      return ɵɵclassMapInterpolate3;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵclassMapInterpolate4", function () {
      return ɵɵclassMapInterpolate4;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵclassMapInterpolate5", function () {
      return ɵɵclassMapInterpolate5;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵclassMapInterpolate6", function () {
      return ɵɵclassMapInterpolate6;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵclassMapInterpolate7", function () {
      return ɵɵclassMapInterpolate7;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵclassMapInterpolate8", function () {
      return ɵɵclassMapInterpolate8;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵclassMapInterpolateV", function () {
      return ɵɵclassMapInterpolateV;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵstyleProp", function () {
      return ɵɵstyleProp;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵstylePropInterpolate1", function () {
      return ɵɵstylePropInterpolate1;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵstylePropInterpolate2", function () {
      return ɵɵstylePropInterpolate2;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵstylePropInterpolate3", function () {
      return ɵɵstylePropInterpolate3;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵstylePropInterpolate4", function () {
      return ɵɵstylePropInterpolate4;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵstylePropInterpolate5", function () {
      return ɵɵstylePropInterpolate5;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵstylePropInterpolate6", function () {
      return ɵɵstylePropInterpolate6;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵstylePropInterpolate7", function () {
      return ɵɵstylePropInterpolate7;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵstylePropInterpolate8", function () {
      return ɵɵstylePropInterpolate8;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵstylePropInterpolateV", function () {
      return ɵɵstylePropInterpolateV;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵstylingApply", function () {
      return ɵɵstylingApply;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵclassProp", function () {
      return ɵɵclassProp;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵelementHostAttrs", function () {
      return ɵɵelementHostAttrs;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵselect", function () {
      return ɵɵselect;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵtextBinding", function () {
      return ɵɵtextBinding;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵtemplate", function () {
      return ɵɵtemplate;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵembeddedViewEnd", function () {
      return ɵɵembeddedViewEnd;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵstore", function () {
      return store;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵload", function () {
      return ɵɵload;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵpipe", function () {
      return ɵɵpipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵwhenRendered", function () {
      return whenRendered;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵi18n", function () {
      return ɵɵi18n;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵi18nAttributes", function () {
      return ɵɵi18nAttributes;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵi18nExp", function () {
      return ɵɵi18nExp;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵi18nStart", function () {
      return ɵɵi18nStart;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵi18nEnd", function () {
      return ɵɵi18nEnd;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵi18nApply", function () {
      return ɵɵi18nApply;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵi18nPostprocess", function () {
      return ɵɵi18nPostprocess;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵi18nConfigureLocalize", function () {
      return i18nConfigureLocalize;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵi18nLocalize", function () {
      return ɵɵi18nLocalize;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵsetLocaleId", function () {
      return setLocaleId;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵsetClassMetadata", function () {
      return setClassMetadata;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵresolveWindow", function () {
      return ɵɵresolveWindow;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵresolveDocument", function () {
      return ɵɵresolveDocument;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵresolveBody", function () {
      return ɵɵresolveBody;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcompileComponent", function () {
      return compileComponent;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcompileDirective", function () {
      return compileDirective;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcompileNgModule", function () {
      return compileNgModule;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcompileNgModuleDefs", function () {
      return compileNgModuleDefs;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵpatchComponentDefWithScope", function () {
      return patchComponentDefWithScope;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵresetCompiledComponents", function () {
      return resetCompiledComponents;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵflushModuleScopingQueueAsMuchAsPossible", function () {
      return flushModuleScopingQueueAsMuchAsPossible;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵtransitiveScopesFor", function () {
      return transitiveScopesFor;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcompilePipe", function () {
      return compilePipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵsanitizeHtml", function () {
      return ɵɵsanitizeHtml;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵsanitizeStyle", function () {
      return ɵɵsanitizeStyle;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵdefaultStyleSanitizer", function () {
      return ɵɵdefaultStyleSanitizer;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵsanitizeScript", function () {
      return ɵɵsanitizeScript;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵsanitizeUrl", function () {
      return ɵɵsanitizeUrl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵsanitizeResourceUrl", function () {
      return ɵɵsanitizeResourceUrl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵɵsanitizeUrlOrResourceUrl", function () {
      return ɵɵsanitizeUrlOrResourceUrl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbypassSanitizationTrustHtml", function () {
      return bypassSanitizationTrustHtml;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbypassSanitizationTrustStyle", function () {
      return bypassSanitizationTrustStyle;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbypassSanitizationTrustScript", function () {
      return bypassSanitizationTrustScript;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbypassSanitizationTrustUrl", function () {
      return bypassSanitizationTrustUrl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵbypassSanitizationTrustResourceUrl", function () {
      return bypassSanitizationTrustResourceUrl;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵgetLContext", function () {
      return getLContext;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵNG_ELEMENT_ID", function () {
      return NG_ELEMENT_ID;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵNG_COMPONENT_DEF", function () {
      return NG_COMPONENT_DEF;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵNG_DIRECTIVE_DEF", function () {
      return NG_DIRECTIVE_DEF;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵNG_PIPE_DEF", function () {
      return NG_PIPE_DEF;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵNG_MODULE_DEF", function () {
      return NG_MODULE_DEF;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵNG_BASE_DEF", function () {
      return NG_BASE_DEF;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵNG_INJECTABLE_DEF", function () {
      return NG_INJECTABLE_DEF;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵNG_INJECTOR_DEF", function () {
      return NG_INJECTOR_DEF;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcompileNgModuleFactory__POST_R3__", function () {
      return compileNgModuleFactory__POST_R3__;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵisBoundToModule__POST_R3__", function () {
      return isBoundToModule__POST_R3__;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵSWITCH_COMPILE_COMPONENT__POST_R3__", function () {
      return SWITCH_COMPILE_COMPONENT__POST_R3__;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵSWITCH_COMPILE_DIRECTIVE__POST_R3__", function () {
      return SWITCH_COMPILE_DIRECTIVE__POST_R3__;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵSWITCH_COMPILE_PIPE__POST_R3__", function () {
      return SWITCH_COMPILE_PIPE__POST_R3__;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵSWITCH_COMPILE_NGMODULE__POST_R3__", function () {
      return SWITCH_COMPILE_NGMODULE__POST_R3__;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵgetDebugNode__POST_R3__", function () {
      return getDebugNode__POST_R3__;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵSWITCH_COMPILE_INJECTABLE__POST_R3__", function () {
      return SWITCH_COMPILE_INJECTABLE__POST_R3__;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵSWITCH_IVY_ENABLED__POST_R3__", function () {
      return SWITCH_IVY_ENABLED__POST_R3__;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵSWITCH_CHANGE_DETECTOR_REF_FACTORY__POST_R3__", function () {
      return SWITCH_CHANGE_DETECTOR_REF_FACTORY__POST_R3__;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵCompiler_compileModuleSync__POST_R3__", function () {
      return Compiler_compileModuleSync__POST_R3__;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵCompiler_compileModuleAsync__POST_R3__", function () {
      return Compiler_compileModuleAsync__POST_R3__;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵCompiler_compileModuleAndAllComponentsSync__POST_R3__", function () {
      return Compiler_compileModuleAndAllComponentsSync__POST_R3__;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵCompiler_compileModuleAndAllComponentsAsync__POST_R3__", function () {
      return Compiler_compileModuleAndAllComponentsAsync__POST_R3__;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵSWITCH_ELEMENT_REF_FACTORY__POST_R3__", function () {
      return SWITCH_ELEMENT_REF_FACTORY__POST_R3__;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵSWITCH_TEMPLATE_REF_FACTORY__POST_R3__", function () {
      return SWITCH_TEMPLATE_REF_FACTORY__POST_R3__;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵSWITCH_VIEW_CONTAINER_REF_FACTORY__POST_R3__", function () {
      return SWITCH_VIEW_CONTAINER_REF_FACTORY__POST_R3__;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵSWITCH_RENDERER2_FACTORY__POST_R3__", function () {
      return SWITCH_RENDERER2_FACTORY__POST_R3__;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵgetModuleFactory__POST_R3__", function () {
      return getModuleFactory__POST_R3__;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵregisterNgModuleType", function () {
      return registerNgModuleType;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵpublishGlobalUtil", function () {
      return publishGlobalUtil;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵpublishDefaultGlobalUtils", function () {
      return publishDefaultGlobalUtils;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcreateInjector", function () {
      return createInjector;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵINJECTOR_IMPL__POST_R3__", function () {
      return INJECTOR_IMPL__POST_R3__;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵregisterModuleFactory", function () {
      return registerModuleFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵEMPTY_ARRAY", function () {
      return EMPTY_ARRAY$3;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵEMPTY_MAP", function () {
      return EMPTY_MAP;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵand", function () {
      return anchorDef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵccf", function () {
      return createComponentFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcmf", function () {
      return createNgModuleFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵcrt", function () {
      return createRendererType2;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵdid", function () {
      return directiveDef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵeld", function () {
      return elementDef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵgetComponentViewDefinitionFactory", function () {
      return getComponentViewDefinitionFactory;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵinlineInterpolate", function () {
      return inlineInterpolate;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵinterpolate", function () {
      return interpolate;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵmod", function () {
      return moduleDef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵmpd", function () {
      return moduleProvideDef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵncd", function () {
      return ngContentDef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵnov", function () {
      return nodeValue;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵpid", function () {
      return pipeDef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵprd", function () {
      return providerDef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵpad", function () {
      return pureArrayDef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵpod", function () {
      return pureObjectDef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵppd", function () {
      return purePipeDef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵqud", function () {
      return queryDef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵted", function () {
      return textDef;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵunv", function () {
      return unwrapValue;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ɵvid", function () {
      return viewDef;
    });
    /* harmony import */


    var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! rxjs */
    "./node_modules/rxjs/_esm2015/index.js");
    /* harmony import */


    var rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! rxjs/operators */
    "./node_modules/rxjs/_esm2015/operators/index.js");
    /**
     * @license Angular v8.2.14
     * (c) 2010-2019 Google LLC. https://angular.io/
     * License: MIT
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    const ANNOTATIONS = '__annotations__';
    const PARAMETERS = '__parameters__';
    const PROP_METADATA = '__prop__metadata__';
    /**
     * @suppress {globalThis}
     */

    function makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {
      const metaCtor = makeMetadataCtor(props);

      function DecoratorFactory(...args) {
        if (this instanceof DecoratorFactory) {
          metaCtor.call(this, ...args);
          return this;
        }

        const annotationInstance = new DecoratorFactory(...args);
        return function TypeDecorator(cls) {
          if (typeFn) typeFn(cls, ...args); // Use of Object.defineProperty is important since it creates non-enumerable property which
          // prevents the property is copied during subclassing.

          const annotations = cls.hasOwnProperty(ANNOTATIONS) ? cls[ANNOTATIONS] : Object.defineProperty(cls, ANNOTATIONS, {
            value: []
          })[ANNOTATIONS];
          annotations.push(annotationInstance);
          if (additionalProcessing) additionalProcessing(cls);
          return cls;
        };
      }

      if (parentClass) {
        DecoratorFactory.prototype = Object.create(parentClass.prototype);
      }

      DecoratorFactory.prototype.ngMetadataName = name;
      DecoratorFactory.annotationCls = DecoratorFactory;
      return DecoratorFactory;
    }

    function makeMetadataCtor(props) {
      return function ctor(...args) {
        if (props) {
          const values = props(...args);

          for (const propName in values) {
            this[propName] = values[propName];
          }
        }
      };
    }

    function makeParamDecorator(name, props, parentClass) {
      const metaCtor = makeMetadataCtor(props);

      function ParamDecoratorFactory(...args) {
        if (this instanceof ParamDecoratorFactory) {
          metaCtor.apply(this, args);
          return this;
        }

        const annotationInstance = new ParamDecoratorFactory(...args);
        ParamDecorator.annotation = annotationInstance;
        return ParamDecorator;

        function ParamDecorator(cls, unusedKey, index) {
          // Use of Object.defineProperty is important since it creates non-enumerable property which
          // prevents the property is copied during subclassing.
          const parameters = cls.hasOwnProperty(PARAMETERS) ? cls[PARAMETERS] : Object.defineProperty(cls, PARAMETERS, {
            value: []
          })[PARAMETERS]; // there might be gaps if some in between parameters do not have annotations.
          // we pad with nulls.

          while (parameters.length <= index) {
            parameters.push(null);
          }

          (parameters[index] = parameters[index] || []).push(annotationInstance);
          return cls;
        }
      }

      if (parentClass) {
        ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);
      }

      ParamDecoratorFactory.prototype.ngMetadataName = name;
      ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;
      return ParamDecoratorFactory;
    }

    function makePropDecorator(name, props, parentClass, additionalProcessing) {
      const metaCtor = makeMetadataCtor(props);

      function PropDecoratorFactory(...args) {
        if (this instanceof PropDecoratorFactory) {
          metaCtor.apply(this, args);
          return this;
        }

        const decoratorInstance = new PropDecoratorFactory(...args);

        function PropDecorator(target, name) {
          const constructor = target.constructor; // Use of Object.defineProperty is important since it creates non-enumerable property which
          // prevents the property is copied during subclassing.

          const meta = constructor.hasOwnProperty(PROP_METADATA) ? constructor[PROP_METADATA] : Object.defineProperty(constructor, PROP_METADATA, {
            value: {}
          })[PROP_METADATA];
          meta[name] = meta.hasOwnProperty(name) && meta[name] || [];
          meta[name].unshift(decoratorInstance);
          if (additionalProcessing) additionalProcessing(target, name, ...args);
        }

        return PropDecorator;
      }

      if (parentClass) {
        PropDecoratorFactory.prototype = Object.create(parentClass.prototype);
      }

      PropDecoratorFactory.prototype.ngMetadataName = name;
      PropDecoratorFactory.annotationCls = PropDecoratorFactory;
      return PropDecoratorFactory;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Type of the Inject decorator / constructor function.
     *
     * \@publicApi
     * @record
     */


    function InjectDecorator() {} // WARNING: interface has both a type and a value, skipping emit


    const ɵ0 =
    /**
    * @param {?} token
    * @return {?}
    */
    token => ({
      token
    });
    /**
     * Inject decorator and metadata.
     *
     * \@Annotation
     * \@publicApi
     * @type {?}
     */


    const Inject = makeParamDecorator('Inject', ɵ0);
    /**
     * Type of the Optional decorator / constructor function.
     *
     * \@publicApi
     * @record
     */

    function OptionalDecorator() {} // WARNING: interface has both a type and a value, skipping emit

    /**
     * Optional decorator and metadata.
     *
     * \@Annotation
     * \@publicApi
     * @type {?}
     */


    const Optional = makeParamDecorator('Optional');
    /**
     * Type of the Self decorator / constructor function.
     *
     * \@publicApi
     * @record
     */

    function SelfDecorator() {} // WARNING: interface has both a type and a value, skipping emit

    /**
     * Self decorator and metadata.
     *
     * \@Annotation
     * \@publicApi
     * @type {?}
     */


    const Self = makeParamDecorator('Self');
    /**
     * Type of the SkipSelf decorator / constructor function.
     *
     * \@publicApi
     * @record
     */

    function SkipSelfDecorator() {} // WARNING: interface has both a type and a value, skipping emit

    /**
     * SkipSelf decorator and metadata.
     *
     * \@Annotation
     * \@publicApi
     * @type {?}
     */


    const SkipSelf = makeParamDecorator('SkipSelf');
    /**
     * Type of the Host decorator / constructor function.
     *
     * \@publicApi
     * @record
     */

    function HostDecorator() {} // WARNING: interface has both a type and a value, skipping emit

    /**
     * Host decorator and metadata.
     *
     * \@Annotation
     * \@publicApi
     * @type {?}
     */


    const Host = makeParamDecorator('Host');
    /**
     * Type of the Attribute decorator / constructor function.
     *
     * \@publicApi
     * @record
     */

    function AttributeDecorator() {} // WARNING: interface has both a type and a value, skipping emit


    const ɵ1 =
    /**
    * @param {?=} attributeName
    * @return {?}
    */
    attributeName => ({
      attributeName
    });
    /**
     * Attribute decorator and metadata.
     *
     * \@Annotation
     * \@publicApi
     * @type {?}
     */


    const Attribute = makeParamDecorator('Attribute', ɵ1);
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Injection flags for DI.
     *
     * @publicApi
     */

    var InjectFlags;

    (function (InjectFlags) {
      // TODO(alxhub): make this 'const' when ngc no longer writes exports of it into ngfactory files.

      /** Check self and check parent injector if needed */
      InjectFlags[InjectFlags["Default"] = 0] = "Default";
      /**
       * Specifies that an injector should retrieve a dependency from any injector until reaching the
       * host element of the current component. (Only used with Element Injector)
       */

      InjectFlags[InjectFlags["Host"] = 1] = "Host";
      /** Don't ascend to ancestors of the node requesting injection. */

      InjectFlags[InjectFlags["Self"] = 2] = "Self";
      /** Skip the node that is requesting injection. */

      InjectFlags[InjectFlags["SkipSelf"] = 4] = "SkipSelf";
      /** Inject `defaultValue` instead if token not found. */

      InjectFlags[InjectFlags["Optional"] = 8] = "Optional";
    })(InjectFlags || (InjectFlags = {}));
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    function getClosureSafeProperty(objWithPropertyToExtract) {
      for (let key in objWithPropertyToExtract) {
        if (objWithPropertyToExtract[key] === getClosureSafeProperty) {
          return key;
        }
      }

      throw Error('Could not find renamed property on target object.');
    }
    /**
     * Sets properties on a target object from a source object, but only if
     * the property doesn't already exist on the target object.
     * @param target The target to set properties on
     * @param source The source of the property keys and values to set
     */


    function fillProperties(target, source) {
      for (const key in source) {
        if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {
          target[key] = source[key];
        }
      }
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Construct an `InjectableDef` which defines how a token will be constructed by the DI system, and
     * in which injectors (if any) it will be available.
     *
     * This should be assigned to a static `ngInjectableDef` field on a type, which will then be an
     * `InjectableType`.
     *
     * Options:
     * * `providedIn` determines which injectors will include the injectable, by either associating it
     *   with an `@NgModule` or other `InjectorType`, or by specifying that this injectable should be
     *   provided in the `'root'` injector, which will be the application-level injector in most apps.
     * * `factory` gives the zero argument function which will create an instance of the injectable.
     *   The factory can call `inject` to access the `Injector` and request injection of dependencies.
     *
     * @codeGenApi
     */


    function ɵɵdefineInjectable(opts) {
      return {
        token: opts.token,
        providedIn: opts.providedIn || null,
        factory: opts.factory,
        value: undefined
      };
    }
    /**
     * @deprecated in v8, delete after v10. This API should be used only be generated code, and that
     * code should now use ɵɵdefineInjectable instead.
     * @publicApi
     */


    const defineInjectable = ɵɵdefineInjectable;
    /**
     * Construct an `InjectorDef` which configures an injector.
     *
     * This should be assigned to a static `ngInjectorDef` field on a type, which will then be an
     * `InjectorType`.
     *
     * Options:
     *
     * * `factory`: an `InjectorType` is an instantiable type, so a zero argument `factory` function to
     *   create the type must be provided. If that factory function needs to inject arguments, it can
     *   use the `inject` function.
     * * `providers`: an optional array of providers to add to the injector. Each provider must
     *   either have a factory or point to a type which has an `ngInjectableDef` static property (the
     *   type must be an `InjectableType`).
     * * `imports`: an optional array of imports of other `InjectorType`s or `InjectorTypeWithModule`s
     *   whose providers will also be added to the injector. Locally provided types will override
     *   providers from imports.
     *
     * @publicApi
     */

    function ɵɵdefineInjector(options) {
      return {
        factory: options.factory,
        providers: options.providers || [],
        imports: options.imports || []
      };
    }
    /**
     * Read the `ngInjectableDef` for `type` in a way which is immune to accidentally reading inherited
     * value.
     *
     * @param type A type which may have its own (non-inherited) `ngInjectableDef`.
     */


    function getInjectableDef(type) {
      const def = type[NG_INJECTABLE_DEF]; // The definition read above may come from a base class. `hasOwnProperty` is not sufficient to
      // distinguish this case, as in older browsers (e.g. IE10) static property inheritance is
      // implemented by copying the properties.
      //
      // Instead, the ngInjectableDef's token is compared to the type, and if they don't match then the
      // property was not defined directly on the type itself, and was likely inherited. The definition
      // is only returned if the type matches the def.token.

      return def && def.token === type ? def : null;
    }
    /**
     * Read the `ngInjectableDef` for `type` or read the `ngInjectableDef` from one of its ancestors.
     *
     * @param type A type which may have `ngInjectableDef`, via inheritance.
     *
     * @deprecated Will be removed in v10, where an error will occur in the scenario if we find the
     * `ngInjectableDef` on an ancestor only.
     */


    function getInheritedInjectableDef(type) {
      if (type && type[NG_INJECTABLE_DEF]) {
        // TODO(FW-1307): Re-add ngDevMode when closure can handle it
        // ngDevMode &&
        console.warn("DEPRECATED: DI is instantiating a token \"".concat(type.name, "\" that inherits its @Injectable decorator but does not provide one itself.\n") + "This will become an error in v10. Please add @Injectable() to the \"".concat(type.name, "\" class."));
        return type[NG_INJECTABLE_DEF];
      } else {
        return null;
      }
    }
    /**
     * Read the `ngInjectorDef` type in a way which is immune to accidentally reading inherited value.
     *
     * @param type type which may have `ngInjectorDef`
     */


    function getInjectorDef(type) {
      return type && type.hasOwnProperty(NG_INJECTOR_DEF) ? type[NG_INJECTOR_DEF] : null;
    }

    const NG_INJECTABLE_DEF = getClosureSafeProperty({
      ngInjectableDef: getClosureSafeProperty
    });
    const NG_INJECTOR_DEF = getClosureSafeProperty({
      ngInjectorDef: getClosureSafeProperty
    });
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    function stringify(token) {
      if (typeof token === 'string') {
        return token;
      }

      if (token instanceof Array) {
        return '[' + token.map(stringify).join(', ') + ']';
      }

      if (token == null) {
        return '' + token;
      }

      if (token.overriddenName) {
        return "".concat(token.overriddenName);
      }

      if (token.name) {
        return "".concat(token.name);
      }

      const res = token.toString();

      if (res == null) {
        return '' + res;
      }

      const newLineIndex = res.indexOf('\n');
      return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * An interface that a function passed into {\@link forwardRef} has to implement.
     *
     * \@usageNotes
     * ### Example
     *
     * {\@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref_fn'}
     * \@publicApi
     * @record
     */


    function ForwardRefFn() {}
    /** @type {?} */


    const __forward_ref__ = getClosureSafeProperty({
      __forward_ref__: getClosureSafeProperty
    });
    /**
     * Allows to refer to references which are not yet defined.
     *
     * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of
     * DI is declared, but not yet defined. It is also used when the `token` which we use when creating
     * a query is not yet defined.
     *
     * \@usageNotes
     * ### Example
     * {\@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}
     * \@publicApi
     * @param {?} forwardRefFn
     * @return {?}
     */


    function forwardRef(forwardRefFn) {
      /** @type {?} */
      forwardRefFn.__forward_ref__ = forwardRef;

      /** @type {?} */
      forwardRefFn.toString =
      /**
      * @return {?}
      */
      function () {
        return stringify(this());
      };

      return (
        /** @type {?} */

        /** @type {?} */
        forwardRefFn
      );
    }
    /**
     * Lazily retrieves the reference value from a forwardRef.
     *
     * Acts as the identity function when given a non-forward-ref value.
     *
     * \@usageNotes
     * ### Example
     *
     * {\@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}
     *
     * @see `forwardRef`
     * \@publicApi
     * @template T
     * @param {?} type
     * @return {?}
     */


    function resolveForwardRef(type) {
      /** @type {?} */
      const fn = type;

      if (typeof fn === 'function' && fn.hasOwnProperty(__forward_ref__) && fn.__forward_ref__ === forwardRef) {
        return fn();
      } else {
        return type;
      }
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    const __globalThis = typeof globalThis !== 'undefined' && globalThis;

    const __window = typeof window !== 'undefined' && window;

    const __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && self;

    const __global = typeof global !== 'undefined' && global; // Always use __globalThis if available, which is the spec-defined global variable across all
    // environments, then fallback to __global first, because in Node tests both __global and
    // __window may be defined and _global should be __global in that case.


    const _global = __globalThis || __global || __window || __self;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    var R3ResolvedDependencyType;

    (function (R3ResolvedDependencyType) {
      R3ResolvedDependencyType[R3ResolvedDependencyType["Token"] = 0] = "Token";
      R3ResolvedDependencyType[R3ResolvedDependencyType["Attribute"] = 1] = "Attribute";
      R3ResolvedDependencyType[R3ResolvedDependencyType["ChangeDetectorRef"] = 2] = "ChangeDetectorRef";
    })(R3ResolvedDependencyType || (R3ResolvedDependencyType = {}));
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    function getCompilerFacade() {
      const globalNg = _global['ng'];

      if (!globalNg || !globalNg.ɵcompilerFacade) {
        throw new Error("Angular JIT compilation failed: '@angular/compiler' not loaded!\n" + "  - JIT compilation is discouraged for production use-cases! Consider AOT mode instead.\n" + "  - Did you bootstrap using '@angular/platform-browser-dynamic' or '@angular/platform-server'?\n" + "  - Alternatively provide the compiler with 'import \"@angular/compiler\";' before bootstrapping.");
      }

      return globalNg.ɵcompilerFacade;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Creates a token that can be used in a DI Provider.
     *
     * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a
     * runtime representation) such as when injecting an interface, callable type, array or
     * parameterized type.
     *
     * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by
     * the `Injector`. This provides additional level of type safety.
     *
     * ```
     * interface MyInterface {...}
     * var myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));
     * // myInterface is inferred to be MyInterface.
     * ```
     *
     * When creating an `InjectionToken`, you can optionally specify a factory function which returns
     * (possibly by creating) a default value of the parameterized type `T`. This sets up the
     * `InjectionToken` using this factory as a provider as if it was defined explicitly in the
     * application's root injector. If the factory function, which takes zero arguments, needs to inject
     * dependencies, it can do so using the `inject` function. See below for an example.
     *
     * Additionally, if a `factory` is specified you can also specify the `providedIn` option, which
     * overrides the above behavior and marks the token as belonging to a particular `\@NgModule`. As
     * mentioned above, `'root'` is the default value for `providedIn`.
     *
     * \@usageNotes
     * ### Basic Example
     *
     * ### Plain InjectionToken
     *
     * {\@example core/di/ts/injector_spec.ts region='InjectionToken'}
     *
     * ### Tree-shakable InjectionToken
     *
     * {\@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}
     *
     *
     * \@publicApi
     * @template T
     */


    class InjectionToken {
      /**
       * @param {?} _desc
       * @param {?=} options
       */
      constructor(_desc, options) {
        this._desc = _desc;
        /**
         * \@internal
         */

        this.ngMetadataName = 'InjectionToken';
        /** @nocollapse */

        this.ngInjectableDef = undefined;

        if (typeof options == 'number') {
          // This is a special hack to assign __NG_ELEMENT_ID__ to this instance.
          // __NG_ELEMENT_ID__ is Used by Ivy to determine bloom filter id.
          // We are using it to assign `-1` which is used to identify `Injector`.

          /** @type {?} */
          this.__NG_ELEMENT_ID__ = options;
        } else if (options !== undefined) {
          /** @nocollapse */
          this.ngInjectableDef = ɵɵdefineInjectable({
            token: this,
            providedIn: options.providedIn || 'root',
            factory: options.factory
          });
        }
      }
      /**
       * @return {?}
       */


      toString() {
        return "InjectionToken ".concat(this._desc);
      }

    }

    if (false) {}
    /**
     * @record
     * @template T
     */


    function InjectableDefToken() {}

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.
     *
     * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a
     * project.
     *
     * \@publicApi
     * @type {?}
     */


    const INJECTOR = new InjectionToken('INJECTOR',
    /** @type {?} */
    -1);
    /** @type {?} */

    const _THROW_IF_NOT_FOUND = new Object();
    /** @type {?} */


    const THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
    /** @type {?} */

    const NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';
    /** @type {?} */

    const NG_TOKEN_PATH = 'ngTokenPath';
    /** @type {?} */

    const NEW_LINE = /\n/gm;
    /** @type {?} */

    const NO_NEW_LINE = 'ɵ';
    /** @type {?} */

    const SOURCE = '__source';
    const ɵ0$1 = getClosureSafeProperty;
    /** @type {?} */

    const USE_VALUE = getClosureSafeProperty({
      provide: String,
      useValue: ɵ0$1
    });
    /**
     * Current injector value used by `inject`.
     * - `undefined`: it is an error to call `inject`
     * - `null`: `inject` can be called but there is no injector (limp-mode).
     * - Injector instance: Use the injector for resolution.
     * @type {?}
     */

    let _currentInjector = undefined;
    /**
     * @param {?} injector
     * @return {?}
     */

    function setCurrentInjector(injector) {
      /** @type {?} */
      const former = _currentInjector;
      _currentInjector = injector;
      return former;
    }
    /**
     * Current implementation of inject.
     *
     * By default, it is `injectInjectorOnly`, which makes it `Injector`-only aware. It can be changed
     * to `directiveInject`, which brings in the `NodeInjector` system of ivy. It is designed this
     * way for two reasons:
     *  1. `Injector` should not depend on ivy logic.
     *  2. To maintain tree shake-ability we don't want to bring in unnecessary code.
     * @type {?}
     */


    let _injectImplementation;
    /**
     * Sets the current inject implementation.
     * @param {?} impl
     * @return {?}
     */


    function setInjectImplementation(impl) {
      /** @type {?} */
      const previous = _injectImplementation;
      _injectImplementation = impl;
      return previous;
    }
    /**
     * @template T
     * @param {?} token
     * @param {?=} flags
     * @return {?}
     */


    function injectInjectorOnly(token, flags = InjectFlags.Default) {
      if (_currentInjector === undefined) {
        throw new Error("inject() must be called from an injection context");
      } else if (_currentInjector === null) {
        return injectRootLimpMode(token, undefined, flags);
      } else {
        return _currentInjector.get(token, flags & InjectFlags.Optional ? null : undefined, flags);
      }
    }
    /**
     * @template T
     * @param {?} token
     * @param {?=} flags
     * @return {?}
     */


    function ɵɵinject(token, flags = InjectFlags.Default) {
      return (_injectImplementation || injectInjectorOnly)(token, flags);
    }
    /**
     * Injects a token from the currently active injector.
     *
     * Must be used in the context of a factory function such as one defined for an
     * `InjectionToken`. Throws an error if not called from such a context.
     *
     * Within such a factory function, using this function to request injection of a dependency
     * is faster and more type-safe than providing an additional array of dependencies
     * (as has been common with `useFactory` providers).
     *
     * \@param token The injection token for the dependency to be injected.
     * \@param flags Optional flags that control how injection is executed.
     * The flags correspond to injection strategies that can be specified with
     * parameter decorators `\@Host`, `\@Self`, `\@SkipSef`, and `\@Optional`.
     * \@return True if injection is successful, null otherwise.
     *
     * \@usageNotes
     *
     * ### Example
     *
     * {\@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}
     *
     * \@publicApi
     * @type {?}
     */


    const inject = ɵɵinject;
    /**
     * Injects `root` tokens in limp mode.
     *
     * If no injector exists, we can still inject tree-shakable providers which have `providedIn` set to
     * `"root"`. This is known as the limp mode injection. In such case the value is stored in the
     * `InjectableDef`.
     * @template T
     * @param {?} token
     * @param {?} notFoundValue
     * @param {?} flags
     * @return {?}
     */

    function injectRootLimpMode(token, notFoundValue, flags) {
      /** @type {?} */
      const injectableDef = getInjectableDef(token);

      if (injectableDef && injectableDef.providedIn == 'root') {
        return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() : injectableDef.value;
      }

      if (flags & InjectFlags.Optional) return null;
      if (notFoundValue !== undefined) return notFoundValue;
      throw new Error("Injector: NOT_FOUND [".concat(stringify(token), "]"));
    }
    /**
     * @param {?} types
     * @return {?}
     */


    function injectArgs(types) {
      /** @type {?} */
      const args = [];

      for (let i = 0; i < types.length; i++) {
        /** @type {?} */
        const arg = resolveForwardRef(types[i]);

        if (Array.isArray(arg)) {
          if (arg.length === 0) {
            throw new Error('Arguments array must have arguments.');
          }
          /** @type {?} */


          let type = undefined;
          /** @type {?} */

          let flags = InjectFlags.Default;

          for (let j = 0; j < arg.length; j++) {
            /** @type {?} */
            const meta = arg[j];

            if (meta instanceof Optional || meta.ngMetadataName === 'Optional' || meta === Optional) {
              flags |= InjectFlags.Optional;
            } else if (meta instanceof SkipSelf || meta.ngMetadataName === 'SkipSelf' || meta === SkipSelf) {
              flags |= InjectFlags.SkipSelf;
            } else if (meta instanceof Self || meta.ngMetadataName === 'Self' || meta === Self) {
              flags |= InjectFlags.Self;
            } else if (meta instanceof Inject || meta === Inject) {
              type = meta.token;
            } else {
              type = meta;
            }
          }

          args.push(ɵɵinject(
          /** @type {?} */
          type, flags));
        } else {
          args.push(ɵɵinject(arg));
        }
      }

      return args;
    }

    class NullInjector {
      /**
       * @param {?} token
       * @param {?=} notFoundValue
       * @return {?}
       */
      get(token, notFoundValue = THROW_IF_NOT_FOUND) {
        if (notFoundValue === THROW_IF_NOT_FOUND) {
          // Intentionally left behind: With dev tools open the debugger will stop here. There is no
          // reason why correctly written application should cause this exception.
          // TODO(misko): uncomment the next line once `ngDevMode` works with closure.
          // if(ngDevMode) debugger;

          /** @type {?} */
          const error = new Error("NullInjectorError: No provider for ".concat(stringify(token), "!"));
          error.name = 'NullInjectorError';
          throw error;
        }

        return notFoundValue;
      }

    }
    /**
     * @param {?} e
     * @param {?} token
     * @param {?} injectorErrorName
     * @param {?} source
     * @return {?}
     */


    function catchInjectorError(e, token, injectorErrorName, source) {
      /** @type {?} */
      const tokenPath = e[NG_TEMP_TOKEN_PATH];

      if (token[SOURCE]) {
        tokenPath.unshift(token[SOURCE]);
      }

      e.message = formatError('\n' + e.message, tokenPath, injectorErrorName, source);
      e[NG_TOKEN_PATH] = tokenPath;
      e[NG_TEMP_TOKEN_PATH] = null;
      throw e;
    }
    /**
     * @param {?} text
     * @param {?} obj
     * @param {?} injectorErrorName
     * @param {?=} source
     * @return {?}
     */


    function formatError(text, obj, injectorErrorName, source = null) {
      text = text && text.charAt(0) === '\n' && text.charAt(1) == NO_NEW_LINE ? text.substr(2) : text;
      /** @type {?} */

      let context = stringify(obj);

      if (obj instanceof Array) {
        context = obj.map(stringify).join(' -> ');
      } else if (typeof obj === 'object') {
        /** @type {?} */
        let parts =
        /** @type {?} */
        [];

        for (let key in obj) {
          if (obj.hasOwnProperty(key)) {
            /** @type {?} */
            let value = obj[key];
            parts.push(key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify(value)));
          }
        }

        context = "{".concat(parts.join(', '), "}");
      }

      return "".concat(injectorErrorName).concat(source ? '(' + source + ')' : '', "[").concat(context, "]: ").concat(text.replace(NEW_LINE, '\n  '));
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * A mapping of the \@angular/core API surface used in generated expressions to the actual symbols.
     *
     * This should be kept up to date with the public exports of \@angular/core.
     * @type {?}
     */


    const angularCoreDiEnv = {
      'ɵɵdefineInjectable': ɵɵdefineInjectable,
      'ɵɵdefineInjector': ɵɵdefineInjector,
      'ɵɵinject': ɵɵinject,
      'ɵɵgetFactoryOf': getFactoryOf
    };
    /**
     * @template T
     * @param {?} type
     * @return {?}
     */

    function getFactoryOf(type) {
      /** @type {?} */
      const typeAny =
      /** @type {?} */
      type;
      /** @type {?} */

      const def = getInjectableDef(typeAny) || getInjectorDef(typeAny);

      if (!def || def.factory === undefined) {
        return null;
      }

      return def.factory;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Represents an instance of an NgModule created via a {\@link NgModuleFactory}.
     *
     * `NgModuleRef` provides access to the NgModule Instance as well other objects related to this
     * NgModule Instance.
     *
     * \@publicApi
     * @abstract
     * @template T
     */


    class NgModuleRef {}

    if (false) {}
    /**
     * @record
     * @template T
     */


    function InternalNgModuleRef() {}

    if (false) {}
    /**
     * \@publicApi
     * @abstract
     * @template T
     */


    class NgModuleFactory {}

    if (false) {}
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
    * Equivalent to ES6 spread, add each item to an array.
    *
    * @param items The items to add
    * @param arr The array to which you want to add the items
    */


    function addAllToArray(items, arr) {
      for (let i = 0; i < items.length; i++) {
        arr.push(items[i]);
      }
    }
    /**
     * Flattens an array.
     */


    function flatten(list, dst) {
      if (dst === undefined) dst = list;

      for (let i = 0; i < list.length; i++) {
        let item = list[i];

        if (Array.isArray(item)) {
          // we need to inline it.
          if (dst === list) {
            // Our assumption that the list was already flat was wrong and
            // we need to clone flat since we need to write to it.
            dst = list.slice(0, i);
          }

          flatten(item, dst);
        } else if (dst !== list) {
          dst.push(item);
        }
      }

      return dst;
    }

    function deepForEach(input, fn) {
      input.forEach(value => Array.isArray(value) ? deepForEach(value, fn) : fn(value));
    }

    function addToArray(arr, index, value) {
      // perf: array.push is faster than array.splice!
      if (index >= arr.length) {
        arr.push(value);
      } else {
        arr.splice(index, 0, value);
      }
    }

    function removeFromArray(arr, index) {
      // perf: array.pop is faster than array.splice!
      if (index >= arr.length - 1) {
        return arr.pop();
      } else {
        return arr.splice(index, 1)[0];
      }
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    function assertNumber(actual, msg) {
      if (typeof actual != 'number') {
        throwError(msg);
      }
    }

    function assertEqual(actual, expected, msg) {
      if (actual != expected) {
        throwError(msg);
      }
    }

    function assertNotEqual(actual, expected, msg) {
      if (actual == expected) {
        throwError(msg);
      }
    }

    function assertSame(actual, expected, msg) {
      if (actual !== expected) {
        throwError(msg);
      }
    }

    function assertNotSame(actual, expected, msg) {
      if (actual === expected) {
        throwError(msg);
      }
    }

    function assertLessThan(actual, expected, msg) {
      if (actual >= expected) {
        throwError(msg);
      }
    }

    function assertGreaterThan(actual, expected, msg) {
      if (actual <= expected) {
        throwError(msg);
      }
    }

    function assertNotDefined(actual, msg) {
      if (actual != null) {
        throwError(msg);
      }
    }

    function assertDefined(actual, msg) {
      if (actual == null) {
        throwError(msg);
      }
    }

    function throwError(msg) {
      // tslint:disable-next-line
      debugger; // Left intentionally for better debugger experience.

      throw new Error("ASSERTION ERROR: ".concat(msg));
    }

    function assertDomNode(node) {
      // If we're in a worker, `Node` will not be defined.
      assertEqual(typeof Node !== 'undefined' && node instanceof Node || typeof node === 'object' && node != null && node.constructor.name === 'WebWorkerRenderNode', true, "The provided value must be an instance of a DOM Node but got ".concat(stringify(node)));
    }

    function assertDataInRange(arr, index) {
      const maxLen = arr ? arr.length : 0;
      assertLessThan(index, maxLen, "Index expected to be less than ".concat(maxLen, " but got ").concat(index));
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    function ngDevModeResetPerfCounters() {
      const locationString = typeof location !== 'undefined' ? location.toString() : '';
      const newCounters = {
        namedConstructors: locationString.indexOf('ngDevMode=namedConstructors') != -1,
        firstTemplatePass: 0,
        tNode: 0,
        tView: 0,
        rendererCreateTextNode: 0,
        rendererSetText: 0,
        rendererCreateElement: 0,
        rendererAddEventListener: 0,
        rendererSetAttribute: 0,
        rendererRemoveAttribute: 0,
        rendererSetProperty: 0,
        rendererSetClassName: 0,
        rendererAddClass: 0,
        rendererRemoveClass: 0,
        rendererSetStyle: 0,
        rendererRemoveStyle: 0,
        rendererDestroy: 0,
        rendererDestroyNode: 0,
        rendererMoveNode: 0,
        rendererRemoveNode: 0,
        rendererAppendChild: 0,
        rendererInsertBefore: 0,
        rendererCreateComment: 0,
        styleMap: 0,
        styleMapCacheMiss: 0,
        classMap: 0,
        classMapCacheMiss: 0,
        styleProp: 0,
        stylePropCacheMiss: 0,
        classProp: 0,
        classPropCacheMiss: 0,
        flushStyling: 0,
        classesApplied: 0,
        stylesApplied: 0,
        stylingWritePersistedState: 0,
        stylingReadPersistedState: 0
      }; // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.

      const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;
      _global['ngDevMode'] = allowNgDevModeTrue && newCounters;
      return newCounters;
    }
    /**
     * This checks to see if the `ngDevMode` has been set. If yes,
     * then we honor it, otherwise we default to dev mode with additional checks.
     *
     * The idea is that unless we are doing production build where we explicitly
     * set `ngDevMode == false` we should be helping the developer by providing
     * as much early warning and errors as possible.
     *
     * NOTE: changes to the `ngDevMode` name must be synced with `compiler-cli/src/tooling.ts`.
     */


    if (typeof ngDevMode === 'undefined' || ngDevMode) {
      ngDevModeResetPerfCounters();
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /** @enum {number} */


    const ChangeDetectionStrategy = {
      /**
       * Use the `CheckOnce` strategy, meaning that automatic change detection is deactivated
       * until reactivated by setting the strategy to `Default` (`CheckAlways`).
       * Change detection can still be explicitly invoked.
       * This strategy applies to all child directives and cannot be overridden.
       */
      OnPush: 0,

      /**
       * Use the default `CheckAlways` strategy, in which change detection is automatic until
       * explicitly deactivated.
       */
      Default: 1
    };
    ChangeDetectionStrategy[ChangeDetectionStrategy.OnPush] = 'OnPush';
    ChangeDetectionStrategy[ChangeDetectionStrategy.Default] = 'Default';
    /** @enum {number} */

    const ChangeDetectorStatus = {
      /**
       * A state in which, after calling `detectChanges()`, the change detector
       * state becomes `Checked`, and must be explicitly invoked or reactivated.
       */
      CheckOnce: 0,

      /**
       * A state in which change detection is skipped until the change detector mode
       * becomes `CheckOnce`.
       */
      Checked: 1,

      /**
       * A state in which change detection continues automatically until explicitly
       * deactivated.
       */
      CheckAlways: 2,

      /**
       * A state in which a change detector sub tree is not a part of the main tree and
       * should be skipped.
       */
      Detached: 3,

      /**
       * Indicates that the change detector encountered an error checking a binding
       * or calling a directive lifecycle method and is now in an inconsistent state. Change
       * detectors in this state do not detect changes.
       */
      Errored: 4,

      /**
       * Indicates that the change detector has been destroyed.
       */
      Destroyed: 5
    };
    ChangeDetectorStatus[ChangeDetectorStatus.CheckOnce] = 'CheckOnce';
    ChangeDetectorStatus[ChangeDetectorStatus.Checked] = 'Checked';
    ChangeDetectorStatus[ChangeDetectorStatus.CheckAlways] = 'CheckAlways';
    ChangeDetectorStatus[ChangeDetectorStatus.Detached] = 'Detached';
    ChangeDetectorStatus[ChangeDetectorStatus.Errored] = 'Errored';
    ChangeDetectorStatus[ChangeDetectorStatus.Destroyed] = 'Destroyed';
    /**
     * Reports whether a given strategy is currently the default for change detection.
     * @see `ChangeDetectorStatus` / `ChangeDetectorRef`
     * @param {?} changeDetectionStrategy The strategy to check.
     * @return {?} True if the given strategy is the current default, false otherwise.
     */

    function isDefaultChangeDetectionStrategy(changeDetectionStrategy) {
      return changeDetectionStrategy == null || changeDetectionStrategy === ChangeDetectionStrategy.Default;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /** @enum {number} */


    const ViewEncapsulation = {
      /**
       * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host
       * Element and pre-processing the style rules provided via {@link Component#styles styles} or
       * {@link Component#styleUrls styleUrls}, and adding the new Host Element attribute to all
       * selectors.
       *
       * This is the default option.
       */
      Emulated: 0,

      /**
       * @deprecated v6.1.0 - use {ViewEncapsulation.ShadowDom} instead.
       * Use the native encapsulation mechanism of the renderer.
       *
       * For the DOM this means using the deprecated [Shadow DOM
       * v0](https://w3c.github.io/webcomponents/spec/shadow/) and
       * creating a ShadowRoot for Component's Host Element.
       */
      Native: 1,

      /**
       * Don't provide any template or style encapsulation.
       */
      None: 2,

      /**
       * Use Shadow DOM to encapsulate styles.
       *
       * For the DOM this means using modern [Shadow
       * DOM](https://w3c.github.io/webcomponents/spec/shadow/) and
       * creating a ShadowRoot for Component's Host Element.
       */
      ShadowDom: 3
    };
    ViewEncapsulation[ViewEncapsulation.Emulated] = 'Emulated';
    ViewEncapsulation[ViewEncapsulation.Native] = 'Native';
    ViewEncapsulation[ViewEncapsulation.None] = 'None';
    ViewEncapsulation[ViewEncapsulation.ShadowDom] = 'ShadowDom';
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Convince closure compiler that the wrapped function has no side-effects.
     *
     * Closure compiler always assumes that `toString` has no side-effects. We use this quirk to
     * allow us to execute a function but have closure compiler mark the call as no-side-effects.
     * It is important that the return value for the `noSideEffects` function be assigned
     * to something which is retained otherwise the call to `noSideEffects` will be removed by closure
     * compiler.
     */

    function noSideEffects(fn) {
      return '' + {
        toString: fn
      };
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * This file contains reuseable "empty" symbols that can be used as default return values
     * in different parts of the rendering code. Because the same symbols are returned, this
     * allows for identity checks against these values to be consistently used by the framework
     * code.
     * @type {?}
     */


    const EMPTY_OBJ = {};
    /** @type {?} */

    const EMPTY_ARRAY = []; // freezing the values prevents any code from accidentally inserting new values in

    if (typeof ngDevMode !== 'undefined' && ngDevMode) {
      // These property accesses can be ignored because ngDevMode will be set to false
      // when optimizing code and the whole if statement will be dropped.
      // tslint:disable-next-line:no-toplevel-property-access
      Object.freeze(EMPTY_OBJ); // tslint:disable-next-line:no-toplevel-property-access

      Object.freeze(EMPTY_ARRAY);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    const NG_COMPONENT_DEF = getClosureSafeProperty({
      ngComponentDef: getClosureSafeProperty
    });
    /** @type {?} */

    const NG_DIRECTIVE_DEF = getClosureSafeProperty({
      ngDirectiveDef: getClosureSafeProperty
    });
    /** @type {?} */

    const NG_PIPE_DEF = getClosureSafeProperty({
      ngPipeDef: getClosureSafeProperty
    });
    /** @type {?} */

    const NG_MODULE_DEF = getClosureSafeProperty({
      ngModuleDef: getClosureSafeProperty
    });
    /** @type {?} */

    const NG_LOCALE_ID_DEF = getClosureSafeProperty({
      ngLocaleIdDef: getClosureSafeProperty
    });
    /** @type {?} */

    const NG_BASE_DEF = getClosureSafeProperty({
      ngBaseDef: getClosureSafeProperty
    }); // TODO(misko): This is wrong. The NG_ELEMENT_ID should never be minified.

    /**
     * If a directive is diPublic, bloomAdd sets a property on the type with this constant as
     * the key and the directive's unique ID as the value. This allows us to map directives to their
     * bloom filter bit for DI.
     * @type {?}
     */

    const NG_ELEMENT_ID = getClosureSafeProperty({
      __NG_ELEMENT_ID__: getClosureSafeProperty
    });
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    let _renderCompCount = 0;
    /**
     * Create a component definition object.
     *
     *
     * # Example
     * ```
     * class MyDirective {
     *   // Generated by Angular Template Compiler
     *   // [Symbol] syntax will not be supported by TypeScript until v2.7
     *   static ngComponentDef = defineComponent({
     *     ...
     *   });
     * }
     * ```
     * \@codeGenApi
     * @template T
     * @param {?} componentDefinition
     * @return {?}
     */

    function ɵɵdefineComponent(componentDefinition) {
      /** @type {?} */
      const type = componentDefinition.type;
      /** @type {?} */

      const typePrototype = type.prototype;
      /** @type {?} */

      const declaredInputs =
      /** @type {?} */
      {};
      /** @type {?} */

      const def = {
        type: type,
        providersResolver: null,
        consts: componentDefinition.consts,
        vars: componentDefinition.vars,
        factory: componentDefinition.factory,
        template: componentDefinition.template ||
        /** @type {?} */
        null,
        ngContentSelectors: componentDefinition.ngContentSelectors,
        hostBindings: componentDefinition.hostBindings || null,
        contentQueries: componentDefinition.contentQueries || null,
        declaredInputs: declaredInputs,
        inputs:
        /** @type {?} */
        null,
        // assigned in noSideEffects
        outputs:
        /** @type {?} */
        null,
        // assigned in noSideEffects
        exportAs: componentDefinition.exportAs || null,
        onChanges: null,
        onInit: typePrototype.ngOnInit || null,
        doCheck: typePrototype.ngDoCheck || null,
        afterContentInit: typePrototype.ngAfterContentInit || null,
        afterContentChecked: typePrototype.ngAfterContentChecked || null,
        afterViewInit: typePrototype.ngAfterViewInit || null,
        afterViewChecked: typePrototype.ngAfterViewChecked || null,
        onDestroy: typePrototype.ngOnDestroy || null,
        onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,
        directiveDefs:
        /** @type {?} */
        null,
        // assigned in noSideEffects
        pipeDefs:
        /** @type {?} */
        null,
        // assigned in noSideEffects
        selectors: componentDefinition.selectors,
        viewQuery: componentDefinition.viewQuery || null,
        features:
        /** @type {?} */
        componentDefinition.features || null,
        data: componentDefinition.data || {},
        // TODO(misko): convert ViewEncapsulation into const enum so that it can be used directly in the
        // next line. Also `None` should be 0 not 2.
        encapsulation: componentDefinition.encapsulation || ViewEncapsulation.Emulated,
        id: 'c',
        styles: componentDefinition.styles || EMPTY_ARRAY,
        _:
        /** @type {?} */
        null,
        setInput: null,
        schemas: componentDefinition.schemas || null,
        tView: null
      };
      def._ =
      /** @type {?} */
      noSideEffects(
      /**
      * @return {?}
      */
      () => {
        /** @type {?} */
        const directiveTypes =
        /** @type {?} */
        componentDefinition.directives;
        /** @type {?} */

        const feature = componentDefinition.features;
        /** @type {?} */

        const pipeTypes =
        /** @type {?} */
        componentDefinition.pipes;
        def.id += _renderCompCount++;
        def.inputs = invertObject(componentDefinition.inputs, declaredInputs), def.outputs = invertObject(componentDefinition.outputs), feature && feature.forEach(
        /**
        * @param {?} fn
        * @return {?}
        */
        fn => fn(def));
        def.directiveDefs = directiveTypes ?
        /**
        * @return {?}
        */
        () => (typeof directiveTypes === 'function' ? directiveTypes() : directiveTypes).map(extractDirectiveDef) : null;
        def.pipeDefs = pipeTypes ?
        /**
        * @return {?}
        */
        () => (typeof pipeTypes === 'function' ? pipeTypes() : pipeTypes).map(extractPipeDef) : null; // Add ngInjectableDef so components are reachable through the module injector by default
        // (unless it has already been set by the @Injectable decorator). This is mostly to
        // support injecting components in tests. In real application code, components should
        // be retrieved through the node injector, so this isn't a problem.

        if (!type.hasOwnProperty(NG_INJECTABLE_DEF)) {
          /** @type {?} */
          type[NG_INJECTABLE_DEF] = ɵɵdefineInjectable({
            token: type,
            factory:
            /** @type {?} */
            componentDefinition.factory
          });
        }
      });
      return (
        /** @type {?} */
        def
      );
    }
    /**
     * \@codeGenApi
     * @param {?} type
     * @param {?} directives
     * @param {?} pipes
     * @return {?}
     */


    function ɵɵsetComponentScope(type, directives, pipes) {
      /** @type {?} */
      const def =
      /** @type {?} */
      type.ngComponentDef;

      def.directiveDefs =
      /**
      * @return {?}
      */
      () => directives.map(extractDirectiveDef);

      def.pipeDefs =
      /**
      * @return {?}
      */
      () => pipes.map(extractPipeDef);
    }
    /**
     * @param {?} type
     * @return {?}
     */


    function extractDirectiveDef(type) {
      /** @type {?} */
      const def = getComponentDef(type) || getDirectiveDef(type);

      if (ngDevMode && !def) {
        throw new Error("'".concat(type.name, "' is neither 'ComponentType' or 'DirectiveType'."));
      }

      return (
        /** @type {?} */
        def
      );
    }
    /**
     * @param {?} type
     * @return {?}
     */


    function extractPipeDef(type) {
      /** @type {?} */
      const def = getPipeDef(type);

      if (ngDevMode && !def) {
        throw new Error("'".concat(type.name, "' is not a 'PipeType'."));
      }

      return (
        /** @type {?} */
        def
      );
    }
    /**
     * \@codeGenApi
     * @template T
     * @param {?} def
     * @return {?}
     */


    function ɵɵdefineNgModule(def) {
      /** @type {?} */
      const res = {
        type: def.type,
        bootstrap: def.bootstrap || EMPTY_ARRAY,
        declarations: def.declarations || EMPTY_ARRAY,
        imports: def.imports || EMPTY_ARRAY,
        exports: def.exports || EMPTY_ARRAY,
        transitiveCompileScopes: null,
        schemas: def.schemas || null,
        id: def.id || null
      };
      return (
        /** @type {?} */
        res
      );
    }
    /**
     * Adds the module metadata that is necessary to compute the module's transitive scope to an
     * existing module definition.
     *
     * Scope metadata of modules is not used in production builds, so calls to this function can be
     * marked pure to tree-shake it from the bundle, allowing for all referenced declarations
     * to become eligible for tree-shaking as well.
     *
     * \@codeGenApi
     * @param {?} type
     * @param {?} scope
     * @return {?}
     */


    function ɵɵsetNgModuleScope(type, scope) {
      return (
        /** @type {?} */
        noSideEffects(
        /**
        * @return {?}
        */
        () => {
          /** @type {?} */

          /** @nocollapse */
          const ngModuleDef = getNgModuleDef(type, true);
          ngModuleDef.declarations = scope.declarations || EMPTY_ARRAY;
          ngModuleDef.imports = scope.imports || EMPTY_ARRAY;
          ngModuleDef.exports = scope.exports || EMPTY_ARRAY;
        })
      );
    }
    /**
     * Inverts an inputs or outputs lookup such that the keys, which were the
     * minified keys, are part of the values, and the values are parsed so that
     * the publicName of the property is the new key
     *
     * e.g. for
     *
     * ```
     * class Comp {
     * \@Input()
     *   propName1: string;
     *
     * \@Input('publicName2')
     *   declaredPropName2: number;
     * }
     * ```
     *
     * will be serialized as
     *
     * ```
     * {
     *   propName1: 'propName1',
     *   declaredPropName2: ['publicName2', 'declaredPropName2'],
     * }
     * ```
     *
     * which is than translated by the minifier as:
     *
     * ```
     * {
     *   minifiedPropName1: 'propName1',
     *   minifiedPropName2: ['publicName2', 'declaredPropName2'],
     * }
     * ```
     *
     * becomes: (public name => minifiedName)
     *
     * ```
     * {
     *  'propName1': 'minifiedPropName1',
     *  'publicName2': 'minifiedPropName2',
     * }
     * ```
     *
     * Optionally the function can take `secondary` which will result in: (public name => declared name)
     *
     * ```
     * {
     *  'propName1': 'propName1',
     *  'publicName2': 'declaredPropName2',
     * }
     * ```
     *
     * @template T
     * @param {?=} obj
     * @param {?=} secondary
     * @return {?}
     */


    function invertObject(obj, secondary) {
      if (obj == null) return (
        /** @type {?} */
        EMPTY_OBJ
      );
      /** @type {?} */

      const newLookup = {};

      for (const minifiedKey in obj) {
        if (obj.hasOwnProperty(minifiedKey)) {
          /** @type {?} */
          let publicName =
          /** @type {?} */
          obj[minifiedKey];
          /** @type {?} */

          let declaredName = publicName;

          if (Array.isArray(publicName)) {
            declaredName = publicName[1];
            publicName = publicName[0];
          }

          newLookup[publicName] = minifiedKey;

          if (secondary) {
            secondary[publicName] =
            /** @type {?} */
            declaredName;
          }
        }
      }

      return newLookup;
    }
    /**
     * Create a base definition
     *
     * # Example
     * ```ts
     * class ShouldBeInherited {
     *   static ngBaseDef = ɵɵdefineBase({
     *      ...
     *   })
     * }
     * ```
     *
     * \@codeGenApi
     * @template T
     * @param {?} baseDefinition The base definition parameters
     *
     * @return {?}
     */


    function ɵɵdefineBase(baseDefinition) {
      /** @type {?} */
      const declaredInputs =
      /** @type {?} */
      {};
      return {
        inputs: invertObject(
        /** @type {?} */
        baseDefinition.inputs, declaredInputs),
        declaredInputs: declaredInputs,
        outputs: invertObject(
        /** @type {?} */
        baseDefinition.outputs),
        viewQuery: baseDefinition.viewQuery || null,
        contentQueries: baseDefinition.contentQueries || null,
        hostBindings: baseDefinition.hostBindings || null
      };
    }
    /**
     * Create a directive definition object.
     *
     * # Example
     * ```ts
     * class MyDirective {
     *   // Generated by Angular Template Compiler
     *   // [Symbol] syntax will not be supported by TypeScript until v2.7
     *   static ngDirectiveDef = ɵɵdefineDirective({
     *     ...
     *   });
     * }
     * ```
     *
     * \@codeGenApi
     * @type {?}
     */


    const ɵɵdefineDirective =
    /** @type {?} */

    /** @type {?} */
    ɵɵdefineComponent;
    /**
     * Create a pipe definition object.
     *
     * # Example
     * ```
     * class MyPipe implements PipeTransform {
     *   // Generated by Angular Template Compiler
     *   static ngPipeDef = definePipe({
     *     ...
     *   });
     * }
     * ```
     * \@codeGenApi
     * @template T
     * @param {?} pipeDef Pipe definition generated by the compiler
     *
     * @return {?}
     */

    function ɵɵdefinePipe(pipeDef) {
      return (
        /** @type {?} */

        /** @type {?} */
        {
          name: pipeDef.name,
          factory: pipeDef.factory,
          pure: pipeDef.pure !== false,
          onDestroy: pipeDef.type.prototype.ngOnDestroy || null
        }
      );
    }
    /**
     * The following getter methods retrieve the definition form the type. Currently the retrieval
     * honors inheritance, but in the future we may change the rule to require that definitions are
     * explicit. This would require some sort of migration strategy.
     * @template T
     * @param {?} type
     * @return {?}
     */


    function getComponentDef(type) {
      return (
        /** @type {?} */
        type[NG_COMPONENT_DEF] || null
      );
    }
    /**
     * @template T
     * @param {?} type
     * @return {?}
     */


    function getDirectiveDef(type) {
      return (
        /** @type {?} */
        type[NG_DIRECTIVE_DEF] || null
      );
    }
    /**
     * @template T
     * @param {?} type
     * @return {?}
     */


    function getPipeDef(type) {
      return (
        /** @type {?} */
        type[NG_PIPE_DEF] || null
      );
    }
    /**
     * @template T
     * @param {?} type
     * @return {?}
     */


    function getBaseDef(type) {
      return (
        /** @type {?} */
        type[NG_BASE_DEF] || null
      );
    }
    /**
     * @template T
     * @param {?} type
     * @param {?=} throwNotFound
     * @return {?}
     */


    function getNgModuleDef(type, throwNotFound) {
      /** @type {?} */

      /** @nocollapse */
      const ngModuleDef =
      /** @type {?} */
      type[NG_MODULE_DEF] || null;

      if (!ngModuleDef && throwNotFound === true) {
        throw new Error("Type ".concat(stringify(type), " does not have 'ngModuleDef' property."));
      }

      return ngModuleDef;
    }
    /**
     * @param {?} type
     * @return {?}
     */


    function getNgLocaleIdDef(type) {
      return (
        /** @type {?} */
        type[NG_LOCALE_ID_DEF] || null
      );
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // Below are constants for LView indices to help us look up LView members
    // without having to remember the specific indices.
    // Uglify will inline these when minifying so there shouldn't be a cost.

    /** @type {?} */


    const HOST = 0;
    /** @type {?} */

    const TVIEW = 1;
    /** @type {?} */

    const FLAGS = 2;
    /** @type {?} */

    const PARENT = 3;
    /** @type {?} */

    const NEXT = 4;
    /** @type {?} */

    const QUERIES = 5;
    /** @type {?} */

    const T_HOST = 6;
    /** @type {?} */

    const BINDING_INDEX = 7;
    /** @type {?} */

    const CLEANUP = 8;
    /** @type {?} */

    const CONTEXT = 9;
    /** @type {?} */

    const INJECTOR$1 = 10;
    /** @type {?} */

    const RENDERER_FACTORY = 11;
    /** @type {?} */

    const RENDERER = 12;
    /** @type {?} */

    const SANITIZER = 13;
    /** @type {?} */

    const CHILD_HEAD = 14;
    /** @type {?} */

    const CHILD_TAIL = 15;
    /** @type {?} */

    const DECLARATION_VIEW = 16;
    /** @type {?} */

    const DECLARATION_LCONTAINER = 17;
    /** @type {?} */

    const PREORDER_HOOK_FLAGS = 18;
    /**
     * Size of LView's header. Necessary to adjust for it when setting slots.
     * @type {?}
     */

    const HEADER_OFFSET = 19;
    /**
     * @record
     */

    function OpaqueViewState() {}

    if (false) {}
    /**
     * `LView` stores all of the information needed to process the instructions as
     * they are invoked from the template. Each embedded view and component view has its
     * own `LView`. When processing a particular view, we set the `viewData` to that
     * `LView`. When that view is done processing, the `viewData` is set back to
     * whatever the original `viewData` was before (the parent `LView`).
     *
     * Keeping separate state for each view facilities view insertion / deletion, so we
     * don't have to edit the data array based on which views are present.
     * @record
     */


    function LView() {}

    if (false) {}
    /** @enum {number} */


    const LViewFlags = {
      /** The state of the init phase on the first 2 bits */
      InitPhaseStateIncrementer: 1,
      InitPhaseStateMask: 3,

      /**
       * Whether or not the view is in creationMode.
       *
       * This must be stored in the view rather than using `data` as a marker so that
       * we can properly support embedded views. Otherwise, when exiting a child view
       * back into the parent view, `data` will be defined and `creationMode` will be
       * improperly reported as false.
       */
      CreationMode: 4,

      /**
       * Whether or not this LView instance is on its first processing pass.
       *
       * An LView instance is considered to be on its "first pass" until it
       * has completed one creation mode run and one update mode run. At this
       * time, the flag is turned off.
       */
      FirstLViewPass: 8,

      /** Whether this view has default change detection strategy (checks always) or onPush */
      CheckAlways: 16,

      /**
       * Whether or not manual change detection is turned on for onPush components.
       *
       * This is a special mode that only marks components dirty in two cases:
       * 1) There has been a change to an @Input property
       * 2) `markDirty()` has been called manually by the user
       *
       * Note that in this mode, the firing of events does NOT mark components
       * dirty automatically.
       *
       * Manual mode is turned off by default for backwards compatibility, as events
       * automatically mark OnPush components dirty in View Engine.
       *
       * TODO: Add a public API to ChangeDetectionStrategy to turn this mode on
       */
      ManualOnPush: 32,

      /** Whether or not this view is currently dirty (needing check) */
      Dirty: 64,

      /** Whether or not this view is currently attached to change detection tree. */
      Attached: 128,

      /** Whether or not this view is destroyed. */
      Destroyed: 256,

      /** Whether or not this view is the root view */
      IsRoot: 512,

      /**
       * Index of the current init phase on last 22 bits
       */
      IndexWithinInitPhaseIncrementer: 1024,
      IndexWithinInitPhaseShift: 10,
      IndexWithinInitPhaseReset: 1023
    };
    /** @enum {number} */

    const InitPhaseState = {
      OnInitHooksToBeRun: 0,
      AfterContentInitHooksToBeRun: 1,
      AfterViewInitHooksToBeRun: 2,
      InitPhaseCompleted: 3
    };
    /** @enum {number} */

    const PreOrderHookFlags = {
      /** The index of the next pre-order hook to be called in the hooks array, on the first 16
         bits */
      IndexOfTheNextPreOrderHookMaskMask: 65535,

      /**
       * The number of init hooks that have already been called, on the last 16 bits
       */
      NumberOfInitHooksCalledIncrementer: 65536,
      NumberOfInitHooksCalledShift: 16,
      NumberOfInitHooksCalledMask: 4294901760
    };
    /**
     * Set of instructions used to process host bindings efficiently.
     *
     * See VIEW_DATA.md for more information.
     * @record
     */

    function ExpandoInstructions() {}
    /**
     * The static data for an LView (shared between all templates of a
     * given type).
     *
     * Stored on the `ComponentDef.tView`.
     * @record
     */


    function TView() {}

    if (false) {}
    /** @enum {number} */


    const RootContextFlags = {
      Empty: 0,
      DetectChanges: 1,
      FlushPlayers: 2
    };
    /**
     * RootContext contains information which is shared for all components which
     * were bootstrapped with {\@link renderComponent}.
     * @record
     */

    function RootContext() {}

    if (false) {} // Note: This hack is necessary so we don't erroneously get a circular dependency
    // failure based on types.

    /** @type {?} */


    const unusedValueExportToPlacateAjd = 1;
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Special location which allows easy identification of type. If we have an array which was
     * retrieved from the `LView` and that array has `true` at `TYPE` location, we know it is
     * `LContainer`.
     * @type {?}
     */

    const TYPE = 1;
    /**
     * Below are constants for LContainer indices to help us look up LContainer members
     * without having to remember the specific indices.
     * Uglify will inline these when minifying so there shouldn't be a cost.
     * @type {?}
     */

    const ACTIVE_INDEX = 2; // PARENT and NEXT are indices 3 and 4
    // As we already have these constants in LView, we don't need to re-create them.

    /** @type {?} */

    const MOVED_VIEWS = 5; // T_HOST is index 6
    // We already have this constants in LView, we don't need to re-create it.

    /** @type {?} */

    const NATIVE = 7;
    /** @type {?} */

    const VIEW_REFS = 8;
    /**
     * Size of LContainer's header. Represents the index after which all views in the
     * container will be inserted. We need to keep a record of current views so we know
     * which views are already in the DOM (and don't need to be re-added) and so we can
     * remove views from the DOM when they are no longer required.
     * @type {?}
     */

    const CONTAINER_HEADER_OFFSET = 9;
    /**
     * The state associated with a container.
     *
     * This is an array so that its structure is closer to LView. This helps
     * when traversing the view tree (which is a mix of containers and component
     * views), so we can jump to viewOrContainer[NEXT] in the same way regardless
     * of type.
     * @record
     */

    function LContainer() {}

    if (false) {} // Note: This hack is necessary so we don't erroneously get a circular dependency
    // failure based on types.

    /** @type {?} */


    const unusedValueExportToPlacateAjd$1 = 1;
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * True if `value` is `LView`.
     * @param {?} value wrapped value of `RNode`, `LView`, `LContainer`
     * @return {?}
     */

    function isLView(value) {
      return Array.isArray(value) && typeof value[TYPE] === 'object';
    }
    /**
     * True if `value` is `LContainer`.
     * @param {?} value wrapped value of `RNode`, `LView`, `LContainer`
     * @return {?}
     */


    function isLContainer(value) {
      return Array.isArray(value) && value[TYPE] === true;
    }
    /**
     * @param {?} tNode
     * @return {?}
     */


    function isContentQueryHost(tNode) {
      return (tNode.flags & 4
      /* hasContentQuery */
      ) !== 0;
    }
    /**
     * @param {?} tNode
     * @return {?}
     */


    function isComponent(tNode) {
      return (tNode.flags & 1
      /* isComponent */
      ) === 1
      /* isComponent */
      ;
    }
    /**
     * @template T
     * @param {?} def
     * @return {?}
     */


    function isComponentDef(def) {
      return (
        /** @type {?} */
        def.template !== null
      );
    }
    /**
     * @param {?} target
     * @return {?}
     */


    function isRootView(target) {
      return (target[FLAGS] & 512
      /* IsRoot */
      ) !== 0;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} tNode
     * @param {?} lView
     * @return {?}
     */


    function assertTNodeForLView(tNode, lView) {
      tNode.hasOwnProperty('tView_') && assertEqual(
      /** @type {?} */

      /** @type {?} */
      tNode.tView_, lView[TVIEW], 'This TNode does not belong to this LView.');
    }
    /**
     * @param {?} actual
     * @param {?=} msg
     * @return {?}
     */


    function assertComponentType(actual, msg = 'Type passed in is not ComponentType, it does not have \'ngComponentDef\' property.') {
      if (!getComponentDef(actual)) {
        throwError(msg);
      }
    }
    /**
     * @param {?} actual
     * @param {?=} msg
     * @return {?}
     */


    function assertNgModuleType(actual, msg = 'Type passed in is not NgModuleType, it does not have \'ngModuleDef\' property.') {
      if (!getNgModuleDef(actual)) {
        throwError(msg);
      }
    }
    /**
     * @param {?} isParent
     * @return {?}
     */


    function assertPreviousIsParent(isParent) {
      assertEqual(isParent, true, 'previousOrParentTNode should be a parent');
    }
    /**
     * @param {?} tNode
     * @return {?}
     */


    function assertHasParent(tNode) {
      assertDefined(tNode, 'previousOrParentTNode should exist!');
      assertDefined(
      /** @type {?} */
      tNode.parent, 'previousOrParentTNode should have a parent');
    }
    /**
     * @param {?} lView
     * @param {?} index
     * @param {?=} arr
     * @return {?}
     */


    function assertDataNext(lView, index, arr) {
      if (arr == null) arr = lView;
      assertEqual(arr.length, index, "index ".concat(index, " expected to be at the end of arr (length ").concat(arr.length, ")"));
    }
    /**
     * @param {?} value
     * @return {?}
     */


    function assertLContainerOrUndefined(value) {
      value && assertEqual(isLContainer(value), true, 'Expecting LContainer or undefined or null');
    }
    /**
     * @param {?} value
     * @return {?}
     */


    function assertLContainer(value) {
      assertDefined(value, 'LContainer must be defined');
      assertEqual(isLContainer(value), true, 'Expecting LContainer');
    }
    /**
     * @param {?} value
     * @return {?}
     */


    function assertLViewOrUndefined(value) {
      value && assertEqual(isLView(value), true, 'Expecting LView or undefined or null');
    }
    /**
     * @param {?} value
     * @return {?}
     */


    function assertLView(value) {
      assertDefined(value, 'LView must be defined');
      assertEqual(isLView(value), true, 'Expecting LView');
    }
    /**
     * @param {?} tView
     * @param {?} errMessage
     * @return {?}
     */


    function assertFirstTemplatePass(tView, errMessage) {
      assertEqual(tView.firstTemplatePass, true, errMessage);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /** @type {?} */


    const TNODE = 8;
    /** @type {?} */

    const PARENT_INJECTOR = 8;
    /** @type {?} */

    const INJECTOR_BLOOM_PARENT_SIZE = 9;
    /**
     * Represents a relative location of parent injector.
     *
     * The interfaces encodes number of parents `LView`s to traverse and index in the `LView`
     * pointing to the parent injector.
     * @record
     */

    function RelativeInjectorLocation() {}

    if (false) {}
    /** @enum {number} */


    const RelativeInjectorLocationFlags = {
      InjectorIndexMask: 32767,
      ViewOffsetShift: 16,
      NO_PARENT: -1
    };
    /** @type {?} */

    const NO_PARENT_INJECTOR =
    /** @type {?} */
    -1;
    /**
     * Each injector is saved in 9 contiguous slots in `LView` and 9 contiguous slots in
     * `TView.data`. This allows us to store information about the current node's tokens (which
     * can be shared in `TView`) as well as the tokens of its ancestor nodes (which cannot be
     * shared, so they live in `LView`).
     *
     * Each of these slots (aside from the last slot) contains a bloom filter. This bloom filter
     * determines whether a directive is available on the associated node or not. This prevents us
     * from searching the directives array at this level unless it's probable the directive is in it.
     *
     * See: https://en.wikipedia.org/wiki/Bloom_filter for more about bloom filters.
     *
     * Because all injectors have been flattened into `LView` and `TViewData`, they cannot typed
     * using interfaces as they were previously. The start index of each `LInjector` and `TInjector`
     * will differ based on where it is flattened into the main array, so it's not possible to know
     * the indices ahead of time and save their types here. The interfaces are still included here
     * for documentation purposes.
     *
     * export interface LInjector extends Array<any> {
     *
     *    // Cumulative bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)
     *    [0]: number;
     *
     *    // Cumulative bloom for directive IDs 32-63
     *    [1]: number;
     *
     *    // Cumulative bloom for directive IDs 64-95
     *    [2]: number;
     *
     *    // Cumulative bloom for directive IDs 96-127
     *    [3]: number;
     *
     *    // Cumulative bloom for directive IDs 128-159
     *    [4]: number;
     *
     *    // Cumulative bloom for directive IDs 160 - 191
     *    [5]: number;
     *
     *    // Cumulative bloom for directive IDs 192 - 223
     *    [6]: number;
     *
     *    // Cumulative bloom for directive IDs 224 - 255
     *    [7]: number;
     *
     *    // We need to store a reference to the injector's parent so DI can keep looking up
     *    // the injector tree until it finds the dependency it's looking for.
     *    [PARENT_INJECTOR]: number;
     * }
     *
     * export interface TInjector extends Array<any> {
     *
     *    // Shared node bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)
     *    [0]: number;
     *
     *    // Shared node bloom for directive IDs 32-63
     *    [1]: number;
     *
     *    // Shared node bloom for directive IDs 64-95
     *    [2]: number;
     *
     *    // Shared node bloom for directive IDs 96-127
     *    [3]: number;
     *
     *    // Shared node bloom for directive IDs 128-159
     *    [4]: number;
     *
     *    // Shared node bloom for directive IDs 160 - 191
     *    [5]: number;
     *
     *    // Shared node bloom for directive IDs 192 - 223
     *    [6]: number;
     *
     *    // Shared node bloom for directive IDs 224 - 255
     *    [7]: number;
     *
     *    // Necessary to find directive indices for a particular node.
     *    [TNODE]: TElementNode|TElementContainerNode|TContainerNode;
     *  }
     */

    /**
     * Factory for creating instances of injectors in the NodeInjector.
     *
     * This factory is complicated by the fact that it can resolve `multi` factories as well.
     *
     * NOTE: Some of the fields are optional which means that this class has two hidden classes.
     * - One without `multi` support (most common)
     * - One with `multi` values, (rare).
     *
     * Since VMs can cache up to 4 inline hidden classes this is OK.
     *
     * - Single factory: Only `resolving` and `factory` is defined.
     * - `providers` factory: `componentProviders` is a number and `index = -1`.
     * - `viewProviders` factory: `componentProviders` is a number and `index` points to `providers`.
     */

    class NodeInjectorFactory {
      /**
       * @param {?} factory
       * @param {?} isViewProvider
       * @param {?} injectImplementation
       */
      constructor(factory,
      /**
       * Set to `true` if the token is declared in `viewProviders` (or if it is component).
       */
      isViewProvider, injectImplementation) {
        this.factory = factory;
        /**
         * Marker set to true during factory invocation to see if we get into recursive loop.
         * Recursive loop causes an error to be displayed.
         */

        this.resolving = false;
        this.canSeeViewProviders = isViewProvider;
        this.injectImpl = injectImplementation;
      }

    }

    if (false) {}
    /**
     * @param {?} obj
     * @return {?}
     */


    function isFactory(obj) {
      // See: https://jsperf.com/instanceof-vs-getprototypeof
      return obj !== null && typeof obj == 'object' && Object.getPrototypeOf(obj) == NodeInjectorFactory.prototype;
    } // Note: This hack is necessary so we don't erroneously get a circular dependency
    // failure based on types.

    /** @type {?} */


    const unusedValueExportToPlacateAjd$2 = 1;
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} tNode
     * @param {?} type
     * @return {?}
     */

    function assertNodeType(tNode, type) {
      assertDefined(tNode, 'should be called with a TNode');
      assertEqual(tNode.type, type, "should be a ".concat(typeName(type)));
    }
    /**
     * @param {?} tNode
     * @param {...?} types
     * @return {?}
     */


    function assertNodeOfPossibleTypes(tNode, ...types) {
      assertDefined(tNode, 'should be called with a TNode');
      /** @type {?} */

      const found = types.some(
      /**
      * @param {?} type
      * @return {?}
      */
      type => tNode.type === type);
      assertEqual(found, true, "Should be one of ".concat(types.map(typeName).join(', '), " but got ").concat(typeName(tNode.type)));
    }
    /**
     * @param {?} type
     * @return {?}
     */


    function typeName(type) {
      if (type == 1
      /* Projection */
      ) return 'Projection';
      if (type == 0
      /* Container */
      ) return 'Container';
      if (type == 2
      /* View */
      ) return 'View';
      if (type == 3
      /* Element */
      ) return 'Element';
      if (type == 4
      /* ElementContainer */
      ) return 'ElementContainer';
      return '<unknown>';
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Adds all directive lifecycle hooks from the given `DirectiveDef` to the given `TView`.
     *
     * Must be run *only* on the first template pass.
     *
     * Sets up the pre-order hooks on the provided `tView`,
     * see {\@link HookData} for details about the data structure.
     *
     * @param {?} directiveIndex The index of the directive in LView
     * @param {?} directiveDef The definition containing the hooks to setup in tView
     * @param {?} tView The current TView
     * @param {?} nodeIndex The index of the node to which the directive is attached
     * @param {?} initialPreOrderHooksLength the number of pre-order hooks already registered before the
     * current process, used to know if the node index has to be added to the array. If it is -1,
     * the node index is never added.
     * @param {?} initialPreOrderCheckHooksLength same as previous for pre-order check hooks
     * @return {?}
     */


    function registerPreOrderHooks(directiveIndex, directiveDef, tView, nodeIndex, initialPreOrderHooksLength, initialPreOrderCheckHooksLength) {
      ngDevMode && assertEqual(tView.firstTemplatePass, true, 'Should only be called on first template pass');
      const {
        onChanges,
        onInit,
        doCheck
      } = directiveDef;

      if (initialPreOrderHooksLength >= 0 && (!tView.preOrderHooks || initialPreOrderHooksLength === tView.preOrderHooks.length) && (onChanges || onInit || doCheck)) {
        (tView.preOrderHooks || (tView.preOrderHooks = [])).push(nodeIndex);
      }

      if (initialPreOrderCheckHooksLength >= 0 && (!tView.preOrderCheckHooks || initialPreOrderCheckHooksLength === tView.preOrderCheckHooks.length) && (onChanges || doCheck)) {
        (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(nodeIndex);
      }

      if (onChanges) {
        (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, onChanges);
        (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, onChanges);
      }

      if (onInit) {
        (tView.preOrderHooks || (tView.preOrderHooks = [])).push(-directiveIndex, onInit);
      }

      if (doCheck) {
        (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, doCheck);
        (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, doCheck);
      }
    }
    /**
     *
     * Loops through the directives on the provided `tNode` and queues hooks to be
     * run that are not initialization hooks.
     *
     * Should be executed during `elementEnd()` and similar to
     * preserve hook execution order. Content, view, and destroy hooks for projected
     * components and directives must be called *before* their hosts.
     *
     * Sets up the content, view, and destroy hooks on the provided `tView`,
     * see {\@link HookData} for details about the data structure.
     *
     * NOTE: This does not set up `onChanges`, `onInit` or `doCheck`, those are set up
     * separately at `elementStart`.
     *
     * @param {?} tView The current TView
     * @param {?} tNode The TNode whose directives are to be searched for hooks to queue
     * @return {?}
     */


    function registerPostOrderHooks(tView, tNode) {
      if (tView.firstTemplatePass) {
        // It's necessary to loop through the directives at elementEnd() (rather than processing in
        // directiveCreate) so we can preserve the current hook order. Content, view, and destroy
        // hooks for projected components and directives must be called *before* their hosts.
        for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {
          /** @type {?} */
          const directiveDef =
          /** @type {?} */
          tView.data[i];

          if (directiveDef.afterContentInit) {
            (tView.contentHooks || (tView.contentHooks = [])).push(-i, directiveDef.afterContentInit);
          }

          if (directiveDef.afterContentChecked) {
            (tView.contentHooks || (tView.contentHooks = [])).push(i, directiveDef.afterContentChecked);
            (tView.contentCheckHooks || (tView.contentCheckHooks = [])).push(i, directiveDef.afterContentChecked);
          }

          if (directiveDef.afterViewInit) {
            (tView.viewHooks || (tView.viewHooks = [])).push(-i, directiveDef.afterViewInit);
          }

          if (directiveDef.afterViewChecked) {
            (tView.viewHooks || (tView.viewHooks = [])).push(i, directiveDef.afterViewChecked);
            (tView.viewCheckHooks || (tView.viewCheckHooks = [])).push(i, directiveDef.afterViewChecked);
          }

          if (directiveDef.onDestroy != null) {
            (tView.destroyHooks || (tView.destroyHooks = [])).push(i, directiveDef.onDestroy);
          }
        }
      }
    }
    /**
     * Executing hooks requires complex logic as we need to deal with 2 constraints.
     *
     * 1. Init hooks (ngOnInit, ngAfterContentInit, ngAfterViewInit) must all be executed once and only
     * once, across many change detection cycles. This must be true even if some hooks throw, or if
     * some recursively trigger a change detection cycle.
     * To solve that, it is required to track the state of the execution of these init hooks.
     * This is done by storing and maintaining flags in the view: the {@link InitPhaseState},
     * and the index within that phase. They can be seen as a cursor in the following structure:
     * [[onInit1, onInit2], [afterContentInit1], [afterViewInit1, afterViewInit2, afterViewInit3]]
     * They are are stored as flags in LView[FLAGS].
     *
     * 2. Pre-order hooks can be executed in batches, because of the select instruction.
     * To be able to pause and resume their execution, we also need some state about the hook's array
     * that is being processed:
     * - the index of the next hook to be executed
     * - the number of init hooks already found in the processed part of the  array
     * They are are stored as flags in LView[PREORDER_HOOK_FLAGS].
     */

    /**
     * Executes necessary hooks at the start of executing a template.
     *
     * Executes hooks that are to be run during the initialization of a directive such
     * as `onChanges`, `onInit`, and `doCheck`.
     *
     * @param {?} currentView
     * @param {?} tView Static data for the view containing the hooks to be executed
     * @param {?} checkNoChangesMode Whether or not we're in checkNoChanges mode.
     * @param {?} currentNodeIndex
     * @return {?}
     */


    function executePreOrderHooks(currentView, tView, checkNoChangesMode, currentNodeIndex) {
      if (!checkNoChangesMode) {
        executeHooks(currentView, tView.preOrderHooks, tView.preOrderCheckHooks, checkNoChangesMode, 0
        /* OnInitHooksToBeRun */
        , currentNodeIndex !== undefined ? currentNodeIndex : null);
      }
    }
    /**
     * Executes hooks against the given `LView` based off of whether or not
     * This is the first pass.
     *
     * @param {?} currentView The view instance data to run the hooks against
     * @param {?} firstPassHooks An array of hooks to run if we're in the first view pass
     * @param {?} checkHooks An Array of hooks to run if we're not in the first view pass.
     * @param {?} checkNoChangesMode Whether or not we're in no changes mode.
     * @param {?} initPhaseState the current state of the init phase
     * @param {?} currentNodeIndex 3 cases depending the the value:
     * - undefined: all hooks from the array should be executed (post-order case)
     * - null: execute hooks only from the saved index until the end of the array (pre-order case, when
     * flushing the remaining hooks)
     * - number: execute hooks only from the saved index until that node index exclusive (pre-order
     * case, when executing select(number))
     * @return {?}
     */


    function executeHooks(currentView, firstPassHooks, checkHooks, checkNoChangesMode, initPhaseState, currentNodeIndex) {
      if (checkNoChangesMode) return;
      /** @type {?} */

      const hooksToCall = (currentView[FLAGS] & 3
      /* InitPhaseStateMask */
      ) === initPhaseState ? firstPassHooks : checkHooks;

      if (hooksToCall) {
        callHooks(currentView, hooksToCall, initPhaseState, currentNodeIndex);
      } // The init phase state must be always checked here as it may have been recursively updated


      if (currentNodeIndex == null && (currentView[FLAGS] & 3
      /* InitPhaseStateMask */
      ) === initPhaseState && initPhaseState !== 3
      /* InitPhaseCompleted */
      ) {
          currentView[FLAGS] &= 1023
          /* IndexWithinInitPhaseReset */
          ;
          currentView[FLAGS] += 1
          /* InitPhaseStateIncrementer */
          ;
        }
    }
    /**
     * Calls lifecycle hooks with their contexts, skipping init hooks if it's not
     * the first LView pass
     *
     * @param {?} currentView The current view
     * @param {?} arr The array in which the hooks are found
     * @param {?} initPhase
     * @param {?} currentNodeIndex 3 cases depending the the value:
     * - undefined: all hooks from the array should be executed (post-order case)
     * - null: execute hooks only from the saved index until the end of the array (pre-order case, when
     * flushing the remaining hooks)
     * - number: execute hooks only from the saved index until that node index exclusive (pre-order
     * case, when executing select(number))
     * @return {?}
     */


    function callHooks(currentView, arr, initPhase, currentNodeIndex) {
      /** @type {?} */
      const startIndex = currentNodeIndex !== undefined ? currentView[PREORDER_HOOK_FLAGS] & 65535
      /* IndexOfTheNextPreOrderHookMaskMask */
      : 0;
      /** @type {?} */

      const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;
      /** @type {?} */

      let lastNodeIndexFound = 0;

      for (let i = startIndex; i < arr.length; i++) {
        /** @type {?} */
        const hook =
        /** @type {?} */
        arr[i + 1];

        if (typeof hook === 'number') {
          lastNodeIndexFound =
          /** @type {?} */
          arr[i];

          if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {
            break;
          }
        } else {
          /** @type {?} */
          const isInitHook = arr[i] < 0;
          if (isInitHook) currentView[PREORDER_HOOK_FLAGS] += 65536
          /* NumberOfInitHooksCalledIncrementer */
          ;

          if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {
            callHook(currentView, initPhase, arr, i);
            currentView[PREORDER_HOOK_FLAGS] = (currentView[PREORDER_HOOK_FLAGS] & 4294901760
            /* NumberOfInitHooksCalledMask */
            ) + i + 2;
          }

          i++;
        }
      }
    }
    /**
     * Execute one hook against the current `LView`.
     *
     * @param {?} currentView The current view
     * @param {?} initPhase
     * @param {?} arr The array in which the hooks are found
     * @param {?} i The current index within the hook data array
     * @return {?}
     */


    function callHook(currentView, initPhase, arr, i) {
      /** @type {?} */
      const isInitHook = arr[i] < 0;
      /** @type {?} */

      const hook =
      /** @type {?} */
      arr[i + 1];
      /** @type {?} */

      const directiveIndex = isInitHook ? -arr[i] :
      /** @type {?} */
      arr[i];
      /** @type {?} */

      const directive = currentView[directiveIndex];

      if (isInitHook) {
        /** @type {?} */
        const indexWithintInitPhase = currentView[FLAGS] >> 10
        /* IndexWithinInitPhaseShift */
        ; // The init phase state must be always checked here as it may have been recursively
        // updated

        if (indexWithintInitPhase < currentView[PREORDER_HOOK_FLAGS] >> 16
        /* NumberOfInitHooksCalledShift */
        && (currentView[FLAGS] & 3
        /* InitPhaseStateMask */
        ) === initPhase) {
          currentView[FLAGS] += 1024
          /* IndexWithinInitPhaseIncrementer */
          ;
          hook.call(directive);
        }
      } else {
        hook.call(directive);
      }
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */

    /**
     * --------
     *
     * // TODO(matsko): add updateMask info
     *
     * This file contains all state-based logic for styling in Angular.
     *
     * Styling in Angular is evaluated with a series of styling-specific
     * template instructions which are called one after another each time
     * change detection occurs in Angular.
     *
     * Styling makes use of various temporary, state-based variables between
     * instructions so that it can better cache and optimize its values.
     * These values are usually populated and cleared when an element is
     * exited in change detection (once all the instructions are run for
     * that element).
     *
     * There are, however, situations where the state-based values
     * need to be stored and used at a later point. This ONLY occurs when
     * there are template-level as well as host-binding-level styling
     * instructions on the same element. The example below shows exactly
     * what could be:
     *
     * ```html
     * <!-- two sources of styling: the template and the directive -->
     * <div [style.width]="width" dir-that-sets-height></div>
     * ```
     *
     * If and when this situation occurs, the current styling state is
     * stored in a storage map value and then later accessed once the
     * host bindings are evaluated. Once styling for the current element
     * is over then the map entry will be cleared.
     *
     * To learn more about the algorithm see `TStylingContext`.
     *
     * --------
     */

    /** @type {?} */


    let _stylingState = null;
    /** @type {?} */

    const _stateStorage = new Map(); // this value is not used outside this file and is only here
    // as a caching check for when the element changes.

    /** @type {?} */


    let _stylingElement = null;
    /**
     * Used as a state reference for update values between style/class binding instructions.
     * @record
     */

    function StylingState() {}

    if (false) {}
    /** @type {?} */


    const STYLING_INDEX_START_VALUE = 1;
    /** @type {?} */

    const BIT_MASK_START_VALUE = 0;
    /**
     * @param {?} element
     * @param {?=} readFromMap
     * @return {?}
     */

    function getStylingState(element, readFromMap) {
      if (!_stylingElement || element !== _stylingElement) {
        _stylingElement = element;

        if (readFromMap) {
          _stylingState = _stateStorage.get(element) || null;
          ngDevMode && ngDevMode.stylingReadPersistedState++;
        }

        _stylingState = _stylingState || {
          classesBitMask: BIT_MASK_START_VALUE,
          classesIndex: STYLING_INDEX_START_VALUE,
          stylesBitMask: BIT_MASK_START_VALUE,
          stylesIndex: STYLING_INDEX_START_VALUE
        };
      }

      return (
        /** @type {?} */
        _stylingState
      );
    }
    /**
     * @return {?}
     */


    function resetStylingState() {
      _stylingState = null;
      _stylingElement = null;
    }
    /**
     * @param {?} element
     * @param {?} state
     * @return {?}
     */


    function storeStylingState(element, state) {
      ngDevMode && ngDevMode.stylingWritePersistedState++;

      _stateStorage.set(element, state);
    }
    /**
     * @param {?} element
     * @return {?}
     */


    function deleteStylingStateFromStorage(element) {
      _stateStorage.delete(element);
    }
    /**
     * @return {?}
     */


    function resetAllStylingState() {
      resetStylingState();

      _stateStorage.clear();
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * This property will be monkey-patched on elements, components and directives
     * @type {?}
     */


    const MONKEY_PATCH_KEY_NAME = '__ngContext__';
    /**
     * The internal view context which is specific to a given DOM element, directive or
     * component instance. Each value in here (besides the LView and element node details)
     * can be present, null or undefined. If undefined then it implies the value has not been
     * looked up yet, otherwise, if null, then a lookup was executed and nothing was found.
     *
     * Each value will get filled when the respective value is examined within the getContext
     * function. The component, element and each directive instance will share the same instance
     * of the context.
     * @record
     */

    function LContext() {}

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * For efficiency reasons we often put several different data types (`RNode`, `LView`, `LContainer`)
     * in same location in `LView`. This is because we don't want to pre-allocate space for it
     * because the storage is sparse. This file contains utilities for dealing with such data types.
     *
     * How do we know what is stored at a given location in `LView`.
     * - `Array.isArray(value) === false` => `RNode` (The normal storage value)
     * - `Array.isArray(value) === true` => then the `value[0]` represents the wrapped value.
     *   - `typeof value[TYPE] === 'object'` => `LView`
     *      - This happens when we have a component at a given location
     *   - `typeof value[TYPE] === true` => `LContainer`
     *      - This happens when we have `LContainer` binding at a given location.
     *
     *
     * NOTE: it is assumed that `Array.isArray` and `typeof` operations are very efficient.
     */

    /**
     * Returns `RNode`.
     * @param {?} value wrapped value of `RNode`, `LView`, `LContainer`
     * @return {?}
     */


    function unwrapRNode(value) {
      while (Array.isArray(value)) {
        value =
        /** @type {?} */
        value[HOST];
      }

      return (
        /** @type {?} */
        value
      );
    }
    /**
     * Returns `LView` or `null` if not found.
     * @param {?} value wrapped value of `RNode`, `LView`, `LContainer`
     * @return {?}
     */


    function unwrapLView(value) {
      while (Array.isArray(value)) {
        // This check is same as `isLView()` but we don't call at as we don't want to call
        // `Array.isArray()` twice and give JITer more work for inlining.
        if (typeof value[TYPE] === 'object') return (
          /** @type {?} */
          value
        );
        value =
        /** @type {?} */
        value[HOST];
      }

      return null;
    }
    /**
     * Returns `LContainer` or `null` if not found.
     * @param {?} value wrapped value of `RNode`, `LView`, `LContainer`
     * @return {?}
     */


    function unwrapLContainer(value) {
      while (Array.isArray(value)) {
        // This check is same as `isLContainer()` but we don't call at as we don't want to call
        // `Array.isArray()` twice and give JITer more work for inlining.
        if (value[TYPE] === true) return (
          /** @type {?} */
          value
        );
        value =
        /** @type {?} */
        value[HOST];
      }

      return null;
    }
    /**
     * Retrieves an element value from the provided `viewData`, by unwrapping
     * from any containers, component views, or style contexts.
     * @param {?} index
     * @param {?} lView
     * @return {?}
     */


    function getNativeByIndex(index, lView) {
      return unwrapRNode(lView[index + HEADER_OFFSET]);
    }
    /**
     * Retrieve an `RNode` for a given `TNode` and `LView`.
     *
     * This function guarantees in dev mode to retrieve a non-null `RNode`.
     *
     * @param {?} tNode
     * @param {?} lView
     * @return {?}
     */


    function getNativeByTNode(tNode, lView) {
      ngDevMode && assertTNodeForLView(tNode, lView);
      ngDevMode && assertDataInRange(lView, tNode.index);
      /** @type {?} */

      const node = unwrapRNode(lView[tNode.index]);
      ngDevMode && assertDomNode(node);
      return node;
    }
    /**
     * Retrieve an `RNode` or `null` for a given `TNode` and `LView`.
     *
     * Some `TNode`s don't have associated `RNode`s. For example `Projection`
     *
     * @param {?} tNode
     * @param {?} lView
     * @return {?}
     */


    function getNativeByTNodeOrNull(tNode, lView) {
      ngDevMode && assertTNodeForLView(tNode, lView);
      /** @type {?} */

      const index = tNode.index;
      /** @type {?} */

      const node = index == -1 ? null : unwrapRNode(lView[index]);
      ngDevMode && node !== null && assertDomNode(node);
      return node;
    }
    /**
     * A helper function that returns `true` if a given `TNode` has any matching directives.
     * @param {?} tNode
     * @return {?}
     */


    function hasDirectives(tNode) {
      return tNode.directiveEnd > tNode.directiveStart;
    }
    /**
     * @param {?} index
     * @param {?} view
     * @return {?}
     */


    function getTNode(index, view) {
      ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');
      ngDevMode && assertLessThan(index, view[TVIEW].data.length, 'wrong index for TNode');
      return (
        /** @type {?} */
        view[TVIEW].data[index + HEADER_OFFSET]
      );
    }
    /**
     * Retrieves a value from any `LView` or `TData`.
     * @template T
     * @param {?} view
     * @param {?} index
     * @return {?}
     */


    function loadInternal(view, index) {
      ngDevMode && assertDataInRange(view, index + HEADER_OFFSET);
      return view[index + HEADER_OFFSET];
    }
    /**
     * @param {?} nodeIndex
     * @param {?} hostView
     * @return {?}
     */


    function getComponentViewByIndex(nodeIndex, hostView) {
      // Could be an LView or an LContainer. If LContainer, unwrap to find LView.

      /** @type {?} */
      const slotValue = hostView[nodeIndex];
      /** @type {?} */

      const lView = isLView(slotValue) ? slotValue : slotValue[HOST];
      return lView;
    }
    /**
     * Returns the monkey-patch value data present on the target (which could be
     * a component, directive or a DOM node).
     * @param {?} target
     * @return {?}
     */


    function readPatchedData(target) {
      ngDevMode && assertDefined(target, 'Target expected');
      return target[MONKEY_PATCH_KEY_NAME];
    }
    /**
     * @param {?} target
     * @return {?}
     */


    function readPatchedLView(target) {
      /** @type {?} */
      const value = readPatchedData(target);

      if (value) {
        return Array.isArray(value) ? value :
        /** @type {?} */
        value.lView;
      }

      return null;
    }
    /**
     * Returns a boolean for whether the view is attached to the change detection tree.
     *
     * Note: This determines whether a view should be checked, not whether it's inserted
     * into a container. For that, you'll want `viewAttachedToContainer` below.
     * @param {?} view
     * @return {?}
     */


    function viewAttachedToChangeDetector(view) {
      return (view[FLAGS] & 128
      /* Attached */
      ) === 128
      /* Attached */
      ;
    }
    /**
     * Returns a boolean for whether the view is attached to a container.
     * @param {?} view
     * @return {?}
     */


    function viewAttachedToContainer(view) {
      return isLContainer(view[PARENT]);
    }
    /**
     * Resets the pre-order hook flags of the view.
     * @param {?} lView the LView on which the flags are reset
     * @return {?}
     */


    function resetPreOrderHookFlags(lView) {
      lView[PREORDER_HOOK_FLAGS] = 0;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Store the element depth count. This is used to identify the root elements of the template
     * so that we can than attach `LView` to only those elements.
     * @type {?}
     */


    let elementDepthCount;
    /**
     * @return {?}
     */

    function getElementDepthCount() {
      // top level variables should not be exported for performance reasons (PERF_NOTES.md)
      return elementDepthCount;
    }
    /**
     * @return {?}
     */


    function increaseElementDepthCount() {
      elementDepthCount++;
    }
    /**
     * @return {?}
     */


    function decreaseElementDepthCount() {
      elementDepthCount--;
    }
    /** @type {?} */


    let currentDirectiveDef = null;
    /**
     * @return {?}
     */

    function getCurrentDirectiveDef() {
      // top level variables should not be exported for performance reasons (PERF_NOTES.md)
      return currentDirectiveDef;
    }
    /**
     * @param {?} def
     * @return {?}
     */


    function setCurrentDirectiveDef(def) {
      currentDirectiveDef = def;
    }
    /**
     * Stores whether directives should be matched to elements.
     *
     * When template contains `ngNonBindable` than we need to prevent the runtime form matching
     * directives on children of that element.
     *
     * Example:
     * ```
     * <my-comp my-directive>
     *   Should match component / directive.
     * </my-comp>
     * <div ngNonBindable>
     *   <my-comp my-directive>
     *     Should not match component / directive because we are in ngNonBindable.
     *   </my-comp>
     * </div>
     * ```
     * @type {?}
     */


    let bindingsEnabled;
    /**
     * @return {?}
     */

    function getBindingsEnabled() {
      // top level variables should not be exported for performance reasons (PERF_NOTES.md)
      return bindingsEnabled;
    }
    /**
     * Enables directive matching on elements.
     *
     *  * Example:
     * ```
     * <my-comp my-directive>
     *   Should match component / directive.
     * </my-comp>
     * <div ngNonBindable>
     *   <!-- ɵɵdisableBindings() -->
     *   <my-comp my-directive>
     *     Should not match component / directive because we are in ngNonBindable.
     *   </my-comp>
     *   <!-- ɵɵenableBindings() -->
     * </div>
     * ```
     *
     * \@codeGenApi
     * @return {?}
     */


    function ɵɵenableBindings() {
      bindingsEnabled = true;
    }
    /**
     * Disables directive matching on element.
     *
     *  * Example:
     * ```
     * <my-comp my-directive>
     *   Should match component / directive.
     * </my-comp>
     * <div ngNonBindable>
     *   <!-- ɵɵdisableBindings() -->
     *   <my-comp my-directive>
     *     Should not match component / directive because we are in ngNonBindable.
     *   </my-comp>
     *   <!-- ɵɵenableBindings() -->
     * </div>
     * ```
     *
     * \@codeGenApi
     * @return {?}
     */


    function ɵɵdisableBindings() {
      bindingsEnabled = false;
    }
    /**
     * @return {?}
     */


    function getLView() {
      return lView;
    }
    /**
     * Used as the starting directive id value.
     *
     * All subsequent directives are incremented from this value onwards.
     * The reason why this value is `1` instead of `0` is because the `0`
     * value is reserved for the template.
     * @type {?}
     */


    const MIN_DIRECTIVE_ID = 1;
    /** @type {?} */

    let activeDirectiveId = MIN_DIRECTIVE_ID;
    /**
     * Position depth (with respect from leaf to root) in a directive sub-class inheritance chain.
     * @type {?}
     */

    let activeDirectiveSuperClassDepthPosition = 0;
    /**
     * Total count of how many directives are a part of an inheritance chain.
     *
     * When directives are sub-classed (extended) from one to another, Angular
     * needs to keep track of exactly how many were encountered so it can accurately
     * generate the next directive id (once the next directive id is visited).
     * Normally the next directive id just a single incremented value from the
     * previous one, however, if the previous directive is a part of an inheritance
     * chain (a series of sub-classed directives) then the incremented value must
     * also take into account the total amount of sub-classed values.
     *
     * Note that this value resets back to zero once the next directive is
     * visited (when `incrementActiveDirectiveId` or `setActiveHostElement`
     * is called).
     * @type {?}
     */

    let activeDirectiveSuperClassHeight = 0;
    /**
     * Sets the active directive host element and resets the directive id value
     * (when the provided elementIndex value has changed).
     *
     * @param {?=} elementIndex the element index value for the host element where
     *                     the directive/component instance lives
     * @return {?}
     */

    function setActiveHostElement(elementIndex = null) {
      if (_selectedIndex !== elementIndex) {
        setSelectedIndex(elementIndex == null ? -1 : elementIndex);
        activeDirectiveId = elementIndex == null ? 0 : MIN_DIRECTIVE_ID;
        activeDirectiveSuperClassDepthPosition = 0;
        activeDirectiveSuperClassHeight = 0;
      }
    }
    /**
     * Returns the current id value of the current directive.
     *
     * For example we have an element that has two directives on it:
     * <div dir-one dir-two></div>
     *
     * dirOne->hostBindings() (id == 1)
     * dirTwo->hostBindings() (id == 2)
     *
     * Note that this is only active when `hostBinding` functions are being processed.
     *
     * Note that directive id values are specific to an element (this means that
     * the same id value could be present on another element with a completely
     * different set of directives).
     * @return {?}
     */


    function getActiveDirectiveId() {
      return activeDirectiveId;
    }
    /**
     * Increments the current directive id value.
     *
     * For example we have an element that has two directives on it:
     * <div dir-one dir-two></div>
     *
     * dirOne->hostBindings() (index = 1)
     * // increment
     * dirTwo->hostBindings() (index = 2)
     *
     * Depending on whether or not a previous directive had any inherited
     * directives present, that value will be incremented in addition
     * to the id jumping up by one.
     *
     * Note that this is only active when `hostBinding` functions are being processed.
     *
     * Note that directive id values are specific to an element (this means that
     * the same id value could be present on another element with a completely
     * different set of directives).
     * @return {?}
     */


    function incrementActiveDirectiveId() {
      activeDirectiveId += 1 + activeDirectiveSuperClassHeight; // because we are dealing with a new directive this
      // means we have exited out of the inheritance chain

      activeDirectiveSuperClassDepthPosition = 0;
      activeDirectiveSuperClassHeight = 0;
    }
    /**
     * Set the current super class (reverse inheritance) position depth for a directive.
     *
     * For example we have two directives: Child and Other (but Child is a sub-class of Parent)
     * <div child-dir other-dir></div>
     *
     * // increment
     * parentInstance->hostBindings() (depth = 1)
     * // decrement
     * childInstance->hostBindings() (depth = 0)
     * otherInstance->hostBindings() (depth = 0 b/c it's a different directive)
     *
     * Note that this is only active when `hostBinding` functions are being processed.
     * @param {?} delta
     * @return {?}
     */


    function adjustActiveDirectiveSuperClassDepthPosition(delta) {
      activeDirectiveSuperClassDepthPosition += delta; // we keep track of the height value so that when the next directive is visited
      // then Angular knows to generate a new directive id value which has taken into
      // account how many sub-class directives were a part of the previous directive.

      activeDirectiveSuperClassHeight = Math.max(activeDirectiveSuperClassHeight, activeDirectiveSuperClassDepthPosition);
    }
    /**
     * Returns he current depth of the super/sub class inheritance chain.
     *
     * This will return how many inherited directive/component classes
     * exist in the current chain.
     *
     * ```typescript
     * \@Directive({ selector: '[super-dir]' })
     * class SuperDir {}
     *  / selector: '[sub-dir]' })
     * class SubDir extends SuperDir {}
     *
     * // if `<div sub-dir>` is used then the super class height is `1`
     * // if `<div super-dir>` is used then the super class height is `0`
     * ```
     * @return {?}
     */


    function getActiveDirectiveSuperClassHeight() {
      return activeDirectiveSuperClassHeight;
    }
    /**
     * Returns the current super class (reverse inheritance) depth for a directive.
     *
     * This is designed to help instruction code distinguish different hostBindings
     * calls from each other when a directive has extended from another directive.
     * Normally using the directive id value is enough, but with the case
     * of parent/sub-class directive inheritance more information is required.
     *
     * Note that this is only active when `hostBinding` functions are being processed.
     * @return {?}
     */


    function getActiveDirectiveSuperClassDepth() {
      return activeDirectiveSuperClassDepthPosition;
    }
    /**
     * Restores `contextViewData` to the given OpaqueViewState instance.
     *
     * Used in conjunction with the getCurrentView() instruction to save a snapshot
     * of the current view and restore it when listeners are invoked. This allows
     * walking the declaration view tree in listeners to get vars from parent views.
     *
     * \@codeGenApi
     * @param {?} viewToRestore The OpaqueViewState instance to restore.
     *
     * @return {?}
     */


    function ɵɵrestoreView(viewToRestore) {
      contextLView =
      /** @type {?} */

      /** @type {?} */
      viewToRestore;
    }
    /**
     * Used to set the parent property when nodes are created and track query results.
     * @type {?}
     */


    let previousOrParentTNode;
    /**
     * @return {?}
     */

    function getPreviousOrParentTNode() {
      // top level variables should not be exported for performance reasons (PERF_NOTES.md)
      return previousOrParentTNode;
    }
    /**
     * @param {?} tNode
     * @param {?} _isParent
     * @return {?}
     */


    function setPreviousOrParentTNode(tNode, _isParent) {
      previousOrParentTNode = tNode;
      isParent = _isParent;
    }
    /**
     * @param {?} tNode
     * @param {?} view
     * @return {?}
     */


    function setTNodeAndViewData(tNode, view) {
      ngDevMode && assertLViewOrUndefined(view);
      previousOrParentTNode = tNode;
      lView = view;
    }
    /**
     * If `isParent` is:
     *  - `true`: then `previousOrParentTNode` points to a parent node.
     *  - `false`: then `previousOrParentTNode` points to previous node (sibling).
     * @type {?}
     */


    let isParent;
    /**
     * @return {?}
     */

    function getIsParent() {
      // top level variables should not be exported for performance reasons (PERF_NOTES.md)
      return isParent;
    }
    /**
     * @return {?}
     */


    function setIsNotParent() {
      isParent = false;
    }
    /**
     * @return {?}
     */


    function setIsParent() {
      isParent = true;
    }
    /**
     * Checks whether a given view is in creation mode
     * @param {?=} view
     * @return {?}
     */


    function isCreationMode(view = lView) {
      return (view[FLAGS] & 4
      /* CreationMode */
      ) === 4
      /* CreationMode */
      ;
    }
    /**
     * State of the current view being processed.
     *
     * An array of nodes (text, element, container, etc), pipes, their bindings, and
     * any local variables that need to be stored between invocations.
     * @type {?}
     */


    let lView;
    /**
     * The last viewData retrieved by nextContext().
     * Allows building nextContext() and reference() calls.
     *
     * e.g. const inner = x().$implicit; const outer = x().$implicit;
     * @type {?}
     */

    let contextLView =
    /** @type {?} */
    null;
    /**
     * @return {?}
     */

    function getContextLView() {
      // top level variables should not be exported for performance reasons (PERF_NOTES.md)
      return contextLView;
    }
    /**
     * In this mode, any changes in bindings will throw an ExpressionChangedAfterChecked error.
     *
     * Necessary to support ChangeDetectorRef.checkNoChanges().
     * @type {?}
     */


    let checkNoChangesMode = false;
    /**
     * @return {?}
     */

    function getCheckNoChangesMode() {
      // top level variables should not be exported for performance reasons (PERF_NOTES.md)
      return checkNoChangesMode;
    }
    /**
     * @param {?} mode
     * @return {?}
     */


    function setCheckNoChangesMode(mode) {
      checkNoChangesMode = mode;
    }
    /**
     * The root index from which pure function instructions should calculate their binding
     * indices. In component views, this is TView.bindingStartIndex. In a host binding
     * context, this is the TView.expandoStartIndex + any dirs/hostVars before the given dir.
     * @type {?}
     */


    let bindingRootIndex = -1; // top level variables should not be exported for performance reasons (PERF_NOTES.md)

    /**
     * @return {?}
     */

    function getBindingRoot() {
      return bindingRootIndex;
    }
    /**
     * @param {?} value
     * @return {?}
     */


    function setBindingRoot(value) {
      bindingRootIndex = value;
    }
    /**
     * Current index of a View or Content Query which needs to be processed next.
     * We iterate over the list of Queries and increment current query index at every step.
     * @type {?}
     */


    let currentQueryIndex = 0;
    /**
     * @return {?}
     */

    function getCurrentQueryIndex() {
      // top level variables should not be exported for performance reasons (PERF_NOTES.md)
      return currentQueryIndex;
    }
    /**
     * @param {?} value
     * @return {?}
     */


    function setCurrentQueryIndex(value) {
      currentQueryIndex = value;
    }
    /**
     * Swap the current state with a new state.
     *
     * For performance reasons we store the state in the top level of the module.
     * This way we minimize the number of properties to read. Whenever a new view
     * is entered we have to store the state for later, and when the view is
     * exited the state has to be restored
     *
     * @param {?} newView New state to become active
     * @param {?} hostTNode
     * @return {?} the previous state;
     */


    function enterView(newView, hostTNode) {
      ngDevMode && assertLViewOrUndefined(newView);
      /** @type {?} */

      const oldView = lView;

      if (newView) {
        /** @type {?} */
        const tView = newView[TVIEW];
        bindingRootIndex = tView.bindingStartIndex;
      }

      previousOrParentTNode =
      /** @type {?} */
      hostTNode;
      isParent = true;
      lView = contextLView = newView;
      return oldView;
    }
    /**
     * @template T
     * @param {?=} level
     * @return {?}
     */


    function nextContextImpl(level = 1) {
      contextLView = walkUpViews(level,
      /** @type {?} */
      contextLView);
      return (
        /** @type {?} */
        contextLView[CONTEXT]
      );
    }
    /**
     * @param {?} nestingLevel
     * @param {?} currentView
     * @return {?}
     */


    function walkUpViews(nestingLevel, currentView) {
      while (nestingLevel > 0) {
        ngDevMode && assertDefined(currentView[DECLARATION_VIEW], 'Declaration view should be defined if nesting level is greater than 0.');
        currentView =
        /** @type {?} */
        currentView[DECLARATION_VIEW];
        nestingLevel--;
      }

      return currentView;
    }
    /**
     * Resets the application state.
     * @return {?}
     */


    function resetComponentState() {
      isParent = false;
      previousOrParentTNode =
      /** @type {?} */
      null;
      elementDepthCount = 0;
      bindingsEnabled = true;
      setCurrentStyleSanitizer(null);
      resetAllStylingState();
    }
    /**
     * Used in lieu of enterView to make it clear when we are exiting a child view. This makes
     * the direction of traversal (up or down the view tree) a bit clearer.
     *
     * @param {?} newView New state to become active
     * @param {?} safeToRunHooks Whether the runtime is in a state where running lifecycle hooks is valid.
     * This is not always the case (for example, the application may have crashed and `leaveView` is
     * being executed while unwinding the call stack).
     * @return {?}
     */


    function leaveView(newView, safeToRunHooks) {
      /** @type {?} */
      const tView = lView[TVIEW];

      if (isCreationMode(lView)) {
        lView[FLAGS] &= ~4
        /* CreationMode */
        ;
      } else {
        try {
          resetPreOrderHookFlags(lView);
          safeToRunHooks && executeHooks(lView, tView.viewHooks, tView.viewCheckHooks, checkNoChangesMode, 2
          /* AfterViewInitHooksToBeRun */
          , undefined);
        } finally {
          // Views are clean and in update mode after being checked, so these bits are cleared
          lView[FLAGS] &= ~(64
          /* Dirty */
          | 8
          /* FirstLViewPass */
          );
          lView[BINDING_INDEX] = tView.bindingStartIndex;
        }
      }

      enterView(newView, null);
    }
    /** @type {?} */


    let _selectedIndex = -1;
    /**
     * Gets the most recent index passed to {\@link select}
     *
     * Used with {\@link property} instruction (and more in the future) to identify the index in the
     * current `LView` to act on.
     * @return {?}
     */


    function getSelectedIndex() {
      return _selectedIndex;
    }
    /**
     * Sets the most recent index passed to {\@link select}
     *
     * Used with {\@link property} instruction (and more in the future) to identify the index in the
     * current `LView` to act on.
     * @param {?} index
     * @return {?}
     */


    function setSelectedIndex(index) {
      _selectedIndex = index; // we have now jumped to another element
      // therefore the state is stale

      resetStylingState();
    }
    /** @type {?} */


    let _currentNamespace = null;
    /**
     * Sets the namespace used to create elements to `'http://www.w3.org/2000/svg'` in global state.
     *
     * \@codeGenApi
     * @return {?}
     */

    function ɵɵnamespaceSVG() {
      _currentNamespace = 'http://www.w3.org/2000/svg';
    }
    /**
     * Sets the namespace used to create elements to `'http://www.w3.org/1998/MathML/'` in global state.
     *
     * \@codeGenApi
     * @return {?}
     */


    function ɵɵnamespaceMathML() {
      _currentNamespace = 'http://www.w3.org/1998/MathML/';
    }
    /**
     * Sets the namespace used to create elements to `null`, which forces element creation to use
     * `createElement` rather than `createElementNS`.
     *
     * \@codeGenApi
     * @return {?}
     */


    function ɵɵnamespaceHTML() {
      namespaceHTMLInternal();
    }
    /**
     * Sets the namespace used to create elements to `null`, which forces element creation to use
     * `createElement` rather than `createElementNS`.
     * @return {?}
     */


    function namespaceHTMLInternal() {
      _currentNamespace = null;
    }
    /**
     * @return {?}
     */


    function getNamespace() {
      return _currentNamespace;
    }
    /** @type {?} */


    let _currentSanitizer;
    /**
     * @param {?} sanitizer
     * @return {?}
     */


    function setCurrentStyleSanitizer(sanitizer) {
      _currentSanitizer = sanitizer;
    }
    /**
     * @return {?}
     */


    function getCurrentStyleSanitizer() {
      return _currentSanitizer;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Returns whether the values are different from a change detection stand point.
     *
     * Constraints are relaxed in checkNoChanges mode. See `devModeEqual` for details.
     * @param {?} a
     * @param {?} b
     * @return {?}
     */


    function isDifferent(a, b) {
      // NaN is the only value that is not equal to itself so the first
      // test checks if both a and b are not NaN
      return !(a !== a && b !== b) && a !== b;
    }
    /**
     * Used for stringify render output in Ivy.
     * Important! This function is very performance-sensitive and we should
     * be extra careful not to introduce megamorphic reads in it.
     * @param {?} value
     * @return {?}
     */


    function renderStringify(value) {
      if (typeof value === 'string') return value;
      if (value == null) return '';
      return '' + value;
    }
    /**
     * Used to stringify a value so that it can be displayed in an error message.
     * Important! This function contains a megamorphic read and should only be
     * used for error messages.
     * @param {?} value
     * @return {?}
     */


    function stringifyForError(value) {
      if (typeof value === 'function') return value.name || value.toString();

      if (typeof value === 'object' && value != null && typeof value.type === 'function') {
        return value.type.name || value.type.toString();
      }

      return renderStringify(value);
    }

    const ɵ0$2 =
    /**
    * @return {?}
    */
    () => (typeof requestAnimationFrame !== 'undefined' && requestAnimationFrame || // browser only
    setTimeout // everything else
    ).bind(_global);
    /** @type {?} */


    const defaultScheduler = ɵ0$2();
    /**
     *
     * \@codeGenApi
     * @param {?} element
     * @return {?}
     */

    function ɵɵresolveWindow(element) {
      return {
        name: 'window',
        target: element.ownerDocument.defaultView
      };
    }
    /**
     *
     * \@codeGenApi
     * @param {?} element
     * @return {?}
     */


    function ɵɵresolveDocument(element) {
      return {
        name: 'document',
        target: element.ownerDocument
      };
    }
    /**
     *
     * \@codeGenApi
     * @param {?} element
     * @return {?}
     */


    function ɵɵresolveBody(element) {
      return {
        name: 'body',
        target: element.ownerDocument.body
      };
    }
    /**
     * The special delimiter we use to separate property names, prefixes, and suffixes
     * in property binding metadata. See storeBindingMetadata().
     *
     * We intentionally use the Unicode "REPLACEMENT CHARACTER" (U+FFFD) as a delimiter
     * because it is a very uncommon character that is unlikely to be part of a user's
     * property names or interpolation strings. If it is in fact used in a property
     * binding, DebugElement.properties will not return the correct value for that
     * binding. However, there should be no runtime effect for real applications.
     *
     * This character is typically rendered as a question mark inside of a diamond.
     * See https://en.wikipedia.org/wiki/Specials_(Unicode_block)
     *
     * @type {?}
     */


    const INTERPOLATION_DELIMITER = "\uFFFD";
    /**
     * Determines whether or not the given string is a property metadata string.
     * See storeBindingMetadata().
     * @param {?} str
     * @return {?}
     */

    function isPropMetadataString(str) {
      return str.indexOf(INTERPOLATION_DELIMITER) >= 0;
    }
    /**
     * Unwrap a value which might be behind a closure (for forward declaration reasons).
     * @template T
     * @param {?} value
     * @return {?}
     */


    function maybeUnwrapFn(value) {
      if (value instanceof Function) {
        return value();
      } else {
        return value;
      }
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    const MAP_BASED_ENTRY_PROP_NAME = '--MAP--';
    /** @type {?} */

    const TEMPLATE_DIRECTIVE_INDEX = 0;
    /**
     * Creates a new instance of the `TStylingContext`.
     *
     * The `TStylingContext` is used as a manifest of all style or all class bindings on
     * an element. Because it is a T-level data-structure, it is only created once per
     * tNode for styles and for classes. This function allocates a new instance of a
     * `TStylingContext` with the initial values (see `interfaces.ts` for more info).
     * @param {?=} initialStyling
     * @return {?}
     */

    function allocTStylingContext(initialStyling) {
      // because map-based bindings deal with a dynamic set of values, there
      // is no way to know ahead of time whether or not sanitization is required.
      // For this reason the configuration will always mark sanitization as active
      // (this means that when map-based values are applied then sanitization will
      // be checked against each property).

      /** @type {?} */
      const mapBasedConfig = 1
      /* SanitizationRequired */
      ;
      return [initialStyling || [''], 0
      /* Initial */
      , TEMPLATE_DIRECTIVE_INDEX, mapBasedConfig, 0, MAP_BASED_ENTRY_PROP_NAME];
    }
    /**
     * Sets the provided directive as the last directive index in the provided `TStylingContext`.
     *
     * Styling in Angular can be applied from the template as well as multiple sources of
     * host bindings. This means that each binding function (the template function or the
     * hostBindings functions) will generate styling instructions as well as a styling
     * apply function (i.e. `stylingApply()`). Because host bindings functions and the
     * template function are independent from one another this means that the styling apply
     * function will be called multiple times. By tracking the last directive index (which
     * is what happens in this function) the styling algorithm knows exactly when to flush
     * styling (which is when the last styling apply function is executed).
     * @param {?} context
     * @param {?} lastDirectiveIndex
     * @return {?}
     */


    function updateLastDirectiveIndex(context, lastDirectiveIndex) {
      if (lastDirectiveIndex === TEMPLATE_DIRECTIVE_INDEX) {
        /** @type {?} */
        const currentValue = context[2
        /* LastDirectiveIndexPosition */
        ];

        if (currentValue > TEMPLATE_DIRECTIVE_INDEX) {
          // This means that a directive or two contained a host bindings function, but
          // now the template function also contains styling. When this combination of sources
          // comes up then we need to tell the context to store the state between updates
          // (because host bindings evaluation happens after template binding evaluation).
          markContextToPersistState(context);
        }
      } else {
        context[2
        /* LastDirectiveIndexPosition */
        ] = lastDirectiveIndex;
      }
    }
    /**
     * @param {?} context
     * @return {?}
     */


    function getConfig(context) {
      return context[1
      /* ConfigPosition */
      ];
    }
    /**
     * @param {?} context
     * @param {?} value
     * @return {?}
     */


    function setConfig(context, value) {
      context[1
      /* ConfigPosition */
      ] = value;
    }
    /**
     * @param {?} context
     * @param {?} index
     * @return {?}
     */


    function getProp(context, index) {
      return (
        /** @type {?} */
        context[index + 2
        /* PropOffset */
        ]
      );
    }
    /**
     * @param {?} context
     * @param {?} index
     * @return {?}
     */


    function getPropConfig(context, index) {
      return (
        /** @type {?} */
        context[index + 0
        /* ConfigAndGuardOffset */
        ] & 1
        /* Mask */

      );
    }
    /**
     * @param {?} context
     * @param {?} index
     * @return {?}
     */


    function isSanitizationRequired(context, index) {
      return (getPropConfig(context, index) & 1
      /* SanitizationRequired */
      ) > 0;
    }
    /**
     * @param {?} context
     * @param {?} index
     * @return {?}
     */


    function getGuardMask(context, index) {
      /** @type {?} */
      const configGuardValue =
      /** @type {?} */
      context[index + 0
      /* ConfigAndGuardOffset */
      ];
      return configGuardValue >> 1
      /* TotalBits */
      ;
    }
    /**
     * @param {?} context
     * @param {?} index
     * @param {?} maskValue
     * @return {?}
     */


    function setGuardMask(context, index, maskValue) {
      /** @type {?} */
      const config = getPropConfig(context, index);
      /** @type {?} */

      const guardMask = maskValue << 1
      /* TotalBits */
      ;
      context[index + 0
      /* ConfigAndGuardOffset */
      ] = config | guardMask;
    }
    /**
     * @param {?} context
     * @param {?} index
     * @return {?}
     */


    function getValuesCount(context, index) {
      return (
        /** @type {?} */
        context[index + 1
        /* ValuesCountOffset */
        ]
      );
    }
    /**
     * @param {?} context
     * @param {?} index
     * @param {?} offset
     * @return {?}
     */


    function getBindingValue(context, index, offset) {
      return (
        /** @type {?} */
        context[index + 3
        /* BindingsStartOffset */
        + offset]
      );
    }
    /**
     * @param {?} context
     * @param {?} index
     * @return {?}
     */


    function getDefaultValue(context, index) {
      /** @type {?} */
      const valuesCount = getValuesCount(context, index);
      return (
        /** @type {?} */
        context[index + 3
        /* BindingsStartOffset */
        + valuesCount - 1]
      );
    }
    /**
     * Temporary function which determines whether or not a context is
     * allowed to be flushed based on the provided directive index.
     * @param {?} context
     * @param {?} index
     * @return {?}
     */


    function allowStylingFlush(context, index) {
      return context && index === context[2
      /* LastDirectiveIndexPosition */
      ] ? true : false;
    }
    /**
     * @param {?} context
     * @return {?}
     */


    function lockContext(context) {
      setConfig(context, getConfig(context) | 1
      /* Locked */
      );
    }
    /**
     * @param {?} context
     * @return {?}
     */


    function isContextLocked(context) {
      return (getConfig(context) & 1
      /* Locked */
      ) > 0;
    }
    /**
     * @param {?} context
     * @return {?}
     */


    function stateIsPersisted(context) {
      return (getConfig(context) & 2
      /* PersistStateValues */
      ) > 0;
    }
    /**
     * @param {?} context
     * @return {?}
     */


    function markContextToPersistState(context) {
      setConfig(context, getConfig(context) | 2
      /* PersistStateValues */
      );
    }
    /**
     * @param {?} context
     * @return {?}
     */


    function getPropValuesStartPosition(context) {
      return 6
      /* MapBindingsBindingsStartPosition */
      + context[4
      /* MapBindingsValuesCountPosition */
      ];
    }
    /**
     * @param {?} prop
     * @return {?}
     */


    function isMapBased(prop) {
      return prop === MAP_BASED_ENTRY_PROP_NAME;
    }
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */


    function hasValueChanged(a, b) {
      /** @type {?} */
      let compareValueA = Array.isArray(a) ? a[0
      /* RawValuePosition */
      ] : a;
      /** @type {?} */

      let compareValueB = Array.isArray(b) ? b[0
      /* RawValuePosition */
      ] : b; // these are special cases for String based values (which are created as artifacts
      // when sanitization is bypassed on a particular value)

      if (compareValueA instanceof String) {
        compareValueA = compareValueA.toString();
      }

      if (compareValueB instanceof String) {
        compareValueB = compareValueB.toString();
      }

      return isDifferent(compareValueA, compareValueB);
    }
    /**
     * Determines whether the provided styling value is truthy or falsy.
     * @param {?} value
     * @return {?}
     */


    function isStylingValueDefined(value) {
      // the reason why null is compared against is because
      // a CSS class value that is set to `false` must be
      // respected (otherwise it would be treated as falsy).
      // Empty string values are because developers usually
      // set a value to an empty string to remove it.
      return value != null && value !== '';
    }
    /**
     * @param {?} a
     * @param {?} b
     * @param {?=} separator
     * @return {?}
     */


    function concatString(a, b, separator = ' ') {
      return a + (b.length && a.length ? separator : '') + b;
    }
    /**
     * @param {?} value
     * @return {?}
     */


    function hyphenate(value) {
      return value.replace(/[a-z][A-Z]/g,
      /**
      * @param {?} v
      * @return {?}
      */
      v => v.charAt(0) + '-' + v.charAt(1)).toLowerCase();
    }
    /**
     * Returns an instance of `StylingMapArray`.
     *
     * This function is designed to find an instance of `StylingMapArray` in case it is stored
     * inside of an instance of `TStylingContext`. When a styling context is created it
     * will copy over an initial styling values from the tNode (which are stored as a
     * `StylingMapArray` on the `tNode.classes` or `tNode.styles` values).
     * @param {?} value
     * @return {?}
     */


    function getStylingMapArray(value) {
      return isStylingContext(value) ?
      /** @type {?} */
      value[0
      /* InitialStylingValuePosition */
      ] : value;
    }
    /**
     * @param {?} value
     * @return {?}
     */


    function isStylingContext(value) {
      // the StylingMapArray is in the format of [initial, prop, string, prop, string]
      // and this is the defining value to distinguish between arrays
      return Array.isArray(value) && value.length >= 6
      /* MapBindingsBindingsStartPosition */
      && typeof value[1] !== 'string';
    }
    /**
     * @param {?} context
     * @return {?}
     */


    function getInitialStylingValue(context) {
      /** @type {?} */
      const map = getStylingMapArray(context);
      return map &&
      /** @type {?} */
      map[0
      /* RawValuePosition */
      ] || '';
    }
    /**
     * @param {?} tNode
     * @return {?}
     */


    function hasClassInput(tNode) {
      return (tNode.flags & 8
      /* hasClassInput */
      ) !== 0;
    }
    /**
     * @param {?} tNode
     * @return {?}
     */


    function hasStyleInput(tNode) {
      return (tNode.flags & 16
      /* hasStyleInput */
      ) !== 0;
    }
    /**
     * @param {?} map
     * @param {?} index
     * @return {?}
     */


    function getMapProp(map, index) {
      return (
        /** @type {?} */
        map[index + 0
        /* PropOffset */
        ]
      );
    }
    /**
     * @param {?} map
     * @param {?} index
     * @param {?} value
     * @return {?}
     */


    function setMapValue(map, index, value) {
      map[index + 1
      /* ValueOffset */
      ] = value;
    }
    /**
     * @param {?} map
     * @param {?} index
     * @return {?}
     */


    function getMapValue(map, index) {
      return (
        /** @type {?} */
        map[index + 1
        /* ValueOffset */
        ]
      );
    }
    /**
     * @param {?} classes
     * @return {?}
     */


    function forceClassesAsString(classes) {
      if (classes && typeof classes !== 'string') {
        classes = Object.keys(classes).join(' ');
      }

      return (
        /** @type {?} */
        classes || ''
      );
    }
    /**
     * @param {?} styles
     * @return {?}
     */


    function forceStylesAsString(styles) {
      /** @type {?} */
      let str = '';

      if (styles) {
        /** @type {?} */
        const props = Object.keys(styles);

        for (let i = 0; i < props.length; i++) {
          /** @type {?} */
          const prop = props[i];
          str = concatString(str, "".concat(prop, ":").concat(styles[prop]), ';');
        }
      }

      return str;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * The goal here is to make sure that the browser DOM API is the Renderer.
     * We do this by defining a subset of DOM API to be the renderer and than
     * use that time for rendering.
     *
     * At runtime we can then use the DOM api directly, in server or web-worker
     * it will be easy to implement such API.
     */

    /** @enum {number} */


    const RendererStyleFlags3 = {
      Important: 1,
      DashCase: 2
    };
    RendererStyleFlags3[RendererStyleFlags3.Important] = 'Important';
    RendererStyleFlags3[RendererStyleFlags3.DashCase] = 'DashCase';
    /**
     * Object Oriented style of API needed to create elements and text nodes.
     *
     * This is the native browser API style, e.g. operations are methods on individual objects
     * like HTMLElement. With this style, no additional code is needed as a facade
     * (reducing payload size).
     *
     * @record
     */

    function ObjectOrientedRenderer3() {}

    if (false) {}
    /**
     * Returns whether the `renderer` is a `ProceduralRenderer3`
     * @param {?} renderer
     * @return {?}
     */


    function isProceduralRenderer(renderer) {
      return !!
      /** @type {?} */
      renderer.listen;
    }
    /**
     * Procedural style of API needed to create elements and text nodes.
     *
     * In non-native browser environments (e.g. platforms such as web-workers), this is the
     * facade that enables element manipulation. This also facilitates backwards compatibility
     * with Renderer2.
     * @record
     */


    function ProceduralRenderer3() {}

    if (false) {}
    /**
     * @record
     */


    function RendererFactory3() {}

    if (false) {}

    const ɵ0$3 =
    /**
    * @param {?} hostElement
    * @param {?} rendererType
    * @return {?}
    */
    (hostElement, rendererType) => {
      return document;
    };
    /** @type {?} */


    const domRendererFactory3 = {
      createRenderer: ɵ0$3
    };
    /**
     * Subset of API needed for appending elements and text nodes.
     * @record
     */

    function RNode() {}

    if (false) {}
    /**
     * Subset of API needed for writing attributes, properties, and setting up
     * listeners on Element.
     * @record
     */


    function RElement() {}

    if (false) {}
    /**
     * @record
     */


    function RCssStyleDeclaration() {}

    if (false) {}
    /**
     * @record
     */


    function RDomTokenList() {}

    if (false) {}
    /**
     * @record
     */


    function RText() {}

    if (false) {}
    /**
     * @record
     */


    function RComment() {}

    if (false) {} // Note: This hack is necessary so we don't erroneously get a circular dependency
    // failure based on types.

    /** @type {?} */


    const unusedValueExportToPlacateAjd$3 = 1;
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Assigns all attribute values to the provided element via the inferred renderer.
     *
     * This function accepts two forms of attribute entries:
     *
     * default: (key, value):
     *  attrs = [key1, value1, key2, value2]
     *
     * namespaced: (NAMESPACE_MARKER, uri, name, value)
     *  attrs = [NAMESPACE_MARKER, uri, name, value, NAMESPACE_MARKER, uri, name, value]
     *
     * The `attrs` array can contain a mix of both the default and namespaced entries.
     * The "default" values are set without a marker, but if the function comes across
     * a marker value then it will attempt to set a namespaced value. If the marker is
     * not of a namespaced value then the function will quit and return the index value
     * where it stopped during the iteration of the attrs array.
     *
     * See [AttributeMarker] to understand what the namespace marker value is.
     *
     * Note that this instruction does not support assigning style and class values to
     * an element. See `elementStart` and `elementHostAttrs` to learn how styling values
     * are applied to an element.
     *
     * @param {?} native The element that the attributes will be assigned to
     * @param {?} attrs The attribute array of values that will be assigned to the element
     * @return {?} the index value that was last accessed in the attributes array
     */

    function setUpAttributes(native, attrs) {
      /** @type {?} */
      const renderer = getLView()[RENDERER];
      /** @type {?} */

      const isProc = isProceduralRenderer(renderer);
      /** @type {?} */

      let i = 0;

      while (i < attrs.length) {
        /** @type {?} */
        const value = attrs[i];

        if (typeof value === 'number') {
          // only namespaces are supported. Other value types (such as style/class
          // entries) are not supported in this function.
          if (value !== 0
          /* NamespaceURI */
          ) {
              break;
            } // we just landed on the marker value ... therefore
          // we should skip to the next entry


          i++;
          /** @type {?} */

          const namespaceURI =
          /** @type {?} */
          attrs[i++];
          /** @type {?} */

          const attrName =
          /** @type {?} */
          attrs[i++];
          /** @type {?} */

          const attrVal =
          /** @type {?} */
          attrs[i++];
          ngDevMode && ngDevMode.rendererSetAttribute++;
          isProc ?
          /** @type {?} */
          renderer.setAttribute(native, attrName, attrVal, namespaceURI) : native.setAttributeNS(namespaceURI, attrName, attrVal);
        } else {
          // attrName is string;

          /** @type {?} */
          const attrName =
          /** @type {?} */
          value;
          /** @type {?} */

          const attrVal = attrs[++i]; // Standard attributes

          ngDevMode && ngDevMode.rendererSetAttribute++;

          if (isAnimationProp(attrName)) {
            if (isProc) {
              /** @type {?} */
              renderer.setProperty(native, attrName, attrVal);
            }
          } else {
            isProc ?
            /** @type {?} */
            renderer.setAttribute(native,
            /** @type {?} */
            attrName,
            /** @type {?} */
            attrVal) : native.setAttribute(
            /** @type {?} */
            attrName,
            /** @type {?} */
            attrVal);
          }

          i++;
        }
      } // another piece of code may iterate over the same attributes array. Therefore
      // it may be helpful to return the exact spot where the attributes array exited
      // whether by running into an unsupported marker or if all the static values were
      // iterated over.


      return i;
    }
    /**
     * @param {?} attrs
     * @param {?} startIndex
     * @return {?}
     */


    function attrsStylingIndexOf(attrs, startIndex) {
      for (let i = startIndex; i < attrs.length; i++) {
        /** @type {?} */
        const val = attrs[i];

        if (val === 1
        /* Classes */
        || val === 2
        /* Styles */
        ) {
            return i;
          }
      }

      return -1;
    }
    /**
     * Test whether the given value is a marker that indicates that the following
     * attribute values in a `TAttributes` array are only the names of attributes,
     * and not name-value pairs.
     * @param {?} marker The attribute marker to test.
     * @return {?} true if the marker is a "name-only" marker (e.g. `Bindings`, `Template` or `I18n`).
     */


    function isNameOnlyAttributeMarker(marker) {
      return marker === 3
      /* Bindings */
      || marker === 4
      /* Template */
      || marker === 6
      /* I18n */
      ;
    }
    /** @type {?} */


    const ANIMATION_PROP_PREFIX = '@';
    /**
     * @param {?} name
     * @return {?}
     */

    function isAnimationProp(name) {
      return name[0] === ANIMATION_PROP_PREFIX;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    /// Parent Injector Utils ///////////////////////////////////////////////////////////////

    /**
     * @param {?} parentLocation
     * @return {?}
     */


    function hasParentInjector(parentLocation) {
      return parentLocation !== NO_PARENT_INJECTOR;
    }
    /**
     * @param {?} parentLocation
     * @return {?}
     */


    function getParentInjectorIndex(parentLocation) {
      return (
        /** @type {?} */

        /** @type {?} */
        parentLocation & 32767
        /* InjectorIndexMask */

      );
    }
    /**
     * @param {?} parentLocation
     * @return {?}
     */


    function getParentInjectorViewOffset(parentLocation) {
      return (
        /** @type {?} */

        /** @type {?} */
        parentLocation >> 16
        /* ViewOffsetShift */

      );
    }
    /**
     * Unwraps a parent injector location number to find the view offset from the current injector,
     * then walks up the declaration view tree until the view is found that contains the parent
     * injector.
     *
     * @param {?} location The location of the parent injector, which contains the view offset
     * @param {?} startView The LView instance from which to start walking up the view tree
     * @return {?} The LView instance that contains the parent injector
     */


    function getParentInjectorView(location, startView) {
      /** @type {?} */
      let viewOffset = getParentInjectorViewOffset(location);
      /** @type {?} */

      let parentView = startView; // For most cases, the parent injector can be found on the host node (e.g. for component
      // or container), but we must keep the loop here to support the rarer case of deeply nested
      // <ng-template> tags or inline views, where the parent injector might live many views
      // above the child injector.

      while (viewOffset > 0) {
        parentView =
        /** @type {?} */
        parentView[DECLARATION_VIEW];
        viewOffset--;
      }

      return parentView;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Gets the parent LView of the passed LView, if the PARENT is an LContainer, will get the parent of
     * that LContainer, which is an LView
     * @param {?} lView the lView whose parent to get
     * @return {?}
     */


    function getLViewParent(lView) {
      ngDevMode && assertLView(lView);
      /** @type {?} */

      const parent = lView[PARENT];
      return isLContainer(parent) ?
      /** @type {?} */
      parent[PARENT] : parent;
    }
    /**
     * Retrieve the root view from any component or `LView` by walking the parent `LView` until
     * reaching the root `LView`.
     *
     * @param {?} componentOrLView any component or `LView`
     * @return {?}
     */


    function getRootView(componentOrLView) {
      ngDevMode && assertDefined(componentOrLView, 'component');
      /** @type {?} */

      let lView = isLView(componentOrLView) ? componentOrLView :
      /** @type {?} */
      readPatchedLView(componentOrLView);

      while (lView && !(lView[FLAGS] & 512
      /* IsRoot */
      )) {
        lView =
        /** @type {?} */
        getLViewParent(lView);
      }

      ngDevMode && assertLView(lView);
      return lView;
    }
    /**
     * Given an `LView`, find the closest declaration view which is not an embedded view.
     *
     * This method searches for the `LView` associated with the component which declared the `LView`.
     *
     * This function may return itself if the `LView` passed in is not an embedded `LView`. Otherwise
     * it walks the declaration parents until it finds a component view (non-embedded-view.)
     *
     * @param {?} lView LView for which we want a host element node
     * @return {?} The host node
     */


    function findComponentView(lView) {
      /** @type {?} */
      let rootTNode = lView[T_HOST];

      while (rootTNode !== null && rootTNode.type === 2
      /* View */
      ) {
        ngDevMode && assertDefined(lView[DECLARATION_VIEW], 'lView[DECLARATION_VIEW]');
        lView =
        /** @type {?} */
        lView[DECLARATION_VIEW];
        rootTNode = lView[T_HOST];
      }

      ngDevMode && assertLView(lView);
      return lView;
    }
    /**
     * Returns the `RootContext` instance that is associated with
     * the application where the target is situated. It does this by walking the parent views until it
     * gets to the root view, then getting the context off of that.
     *
     * @param {?} viewOrComponent the `LView` or component to get the root context for.
     * @return {?}
     */


    function getRootContext(viewOrComponent) {
      /** @type {?} */
      const rootView = getRootView(viewOrComponent);
      ngDevMode && assertDefined(rootView[CONTEXT], 'RootView has no context. Perhaps it is disconnected?');
      return (
        /** @type {?} */
        rootView[CONTEXT]
      );
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Defines if the call to `inject` should include `viewProviders` in its resolution.
     *
     * This is set to true when we try to instantiate a component. This value is reset in
     * `getNodeInjectable` to a value which matches the declaration location of the token about to be
     * instantiated. This is done so that if we are injecting a token which was declared outside of
     * `viewProviders` we don't accidentally pull `viewProviders` in.
     *
     * Example:
     *
     * ```
     * \@Injectable()
     * class MyService {
     *   constructor(public value: String) {}
     * }
     *
     * \@Component({
     *   providers: [
     *     MyService,
     *     {provide: String, value: 'providers' }
     *   ]
     *   viewProviders: [
     *     {provide: String, value: 'viewProviders'}
     *   ]
     * })
     * class MyComponent {
     *   constructor(myService: MyService, value: String) {
     *     // We expect that Component can see into `viewProviders`.
     *     expect(value).toEqual('viewProviders');
     *     // `MyService` was not declared in `viewProviders` hence it can't see it.
     *     expect(myService.value).toEqual('providers');
     *   }
     * }
     *
     * ```
     * @type {?}
     */


    let includeViewProviders = true;
    /**
     * @param {?} v
     * @return {?}
     */

    function setIncludeViewProviders(v) {
      /** @type {?} */
      const oldValue = includeViewProviders;
      includeViewProviders = v;
      return oldValue;
    }
    /**
     * The number of slots in each bloom filter (used by DI). The larger this number, the fewer
     * directives that will share slots, and thus, the fewer false positives when checking for
     * the existence of a directive.
     * @type {?}
     */


    const BLOOM_SIZE = 256;
    /** @type {?} */

    const BLOOM_MASK = BLOOM_SIZE - 1;
    /**
     * Counter used to generate unique IDs for directives.
     * @type {?}
     */

    let nextNgElementId = 0;
    /**
     * Registers this directive as present in its node's injector by flipping the directive's
     * corresponding bit in the injector's bloom filter.
     *
     * @param {?} injectorIndex The index of the node injector where this token should be registered
     * @param {?} tView The TView for the injector's bloom filters
     * @param {?} type The directive token to register
     * @return {?}
     */

    function bloomAdd(injectorIndex, tView, type) {
      ngDevMode && assertEqual(tView.firstTemplatePass, true, 'expected firstTemplatePass to be true');
      /** @type {?} */

      let id = typeof type !== 'string' ?
      /** @type {?} */
      type[NG_ELEMENT_ID] : type.charCodeAt(0) || 0; // Set a unique ID on the directive type, so if something tries to inject the directive,
      // we can easily retrieve the ID and hash it into the bloom bit that should be checked.

      if (id == null) {
        id =
        /** @type {?} */
        type[NG_ELEMENT_ID] = nextNgElementId++;
      } // We only have BLOOM_SIZE (256) slots in our bloom filter (8 buckets * 32 bits each),
      // so all unique IDs must be modulo-ed into a number from 0 - 255 to fit into the filter.

      /** @type {?} */


      const bloomBit = id & BLOOM_MASK; // Create a mask that targets the specific bit associated with the directive.
      // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding
      // to bit positions 0 - 31 in a 32 bit integer.

      /** @type {?} */

      const mask = 1 << bloomBit; // Use the raw bloomBit number to determine which bloom filter bucket we should check
      // e.g: bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc

      /** @type {?} */

      const b7 = bloomBit & 0x80;
      /** @type {?} */

      const b6 = bloomBit & 0x40;
      /** @type {?} */

      const b5 = bloomBit & 0x20;
      /** @type {?} */

      const tData =
      /** @type {?} */
      tView.data;

      if (b7) {
        b6 ? b5 ? tData[injectorIndex + 7] |= mask : tData[injectorIndex + 6] |= mask : b5 ? tData[injectorIndex + 5] |= mask : tData[injectorIndex + 4] |= mask;
      } else {
        b6 ? b5 ? tData[injectorIndex + 3] |= mask : tData[injectorIndex + 2] |= mask : b5 ? tData[injectorIndex + 1] |= mask : tData[injectorIndex] |= mask;
      }
    }
    /**
     * Creates (or gets an existing) injector for a given element or container.
     *
     * @param {?} tNode for which an injector should be retrieved / created.
     * @param {?} hostView View where the node is stored
     * @return {?} Node injector
     */


    function getOrCreateNodeInjectorForNode(tNode, hostView) {
      /** @type {?} */
      const existingInjectorIndex = getInjectorIndex(tNode, hostView);

      if (existingInjectorIndex !== -1) {
        return existingInjectorIndex;
      }
      /** @type {?} */


      const tView = hostView[TVIEW];

      if (tView.firstTemplatePass) {
        tNode.injectorIndex = hostView.length;
        insertBloom(tView.data, tNode); // foundation for node bloom

        insertBloom(hostView, null); // foundation for cumulative bloom

        insertBloom(tView.blueprint, null);
        ngDevMode && assertEqual(tNode.flags === 0 || tNode.flags === 1
        /* isComponent */
        , true, 'expected tNode.flags to not be initialized');
      }
      /** @type {?} */


      const parentLoc = getParentInjectorLocation(tNode, hostView);
      /** @type {?} */

      const parentIndex = getParentInjectorIndex(parentLoc);
      /** @type {?} */

      const parentLView = getParentInjectorView(parentLoc, hostView);
      /** @type {?} */

      const injectorIndex = tNode.injectorIndex; // If a parent injector can't be found, its location is set to -1.
      // In that case, we don't need to set up a cumulative bloom

      if (hasParentInjector(parentLoc)) {
        /** @type {?} */
        const parentData =
        /** @type {?} */
        parentLView[TVIEW].data; // Creates a cumulative bloom filter that merges the parent's bloom filter
        // and its own cumulative bloom (which contains tokens for all ancestors)

        for (let i = 0; i < 8; i++) {
          hostView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];
        }
      }

      hostView[injectorIndex + PARENT_INJECTOR] = parentLoc;
      return injectorIndex;
    }
    /**
     * @param {?} arr
     * @param {?} footer
     * @return {?}
     */


    function insertBloom(arr, footer) {
      arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);
    }
    /**
     * @param {?} tNode
     * @param {?} hostView
     * @return {?}
     */


    function getInjectorIndex(tNode, hostView) {
      if (tNode.injectorIndex === -1 || // If the injector index is the same as its parent's injector index, then the index has been
      // copied down from the parent node. No injector has been created yet on this node.
      tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex || // After the first template pass, the injector index might exist but the parent values
      // might not have been calculated yet for this instance
      hostView[tNode.injectorIndex + PARENT_INJECTOR] == null) {
        return -1;
      } else {
        return tNode.injectorIndex;
      }
    }
    /**
     * Finds the index of the parent injector, with a view offset if applicable. Used to set the
     * parent injector initially.
     *
     * Returns a combination of number of `ViewData` we have to go up and index in that `Viewdata`
     * @param {?} tNode
     * @param {?} view
     * @return {?}
     */


    function getParentInjectorLocation(tNode, view) {
      if (tNode.parent && tNode.parent.injectorIndex !== -1) {
        return (
          /** @type {?} */
          tNode.parent.injectorIndex
        ); // ViewOffset is 0
      } // For most cases, the parent injector index can be found on the host node (e.g. for component
      // or container), so this loop will be skipped, but we must keep the loop here to support
      // the rarer case of deeply nested <ng-template> tags or inline views.

      /** @type {?} */


      let hostTNode = view[T_HOST];
      /** @type {?} */

      let viewOffset = 1;

      while (hostTNode && hostTNode.injectorIndex === -1) {
        view =
        /** @type {?} */
        view[DECLARATION_VIEW];
        hostTNode = view ? view[T_HOST] : null;
        viewOffset++;
      }

      return hostTNode ? hostTNode.injectorIndex | viewOffset << 16
      /* ViewOffsetShift */
      :
      /** @type {?} */
      -1;
    }
    /**
     * Makes a type or an injection token public to the DI system by adding it to an
     * injector's bloom filter.
     *
     * @param {?} injectorIndex
     * @param {?} tView
     * @param {?} token The type or the injection token to be made public
     * @return {?}
     */


    function diPublicInInjector(injectorIndex, tView, token) {
      bloomAdd(injectorIndex, tView, token);
    }
    /**
     * Inject static attribute value into directive constructor.
     *
     * This method is used with `factory` functions which are generated as part of
     * `defineDirective` or `defineComponent`. The method retrieves the static value
     * of an attribute. (Dynamic attributes are not supported since they are not resolved
     *  at the time of injection and can change over time.)
     *
     * # Example
     * Given:
     * ```
     * \@Component(...)
     * class MyComponent {
     *   constructor(\@Attribute('title') title: string) { ... }
     * }
     * ```
     * When instantiated with
     * ```
     * <my-component title="Hello"></my-component>
     * ```
     *
     * Then factory method generated is:
     * ```
     * MyComponent.ngComponentDef = defineComponent({
     *   factory: () => new MyComponent(injectAttribute('title'))
     *   ...
     * })
     * ```
     *
     * \@publicApi
     * @param {?} tNode
     * @param {?} attrNameToInject
     * @return {?}
     */


    function injectAttributeImpl(tNode, attrNameToInject) {
      ngDevMode && assertNodeOfPossibleTypes(tNode, 0
      /* Container */
      , 3
      /* Element */
      , 4
      /* ElementContainer */
      );
      ngDevMode && assertDefined(tNode, 'expecting tNode');

      if (attrNameToInject === 'class') {
        return getInitialStylingValue(tNode.classes);
      }

      if (attrNameToInject === 'style') {
        return getInitialStylingValue(tNode.styles);
      }
      /** @type {?} */


      const attrs = tNode.attrs;

      if (attrs) {
        /** @type {?} */
        const attrsLength = attrs.length;
        /** @type {?} */

        let i = 0;

        while (i < attrsLength) {
          /** @type {?} */
          const value = attrs[i]; // If we hit a `Bindings` or `Template` marker then we are done.

          if (isNameOnlyAttributeMarker(value)) break; // Skip namespaced attributes

          if (value === 0
          /* NamespaceURI */
          ) {
              // we skip the next two values
              // as namespaced attributes looks like
              // [..., AttributeMarker.NamespaceURI, 'http://someuri.com/test', 'test:exist',
              // 'existValue', ...]
              i = i + 2;
            } else if (typeof value === 'number') {
            // Skip to the first value of the marked attribute.
            i++;

            while (i < attrsLength && typeof attrs[i] === 'string') {
              i++;
            }
          } else if (value === attrNameToInject) {
            return (
              /** @type {?} */
              attrs[i + 1]
            );
          } else {
            i = i + 2;
          }
        }
      }

      return null;
    }
    /**
     * Returns the value associated to the given token from the NodeInjectors => ModuleInjector.
     *
     * Look for the injector providing the token by walking up the node injector tree and then
     * the module injector tree.
     *
     * This function patches `token` with `__NG_ELEMENT_ID__` which contains the id for the bloom
     * filter. Negative values are reserved for special objects.
     *   - `-1` is reserved for injecting `Injector` (implemented by `NodeInjector`)
     *
     * @template T
     * @param {?} tNode The Node where the search for the injector should start
     * @param {?} lView The `LView` that contains the `tNode`
     * @param {?} token The token to look for
     * @param {?=} flags Injection flags
     * @param {?=} notFoundValue The value to return when the injection flags is `InjectFlags.Optional`
     * @return {?} the value from the injector, `null` when not found, or `notFoundValue` if provided
     */


    function getOrCreateInjectable(tNode, lView, token, flags = InjectFlags.Default, notFoundValue) {
      if (tNode) {
        /** @type {?} */
        const bloomHash = bloomHashBitOrFactory(token); // If the ID stored here is a function, this is a special object like ElementRef or TemplateRef
        // so just call the factory function to create it.

        if (typeof bloomHash === 'function') {
          /** @type {?} */
          const savePreviousOrParentTNode = getPreviousOrParentTNode();
          /** @type {?} */

          const saveLView = getLView();
          setTNodeAndViewData(tNode, lView);

          try {
            /** @type {?} */
            const value = bloomHash();

            if (value == null && !(flags & InjectFlags.Optional)) {
              throw new Error("No provider for ".concat(stringifyForError(token), "!"));
            } else {
              return value;
            }
          } finally {
            setTNodeAndViewData(savePreviousOrParentTNode, saveLView);
          }
        } else if (typeof bloomHash == 'number') {
          if (bloomHash === -1) {
            // `-1` is a special value used to identify `Injector` types.
            return (
              /** @type {?} */
              new NodeInjector(tNode, lView)
            );
          } // If the token has a bloom hash, then it is a token which could be in NodeInjector.
          // A reference to the previous injector TView that was found while climbing the element
          // injector tree. This is used to know if viewProviders can be accessed on the current
          // injector.

          /** @type {?} */


          let previousTView = null;
          /** @type {?} */

          let injectorIndex = getInjectorIndex(tNode, lView);
          /** @type {?} */

          let parentLocation = NO_PARENT_INJECTOR;
          /** @type {?} */

          let hostTElementNode = flags & InjectFlags.Host ? findComponentView(lView)[T_HOST] : null; // If we should skip this injector, or if there is no injector on this node, start by
          // searching
          // the parent injector.

          if (injectorIndex === -1 || flags & InjectFlags.SkipSelf) {
            parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) : lView[injectorIndex + PARENT_INJECTOR];

            if (!shouldSearchParent(flags, false)) {
              injectorIndex = -1;
            } else {
              previousTView = lView[TVIEW];
              injectorIndex = getParentInjectorIndex(parentLocation);
              lView = getParentInjectorView(parentLocation, lView);
            }
          } // Traverse up the injector tree until we find a potential match or until we know there
          // *isn't* a match.


          while (injectorIndex !== -1) {
            parentLocation = lView[injectorIndex + PARENT_INJECTOR]; // Check the current injector. If it matches, see if it contains token.

            /** @type {?} */

            const tView = lView[TVIEW];

            if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {
              // At this point, we have an injector which *may* contain the token, so we step through
              // the providers and directives associated with the injector's corresponding node to get
              // the instance.

              /** @type {?} */
              const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);

              if (instance !== NOT_FOUND) {
                return instance;
              }
            }

            if (shouldSearchParent(flags, lView[TVIEW].data[injectorIndex + TNODE] === hostTElementNode) && bloomHasToken(bloomHash, injectorIndex, lView)) {
              // The def wasn't found anywhere on this node, so it was a false positive.
              // Traverse up the tree and continue searching.
              previousTView = tView;
              injectorIndex = getParentInjectorIndex(parentLocation);
              lView = getParentInjectorView(parentLocation, lView);
            } else {
              // If we should not search parent OR If the ancestor bloom filter value does not have the
              // bit corresponding to the directive we can give up on traversing up to find the specific
              // injector.
              injectorIndex = -1;
            }
          }
        }
      }

      if (flags & InjectFlags.Optional && notFoundValue === undefined) {
        // This must be set or the NullInjector will throw for optional deps
        notFoundValue = null;
      }

      if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {
        /** @type {?} */
        const moduleInjector = lView[INJECTOR$1]; // switch to `injectInjectorOnly` implementation for module injector, since module injector
        // should not have access to Component/Directive DI scope (that may happen through
        // `directiveInject` implementation)

        /** @type {?} */

        const previousInjectImplementation = setInjectImplementation(undefined);

        try {
          if (moduleInjector) {
            return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);
          } else {
            return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);
          }
        } finally {
          setInjectImplementation(previousInjectImplementation);
        }
      }

      if (flags & InjectFlags.Optional) {
        return notFoundValue;
      } else {
        throw new Error("NodeInjector: NOT_FOUND [".concat(stringifyForError(token), "]"));
      }
    }
    /** @type {?} */


    const NOT_FOUND = {};
    /**
     * @template T
     * @param {?} injectorIndex
     * @param {?} lView
     * @param {?} token
     * @param {?} previousTView
     * @param {?} flags
     * @param {?} hostTElementNode
     * @return {?}
     */

    function searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {
      /** @type {?} */
      const currentTView = lView[TVIEW];
      /** @type {?} */

      const tNode =
      /** @type {?} */
      currentTView.data[injectorIndex + TNODE]; // First, we need to determine if view providers can be accessed by the starting element.
      // There are two possibities

      /** @type {?} */

      const canAccessViewProviders = previousTView == null ? // 1) This is the first invocation `previousTView == null` which means that we are at the
      // `TNode` of where injector is starting to look. In such a case the only time we are allowed
      // to look into the ViewProviders is if:
      // - we are on a component
      // - AND the injector set `includeViewProviders` to true (implying that the token can see
      // ViewProviders because it is the Component or a Service which itself was declared in
      // ViewProviders)
      isComponent(tNode) && includeViewProviders : // 2) `previousTView != null` which means that we are now walking across the parent nodes.
      // In such a case we are only allowed to look into the ViewProviders if:
      // - We just crossed from child View to Parent View `previousTView != currentTView`
      // - AND the parent TNode is an Element.
      // This means that we just came from the Component's View and therefore are allowed to see
      // into the ViewProviders.
      previousTView != currentTView && tNode.type === 3
      /* Element */
      ; // This special case happens when there is a @host on the inject and when we are searching
      // on the host element node.

      /** @type {?} */

      const isHostSpecialCase = flags & InjectFlags.Host && hostTElementNode === tNode;
      /** @type {?} */

      const injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);

      if (injectableIdx !== null) {
        return getNodeInjectable(currentTView.data, lView, injectableIdx,
        /** @type {?} */
        tNode);
      } else {
        return NOT_FOUND;
      }
    }
    /**
     * Searches for the given token among the node's directives and providers.
     *
     * @template T
     * @param {?} tNode TNode on which directives are present.
     * @param {?} tView The tView we are currently processing
     * @param {?} token Provider token or type of a directive to look for.
     * @param {?} canAccessViewProviders Whether view providers should be considered.
     * @param {?} isHostSpecialCase Whether the host special case applies.
     * @return {?} Index of a found directive or provider, or null when none found.
     */


    function locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {
      /** @type {?} */
      const nodeProviderIndexes = tNode.providerIndexes;
      /** @type {?} */

      const tInjectables = tView.data;
      /** @type {?} */

      const injectablesStart = nodeProviderIndexes & 65535
      /* ProvidersStartIndexMask */
      ;
      /** @type {?} */

      const directivesStart = tNode.directiveStart;
      /** @type {?} */

      const directiveEnd = tNode.directiveEnd;
      /** @type {?} */

      const cptViewProvidersCount = nodeProviderIndexes >> 16
      /* CptViewProvidersCountShift */
      ;
      /** @type {?} */

      const startingIndex = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount; // When the host special case applies, only the viewProviders and the component are visible

      /** @type {?} */

      const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;

      for (let i = startingIndex; i < endIndex; i++) {
        /** @type {?} */
        const providerTokenOrDef =
        /** @type {?} */
        tInjectables[i];

        if (i < directivesStart && token === providerTokenOrDef || i >= directivesStart &&
        /** @type {?} */
        providerTokenOrDef.type === token) {
          return i;
        }
      }

      if (isHostSpecialCase) {
        /** @type {?} */
        const dirDef =
        /** @type {?} */
        tInjectables[directivesStart];

        if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {
          return directivesStart;
        }
      }

      return null;
    }
    /**
     * Retrieve or instantiate the injectable from the `lData` at particular `index`.
     *
     * This function checks to see if the value has already been instantiated and if so returns the
     * cached `injectable`. Otherwise if it detects that the value is still a factory it
     * instantiates the `injectable` and caches the value.
     * @param {?} tData
     * @param {?} lData
     * @param {?} index
     * @param {?} tNode
     * @return {?}
     */


    function getNodeInjectable(tData, lData, index, tNode) {
      /** @type {?} */
      let value = lData[index];

      if (isFactory(value)) {
        /** @type {?} */
        const factory = value;

        if (factory.resolving) {
          throw new Error("Circular dep for ".concat(stringifyForError(tData[index])));
        }
        /** @type {?} */


        const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);
        factory.resolving = true;
        /** @type {?} */

        let previousInjectImplementation;

        if (factory.injectImpl) {
          previousInjectImplementation = setInjectImplementation(factory.injectImpl);
        }
        /** @type {?} */


        const savePreviousOrParentTNode = getPreviousOrParentTNode();
        /** @type {?} */

        const saveLView = getLView();
        setTNodeAndViewData(tNode, lData);

        try {
          value = lData[index] = factory.factory(undefined, tData, lData, tNode);
        } finally {
          if (factory.injectImpl) setInjectImplementation(previousInjectImplementation);
          setIncludeViewProviders(previousIncludeViewProviders);
          factory.resolving = false;
          setTNodeAndViewData(savePreviousOrParentTNode, saveLView);
        }
      }

      return value;
    }
    /**
     * Returns the bit in an injector's bloom filter that should be used to determine whether or not
     * the directive might be provided by the injector.
     *
     * When a directive is public, it is added to the bloom filter and given a unique ID that can be
     * retrieved on the Type. When the directive isn't public or the token is not a directive `null`
     * is returned as the node injector can not possibly provide that token.
     *
     * @param {?} token the injection token
     * @return {?} the matching bit to check in the bloom filter or `null` if the token is not known.
     *   When the returned value is negative then it represents special values such as `Injector`.
     */


    function bloomHashBitOrFactory(token) {
      ngDevMode && assertDefined(token, 'token must be defined');

      if (typeof token === 'string') {
        return token.charCodeAt(0) || 0;
      }
      /** @type {?} */


      const tokenId =
      /** @type {?} */
      token[NG_ELEMENT_ID]; // Negative token IDs are used for special objects such as `Injector`

      return typeof tokenId === 'number' && tokenId > 0 ? tokenId & BLOOM_MASK : tokenId;
    }
    /**
     * @param {?} bloomHash
     * @param {?} injectorIndex
     * @param {?} injectorView
     * @return {?}
     */


    function bloomHasToken(bloomHash, injectorIndex, injectorView) {
      // Create a mask that targets the specific bit associated with the directive we're looking for.
      // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding
      // to bit positions 0 - 31 in a 32 bit integer.

      /** @type {?} */
      const mask = 1 << bloomHash;
      /** @type {?} */

      const b7 = bloomHash & 0x80;
      /** @type {?} */

      const b6 = bloomHash & 0x40;
      /** @type {?} */

      const b5 = bloomHash & 0x20; // Our bloom filter size is 256 bits, which is eight 32-bit bloom filter buckets:
      // bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc.
      // Get the bloom filter value from the appropriate bucket based on the directive's bloomBit.

      /** @type {?} */

      let value;

      if (b7) {
        value = b6 ? b5 ? injectorView[injectorIndex + 7] : injectorView[injectorIndex + 6] : b5 ? injectorView[injectorIndex + 5] : injectorView[injectorIndex + 4];
      } else {
        value = b6 ? b5 ? injectorView[injectorIndex + 3] : injectorView[injectorIndex + 2] : b5 ? injectorView[injectorIndex + 1] : injectorView[injectorIndex];
      } // If the bloom filter value has the bit corresponding to the directive's bloomBit flipped on,
      // this injector is a potential match.


      return !!(value & mask);
    }
    /**
     * Returns true if flags prevent parent injector from being searched for tokens
     * @param {?} flags
     * @param {?} isFirstHostTNode
     * @return {?}
     */


    function shouldSearchParent(flags, isFirstHostTNode) {
      return !(flags & InjectFlags.Self) && !(flags & InjectFlags.Host && isFirstHostTNode);
    }

    class NodeInjector {
      /**
       * @param {?} _tNode
       * @param {?} _lView
       */
      constructor(_tNode, _lView) {
        this._tNode = _tNode;
        this._lView = _lView;
      }
      /**
       * @param {?} token
       * @param {?=} notFoundValue
       * @return {?}
       */


      get(token, notFoundValue) {
        return getOrCreateInjectable(this._tNode, this._lView, token, undefined, notFoundValue);
      }

    }

    if (false) {}
    /**
     * \@codeGenApi
     * @template T
     * @param {?} type
     * @return {?}
     */


    function ɵɵgetFactoryOf(type) {
      /** @type {?} */
      const typeAny =
      /** @type {?} */
      type;
      /** @type {?} */

      const def = getComponentDef(typeAny) || getDirectiveDef(typeAny) || getPipeDef(typeAny) || getInjectableDef(typeAny) || getInjectorDef(typeAny);

      if (!def || def.factory === undefined) {
        return null;
      }

      return def.factory;
    }
    /**
     * \@codeGenApi
     * @template T
     * @param {?} type
     * @return {?}
     */


    function ɵɵgetInheritedFactory(type) {
      /** @type {?} */
      const proto =
      /** @type {?} */
      Object.getPrototypeOf(type.prototype).constructor;
      /** @type {?} */

      const factory = ɵɵgetFactoryOf(proto);

      if (factory !== null) {
        return factory;
      } else {
        // There is no factory defined. Either this was improper usage of inheritance
        // (no Angular decorator on the superclass) or there is no constructor at all
        // in the inheritance chain. Since the two cases cannot be distinguished, the
        // latter has to be assumed.
        return (
          /**
          * @param {?} t
          * @return {?}
          */
          t => new t()
        );
      }
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    const ERROR_TYPE = 'ngType';
    const ERROR_DEBUG_CONTEXT = 'ngDebugContext';
    const ERROR_ORIGINAL_ERROR = 'ngOriginalError';
    const ERROR_LOGGER = 'ngErrorLogger';

    function wrappedError(message, originalError) {
      const msg = "".concat(message, " caused by: ").concat(originalError instanceof Error ? originalError.message : originalError);
      const error = Error(msg);
      error[ERROR_ORIGINAL_ERROR] = originalError;
      return error;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} error
     * @return {?}
     */


    function getType(error) {
      return (
        /** @type {?} */
        error[ERROR_TYPE]
      );
    }
    /**
     * @param {?} error
     * @return {?}
     */


    function getDebugContext(error) {
      return (
        /** @type {?} */
        error[ERROR_DEBUG_CONTEXT]
      );
    }
    /**
     * @param {?} error
     * @return {?}
     */


    function getOriginalError(error) {
      return (
        /** @type {?} */
        error[ERROR_ORIGINAL_ERROR]
      );
    }
    /**
     * @param {?} error
     * @return {?}
     */


    function getErrorLogger(error) {
      return (
        /** @type {?} */
        error[ERROR_LOGGER] || defaultErrorLogger
      );
    }
    /**
     * @param {?} console
     * @param {...?} values
     * @return {?}
     */


    function defaultErrorLogger(console, ...values) {
      /** @type {?} */
      console.error(...values);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Provides a hook for centralized exception handling.
     *
     * The default implementation of `ErrorHandler` prints error messages to the `console`. To
     * intercept error handling, write a custom exception handler that replaces this default as
     * appropriate for your app.
     *
     * \@usageNotes
     * ### Example
     *
     * ```
     * class MyErrorHandler implements ErrorHandler {
     *   handleError(error) {
     *     // do something with the exception
     *   }
     * }
     *
     * \@NgModule({
     *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]
     * })
     * class MyModule {}
     * ```
     *
     * \@publicApi
     */


    class ErrorHandler {
      constructor() {
        /**
         * \@internal
         */
        this._console = console;
      }
      /**
       * @param {?} error
       * @return {?}
       */


      handleError(error) {
        /** @type {?} */
        const originalError = this._findOriginalError(error);
        /** @type {?} */


        const context = this._findContext(error); // Note: Browser consoles show the place from where console.error was called.
        // We can use this to give users additional information about the error.

        /** @type {?} */


        const errorLogger = getErrorLogger(error);
        errorLogger(this._console, "ERROR", error);

        if (originalError) {
          errorLogger(this._console, "ORIGINAL ERROR", originalError);
        }

        if (context) {
          errorLogger(this._console, 'ERROR CONTEXT', context);
        }
      }
      /**
       * \@internal
       * @param {?} error
       * @return {?}
       */


      _findContext(error) {
        if (error) {
          return getDebugContext(error) ? getDebugContext(error) : this._findContext(getOriginalError(error));
        }

        return null;
      }
      /**
       * \@internal
       * @param {?} error
       * @return {?}
       */


      _findOriginalError(error) {
        /** @type {?} */
        let e = getOriginalError(error);

        while (e && getOriginalError(e)) {
          e = getOriginalError(e);
        }

        return e;
      }

    }

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * A schema definition associated with an NgModule.
     *
     * @see `\@NgModule`, `CUSTOM_ELEMENTS_SCHEMA`, `NO_ERRORS_SCHEMA`
     *
     * @param name The name of a defined schema.
     *
     * \@publicApi
     * @record
     */


    function SchemaMetadata() {}

    if (false) {}
    /**
     * Defines a schema that allows an NgModule to contain the following:
     * - Non-Angular elements named with dash case (`-`).
     * - Element properties named with dash case (`-`).
     * Dash case is the naming convention for custom elements.
     *
     * \@publicApi
     * @type {?}
     */


    const CUSTOM_ELEMENTS_SCHEMA = {
      name: 'custom-elements'
    };
    /**
     * Defines a schema that allows any property on any element.
     *
     * \@publicApi
     * @type {?}
     */

    const NO_ERRORS_SCHEMA = {
      name: 'no-errors-schema'
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /** @type {?} */

    const BRAND = '__SANITIZER_TRUSTED_BRAND__';
    /** @enum {string} */

    const BypassType = {
      Url: 'Url',
      Html: 'Html',
      ResourceUrl: 'ResourceUrl',
      Script: 'Script',
      Style: 'Style'
    };
    /**
     * A branded trusted string used with sanitization.
     *
     * See: {\@link TrustedHtmlString}, {\@link TrustedResourceUrlString}, {\@link TrustedScriptString},
     * {\@link TrustedStyleString}, {\@link TrustedUrlString}
     * @record
     */

    function TrustedString() {}

    if (false) {}
    /**
     * A branded trusted string used with sanitization of `html` strings.
     *
     * See: {\@link bypassSanitizationTrustHtml} and {\@link htmlSanitizer}.
     * @record
     */


    function TrustedHtmlString() {}

    if (false) {}
    /**
     * A branded trusted string used with sanitization of `style` strings.
     *
     * See: {\@link bypassSanitizationTrustStyle} and {\@link styleSanitizer}.
     * @record
     */


    function TrustedStyleString() {}

    if (false) {}
    /**
     * A branded trusted string used with sanitization of `url` strings.
     *
     * See: {\@link bypassSanitizationTrustScript} and {\@link scriptSanitizer}.
     * @record
     */


    function TrustedScriptString() {}

    if (false) {}
    /**
     * A branded trusted string used with sanitization of `url` strings.
     *
     * See: {\@link bypassSanitizationTrustUrl} and {\@link urlSanitizer}.
     * @record
     */


    function TrustedUrlString() {}

    if (false) {}
    /**
     * A branded trusted string used with sanitization of `resourceUrl` strings.
     *
     * See: {\@link bypassSanitizationTrustResourceUrl} and {\@link resourceUrlSanitizer}.
     * @record
     */


    function TrustedResourceUrlString() {}

    if (false) {}
    /**
     * @param {?} value
     * @param {?} type
     * @return {?}
     */


    function allowSanitizationBypass(value, type) {
      return value instanceof String &&
      /** @type {?} */
      value[BRAND] === type;
    }
    /**
     * Mark `html` string as trusted.
     *
     * This function wraps the trusted string in `String` and brands it in a way which makes it
     * recognizable to {\@link htmlSanitizer} to be trusted implicitly.
     *
     * @param {?} trustedHtml `html` string which needs to be implicitly trusted.
     * @return {?} a `html` `String` which has been branded to be implicitly trusted.
     */


    function bypassSanitizationTrustHtml(trustedHtml) {
      return bypassSanitizationTrustString(trustedHtml, "Html"
      /* Html */
      );
    }
    /**
     * Mark `style` string as trusted.
     *
     * This function wraps the trusted string in `String` and brands it in a way which makes it
     * recognizable to {\@link styleSanitizer} to be trusted implicitly.
     *
     * @param {?} trustedStyle `style` string which needs to be implicitly trusted.
     * @return {?} a `style` `String` which has been branded to be implicitly trusted.
     */


    function bypassSanitizationTrustStyle(trustedStyle) {
      return bypassSanitizationTrustString(trustedStyle, "Style"
      /* Style */
      );
    }
    /**
     * Mark `script` string as trusted.
     *
     * This function wraps the trusted string in `String` and brands it in a way which makes it
     * recognizable to {\@link scriptSanitizer} to be trusted implicitly.
     *
     * @param {?} trustedScript `script` string which needs to be implicitly trusted.
     * @return {?} a `script` `String` which has been branded to be implicitly trusted.
     */


    function bypassSanitizationTrustScript(trustedScript) {
      return bypassSanitizationTrustString(trustedScript, "Script"
      /* Script */
      );
    }
    /**
     * Mark `url` string as trusted.
     *
     * This function wraps the trusted string in `String` and brands it in a way which makes it
     * recognizable to {\@link urlSanitizer} to be trusted implicitly.
     *
     * @param {?} trustedUrl `url` string which needs to be implicitly trusted.
     * @return {?} a `url` `String` which has been branded to be implicitly trusted.
     */


    function bypassSanitizationTrustUrl(trustedUrl) {
      return bypassSanitizationTrustString(trustedUrl, "Url"
      /* Url */
      );
    }
    /**
     * Mark `url` string as trusted.
     *
     * This function wraps the trusted string in `String` and brands it in a way which makes it
     * recognizable to {\@link resourceUrlSanitizer} to be trusted implicitly.
     *
     * @param {?} trustedResourceUrl `url` string which needs to be implicitly trusted.
     * @return {?} a `url` `String` which has been branded to be implicitly trusted.
     */


    function bypassSanitizationTrustResourceUrl(trustedResourceUrl) {
      return bypassSanitizationTrustString(trustedResourceUrl, "ResourceUrl"
      /* ResourceUrl */
      );
    }
    /**
     * @param {?} trustedString
     * @param {?} mode
     * @return {?}
     */


    function bypassSanitizationTrustString(trustedString, mode) {
      // tslint:disable-next-line

      /** @type {?} */
      const trusted =
      /** @type {?} */
      new String(trustedString);
      trusted[BRAND] = mode;
      return trusted;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * This file is used to control if the default rendering pipeline should be `ViewEngine` or `Ivy`.
     *
     * For more information on how to run and debug tests with either Ivy or View Engine (legacy),
     * please see [BAZEL.md](./docs/BAZEL.md).
     */


    let _devMode = true;
    let _runModeLocked = false;
    /**
     * Returns whether Angular is in development mode. After called once,
     * the value is locked and won't change any more.
     *
     * By default, this is true, unless a user calls `enableProdMode` before calling this.
     *
     * @publicApi
     */

    function isDevMode() {
      _runModeLocked = true;
      return _devMode;
    }
    /**
     * Disable Angular's development mode, which turns off assertions and other
     * checks within the framework.
     *
     * One important assertion this disables verifies that a change detection pass
     * does not result in additional changes to any bindings (also known as
     * unidirectional data flow).
     *
     * @publicApi
     */


    function enableProdMode() {
      if (_runModeLocked) {
        throw new Error('Cannot enable prod mode after platform setup.');
      }

      _devMode = false;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * This helper class is used to get hold of an inert tree of DOM elements containing dirty HTML
     * that needs sanitizing.
     * Depending upon browser support we must use one of three strategies for doing this.
     * Support: Safari 10.x -> XHR strategy
     * Support: Firefox -> DomParser strategy
     * Default: InertDocument strategy
     */


    class InertBodyHelper {
      /**
       * @param {?} defaultDoc
       */
      constructor(defaultDoc) {
        this.defaultDoc = defaultDoc;
        this.inertDocument = this.defaultDoc.implementation.createHTMLDocument('sanitization-inert');
        this.inertBodyElement = this.inertDocument.body;

        if (this.inertBodyElement == null) {
          // usually there should be only one body element in the document, but IE doesn't have any, so
          // we need to create one.

          /** @type {?} */
          const inertHtml = this.inertDocument.createElement('html');
          this.inertDocument.appendChild(inertHtml);
          this.inertBodyElement = this.inertDocument.createElement('body');
          inertHtml.appendChild(this.inertBodyElement);
        }

        this.inertBodyElement.innerHTML = '<svg><g onload="this.parentNode.remove()"></g></svg>';

        if (this.inertBodyElement.querySelector && !this.inertBodyElement.querySelector('svg')) {
          // We just hit the Safari 10.1 bug - which allows JS to run inside the SVG G element
          // so use the XHR strategy.
          this.getInertBodyElement = this.getInertBodyElement_XHR;
          return;
        }

        this.inertBodyElement.innerHTML = '<svg><p><style><img src="</style><img src=x onerror=alert(1)//">';

        if (this.inertBodyElement.querySelector && this.inertBodyElement.querySelector('svg img')) {
          // We just hit the Firefox bug - which prevents the inner img JS from being sanitized
          // so use the DOMParser strategy, if it is available.
          // If the DOMParser is not available then we are not in Firefox (Server/WebWorker?) so we
          // fall through to the default strategy below.
          if (isDOMParserAvailable()) {
            this.getInertBodyElement = this.getInertBodyElement_DOMParser;
            return;
          }
        } // None of the bugs were hit so it is safe for us to use the default InertDocument strategy


        this.getInertBodyElement = this.getInertBodyElement_InertDocument;
      }
      /**
       * Use XHR to create and fill an inert body element (on Safari 10.1)
       * See
       * https://github.com/cure53/DOMPurify/blob/a992d3a75031cb8bb032e5ea8399ba972bdf9a65/src/purify.js#L439-L449
       * @private
       * @param {?} html
       * @return {?}
       */


      getInertBodyElement_XHR(html) {
        // We add these extra elements to ensure that the rest of the content is parsed as expected
        // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the
        // `<head>` tag.
        html = '<body><remove></remove>' + html + '</body>';

        try {
          html = encodeURI(html);
        } catch (_a) {
          return null;
        }
        /** @type {?} */


        const xhr = new XMLHttpRequest();
        xhr.responseType = 'document';
        xhr.open('GET', 'data:text/html;charset=utf-8,' + html, false);
        xhr.send(undefined);
        /** @type {?} */

        const body = xhr.response.body;
        body.removeChild(
        /** @type {?} */
        body.firstChild);
        return body;
      }
      /**
       * Use DOMParser to create and fill an inert body element (on Firefox)
       * See https://github.com/cure53/DOMPurify/releases/tag/0.6.7
       *
       * @private
       * @param {?} html
       * @return {?}
       */


      getInertBodyElement_DOMParser(html) {
        // We add these extra elements to ensure that the rest of the content is parsed as expected
        // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the
        // `<head>` tag.
        html = '<body><remove></remove>' + html + '</body>';

        try {
          /** @type {?} */
          const body =
          /** @type {?} */
          new
          /** @type {?} */
          window.DOMParser().parseFromString(html, 'text/html').body;
          body.removeChild(
          /** @type {?} */
          body.firstChild);
          return body;
        } catch (_a) {
          return null;
        }
      }
      /**
       * Use an HTML5 `template` element, if supported, or an inert body element created via
       * `createHtmlDocument` to create and fill an inert DOM element.
       * This is the default sane strategy to use if the browser does not require one of the specialised
       * strategies above.
       * @private
       * @param {?} html
       * @return {?}
       */


      getInertBodyElement_InertDocument(html) {
        // Prefer using <template> element if supported.

        /** @type {?} */
        const templateEl = this.inertDocument.createElement('template');

        if ('content' in templateEl) {
          templateEl.innerHTML = html;
          return templateEl;
        }

        this.inertBodyElement.innerHTML = html; // Support: IE 9-11 only
        // strip custom-namespaced attributes on IE<=11

        if (
        /** @type {?} */
        this.defaultDoc.documentMode) {
          this.stripCustomNsAttrs(this.inertBodyElement);
        }

        return this.inertBodyElement;
      }
      /**
       * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1'
       * attribute to declare ns1 namespace and prefixes the attribute with 'ns1' (e.g.
       * 'ns1:xlink:foo').
       *
       * This is undesirable since we don't want to allow any of these custom attributes. This method
       * strips them all.
       * @private
       * @param {?} el
       * @return {?}
       */


      stripCustomNsAttrs(el) {
        /** @type {?} */
        const elAttrs = el.attributes; // loop backwards so that we can support removals.

        for (let i = elAttrs.length - 1; 0 < i; i--) {
          /** @type {?} */
          const attrib = elAttrs.item(i);
          /** @type {?} */

          const attrName =
          /** @type {?} */
          attrib.name;

          if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {
            el.removeAttribute(attrName);
          }
        }
        /** @type {?} */


        let childNode =
        /** @type {?} */
        el.firstChild;

        while (childNode) {
          if (childNode.nodeType === Node.ELEMENT_NODE) this.stripCustomNsAttrs(
          /** @type {?} */
          childNode);
          childNode = childNode.nextSibling;
        }
      }

    }

    if (false) {}
    /**
     * We need to determine whether the DOMParser exists in the global context.
     * The try-catch is because, on some browsers, trying to access this property
     * on window can actually throw an error.
     *
     * @suppress {uselessCode}
     * @return {?}
     */


    function isDOMParserAvailable() {
      try {
        return !!
        /** @type {?} */
        window.DOMParser;
      } catch (_a) {
        return false;
      }
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * A pattern that recognizes a commonly useful subset of URLs that are safe.
     *
     * This regular expression matches a subset of URLs that will not cause script
     * execution if used in URL context within a HTML document. Specifically, this
     * regular expression matches if (comment from here on and regex copied from
     * Soy's EscapingConventions):
     * (1) Either an allowed protocol (http, https, mailto or ftp).
     * (2) or no protocol.  A protocol must be followed by a colon. The below
     *     allows that by allowing colons only after one of the characters [/?#].
     *     A colon after a hash (#) must be in the fragment.
     *     Otherwise, a colon after a (?) must be in a query.
     *     Otherwise, a colon after a single solidus (/) must be in a path.
     *     Otherwise, a colon after a double solidus (//) must be in the authority
     *     (before port).
     *
     * The pattern disallows &, used in HTML entity declarations before
     * one of the characters in [/?#]. This disallows HTML entities used in the
     * protocol name, which should never happen, e.g. "h&#116;tp" for "http".
     * It also disallows HTML entities in the first path part of a relative path,
     * e.g. "foo&lt;bar/baz".  Our existing escaping functions should not produce
     * that. More importantly, it disallows masking of a colon,
     * e.g. "javascript&#58;...".
     *
     * This regular expression was taken from the Closure sanitization library.
     * @type {?}
     */


    const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;
    /* A pattern that matches safe srcset values */

    /** @type {?} */

    const SAFE_SRCSET_PATTERN = /^(?:(?:https?|file):|[^&:/?#]*(?:[/?#]|$))/gi;
    /**
     * A pattern that matches safe data URLs. Only matches image, video and audio types.
     * @type {?}
     */

    const DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;
    /**
     * @param {?} url
     * @return {?}
     */

    function _sanitizeUrl(url) {
      url = String(url);
      if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN)) return url;

      if (isDevMode()) {
        console.warn("WARNING: sanitizing unsafe URL value ".concat(url, " (see http://g.co/ng/security#xss)"));
      }

      return 'unsafe:' + url;
    }
    /**
     * @param {?} srcset
     * @return {?}
     */


    function sanitizeSrcset(srcset) {
      srcset = String(srcset);
      return srcset.split(',').map(
      /**
      * @param {?} srcset
      * @return {?}
      */
      srcset => _sanitizeUrl(srcset.trim())).join(', ');
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} tags
     * @return {?}
     */


    function tagSet(tags) {
      /** @type {?} */
      const res = {};

      for (const t of tags.split(',')) res[t] = true;

      return res;
    }
    /**
     * @param {...?} sets
     * @return {?}
     */


    function merge(...sets) {
      /** @type {?} */
      const res = {};

      for (const s of sets) {
        for (const v in s) {
          if (s.hasOwnProperty(v)) res[v] = true;
        }
      }

      return res;
    } // Good source of info about elements and attributes
    // http://dev.w3.org/html5/spec/Overview.html#semantics
    // http://simon.html5.org/html-elements
    // Safe Void Elements - HTML5
    // http://dev.w3.org/html5/spec/Overview.html#void-elements

    /** @type {?} */


    const VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr'); // Elements that you can, intentionally, leave open (and which close themselves)
    // http://dev.w3.org/html5/spec/Overview.html#optional-tags

    /** @type {?} */

    const OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');
    /** @type {?} */

    const OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');
    /** @type {?} */

    const OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS); // Safe Block Elements - HTML5

    /** @type {?} */

    const BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet('address,article,' + 'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' + 'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul')); // Inline Elements - HTML5

    /** @type {?} */

    const INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet('a,abbr,acronym,audio,b,' + 'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' + 'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));
    /** @type {?} */

    const VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS); // Attributes that have href and hence need to be sanitized

    /** @type {?} */

    const URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href'); // Attributes that have special href set hence need to be sanitized

    /** @type {?} */

    const SRCSET_ATTRS = tagSet('srcset');
    /** @type {?} */

    const HTML_ATTRS = tagSet('abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' + 'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' + 'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' + 'scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,' + 'valign,value,vspace,width'); // Accessibility attributes as per WAI-ARIA 1.1 (W3C Working Draft 14 December 2018)

    /** @type {?} */

    const ARIA_ATTRS = tagSet('aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,' + 'aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,' + 'aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,' + 'aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,' + 'aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,' + 'aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,' + 'aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext'); // NB: This currently consciously doesn't support SVG. SVG sanitization has had several security
    // issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via
    // innerHTML is required, SVG attributes should be added here.
    // NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those
    // can be sanitized, but they increase security surface area without a legitimate use case, so they
    // are left out here.

    /** @type {?} */

    const VALID_ATTRS = merge(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS, ARIA_ATTRS); // Elements whose content should not be traversed/preserved, if the elements themselves are invalid.
    //
    // Typically, `<invalid>Some content</invalid>` would traverse (and in this case preserve)
    // `Some content`, but strip `invalid-element` opening/closing tags. For some elements, though, we
    // don't want to preserve the content, if the elements themselves are going to be removed.

    /** @type {?} */

    const SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet('script,style,template');
    /**
     * SanitizingHtmlSerializer serializes a DOM fragment, stripping out any unsafe elements and unsafe
     * attributes.
     */

    class SanitizingHtmlSerializer {
      constructor() {
        // Explicitly track if something was stripped, to avoid accidentally warning of sanitization just
        // because characters were re-encoded.
        this.sanitizedSomething = false;
        this.buf = [];
      }
      /**
       * @param {?} el
       * @return {?}
       */


      sanitizeChildren(el) {
        // This cannot use a TreeWalker, as it has to run on Angular's various DOM adapters.
        // However this code never accesses properties off of `document` before deleting its contents
        // again, so it shouldn't be vulnerable to DOM clobbering.

        /** @type {?} */
        let current =
        /** @type {?} */
        el.firstChild;
        /** @type {?} */

        let traverseContent = true;

        while (current) {
          if (current.nodeType === Node.ELEMENT_NODE) {
            traverseContent = this.startElement(
            /** @type {?} */
            current);
          } else if (current.nodeType === Node.TEXT_NODE) {
            this.chars(
            /** @type {?} */
            current.nodeValue);
          } else {
            // Strip non-element, non-text nodes.
            this.sanitizedSomething = true;
          }

          if (traverseContent && current.firstChild) {
            current =
            /** @type {?} */
            current.firstChild;
            continue;
          }

          while (current) {
            // Leaving the element. Walk up and to the right, closing tags as we go.
            if (current.nodeType === Node.ELEMENT_NODE) {
              this.endElement(
              /** @type {?} */
              current);
            }
            /** @type {?} */


            let next = this.checkClobberedElement(current,
            /** @type {?} */
            current.nextSibling);

            if (next) {
              current = next;
              break;
            }

            current = this.checkClobberedElement(current,
            /** @type {?} */
            current.parentNode);
          }
        }

        return this.buf.join('');
      }
      /**
       * Sanitizes an opening element tag (if valid) and returns whether the element's contents should
       * be traversed. Element content must always be traversed (even if the element itself is not
       * valid/safe), unless the element is one of `SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS`.
       *
       * @private
       * @param {?} element The element to sanitize.
       * @return {?} True if the element's contents should be traversed.
       */


      startElement(element) {
        /** @type {?} */
        const tagName = element.nodeName.toLowerCase();

        if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
          this.sanitizedSomething = true;
          return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);
        }

        this.buf.push('<');
        this.buf.push(tagName);
        /** @type {?} */

        const elAttrs = element.attributes;

        for (let i = 0; i < elAttrs.length; i++) {
          /** @type {?} */
          const elAttr = elAttrs.item(i);
          /** @type {?} */

          const attrName =
          /** @type {?} */
          elAttr.name;
          /** @type {?} */

          const lower = attrName.toLowerCase();

          if (!VALID_ATTRS.hasOwnProperty(lower)) {
            this.sanitizedSomething = true;
            continue;
          }
          /** @type {?} */


          let value =
          /** @type {?} */
          elAttr.value; // TODO(martinprobst): Special case image URIs for data:image/...

          if (URI_ATTRS[lower]) value = _sanitizeUrl(value);
          if (SRCSET_ATTRS[lower]) value = sanitizeSrcset(value);
          this.buf.push(' ', attrName, '="', encodeEntities(value), '"');
        }

        this.buf.push('>');
        return true;
      }
      /**
       * @private
       * @param {?} current
       * @return {?}
       */


      endElement(current) {
        /** @type {?} */
        const tagName = current.nodeName.toLowerCase();

        if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {
          this.buf.push('</');
          this.buf.push(tagName);
          this.buf.push('>');
        }
      }
      /**
       * @private
       * @param {?} chars
       * @return {?}
       */


      chars(chars) {
        this.buf.push(encodeEntities(chars));
      }
      /**
       * @param {?} node
       * @param {?} nextNode
       * @return {?}
       */


      checkClobberedElement(node, nextNode) {
        if (nextNode && (node.compareDocumentPosition(nextNode) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) {
          throw new Error("Failed to sanitize html because the element is clobbered: ".concat(
          /** @type {?} */
          node.outerHTML));
        }

        return nextNode;
      }

    }

    if (false) {} // Regular Expressions for parsing tags and attributes

    /** @type {?} */


    const SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g; // ! to ~ is the ASCII range.

    /** @type {?} */

    const NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;
    /**
     * Escapes all potentially dangerous characters, so that the
     * resulting string can be safely inserted into attribute or
     * element text.
     * @param {?} value
     * @return {?}
     */

    function encodeEntities(value) {
      return value.replace(/&/g, '&amp;').replace(SURROGATE_PAIR_REGEXP,
      /**
      * @param {?} match
      * @return {?}
      */
      function (match) {
        /** @type {?} */
        const hi = match.charCodeAt(0);
        /** @type {?} */

        const low = match.charCodeAt(1);
        return '&#' + ((hi - 0xD800) * 0x400 + (low - 0xDC00) + 0x10000) + ';';
      }).replace(NON_ALPHANUMERIC_REGEXP,
      /**
      * @param {?} match
      * @return {?}
      */
      function (match) {
        return '&#' + match.charCodeAt(0) + ';';
      }).replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }
    /** @type {?} */


    let inertBodyHelper;
    /**
     * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to
     * the DOM in a browser environment.
     * @param {?} defaultDoc
     * @param {?} unsafeHtmlInput
     * @return {?}
     */

    function _sanitizeHtml(defaultDoc, unsafeHtmlInput) {
      /** @type {?} */
      let inertBodyElement = null;

      try {
        inertBodyHelper = inertBodyHelper || new InertBodyHelper(defaultDoc); // Make sure unsafeHtml is actually a string (TypeScript types are not enforced at runtime).

        /** @type {?} */

        let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';
        inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml); // mXSS protection. Repeatedly parse the document to make sure it stabilizes, so that a browser
        // trying to auto-correct incorrect HTML cannot cause formerly inert HTML to become dangerous.

        /** @type {?} */

        let mXSSAttempts = 5;
        /** @type {?} */

        let parsedHtml = unsafeHtml;

        do {
          if (mXSSAttempts === 0) {
            throw new Error('Failed to sanitize html because the input is unstable');
          }

          mXSSAttempts--;
          unsafeHtml = parsedHtml;
          parsedHtml =
          /** @type {?} */
          inertBodyElement.innerHTML;
          inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
        } while (unsafeHtml !== parsedHtml);
        /** @type {?} */


        const sanitizer = new SanitizingHtmlSerializer();
        /** @type {?} */

        const safeHtml = sanitizer.sanitizeChildren(
        /** @type {?} */
        getTemplateContent(
        /** @type {?} */
        inertBodyElement) || inertBodyElement);

        if (isDevMode() && sanitizer.sanitizedSomething) {
          console.warn('WARNING: sanitizing HTML stripped some content, see http://g.co/ng/security#xss');
        }

        return safeHtml;
      } finally {
        // In case anything goes wrong, clear out inertElement to reset the entire DOM structure.
        if (inertBodyElement) {
          /** @type {?} */
          const parent = getTemplateContent(inertBodyElement) || inertBodyElement;

          while (parent.firstChild) {
            parent.removeChild(parent.firstChild);
          }
        }
      }
    }
    /**
     * @param {?} el
     * @return {?}
     */


    function getTemplateContent(el) {
      return 'content' in
      /** @type {?} */
      el && isTemplateElement(el) ? el.content : null;
    }
    /**
     * @param {?} el
     * @return {?}
     */


    function isTemplateElement(el) {
      return el.nodeType === Node.ELEMENT_NODE && el.nodeName === 'TEMPLATE';
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /** @enum {number} */


    const SecurityContext = {
      NONE: 0,
      HTML: 1,
      STYLE: 2,
      SCRIPT: 3,
      URL: 4,
      RESOURCE_URL: 5
    };
    SecurityContext[SecurityContext.NONE] = 'NONE';
    SecurityContext[SecurityContext.HTML] = 'HTML';
    SecurityContext[SecurityContext.STYLE] = 'STYLE';
    SecurityContext[SecurityContext.SCRIPT] = 'SCRIPT';
    SecurityContext[SecurityContext.URL] = 'URL';
    SecurityContext[SecurityContext.RESOURCE_URL] = 'RESOURCE_URL';
    /**
     * Sanitizer is used by the views to sanitize potentially dangerous values.
     *
     * \@publicApi
     * @abstract
     */

    class Sanitizer {}

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Regular expression for safe style values.
     *
     * Quotes (" and ') are allowed, but a check must be done elsewhere to ensure they're balanced.
     *
     * ',' allows multiple values to be assigned to the same property (e.g. background-attachment or
     * font-family) and hence could allow multiple values to get injected, but that should pose no risk
     * of XSS.
     *
     * The function expression checks only for XSS safety, not for CSS validity.
     *
     * This regular expression was taken from the Closure sanitization library, and augmented for
     * transformation values.
     * @type {?}
     */


    const VALUES = '[-,."\'%_!# a-zA-Z0-9]+';
    /** @type {?} */

    const TRANSFORMATION_FNS = '(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|Z|3d)?';
    /** @type {?} */

    const COLOR_FNS = '(?:rgb|hsl)a?';
    /** @type {?} */

    const GRADIENTS = '(?:repeating-)?(?:linear|radial)-gradient';
    /** @type {?} */

    const CSS3_FNS = '(?:calc|attr)';
    /** @type {?} */

    const FN_ARGS = '\\([-0-9.%, #a-zA-Z]+\\)';
    /** @type {?} */

    const SAFE_STYLE_VALUE = new RegExp("^(".concat(VALUES, "|") + "(?:".concat(TRANSFORMATION_FNS, "|").concat(COLOR_FNS, "|").concat(GRADIENTS, "|").concat(CSS3_FNS, ")") + "".concat(FN_ARGS, ")$"), 'g');
    /**
     * Matches a `url(...)` value with an arbitrary argument as long as it does
     * not contain parentheses.
     *
     * The URL value still needs to be sanitized separately.
     *
     * `url(...)` values are a very common use case, e.g. for `background-image`. With carefully crafted
     * CSS style rules, it is possible to construct an information leak with `url` values in CSS, e.g.
     * by observing whether scroll bars are displayed, or character ranges used by a font face
     * definition.
     *
     * Angular only allows binding CSS values (as opposed to entire CSS rules), so it is unlikely that
     * binding a URL value without further cooperation from the page will cause an information leak, and
     * if so, it is just a leak, not a full blown XSS vulnerability.
     *
     * Given the common use case, low likelihood of attack vector, and low impact of an attack, this
     * code is permissive and allows URLs that sanitize otherwise.
     * @type {?}
     */

    const URL_RE = /^url\(([^)]+)\)$/;
    /**
     * Checks that quotes (" and ') are properly balanced inside a string. Assumes
     * that neither escape (\) nor any other character that could result in
     * breaking out of a string parsing context are allowed;
     * see http://www.w3.org/TR/css3-syntax/#string-token-diagram.
     *
     * This code was taken from the Closure sanitization library.
     * @param {?} value
     * @return {?}
     */

    function hasBalancedQuotes(value) {
      /** @type {?} */
      let outsideSingle = true;
      /** @type {?} */

      let outsideDouble = true;

      for (let i = 0; i < value.length; i++) {
        /** @type {?} */
        const c = value.charAt(i);

        if (c === '\'' && outsideDouble) {
          outsideSingle = !outsideSingle;
        } else if (c === '"' && outsideSingle) {
          outsideDouble = !outsideDouble;
        }
      }

      return outsideSingle && outsideDouble;
    }
    /**
     * Sanitizes the given untrusted CSS style property value (i.e. not an entire object, just a single
     * value) and returns a value that is safe to use in a browser environment.
     * @param {?} value
     * @return {?}
     */


    function _sanitizeStyle(value) {
      value = String(value).trim(); // Make sure it's actually a string.

      if (!value) return ''; // Single url(...) values are supported, but only for URLs that sanitize cleanly. See above for
      // reasoning behind this.

      /** @type {?} */

      const urlMatch = value.match(URL_RE);

      if (urlMatch && _sanitizeUrl(urlMatch[1]) === urlMatch[1] || value.match(SAFE_STYLE_VALUE) && hasBalancedQuotes(value)) {
        return value; // Safe style values.
      }

      if (isDevMode()) {
        console.warn("WARNING: sanitizing unsafe style value ".concat(value, " (see http://g.co/ng/security#xss)."));
      }

      return 'unsafe';
    }
    /** @enum {number} */


    const StyleSanitizeMode = {
      /** Just check to see if the property is required to be sanitized or not */
      ValidateProperty: 1,

      /** Skip checking the property; just sanitize the value */
      SanitizeOnly: 2,

      /** Check the property and (if true) then sanitize the value */
      ValidateAndSanitize: 3
    };
    /**
     * Used to intercept and sanitize style values before they are written to the renderer.
     *
     * This function is designed to be called in two modes. When a value is not provided
     * then the function will return a boolean whether a property will be sanitized later.
     * If a value is provided then the sanitized version of that will be returned.
     * @record
     */

    function StyleSanitizeFn() {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * An `html` sanitizer which converts untrusted `html` **string** into trusted string by removing
     * dangerous content.
     *
     * This method parses the `html` and locates potentially dangerous content (such as urls and
     * javascript) and removes it.
     *
     * It is possible to mark a string as trusted by calling {\@link bypassSanitizationTrustHtml}.
     *
     * \@publicApi
     * @param {?} unsafeHtml untrusted `html`, typically from the user.
     * @return {?} `html` string which is safe to display to user, because all of the dangerous javascript
     * and urls have been removed.
     *
     */


    function ɵɵsanitizeHtml(unsafeHtml) {
      /** @type {?} */
      const sanitizer = getSanitizer();

      if (sanitizer) {
        return sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || '';
      }

      if (allowSanitizationBypass(unsafeHtml, "Html"
      /* Html */
      )) {
        return unsafeHtml.toString();
      }

      return _sanitizeHtml(document, renderStringify(unsafeHtml));
    }
    /**
     * A `style` sanitizer which converts untrusted `style` **string** into trusted string by removing
     * dangerous content.
     *
     * This method parses the `style` and locates potentially dangerous content (such as urls and
     * javascript) and removes it.
     *
     * It is possible to mark a string as trusted by calling {\@link bypassSanitizationTrustStyle}.
     *
     * \@publicApi
     * @param {?} unsafeStyle untrusted `style`, typically from the user.
     * @return {?} `style` string which is safe to bind to the `style` properties, because all of the
     * dangerous javascript and urls have been removed.
     *
     */


    function ɵɵsanitizeStyle(unsafeStyle) {
      /** @type {?} */
      const sanitizer = getSanitizer();

      if (sanitizer) {
        return sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || '';
      }

      if (allowSanitizationBypass(unsafeStyle, "Style"
      /* Style */
      )) {
        return unsafeStyle.toString();
      }

      return _sanitizeStyle(renderStringify(unsafeStyle));
    }
    /**
     * A `url` sanitizer which converts untrusted `url` **string** into trusted string by removing
     * dangerous
     * content.
     *
     * This method parses the `url` and locates potentially dangerous content (such as javascript) and
     * removes it.
     *
     * It is possible to mark a string as trusted by calling {\@link bypassSanitizationTrustUrl}.
     *
     * \@publicApi
     * @param {?} unsafeUrl untrusted `url`, typically from the user.
     * @return {?} `url` string which is safe to bind to the `src` properties such as `<img src>`, because
     * all of the dangerous javascript has been removed.
     *
     */


    function ɵɵsanitizeUrl(unsafeUrl) {
      /** @type {?} */
      const sanitizer = getSanitizer();

      if (sanitizer) {
        return sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || '';
      }

      if (allowSanitizationBypass(unsafeUrl, "Url"
      /* Url */
      )) {
        return unsafeUrl.toString();
      }

      return _sanitizeUrl(renderStringify(unsafeUrl));
    }
    /**
     * A `url` sanitizer which only lets trusted `url`s through.
     *
     * This passes only `url`s marked trusted by calling {\@link bypassSanitizationTrustResourceUrl}.
     *
     * \@publicApi
     * @param {?} unsafeResourceUrl untrusted `url`, typically from the user.
     * @return {?} `url` string which is safe to bind to the `src` properties such as `<img src>`, because
     * only trusted `url`s have been allowed to pass.
     *
     */


    function ɵɵsanitizeResourceUrl(unsafeResourceUrl) {
      /** @type {?} */
      const sanitizer = getSanitizer();

      if (sanitizer) {
        return sanitizer.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || '';
      }

      if (allowSanitizationBypass(unsafeResourceUrl, "ResourceUrl"
      /* ResourceUrl */
      )) {
        return unsafeResourceUrl.toString();
      }

      throw new Error('unsafe value used in a resource URL context (see http://g.co/ng/security#xss)');
    }
    /**
     * A `script` sanitizer which only lets trusted javascript through.
     *
     * This passes only `script`s marked trusted by calling {\@link
     * bypassSanitizationTrustScript}.
     *
     * \@publicApi
     * @param {?} unsafeScript untrusted `script`, typically from the user.
     * @return {?} `url` string which is safe to bind to the `<script>` element such as `<img src>`,
     * because only trusted `scripts` have been allowed to pass.
     *
     */


    function ɵɵsanitizeScript(unsafeScript) {
      /** @type {?} */
      const sanitizer = getSanitizer();

      if (sanitizer) {
        return sanitizer.sanitize(SecurityContext.SCRIPT, unsafeScript) || '';
      }

      if (allowSanitizationBypass(unsafeScript, "Script"
      /* Script */
      )) {
        return unsafeScript.toString();
      }

      throw new Error('unsafe value used in a script context');
    }
    /**
     * Detects which sanitizer to use for URL property, based on tag name and prop name.
     *
     * The rules are based on the RESOURCE_URL context config from
     * `packages/compiler/src/schema/dom_security_schema.ts`.
     * If tag and prop names don't match Resource URL schema, use URL sanitizer.
     * @param {?} tag
     * @param {?} prop
     * @return {?}
     */


    function getUrlSanitizer(tag, prop) {
      if (prop === 'src' && (tag === 'embed' || tag === 'frame' || tag === 'iframe' || tag === 'media' || tag === 'script') || prop === 'href' && (tag === 'base' || tag === 'link')) {
        return ɵɵsanitizeResourceUrl;
      }

      return ɵɵsanitizeUrl;
    }
    /**
     * Sanitizes URL, selecting sanitizer function based on tag and property names.
     *
     * This function is used in case we can't define security context at compile time, when only prop
     * name is available. This happens when we generate host bindings for Directives/Components. The
     * host element is unknown at compile time, so we defer calculation of specific sanitizer to
     * runtime.
     *
     * \@publicApi
     * @param {?} unsafeUrl untrusted `url`, typically from the user.
     * @param {?} tag target element tag name.
     * @param {?} prop name of the property that contains the value.
     * @return {?} `url` string which is safe to bind.
     *
     */


    function ɵɵsanitizeUrlOrResourceUrl(unsafeUrl, tag, prop) {
      return getUrlSanitizer(tag, prop)(unsafeUrl);
    }
    /**
     * The default style sanitizer will handle sanitization for style properties by
     * sanitizing any CSS property that can include a `url` value (usually image-based properties)
     *
     * \@publicApi
     * @type {?}
     */


    const ɵɵdefaultStyleSanitizer =
    /** @type {?} */

    /**
    * @param {?} prop
    * @param {?} value
    * @param {?=} mode
    * @return {?}
    */
    function ɵɵdefaultStyleSanitizer(prop, value, mode) {
      mode = mode || 3
      /* ValidateAndSanitize */
      ;
      /** @type {?} */

      let doSanitizeValue = true;

      if (mode & 1
      /* ValidateProperty */
      ) {
          doSanitizeValue = prop === 'background-image' || prop === 'background' || prop === 'border-image' || prop === 'filter' || prop === 'list-style' || prop === 'list-style-image' || prop === 'clip-path';
        }

      if (mode & 2
      /* SanitizeOnly */
      ) {
          return doSanitizeValue ? ɵɵsanitizeStyle(value) : value;
        } else {
        return doSanitizeValue;
      }
    };
    /**
     * @param {?} name
     * @return {?}
     */


    function validateAgainstEventProperties(name) {
      if (name.toLowerCase().startsWith('on')) {
        /** @type {?} */
        const msg = "Binding to event property '".concat(name, "' is disallowed for security reasons, ") + "please use (".concat(name.slice(2), ")=...") + "\nIf '".concat(name, "' is a directive input, make sure the directive is imported by the") + " current module.";
        throw new Error(msg);
      }
    }
    /**
     * @param {?} name
     * @return {?}
     */


    function validateAgainstEventAttributes(name) {
      if (name.toLowerCase().startsWith('on')) {
        /** @type {?} */
        const msg = "Binding to event attribute '".concat(name, "' is disallowed for security reasons, ") + "please use (".concat(name.slice(2), ")=...");
        throw new Error(msg);
      }
    }
    /**
     * @return {?}
     */


    function getSanitizer() {
      /** @type {?} */
      const lView = getLView();
      return lView && lView[SANITIZER];
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * THIS FILE CONTAINS CODE WHICH SHOULD BE TREE SHAKEN AND NEVER CALLED FROM PRODUCTION CODE!!!
     */

    /**
     * Creates an `Array` construction with a given name. This is useful when
     * looking for memory consumption to see what time of array it is.
     *
     *
     * @param name Name to give to the constructor
     * @returns A subclass of `Array` if possible. This can only be done in
     *          environments which support `class` construct.
     */


    function createNamedArrayType(name) {
      // This should never be called in prod mode, so let's verify that is the case.
      if (ngDevMode) {
        try {
          // We need to do it this way so that TypeScript does not down-level the below code.
          const FunctionConstructor = createNamedArrayType.constructor;
          return new FunctionConstructor('Array', "return class ABC extends Array{}")(Array);
        } catch (e) {
          // If it does not work just give up and fall back to regular Array.
          return Array;
        }
      } else {
        throw new Error('Looks like we are in \'prod mode\', but we are creating a named Array type, which is wrong! Check your code');
      }
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    function normalizeDebugBindingName(name) {
      // Attribute names with `$` (eg `x-y$`) are valid per spec, but unsupported by some browsers
      name = camelCaseToDashCase(name.replace(/[$@]/g, '_'));
      return "ng-reflect-".concat(name);
    }

    const CAMEL_CASE_REGEXP = /([A-Z])/g;

    function camelCaseToDashCase(input) {
      return input.replace(CAMEL_CASE_REGEXP, (...m) => '-' + m[1].toLowerCase());
    }

    function normalizeDebugBindingValue(value) {
      try {
        // Limit the size of the value as otherwise the DOM just gets polluted.
        return value != null ? value.toString().slice(0, 30) : value;
      } catch (e) {
        return '[ERROR] Exception while trying to serialize the value';
      }
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Returns the matching `LContext` data for a given DOM node, directive or component instance.
     *
     * This function will examine the provided DOM element, component, or directive instance\'s
     * monkey-patched property to derive the `LContext` data. Once called then the monkey-patched
     * value will be that of the newly created `LContext`.
     *
     * If the monkey-patched value is the `LView` instance then the context value for that
     * target will be created and the monkey-patch reference will be updated. Therefore when this
     * function is called it may mutate the provided element\'s, component\'s or any of the associated
     * directive\'s monkey-patch values.
     *
     * If the monkey-patch value is not detected then the code will walk up the DOM until an element
     * is found which contains a monkey-patch reference. When that occurs then the provided element
     * will be updated with a new context (which is then returned). If the monkey-patch value is not
     * detected for a component/directive instance then it will throw an error (all components and
     * directives should be automatically monkey-patched by ivy).
     *
     * @param {?} target Component, Directive or DOM Node.
     * @return {?}
     */


    function getLContext(target) {
      /** @type {?} */
      let mpValue = readPatchedData(target);

      if (mpValue) {
        // only when it's an array is it considered an LView instance
        // ... otherwise it's an already constructed LContext instance
        if (Array.isArray(mpValue)) {
          /** @type {?} */
          const lView =
          /** @type {?} */
          mpValue;
          /** @type {?} */

          let nodeIndex;
          /** @type {?} */

          let component = undefined;
          /** @type {?} */

          let directives = undefined;

          if (isComponentInstance(target)) {
            nodeIndex = findViaComponent(lView, target);

            if (nodeIndex == -1) {
              throw new Error('The provided component was not found in the application');
            }

            component = target;
          } else if (isDirectiveInstance(target)) {
            nodeIndex = findViaDirective(lView, target);

            if (nodeIndex == -1) {
              throw new Error('The provided directive was not found in the application');
            }

            directives = getDirectivesAtNodeIndex(nodeIndex, lView, false);
          } else {
            nodeIndex = findViaNativeElement(lView,
            /** @type {?} */
            target);

            if (nodeIndex == -1) {
              return null;
            }
          } // the goal is not to fill the entire context full of data because the lookups
          // are expensive. Instead, only the target data (the element, component, container, ICU
          // expression or directive details) are filled into the context. If called multiple times
          // with different target values then the missing target data will be filled in.

          /** @type {?} */


          const native = unwrapRNode(lView[nodeIndex]);
          /** @type {?} */

          const existingCtx = readPatchedData(native);
          /** @type {?} */

          const context = existingCtx && !Array.isArray(existingCtx) ? existingCtx : createLContext(lView, nodeIndex, native); // only when the component has been discovered then update the monkey-patch

          if (component && context.component === undefined) {
            context.component = component;
            attachPatchData(context.component, context);
          } // only when the directives have been discovered then update the monkey-patch


          if (directives && context.directives === undefined) {
            context.directives = directives;

            for (let i = 0; i < directives.length; i++) {
              attachPatchData(directives[i], context);
            }
          }

          attachPatchData(context.native, context);
          mpValue = context;
        }
      } else {
        /** @type {?} */
        const rElement =
        /** @type {?} */
        target;
        ngDevMode && assertDomNode(rElement); // if the context is not found then we need to traverse upwards up the DOM
        // to find the nearest element that has already been monkey patched with data

        /** @type {?} */

        let parent =
        /** @type {?} */
        rElement;

        while (parent = parent.parentNode) {
          /** @type {?} */
          const parentContext = readPatchedData(parent);

          if (parentContext) {
            /** @type {?} */
            let lView;

            if (Array.isArray(parentContext)) {
              lView =
              /** @type {?} */
              parentContext;
            } else {
              lView = parentContext.lView;
            } // the edge of the app was also reached here through another means
            // (maybe because the DOM was changed manually).


            if (!lView) {
              return null;
            }
            /** @type {?} */


            const index = findViaNativeElement(lView, rElement);

            if (index >= 0) {
              /** @type {?} */
              const native = unwrapRNode(lView[index]);
              /** @type {?} */

              const context = createLContext(lView, index, native);
              attachPatchData(native, context);
              mpValue = context;
              break;
            }
          }
        }
      }

      return (
        /** @type {?} */
        mpValue || null
      );
    }
    /**
     * Creates an empty instance of a `LContext` context
     * @param {?} lView
     * @param {?} nodeIndex
     * @param {?} native
     * @return {?}
     */


    function createLContext(lView, nodeIndex, native) {
      return {
        lView,
        nodeIndex,
        native,
        component: undefined,
        directives: undefined,
        localRefs: undefined
      };
    }
    /**
     * Takes a component instance and returns the view for that component.
     *
     * @param {?} componentInstance
     * @return {?} The component's view
     */


    function getComponentViewByInstance(componentInstance) {
      /** @type {?} */
      let lView = readPatchedData(componentInstance);
      /** @type {?} */

      let view;

      if (Array.isArray(lView)) {
        /** @type {?} */
        const nodeIndex = findViaComponent(lView, componentInstance);
        view = getComponentViewByIndex(nodeIndex, lView);
        /** @type {?} */

        const context = createLContext(lView, nodeIndex,
        /** @type {?} */
        view[HOST]);
        context.component = componentInstance;
        attachPatchData(componentInstance, context);
        attachPatchData(context.native, context);
      } else {
        /** @type {?} */
        const context =
        /** @type {?} */

        /** @type {?} */
        lView;
        view = getComponentViewByIndex(context.nodeIndex, context.lView);
      }

      return view;
    }
    /**
     * Assigns the given data to the given target (which could be a component,
     * directive or DOM node instance) using monkey-patching.
     * @param {?} target
     * @param {?} data
     * @return {?}
     */


    function attachPatchData(target, data) {
      target[MONKEY_PATCH_KEY_NAME] = data;
    }
    /**
     * @param {?} instance
     * @return {?}
     */


    function isComponentInstance(instance) {
      return instance && instance.constructor && instance.constructor.ngComponentDef;
    }
    /**
     * @param {?} instance
     * @return {?}
     */


    function isDirectiveInstance(instance) {
      return instance && instance.constructor && instance.constructor.ngDirectiveDef;
    }
    /**
     * Locates the element within the given LView and returns the matching index
     * @param {?} lView
     * @param {?} target
     * @return {?}
     */


    function findViaNativeElement(lView, target) {
      /** @type {?} */
      let tNode = lView[TVIEW].firstChild;

      while (tNode) {
        /** @type {?} */
        const native =
        /** @type {?} */
        getNativeByTNodeOrNull(tNode, lView);

        if (native === target) {
          return tNode.index;
        }

        tNode = traverseNextElement(tNode);
      }

      return -1;
    }
    /**
     * Locates the next tNode (child, sibling or parent).
     * @param {?} tNode
     * @return {?}
     */


    function traverseNextElement(tNode) {
      if (tNode.child) {
        return tNode.child;
      } else if (tNode.next) {
        return tNode.next;
      } else {
        // Let's take the following template: <div><span>text</span></div><component/>
        // After checking the text node, we need to find the next parent that has a "next" TNode,
        // in this case the parent `div`, so that we can find the component.
        while (tNode.parent && !tNode.parent.next) {
          tNode = tNode.parent;
        }

        return tNode.parent && tNode.parent.next;
      }
    }
    /**
     * Locates the component within the given LView and returns the matching index
     * @param {?} lView
     * @param {?} componentInstance
     * @return {?}
     */


    function findViaComponent(lView, componentInstance) {
      /** @type {?} */
      const componentIndices = lView[TVIEW].components;

      if (componentIndices) {
        for (let i = 0; i < componentIndices.length; i++) {
          /** @type {?} */
          const elementComponentIndex = componentIndices[i];
          /** @type {?} */

          const componentView = getComponentViewByIndex(elementComponentIndex, lView);

          if (componentView[CONTEXT] === componentInstance) {
            return elementComponentIndex;
          }
        }
      } else {
        /** @type {?} */
        const rootComponentView = getComponentViewByIndex(HEADER_OFFSET, lView);
        /** @type {?} */

        const rootComponent = rootComponentView[CONTEXT];

        if (rootComponent === componentInstance) {
          // we are dealing with the root element here therefore we know that the
          // element is the very first element after the HEADER data in the lView
          return HEADER_OFFSET;
        }
      }

      return -1;
    }
    /**
     * Locates the directive within the given LView and returns the matching index
     * @param {?} lView
     * @param {?} directiveInstance
     * @return {?}
     */


    function findViaDirective(lView, directiveInstance) {
      // if a directive is monkey patched then it will (by default)
      // have a reference to the LView of the current view. The
      // element bound to the directive being search lives somewhere
      // in the view data. We loop through the nodes and check their
      // list of directives for the instance.

      /** @type {?} */
      let tNode = lView[TVIEW].firstChild;

      while (tNode) {
        /** @type {?} */
        const directiveIndexStart = tNode.directiveStart;
        /** @type {?} */

        const directiveIndexEnd = tNode.directiveEnd;

        for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {
          if (lView[i] === directiveInstance) {
            return tNode.index;
          }
        }

        tNode = traverseNextElement(tNode);
      }

      return -1;
    }
    /**
     * Returns a list of directives extracted from the given view based on the
     * provided list of directive index values.
     *
     * @param {?} nodeIndex The node index
     * @param {?} lView The target view data
     * @param {?} includeComponents Whether or not to include components in returned directives
     * @return {?}
     */


    function getDirectivesAtNodeIndex(nodeIndex, lView, includeComponents) {
      /** @type {?} */
      const tNode =
      /** @type {?} */
      lView[TVIEW].data[nodeIndex];
      /** @type {?} */

      let directiveStartIndex = tNode.directiveStart;
      if (directiveStartIndex == 0) return EMPTY_ARRAY;
      /** @type {?} */

      const directiveEndIndex = tNode.directiveEnd;
      if (!includeComponents && tNode.flags & 1
      /* isComponent */
      ) directiveStartIndex++;
      return lView.slice(directiveStartIndex, directiveEndIndex);
    }
    /**
     * @param {?} nodeIndex
     * @param {?} lView
     * @return {?}
     */


    function getComponentAtNodeIndex(nodeIndex, lView) {
      /** @type {?} */
      const tNode =
      /** @type {?} */
      lView[TVIEW].data[nodeIndex];
      /** @type {?} */

      let directiveStartIndex = tNode.directiveStart;
      return tNode.flags & 1
      /* isComponent */
      ? lView[directiveStartIndex] : null;
    }
    /**
     * Returns a map of local references (local reference name => element or directive instance) that
     * exist on a given element.
     * @param {?} lView
     * @param {?} nodeIndex
     * @return {?}
     */


    function discoverLocalRefs(lView, nodeIndex) {
      /** @type {?} */
      const tNode =
      /** @type {?} */
      lView[TVIEW].data[nodeIndex];

      if (tNode && tNode.localNames) {
        /** @type {?} */
        const result = {};
        /** @type {?} */

        let localIndex = tNode.index + 1;

        for (let i = 0; i < tNode.localNames.length; i += 2) {
          result[tNode.localNames[i]] = lView[localIndex];
          localIndex++;
        }

        return result;
      }

      return null;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Called when directives inject each other (creating a circular dependency)
     * @param {?} token
     * @return {?}
     */


    function throwCyclicDependencyError(token) {
      throw new Error("Cannot instantiate cyclic dependency! ".concat(token));
    }
    /**
     * Called when there are multiple component selectors that match a given node
     * @param {?} tNode
     * @return {?}
     */


    function throwMultipleComponentError(tNode) {
      throw new Error("Multiple components match node with tagname ".concat(tNode.tagName));
    }
    /**
     * Throws an ExpressionChangedAfterChecked error if checkNoChanges mode is on.
     * @param {?} creationMode
     * @param {?} oldValue
     * @param {?} currValue
     * @return {?}
     */


    function throwErrorIfNoChangesMode(creationMode, oldValue, currValue) {
      /** @type {?} */
      let msg = "ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: '".concat(oldValue, "'. Current value: '").concat(currValue, "'.");

      if (creationMode) {
        msg += " It seems like the view has been created after its parent and its children have been dirty checked." + " Has it been created in a change detection hook ?";
      } // TODO: include debug context


      throw new Error(msg);
    }
    /**
     * @return {?}
     */


    function throwMixedMultiProviderError() {
      throw new Error("Cannot mix multi providers and regular providers");
    }
    /**
     * @param {?=} ngModuleType
     * @param {?=} providers
     * @param {?=} provider
     * @return {?}
     */


    function throwInvalidProviderError(ngModuleType, providers, provider) {
      /** @type {?} */
      let ngModuleDetail = '';

      if (ngModuleType && providers) {
        /** @type {?} */
        const providerDetail = providers.map(
        /**
        * @param {?} v
        * @return {?}
        */
        v => v == provider ? '?' + provider + '?' : '...');
        ngModuleDetail = " - only instances of Provider and Type are allowed, got: [".concat(providerDetail.join(', '), "]");
      }

      throw new Error("Invalid provider for the NgModule '".concat(stringify(ngModuleType), "'") + ngModuleDetail);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @enum {number} */


    const TNodeType = {
      /**
       * The TNode contains information about an {@link LContainer} for embedded views.
       */
      Container: 0,

      /**
       * The TNode contains information about an `<ng-content>` projection
       */
      Projection: 1,

      /**
       * The TNode contains information about an {@link LView}
       */
      View: 2,

      /**
       * The TNode contains information about a DOM element aka {@link RNode}.
       */
      Element: 3,

      /**
       * The TNode contains information about an `<ng-container>` element {@link RNode}.
       */
      ElementContainer: 4,

      /**
       * The TNode contains information about an ICU comment used in `i18n`.
       */
      IcuContainer: 5
    };
    /** @enum {number} */

    const TNodeFlags = {
      /** This bit is set if the node is a component */
      isComponent: 1,

      /** This bit is set if the node has been projected */
      isProjected: 2,

      /** This bit is set if any directive on this node has content queries */
      hasContentQuery: 4,

      /** This bit is set if the node has any "class" inputs */
      hasClassInput: 8,

      /** This bit is set if the node has any "style" inputs */
      hasStyleInput: 16,

      /** This bit is set if the node has been detached by i18n */
      isDetached: 32
    };
    /** @enum {number} */

    const TNodeProviderIndexes = {
      /** The index of the first provider on this node is encoded on the least significant bits */
      ProvidersStartIndexMask: 65535,

      /** The count of view providers from the component on this node is encoded on the 16 most
         significant bits */
      CptViewProvidersCountShift: 16,
      CptViewProvidersCountShifter: 65536
    };
    /** @enum {number} */

    const AttributeMarker = {
      /**
       * Marker indicates that the following 3 values in the attributes array are:
       * namespaceUri, attributeName, attributeValue
       * in that order.
       */
      NamespaceURI: 0,

      /**
        * Signals class declaration.
        *
        * Each value following `Classes` designates a class name to include on the element.
        * ## Example:
        *
        * Given:
        * ```
        * <div class="foo bar baz">...<d/vi>
        * ```
        *
        * the generated code is:
        * ```
        * var _c1 = [AttributeMarker.Classes, 'foo', 'bar', 'baz'];
        * ```
        */
      Classes: 1,

      /**
       * Signals style declaration.
       *
       * Each pair of values following `Styles` designates a style name and value to include on the
       * element.
       * ## Example:
       *
       * Given:
       * ```
       * <div style="width:100px; height:200px; color:red">...</div>
       * ```
       *
       * the generated code is:
       * ```
       * var _c1 = [AttributeMarker.Styles, 'width', '100px', 'height'. '200px', 'color', 'red'];
       * ```
       */
      Styles: 2,

      /**
       * Signals that the following attribute names were extracted from input or output bindings.
       *
       * For example, given the following HTML:
       *
       * ```
       * <div moo="car" [foo]="exp" (bar)="doSth()">
       * ```
       *
       * the generated code is:
       *
       * ```
       * var _c1 = ['moo', 'car', AttributeMarker.Bindings, 'foo', 'bar'];
       * ```
       */
      Bindings: 3,

      /**
       * Signals that the following attribute names were hoisted from an inline-template declaration.
       *
       * For example, given the following HTML:
       *
       * ```
       * <div *ngFor="let value of values; trackBy:trackBy" dirA [dirB]="value">
       * ```
       *
       * the generated code for the `template()` instruction would include:
       *
       * ```
       * ['dirA', '', AttributeMarker.Bindings, 'dirB', AttributeMarker.Template, 'ngFor', 'ngForOf',
       * 'ngForTrackBy', 'let-value']
       * ```
       *
       * while the generated code for the `element()` instruction inside the template function would
       * include:
       *
       * ```
       * ['dirA', '', AttributeMarker.Bindings, 'dirB']
       * ```
       */
      Template: 4,

      /**
       * Signals that the following attribute is `ngProjectAs` and its value is a parsed `CssSelector`.
       *
       * For example, given the following HTML:
       *
       * ```
       * <h1 attr="value" ngProjectAs="[title]">
       * ```
       *
       * the generated code for the `element()` instruction would include:
       *
       * ```
       * ['attr', 'value', AttributeMarker.ProjectAs, ['', 'title', '']]
       * ```
       */
      ProjectAs: 5,

      /**
       * Signals that the following attribute will be translated by runtime i18n
       *
       * For example, given the following HTML:
       *
       * ```
       * <div moo="car" foo="value" i18n-foo [bar]="binding" i18n-bar>
       * ```
       *
       * the generated code is:
       *
       * ```
       * var _c1 = ['moo', 'car', AttributeMarker.I18n, 'foo', 'bar'];
       */
      I18n: 6
    };
    /**
     * Binding data (flyweight) for a particular node that is shared between all templates
     * of a specific type.
     *
     * If a property is:
     *    - PropertyAliases: that property's data was generated and this is it
     *    - Null: that property's data was already generated and nothing was found.
     *    - Undefined: that property's data has not yet been generated
     *
     * see: https://en.wikipedia.org/wiki/Flyweight_pattern for more on the Flyweight pattern
     * @record
     */

    function TNode() {}

    if (false) {}
    /**
     * Static data for an element
     * @record
     */


    function TElementNode() {}

    if (false) {}
    /**
     * Static data for a text node
     * @record
     */


    function TTextNode() {}

    if (false) {}
    /**
     * Static data for an LContainer
     * @record
     */


    function TContainerNode() {}

    if (false) {}
    /**
     * Static data for an <ng-container>
     * @record
     */


    function TElementContainerNode() {}

    if (false) {}
    /**
     * Static data for an ICU expression
     * @record
     */


    function TIcuContainerNode() {}

    if (false) {}
    /**
     * Static data for a view
     * @record
     */


    function TViewNode() {}

    if (false) {}
    /**
     * Static data for an LProjectionNode
     * @record
     */


    function TProjectionNode() {}

    if (false) {} // Note: This hack is necessary so we don't erroneously get a circular dependency
    // failure based on types.

    /** @type {?} */


    const unusedValueExportToPlacateAjd$4 = 1;
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /** @enum {number} */

    const SelectorFlags = {
      /** Indicates this is the beginning of a new negative selector */
      NOT: 1,

      /** Mode for matching attributes */
      ATTRIBUTE: 2,

      /** Mode for matching tag names */
      ELEMENT: 4,

      /** Mode for matching class names */
      CLASS: 8
    }; // Note: This hack is necessary so we don't erroneously get a circular dependency
    // failure based on types.

    /** @type {?} */

    const unusedValueExportToPlacateAjd$5 = 1;
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    const unusedValueToPlacateAjd = unusedValueExportToPlacateAjd$4 + unusedValueExportToPlacateAjd$5;
    /** @type {?} */

    const NG_TEMPLATE_SELECTOR = 'ng-template';
    /**
     * @param {?} nodeClassAttrVal
     * @param {?} cssClassToMatch
     * @return {?}
     */

    function isCssClassMatching(nodeClassAttrVal, cssClassToMatch) {
      /** @type {?} */
      const nodeClassesLen = nodeClassAttrVal.length;
      /** @type {?} */

      const matchIndex =
      /** @type {?} */
      nodeClassAttrVal.indexOf(cssClassToMatch);
      /** @type {?} */

      const matchEndIdx = matchIndex + cssClassToMatch.length;

      if (matchIndex === -1 // no match
      || matchIndex > 0 &&
      /** @type {?} */
      nodeClassAttrVal[matchIndex - 1] !== ' ' // no space before
      || matchEndIdx < nodeClassesLen &&
      /** @type {?} */
      nodeClassAttrVal[matchEndIdx] !== ' ') // no space after
        {
          return false;
        }

      return true;
    }
    /**
     * Function that checks whether a given tNode matches tag-based selector and has a valid type.
     *
     * Matching can be performed in 2 modes: projection mode (when we project nodes) and regular
     * directive matching mode:
     * - in the "directive matching" mode we do _not_ take TContainer's tagName into account if it is
     * different from NG_TEMPLATE_SELECTOR (value different from NG_TEMPLATE_SELECTOR indicates that a
     * tag name was extracted from * syntax so we would match the same directive twice);
     * - in the "projection" mode, we use a tag name potentially extracted from the * syntax processing
     * (applicable to TNodeType.Container only).
     * @param {?} tNode
     * @param {?} currentSelector
     * @param {?} isProjectionMode
     * @return {?}
     */


    function hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {
      /** @type {?} */
      const tagNameToCompare = tNode.type === 0
      /* Container */
      && !isProjectionMode ? NG_TEMPLATE_SELECTOR : tNode.tagName;
      return currentSelector === tagNameToCompare;
    }
    /**
     * A utility function to match an Ivy node static data against a simple CSS selector
     *
     * @param {?} tNode
     * @param {?} selector The selector to try matching against the node.
     * @param {?} isProjectionMode if `true` we are matching for content projection, otherwise we are doing
     * directive matching.
     * @return {?} true if node matches the selector.
     */


    function isNodeMatchingSelector(tNode, selector, isProjectionMode) {
      ngDevMode && assertDefined(selector[0], 'Selector should have a tag name');
      /** @type {?} */

      let mode = 4
      /* ELEMENT */
      ;
      /** @type {?} */

      const nodeAttrs = tNode.attrs || []; // Find the index of first attribute that has no value, only a name.

      /** @type {?} */

      const nameOnlyMarkerIdx = getNameOnlyMarkerIndex(nodeAttrs); // When processing ":not" selectors, we skip to the next ":not" if the
      // current one doesn't match

      /** @type {?} */

      let skipToNextSelector = false;

      for (let i = 0; i < selector.length; i++) {
        /** @type {?} */
        const current = selector[i];

        if (typeof current === 'number') {
          // If we finish processing a :not selector and it hasn't failed, return false
          if (!skipToNextSelector && !isPositive(mode) && !isPositive(
          /** @type {?} */
          current)) {
            return false;
          } // If we are skipping to the next :not() and this mode flag is positive,
          // it's a part of the current :not() selector, and we should keep skipping


          if (skipToNextSelector && isPositive(current)) continue;
          skipToNextSelector = false;
          mode =
          /** @type {?} */
          current | mode & 1
          /* NOT */
          ;
          continue;
        }

        if (skipToNextSelector) continue;

        if (mode & 4
        /* ELEMENT */
        ) {
            mode = 2
            /* ATTRIBUTE */
            | mode & 1
            /* NOT */
            ;

            if (current !== '' && !hasTagAndTypeMatch(tNode, current, isProjectionMode) || current === '' && selector.length === 1) {
              if (isPositive(mode)) return false;
              skipToNextSelector = true;
            }
          } else {
          /** @type {?} */
          const selectorAttrValue = mode & 8
          /* CLASS */
          ? current : selector[++i]; // special case for matching against classes when a tNode has been instantiated with
          // class and style values as separate attribute values (e.g. ['title', CLASS, 'foo'])

          if (mode & 8
          /* CLASS */
          && tNode.classes) {
            if (!isCssClassMatching(getInitialStylingValue(tNode.classes),
            /** @type {?} */
            selectorAttrValue)) {
              if (isPositive(mode)) return false;
              skipToNextSelector = true;
            }

            continue;
          }
          /** @type {?} */


          const isInlineTemplate = tNode.type == 0
          /* Container */
          && tNode.tagName !== NG_TEMPLATE_SELECTOR;
          /** @type {?} */

          const attrName = mode & 8
          /* CLASS */
          ? 'class' : current;
          /** @type {?} */

          const attrIndexInNode = findAttrIndexInNode(attrName, nodeAttrs, isInlineTemplate, isProjectionMode);

          if (attrIndexInNode === -1) {
            if (isPositive(mode)) return false;
            skipToNextSelector = true;
            continue;
          }

          if (selectorAttrValue !== '') {
            /** @type {?} */
            let nodeAttrValue;

            if (attrIndexInNode > nameOnlyMarkerIdx) {
              nodeAttrValue = '';
            } else {
              ngDevMode && assertNotEqual(nodeAttrs[attrIndexInNode], 0
              /* NamespaceURI */
              , 'We do not match directives on namespaced attributes');
              nodeAttrValue =
              /** @type {?} */
              nodeAttrs[attrIndexInNode + 1];
            }
            /** @type {?} */


            const compareAgainstClassName = mode & 8
            /* CLASS */
            ? nodeAttrValue : null;

            if (compareAgainstClassName && !isCssClassMatching(compareAgainstClassName,
            /** @type {?} */
            selectorAttrValue) || mode & 2
            /* ATTRIBUTE */
            && selectorAttrValue !== nodeAttrValue) {
              if (isPositive(mode)) return false;
              skipToNextSelector = true;
            }
          }
        }
      }

      return isPositive(mode) || skipToNextSelector;
    }
    /**
     * @param {?} mode
     * @return {?}
     */


    function isPositive(mode) {
      return (mode & 1
      /* NOT */
      ) === 0;
    }
    /**
     * Examines the attribute's definition array for a node to find the index of the
     * attribute that matches the given `name`.
     *
     * NOTE: This will not match namespaced attributes.
     *
     * Attribute matching depends upon `isInlineTemplate` and `isProjectionMode`.
     * The following table summarizes which types of attributes we attempt to match:
     *
     * ===========================================================================================================
     * Modes                   | Normal Attributes | Bindings Attributes | Template Attributes | I18n
     * Attributes
     * ===========================================================================================================
     * Inline + Projection     | YES               | YES                 | NO                  | YES
     * -----------------------------------------------------------------------------------------------------------
     * Inline + Directive      | NO                | NO                  | YES                 | NO
     * -----------------------------------------------------------------------------------------------------------
     * Non-inline + Projection | YES               | YES                 | NO                  | YES
     * -----------------------------------------------------------------------------------------------------------
     * Non-inline + Directive  | YES               | YES                 | NO                  | YES
     * ===========================================================================================================
     *
     * @param {?} name the name of the attribute to find
     * @param {?} attrs the attribute array to examine
     * @param {?} isInlineTemplate true if the node being matched is an inline template (e.g. `*ngFor`)
     * rather than a manually expanded template node (e.g `<ng-template>`).
     * @param {?} isProjectionMode true if we are matching against content projection otherwise we are
     * matching against directives.
     * @return {?}
     */


    function findAttrIndexInNode(name, attrs, isInlineTemplate, isProjectionMode) {
      if (attrs === null) return -1;
      /** @type {?} */

      let i = 0;

      if (isProjectionMode || !isInlineTemplate) {
        /** @type {?} */
        let bindingsMode = false;

        while (i < attrs.length) {
          /** @type {?} */
          const maybeAttrName = attrs[i];

          if (maybeAttrName === name) {
            return i;
          } else if (maybeAttrName === 3
          /* Bindings */
          || maybeAttrName === 6
          /* I18n */
          ) {
              bindingsMode = true;
            } else if (maybeAttrName === 1
          /* Classes */
          ) {
              /** @type {?} */
              let value = attrs[++i]; // We should skip classes here because we have a separate mechanism for
              // matching classes in projection mode.

              while (typeof value === 'string') {
                value = attrs[++i];
              }

              continue;
            } else if (maybeAttrName === 4
          /* Template */
          ) {
              // We do not care about Template attributes in this scenario.
              break;
            } else if (maybeAttrName === 0
          /* NamespaceURI */
          ) {
              // Skip the whole namespaced attribute and value. This is by design.
              i += 4;
              continue;
            } // In binding mode there are only names, rather than name-value pairs.


          i += bindingsMode ? 1 : 2;
        } // We did not match the attribute


        return -1;
      } else {
        return matchTemplateAttribute(attrs, name);
      }
    }
    /**
     * @param {?} tNode
     * @param {?} selector
     * @param {?=} isProjectionMode
     * @return {?}
     */


    function isNodeMatchingSelectorList(tNode, selector, isProjectionMode = false) {
      for (let i = 0; i < selector.length; i++) {
        if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) {
          return true;
        }
      }

      return false;
    }
    /**
     * @param {?} tNode
     * @return {?}
     */


    function getProjectAsAttrValue(tNode) {
      /** @type {?} */
      const nodeAttrs = tNode.attrs;

      if (nodeAttrs != null) {
        /** @type {?} */
        const ngProjectAsAttrIdx = nodeAttrs.indexOf(5
        /* ProjectAs */
        ); // only check for ngProjectAs in attribute names, don't accidentally match attribute's value
        // (attribute names are stored at even indexes)

        if ((ngProjectAsAttrIdx & 1) === 0) {
          return (
            /** @type {?} */
            nodeAttrs[ngProjectAsAttrIdx + 1]
          );
        }
      }

      return null;
    }
    /**
     * @param {?} nodeAttrs
     * @return {?}
     */


    function getNameOnlyMarkerIndex(nodeAttrs) {
      for (let i = 0; i < nodeAttrs.length; i++) {
        /** @type {?} */
        const nodeAttr = nodeAttrs[i];

        if (isNameOnlyAttributeMarker(nodeAttr)) {
          return i;
        }
      }

      return nodeAttrs.length;
    }
    /**
     * @param {?} attrs
     * @param {?} name
     * @return {?}
     */


    function matchTemplateAttribute(attrs, name) {
      /** @type {?} */
      let i = attrs.indexOf(4
      /* Template */
      );

      if (i > -1) {
        i++;

        while (i < attrs.length) {
          if (attrs[i] === name) return i;
          i++;
        }
      }

      return -1;
    }
    /**
     * Checks whether a selector is inside a CssSelectorList
     * @param {?} selector Selector to be checked.
     * @param {?} list List in which to look for the selector.
     * @return {?}
     */


    function isSelectorInSelectorList(selector, list) {
      selectorListLoop: for (let i = 0; i < list.length; i++) {
        /** @type {?} */
        const currentSelectorInList = list[i];

        if (selector.length !== currentSelectorInList.length) {
          continue;
        }

        for (let j = 0; j < selector.length; j++) {
          if (selector[j] !== currentSelectorInList[j]) {
            continue selectorListLoop;
          }
        }

        return true;
      }

      return false;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // The first bit value reflects a map-based binding value's bit.
    // The reason why it's always activated for every entry in the map
    // is so that if any map-binding values update then all other prop
    // based bindings will pass the guard check automatically without
    // any extra code or flags.

    /**
     * --------
     *
     * This file contains the core logic for styling in Angular.
     *
     * All styling bindings (i.e. `[style]`, `[style.prop]`, `[class]` and `[class.name]`)
     * will have their values be applied through the logic in this file.
     *
     * When a binding is encountered (e.g. `<div [style.width]="w">`) then
     * the binding data will be populated into a `TStylingContext` data-structure.
     * There is only one `TStylingContext` per `TNode` and each element instance
     * will update its style/class binding values in concert with the styling
     * context.
     *
     * To learn more about the algorithm see `TStylingContext`.
     *
     * --------
     * @type {?}
     */


    const DEFAULT_GUARD_MASK_VALUE = 0b1;
    /**
     * The guard/update mask bit index location for map-based bindings.
     *
     * All map-based bindings (i.e. `[style]` and `[class]` )
     * @type {?}
     */

    const STYLING_INDEX_FOR_MAP_BINDING = 0;
    /**
     * Default fallback value for a styling binding.
     *
     * A value of `null` is used here which signals to the styling algorithm that
     * the styling value is not present. This way if there are no other values
     * detected then it will be removed once the style/class property is dirty and
     * diffed within the styling algorithm present in `flushStyling`.
     * @type {?}
     */

    const DEFAULT_BINDING_VALUE = null;
    /**
     * Default size count value for a new entry in a context.
     *
     * A value of `1` is used here because each entry in the context has a default
     * property.
     * @type {?}
     */

    const DEFAULT_SIZE_VALUE = 1;
    /** @type {?} */

    let deferredBindingQueue = [];
    /**
     * Visits a class-based binding and updates the new value (if changed).
     *
     * This function is called each time a class-based styling instruction
     * is executed. It's important that it's always called (even if the value
     * has not changed) so that the inner counter index value is incremented.
     * This way, each instruction is always guaranteed to get the same counter
     * state each time it's called (which then allows the `TStylingContext`
     * and the bit mask values to be in sync).
     * @param {?} context
     * @param {?} data
     * @param {?} element
     * @param {?} prop
     * @param {?} bindingIndex
     * @param {?} value
     * @param {?} deferRegistration
     * @param {?} forceUpdate
     * @return {?}
     */

    function updateClassBinding(context, data, element, prop, bindingIndex, value, deferRegistration, forceUpdate) {
      /** @type {?} */
      const isMapBased = !prop;
      /** @type {?} */

      const state = getStylingState(element, stateIsPersisted(context));
      /** @type {?} */

      const index = isMapBased ? STYLING_INDEX_FOR_MAP_BINDING : state.classesIndex++;
      /** @type {?} */

      const updated = updateBindingData(context, data, index, prop, bindingIndex, value, deferRegistration, forceUpdate, false);

      if (updated || forceUpdate) {
        // We flip the bit in the bitMask to reflect that the binding
        // at the `index` slot has changed. This identifies to the flushing
        // phase that the bindings for this particular CSS class need to be
        // applied again because on or more of the bindings for the CSS
        // class have changed.
        state.classesBitMask |= 1 << index;
        return true;
      }

      return false;
    }
    /**
     * Visits a style-based binding and updates the new value (if changed).
     *
     * This function is called each time a style-based styling instruction
     * is executed. It's important that it's always called (even if the value
     * has not changed) so that the inner counter index value is incremented.
     * This way, each instruction is always guaranteed to get the same counter
     * state each time it's called (which then allows the `TStylingContext`
     * and the bit mask values to be in sync).
     * @param {?} context
     * @param {?} data
     * @param {?} element
     * @param {?} prop
     * @param {?} bindingIndex
     * @param {?} value
     * @param {?} sanitizer
     * @param {?} deferRegistration
     * @param {?} forceUpdate
     * @return {?}
     */


    function updateStyleBinding(context, data, element, prop, bindingIndex, value, sanitizer, deferRegistration, forceUpdate) {
      /** @type {?} */
      const isMapBased = !prop;
      /** @type {?} */

      const state = getStylingState(element, stateIsPersisted(context));
      /** @type {?} */

      const index = isMapBased ? STYLING_INDEX_FOR_MAP_BINDING : state.stylesIndex++;
      /** @type {?} */

      const sanitizationRequired = isMapBased ? true : sanitizer ? sanitizer(
      /** @type {?} */
      prop, null, 1
      /* ValidateProperty */
      ) : false;
      /** @type {?} */

      const updated = updateBindingData(context, data, index, prop, bindingIndex, value, deferRegistration, forceUpdate, sanitizationRequired);

      if (updated || forceUpdate) {
        // We flip the bit in the bitMask to reflect that the binding
        // at the `index` slot has changed. This identifies to the flushing
        // phase that the bindings for this particular property need to be
        // applied again because on or more of the bindings for the CSS
        // property have changed.
        state.stylesBitMask |= 1 << index;
        return true;
      }

      return false;
    }
    /**
     * Called each time a binding value has changed within the provided `TStylingContext`.
     *
     * This function is designed to be called from `updateStyleBinding` and `updateClassBinding`.
     * If called during the first update pass, the binding will be registered in the context.
     * If the binding does get registered and the `deferRegistration` flag is true then the
     * binding data will be queued up until the context is later flushed in `applyStyling`.
     *
     * This function will also update binding slot in the provided `LStylingData` with the
     * new binding entry (if it has changed).
     *
     * @param {?} context
     * @param {?} data
     * @param {?} counterIndex
     * @param {?} prop
     * @param {?} bindingIndex
     * @param {?} value
     * @param {?} deferRegistration
     * @param {?} forceUpdate
     * @param {?} sanitizationRequired
     * @return {?} whether or not the binding value was updated in the `LStylingData`.
     */


    function updateBindingData(context, data, counterIndex, prop, bindingIndex, value, deferRegistration, forceUpdate, sanitizationRequired) {
      if (!isContextLocked(context)) {
        if (deferRegistration) {
          deferBindingRegistration(context, counterIndex, prop, bindingIndex, sanitizationRequired);
        } else {
          deferredBindingQueue.length && flushDeferredBindings(); // this will only happen during the first update pass of the
          // context. The reason why we can't use `tNode.firstTemplatePass`
          // here is because its not guaranteed to be true when the first
          // update pass is executed (remember that all styling instructions
          // are run in the update phase, and, as a result, are no more
          // styling instructions that are run in the creation phase).

          registerBinding(context, counterIndex, prop, bindingIndex, sanitizationRequired);
        }
      }
      /** @type {?} */


      const changed = forceUpdate || hasValueChanged(data[bindingIndex], value);

      if (changed) {
        data[bindingIndex] = value;
      }

      return changed;
    }
    /**
     * Schedules a binding registration to be run at a later point.
     *
     * The reasoning for this feature is to ensure that styling
     * bindings are registered in the correct order for when
     * directives/components have a super/sub class inheritance
     * chains. Each directive's styling bindings must be
     * registered into the context in reverse order. Therefore all
     * bindings will be buffered in reverse order and then applied
     * after the inheritance chain exits.
     * @param {?} context
     * @param {?} counterIndex
     * @param {?} prop
     * @param {?} bindingIndex
     * @param {?} sanitizationRequired
     * @return {?}
     */


    function deferBindingRegistration(context, counterIndex, prop, bindingIndex, sanitizationRequired) {
      deferredBindingQueue.unshift(context, counterIndex, prop, bindingIndex, sanitizationRequired);
    }
    /**
     * Flushes the collection of deferred bindings and causes each entry
     * to be registered into the context.
     * @return {?}
     */


    function flushDeferredBindings() {
      /** @type {?} */
      let i = 0;

      while (i < deferredBindingQueue.length) {
        /** @type {?} */
        const context =
        /** @type {?} */
        deferredBindingQueue[i++];
        /** @type {?} */

        const count =
        /** @type {?} */
        deferredBindingQueue[i++];
        /** @type {?} */

        const prop =
        /** @type {?} */
        deferredBindingQueue[i++];
        /** @type {?} */

        const bindingIndex =
        /** @type {?} */
        deferredBindingQueue[i++];
        /** @type {?} */

        const sanitizationRequired =
        /** @type {?} */
        deferredBindingQueue[i++];
        registerBinding(context, count, prop, bindingIndex, sanitizationRequired);
      }

      deferredBindingQueue.length = 0;
    }
    /**
     * Registers the provided binding (prop + bindingIndex) into the context.
     *
     * This function is shared between bindings that are assigned immediately
     * (via `updateBindingData`) and at a deferred stage. When called, it will
     * figure out exactly where to place the binding data in the context.
     *
     * It is needed because it will either update or insert a styling property
     * into the context at the correct spot.
     *
     * When called, one of two things will happen:
     *
     * 1) If the property already exists in the context then it will just add
     *    the provided `bindingValue` to the end of the binding sources region
     *    for that particular property.
     *
     *    - If the binding value is a number then it will be added as a new
     *      binding index source next to the other binding sources for the property.
     *
     *    - Otherwise, if the binding value is a string/boolean/null type then it will
     *      replace the default value for the property if the default value is `null`.
     *
     * 2) If the property does not exist then it will be inserted into the context.
     *    The styling context relies on all properties being stored in alphabetical
     *    order, so it knows exactly where to store it.
     *
     *    When inserted, a default `null` value is created for the property which exists
     *    as the default value for the binding. If the bindingValue property is inserted
     *    and it is either a string, number or null value then that will replace the default
     *    value.
     *
     * Note that this function is also used for map-based styling bindings. They are treated
     * much the same as prop-based bindings, but, because they do not have a property value
     * (since it's a map), all map-based entries are stored in an already populated area of
     * the context at the top (which is reserved for map-based entries).
     * @param {?} context
     * @param {?} countId
     * @param {?} prop
     * @param {?} bindingValue
     * @param {?=} sanitizationRequired
     * @return {?}
     */


    function registerBinding(context, countId, prop, bindingValue, sanitizationRequired) {
      /** @type {?} */
      let registered = false;

      if (prop) {
        // prop-based bindings (e.g `<div [style.width]="w" [class.foo]="f">`)

        /** @type {?} */
        let found = false;
        /** @type {?} */

        let i = getPropValuesStartPosition(context);

        while (i < context.length) {
          /** @type {?} */
          const valuesCount = getValuesCount(context, i);
          /** @type {?} */

          const p = getProp(context, i);
          found = prop <= p;

          if (found) {
            // all style/class bindings are sorted by property name
            if (prop < p) {
              allocateNewContextEntry(context, i, prop, sanitizationRequired);
            }

            addBindingIntoContext(context, false, i, bindingValue, countId);
            break;
          }

          i += 3
          /* BindingsStartOffset */
          + valuesCount;
        }

        if (!found) {
          allocateNewContextEntry(context, context.length, prop, sanitizationRequired);
          addBindingIntoContext(context, false, i, bindingValue, countId);
          registered = true;
        }
      } else {
        // map-based bindings (e.g `<div [style]="s" [class]="{className:true}">`)
        // there is no need to allocate the map-based binding region into the context
        // since it is already there when the context is first created.
        addBindingIntoContext(context, true, 3
        /* MapBindingsPosition */
        , bindingValue, countId);
        registered = true;
      }

      return registered;
    }
    /**
     * @param {?} context
     * @param {?} index
     * @param {?} prop
     * @param {?=} sanitizationRequired
     * @return {?}
     */


    function allocateNewContextEntry(context, index, prop, sanitizationRequired) {
      // 1,2: splice index locations
      // 3: each entry gets a config value (guard mask + flags)
      // 4. each entry gets a size value (which is always one because there is always a default binding
      // value)
      // 5. the property that is getting allocated into the context
      // 6. the default binding value (usually `null`)

      /** @type {?} */
      const config = sanitizationRequired ? 1
      /* SanitizationRequired */
      : 0
      /* Default */
      ;
      context.splice(index, 0, config, DEFAULT_SIZE_VALUE, prop, DEFAULT_BINDING_VALUE);
      setGuardMask(context, index, DEFAULT_GUARD_MASK_VALUE);
    }
    /**
     * Inserts a new binding value into a styling property tuple in the `TStylingContext`.
     *
     * A bindingValue is inserted into a context during the first update pass
     * of a template or host bindings function. When this occurs, two things
     * happen:
     *
     * - If the bindingValue value is a number then it is treated as a bindingIndex
     *   value (a index in the `LView`) and it will be inserted next to the other
     *   binding index entries.
     *
     * - Otherwise the binding value will update the default value for the property
     *   and this will only happen if the default value is `null`.
     *
     * Note that this function also handles map-based bindings and will insert them
     * at the top of the context.
     * @param {?} context
     * @param {?} isMapBased
     * @param {?} index
     * @param {?} bindingValue
     * @param {?} countId
     * @return {?}
     */


    function addBindingIntoContext(context, isMapBased, index, bindingValue, countId) {
      /** @type {?} */
      const valuesCount = getValuesCount(context, index);
      /** @type {?} */

      const firstValueIndex = index + 3
      /* BindingsStartOffset */
      ;
      /** @type {?} */

      let lastValueIndex = firstValueIndex + valuesCount;

      if (!isMapBased) {
        // prop-based values all have default values, but map-based entries do not.
        // we want to access the index for the default value in this case and not just
        // the bindings...
        lastValueIndex--;
      }

      if (typeof bindingValue === 'number') {
        // the loop here will check to see if the binding already exists
        // for the property in the context. Why? The reason for this is
        // because the styling context is not "locked" until the first
        // flush has occurred. This means that if a repeated element
        // registers its styling bindings then it will register each
        // binding more than once (since its duplicated). This check
        // will prevent that from happening. Note that this only happens
        // when a binding is first encountered and not each time it is
        // updated.
        for (let i = firstValueIndex; i <= lastValueIndex; i++) {
          /** @type {?} */
          const indexAtPosition = context[i];
          if (indexAtPosition === bindingValue) return;
        }

        context.splice(lastValueIndex, 0, bindingValue);
        /** @type {?} */context[index + 1 /* ValuesCountOffset */]++; // now that a new binding index has been added to the property
        // the guard mask bit value (at the `countId` position) needs
        // to be included into the existing mask value.

        /** @type {?} */

        const guardMask = getGuardMask(context, index) | 1 << countId;
        setGuardMask(context, index, guardMask);
      } else if (bindingValue !== null && context[lastValueIndex] == null) {
        context[lastValueIndex] = bindingValue;
      }
    }
    /**
     * Applies all pending style and class bindings to the provided element.
     *
     * This function will attempt to flush styling via the provided `classesContext`
     * and `stylesContext` context values. This function is designed to be run from
     * the `stylingApply()` instruction (which is run at the very end of styling
     * change detection) and will rely on any state values that are set from when
     * any styling bindings update.
     *
     * This function may be called multiple times on the same element because it can
     * be called from the template code as well as from host bindings. In order for
     * styling to be successfully flushed to the element (which will only happen once
     * despite this being called multiple times), the following criteria must be met:
     *
     * - `flushStyling` is called from the very last directive that has styling for
     *    the element (see `allowStylingFlush()`).
     * - one or more bindings for classes or styles has updated (this is checked by
     *   examining the classes or styles bit mask).
     *
     * If the style and class values are successfully applied to the element then
     * the temporary state values for the element will be cleared. Otherwise, if
     * this did not occur then the styling state is persisted (see `state.ts` for
     * more information on how this works).
     * @param {?} renderer
     * @param {?} data
     * @param {?} classesContext
     * @param {?} stylesContext
     * @param {?} element
     * @param {?} directiveIndex
     * @param {?} styleSanitizer
     * @return {?}
     */


    function flushStyling(renderer, data, classesContext, stylesContext, element, directiveIndex, styleSanitizer) {
      ngDevMode && ngDevMode.flushStyling++;
      /** @type {?} */

      const persistState = classesContext ? stateIsPersisted(classesContext) : stylesContext ? stateIsPersisted(stylesContext) : false;
      /** @type {?} */

      const allowFlushClasses = allowStylingFlush(classesContext, directiveIndex);
      /** @type {?} */

      const allowFlushStyles = allowStylingFlush(stylesContext, directiveIndex); // deferred bindings are bindings which are scheduled to register with
      // the context at a later point. These bindings can only registered when
      // the context will be 100% flushed to the element.

      if (deferredBindingQueue.length && (allowFlushClasses || allowFlushStyles)) {
        flushDeferredBindings();
      }
      /** @type {?} */


      const state = getStylingState(element, persistState);
      /** @type {?} */

      const classesFlushed = maybeApplyStyling(renderer, element, data, classesContext, allowFlushClasses, state.classesBitMask, setClass, null);
      /** @type {?} */

      const stylesFlushed = maybeApplyStyling(renderer, element, data, stylesContext, allowFlushStyles, state.stylesBitMask, setStyle, styleSanitizer);

      if (classesFlushed && stylesFlushed) {
        resetStylingState();

        if (persistState) {
          deleteStylingStateFromStorage(element);
        }
      } else if (persistState) {
        storeStylingState(element, state);
      }
    }
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} data
     * @param {?} context
     * @param {?} allowFlush
     * @param {?} bitMask
     * @param {?} styleSetter
     * @param {?} styleSanitizer
     * @return {?}
     */


    function maybeApplyStyling(renderer, element, data, context, allowFlush, bitMask, styleSetter, styleSanitizer) {
      if (allowFlush && context) {
        lockAndFinalizeContext(context);

        if (contextHasUpdates(context, bitMask)) {
          ngDevMode && (styleSanitizer ? ngDevMode.stylesApplied++ : ngDevMode.classesApplied++);
          applyStyling(
          /** @type {?} */
          context, renderer, element, data, bitMask, styleSetter, styleSanitizer);
          return true;
        }
      }

      return allowFlush;
    }
    /**
     * @param {?} context
     * @param {?} bitMask
     * @return {?}
     */


    function contextHasUpdates(context, bitMask) {
      return context && bitMask > BIT_MASK_START_VALUE;
    }
    /**
     * Locks the context (so no more bindings can be added) and also copies over initial class/style
     * values into their binding areas.
     *
     * There are two main actions that take place in this function:
     *
     * - Locking the context:
     *   Locking the context is required so that the style/class instructions know NOT to
     *   register a binding again after the first update pass has run. If a locking bit was
     *   not used then it would need to scan over the context each time an instruction is run
     *   (which is expensive).
     *
     * - Patching initial values:
     *   Directives and component host bindings may include static class/style values which are
     *   bound to the host element. When this happens, the styling context will need to be informed
     *   so it can use these static styling values as defaults when a matching binding is falsy.
     *   These initial styling values are read from the initial styling values slot within the
     *   provided `TStylingContext` (which is an instance of a `StylingMapArray`). This inner map will
     *   be updated each time a host binding applies its static styling values (via `elementHostAttrs`)
     *   so these values are only read at this point because this is the very last point before the
     *   first style/class values are flushed to the element.
     * @param {?} context
     * @return {?}
     */


    function lockAndFinalizeContext(context) {
      if (!isContextLocked(context)) {
        /** @type {?} */
        const initialValues = getStylingMapArray(context);

        if (initialValues) {
          updateInitialStylingOnContext(context, initialValues);
        }

        lockContext(context);
      }
    }
    /**
     * Runs through the provided styling context and applies each value to
     * the provided element (via the renderer) if one or more values are present.
     *
     * This function will iterate over all entries present in the provided
     * `TStylingContext` array (both prop-based and map-based bindings).-
     *
     * Each entry, within the `TStylingContext` array, is stored alphabetically
     * and this means that each prop/value entry will be applied in order
     * (so long as it is marked dirty in the provided `bitMask` value).
     *
     * If there are any map-based entries present (which are applied to the
     * element via the `[style]` and `[class]` bindings) then those entries
     * will be applied as well. However, the code for that is not a part of
     * this function. Instead, each time a property is visited, then the
     * code below will call an external function called `stylingMapsSyncFn`
     * and, if present, it will keep the application of styling values in
     * map-based bindings up to sync with the application of prop-based
     * bindings.
     *
     * Visit `styling_next/map_based_bindings.ts` to learn more about how the
     * algorithm works for map-based styling bindings.
     *
     * Note that this function is not designed to be called in isolation (use
     * `applyClasses` and `applyStyles` to actually apply styling values).
     * @param {?} context
     * @param {?} renderer
     * @param {?} element
     * @param {?} bindingData
     * @param {?} bitMaskValue
     * @param {?} applyStylingFn
     * @param {?} sanitizer
     * @return {?}
     */


    function applyStyling(context, renderer, element, bindingData, bitMaskValue, applyStylingFn, sanitizer) {
      /** @type {?} */
      const bitMask = normalizeBitMaskValue(bitMaskValue);
      /** @type {?} */

      const stylingMapsSyncFn = getStylingMapsSyncFn();
      /** @type {?} */

      const mapsGuardMask = getGuardMask(context, 3
      /* MapBindingsPosition */
      );
      /** @type {?} */

      const applyAllValues = (bitMask & mapsGuardMask) > 0;
      /** @type {?} */

      const mapsMode = applyAllValues ? 1
      /* ApplyAllValues */
      : 0
      /* TraverseValues */
      ;
      /** @type {?} */

      let i = getPropValuesStartPosition(context);

      while (i < context.length) {
        /** @type {?} */
        const valuesCount = getValuesCount(context, i);
        /** @type {?} */

        const guardMask = getGuardMask(context, i);

        if (bitMask & guardMask) {
          /** @type {?} */
          let valueApplied = false;
          /** @type {?} */

          const prop = getProp(context, i);
          /** @type {?} */

          const valuesCountUpToDefault = valuesCount - 1;
          /** @type {?} */

          const defaultValue =
          /** @type {?} */
          getBindingValue(context, i, valuesCountUpToDefault); // case 1: apply prop-based values
          // try to apply the binding values and see if a non-null
          // value gets set for the styling binding

          for (let j = 0; j < valuesCountUpToDefault; j++) {
            /** @type {?} */
            const bindingIndex =
            /** @type {?} */
            getBindingValue(context, i, j);
            /** @type {?} */

            const value = bindingData[bindingIndex];

            if (isStylingValueDefined(value)) {
              /** @type {?} */
              const finalValue = sanitizer && isSanitizationRequired(context, i) ? sanitizer(prop, value, 2
              /* SanitizeOnly */
              ) : value;
              applyStylingFn(renderer, element, prop, finalValue, bindingIndex);
              valueApplied = true;
              break;
            }
          } // case 2: apply map-based values
          // traverse through each map-based styling binding and update all values up to
          // the provided `prop` value. If the property was not applied in the loop above
          // then it will be attempted to be applied in the maps sync code below.


          if (stylingMapsSyncFn) {
            // determine whether or not to apply the target property or to skip it

            /** @type {?} */
            const mode = mapsMode | (valueApplied ? 4
            /* SkipTargetProp */
            : 2
            /* ApplyTargetProp */
            );
            /** @type {?} */

            const valueAppliedWithinMap = stylingMapsSyncFn(context, renderer, element, bindingData, applyStylingFn, sanitizer, mode, prop, defaultValue);
            valueApplied = valueApplied || valueAppliedWithinMap;
          } // case 3: apply the default value
          // if the value has not yet been applied then a truthy value does not exist in the
          // prop-based or map-based bindings code. If and when this happens, just apply the
          // default value (even if the default value is `null`).


          if (!valueApplied) {
            applyStylingFn(renderer, element, prop, defaultValue);
          }
        }

        i += 3
        /* BindingsStartOffset */
        + valuesCount;
      } // the map-based styling entries may have not applied all their
      // values. For this reason, one more call to the sync function
      // needs to be issued at the end.


      if (stylingMapsSyncFn) {
        stylingMapsSyncFn(context, renderer, element, bindingData, applyStylingFn, sanitizer, mapsMode);
      }
    }
    /**
     * @param {?} value
     * @return {?}
     */


    function normalizeBitMaskValue(value) {
      // if pass => apply all values (-1 implies that all bits are flipped to true)
      if (value === true) return -1; // if pass => skip all values

      if (value === false) return 0; // return the bit mask value as is

      return value;
    }
    /** @type {?} */


    let _activeStylingMapApplyFn = null;
    /**
     * @return {?}
     */

    function getStylingMapsSyncFn() {
      return _activeStylingMapApplyFn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */


    function setStylingMapsSyncFn(fn) {
      _activeStylingMapApplyFn = fn;
    }
    /**
     * Assigns a style value to a style property for the given element.
     * @type {?}
     */


    const setStyle =
    /**
    * @param {?} renderer
    * @param {?} native
    * @param {?} prop
    * @param {?} value
    * @return {?}
    */
    (renderer, native, prop, value) => {
      // the reason why this may be `null` is either because
      // it's a container element or it's a part of a test
      // environment that doesn't have styling. In either
      // case it's safe not to apply styling to the element.

      /** @type {?} */
      const nativeStyle = native.style;

      if (value) {
        // opacity, z-index and flexbox all have number values
        // and these need to be converted into strings so that
        // they can be assigned properly.
        value = value.toString();
        ngDevMode && ngDevMode.rendererSetStyle++;
        renderer && isProceduralRenderer(renderer) ? renderer.setStyle(native, prop, value, RendererStyleFlags3.DashCase) : nativeStyle && nativeStyle.setProperty(prop, value);
      } else {
        ngDevMode && ngDevMode.rendererRemoveStyle++;
        renderer && isProceduralRenderer(renderer) ? renderer.removeStyle(native, prop, RendererStyleFlags3.DashCase) : nativeStyle && nativeStyle.removeProperty(prop);
      }
    };

    const ɵ0$4 = setStyle;
    /**
     * Adds/removes the provided className value to the provided element.
     * @type {?}
     */

    const setClass =
    /**
    * @param {?} renderer
    * @param {?} native
    * @param {?} className
    * @param {?} value
    * @return {?}
    */
    (renderer, native, className, value) => {
      if (className !== '') {
        // the reason why this may be `null` is either because
        // it's a container element or it's a part of a test
        // environment that doesn't have styling. In either
        // case it's safe not to apply styling to the element.

        /** @type {?} */
        const classList = native.classList;

        if (value) {
          ngDevMode && ngDevMode.rendererAddClass++;
          renderer && isProceduralRenderer(renderer) ? renderer.addClass(native, className) : classList && classList.add(className);
        } else {
          ngDevMode && ngDevMode.rendererRemoveClass++;
          renderer && isProceduralRenderer(renderer) ? renderer.removeClass(native, className) : classList && classList.remove(className);
        }
      }
    };

    const ɵ1$1 = setClass;
    /**
     * Iterates over all provided styling entries and renders them on the element.
     *
     * This function is used alongside a `StylingMapArray` entry. This entry is not
     * the same as the `TStylingContext` and is only really used when an element contains
     * initial styling values (e.g. `<div style="width:200px">`), but no style/class bindings
     * are present. If and when that happens then this function will be called to render all
     * initial styling values on an element.
     * @param {?} renderer
     * @param {?} element
     * @param {?} stylingValues
     * @param {?} isClassBased
     * @return {?}
     */

    function renderStylingMap(renderer, element, stylingValues, isClassBased) {
      /** @type {?} */
      const stylingMapArr = getStylingMapArray(stylingValues);

      if (stylingMapArr) {
        for (let i = 1
        /* ValuesStartPosition */
        ; i < stylingMapArr.length; i += 2
        /* TupleSize */
        ) {
          /** @type {?} */
          const prop = getMapProp(stylingMapArr, i);
          /** @type {?} */

          const value = getMapValue(stylingMapArr, i);

          if (isClassBased) {
            setClass(renderer, element, prop, value, null);
          } else {
            setStyle(renderer, element, prop, value, null);
          }
        }
      }
    }
    /**
     * Registers all initial styling entries into the provided context.
     *
     * This function will iterate over all entries in the provided `initialStyling` ar}ray and register
     * them as default (initial) values in the provided context. Initial styling values in a context are
     * the default values that are to be applied unless overwritten by a binding.
     *
     * The reason why this function exists and isn't a part of the context construction is because
     * host binding is evaluated at a later stage after the element is created. This means that
     * if a directive or component contains any initial styling code (i.e. `<div class="foo">`)
     * then that initial styling data can only be applied once the styling for that element
     * is first applied (at the end of the update phase). Once that happens then the context will
     * update itself with the complete initial styling for the element.
     * @param {?} context
     * @param {?} initialStyling
     * @return {?}
     */


    function updateInitialStylingOnContext(context, initialStyling) {
      // `-1` is used here because all initial styling data is not a spart
      // of a binding (since it's static)

      /** @type {?} */
      const INITIAL_STYLING_COUNT_ID = -1;

      for (let i = 1
      /* ValuesStartPosition */
      ; i < initialStyling.length; i += 2
      /* TupleSize */
      ) {
        /** @type {?} */
        const value = getMapValue(initialStyling, i);

        if (value) {
          /** @type {?} */
          const prop = getMapProp(initialStyling, i);
          registerBinding(context, INITIAL_STYLING_COUNT_ID, prop, value, false);
        }
      }
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // WARNING: interface has both a type and a value, skipping emit

    /**
     * A special value which designates that a value has not changed.
     * @type {?}
     */


    const NO_CHANGE =
    /** @type {?} */
    {};
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /** @enum {number} */

    const I18nMutateOpCode = {
      /**
       * Stores shift amount for bits 17-3 that contain reference index.
       */
      SHIFT_REF: 3,

      /**
       * Stores shift amount for bits 31-17 that contain parent index.
       */
      SHIFT_PARENT: 17,

      /**
       * Mask for OpCode
       */
      MASK_OPCODE: 7,

      /**
       * OpCode to select a node. (next OpCode will contain the operation.)
       */
      Select: 0,

      /**
       * OpCode to append the current node to `PARENT`.
       */
      AppendChild: 1,

      /**
       * OpCode to remove the `REF` node from `PARENT`.
       */
      Remove: 3,

      /**
       * OpCode to set the attribute of a node.
       */
      Attr: 4,

      /**
       * OpCode to simulate elementEnd()
       */
      ElementEnd: 5,

      /**
       * OpCode to read the remove OpCodes for the nested ICU
       */
      RemoveNestedIcu: 6
    };
    /**
     * Marks that the next string is for element.
     *
     * See `I18nMutateOpCodes` documentation.
     * @type {?}
     */

    const ELEMENT_MARKER = {
      marker: 'element'
    }; // WARNING: interface has both a type and a value, skipping emit

    /**
     * Marks that the next string is for comment.
     *
     * See `I18nMutateOpCodes` documentation.
     * @type {?}
     */

    const COMMENT_MARKER = {
      marker: 'comment'
    }; // WARNING: interface has both a type and a value, skipping emit

    /**
     * Array storing OpCode for dynamically creating `i18n` blocks.
     *
     * Example:
     * ```ts
     * <I18nCreateOpCode>[
     *   // For adding text nodes
     *   // ---------------------
     *   // Equivalent to:
     *   //   const node = lView[index++] = document.createTextNode('abc');
     *   //   lView[1].insertBefore(node, lView[2]);
     *   'abc', 1 << SHIFT_PARENT | 2 << SHIFT_REF | InsertBefore,
     *
     *   // Equivalent to:
     *   //   const node = lView[index++] = document.createTextNode('xyz');
     *   //   lView[1].appendChild(node);
     *   'xyz', 1 << SHIFT_PARENT | AppendChild,
     *
     *   // For adding element nodes
     *   // ---------------------
     *   // Equivalent to:
     *   //   const node = lView[index++] = document.createElement('div');
     *   //   lView[1].insertBefore(node, lView[2]);
     *   ELEMENT_MARKER, 'div', 1 << SHIFT_PARENT | 2 << SHIFT_REF | InsertBefore,
     *
     *   // Equivalent to:
     *   //   const node = lView[index++] = document.createElement('div');
     *   //   lView[1].appendChild(node);
     *   ELEMENT_MARKER, 'div', 1 << SHIFT_PARENT | AppendChild,
     *
     *   // For adding comment nodes
     *   // ---------------------
     *   // Equivalent to:
     *   //   const node = lView[index++] = document.createComment('');
     *   //   lView[1].insertBefore(node, lView[2]);
     *   COMMENT_MARKER, '', 1 << SHIFT_PARENT | 2 << SHIFT_REF | InsertBefore,
     *
     *   // Equivalent to:
     *   //   const node = lView[index++] = document.createComment('');
     *   //   lView[1].appendChild(node);
     *   COMMENT_MARKER, '', 1 << SHIFT_PARENT | AppendChild,
     *
     *   // For moving existing nodes to a different location
     *   // --------------------------------------------------
     *   // Equivalent to:
     *   //   const node = lView[1];
     *   //   lView[2].insertBefore(node, lView[3]);
     *   1 << SHIFT_REF | Select, 2 << SHIFT_PARENT | 3 << SHIFT_REF | InsertBefore,
     *
     *   // Equivalent to:
     *   //   const node = lView[1];
     *   //   lView[2].appendChild(node);
     *   1 << SHIFT_REF | Select, 2 << SHIFT_PARENT | AppendChild,
     *
     *   // For removing existing nodes
     *   // --------------------------------------------------
     *   //   const node = lView[1];
     *   //   removeChild(tView.data(1), node, lView);
     *   1 << SHIFT_REF | Remove,
     *
     *   // For writing attributes
     *   // --------------------------------------------------
     *   //   const node = lView[1];
     *   //   node.setAttribute('attr', 'value');
     *   1 << SHIFT_REF | Select, 'attr', 'value'
     *            // NOTE: Select followed by two string (vs select followed by OpCode)
     * ];
     * ```
     * NOTE:
     *   - `index` is initial location where the extra nodes should be stored in the EXPANDO section of
     * `LVIewData`.
     *
     * See: `applyI18nCreateOpCodes`;
     * @record
     */

    function I18nMutateOpCodes() {}
    /** @enum {number} */


    const I18nUpdateOpCode = {
      /**
       * Stores shift amount for bits 17-2 that contain reference index.
       */
      SHIFT_REF: 2,

      /**
       * Mask for OpCode
       */
      MASK_OPCODE: 3,

      /**
       * OpCode to update a text node.
       */
      Text: 0,

      /**
       * OpCode to update a attribute of a node.
       */
      Attr: 1,

      /**
       * OpCode to switch the current ICU case.
       */
      IcuSwitch: 2,

      /**
       * OpCode to update the current ICU case.
       */
      IcuUpdate: 3
    };
    /**
     * Stores DOM operations which need to be applied to update DOM render tree due to changes in
     * expressions.
     *
     * The basic idea is that `i18nExp` OpCodes capture expression changes and update a change
     * mask bit. (Bit 1 for expression 1, bit 2 for expression 2 etc..., bit 32 for expression 32 and
     * higher.) The OpCodes then compare its own change mask against the expression change mask to
     * determine if the OpCodes should execute.
     *
     * These OpCodes can be used by both the i18n block as well as ICU sub-block.
     *
     * ## Example
     *
     * Assume
     * ```ts
     *   if (rf & RenderFlags.Update) {
     *    i18nExp(bind(ctx.exp1)); // If changed set mask bit 1
     *    i18nExp(bind(ctx.exp2)); // If changed set mask bit 2
     *    i18nExp(bind(ctx.exp3)); // If changed set mask bit 3
     *    i18nExp(bind(ctx.exp4)); // If changed set mask bit 4
     *    i18nApply(0);            // Apply all changes by executing the OpCodes.
     *  }
     * ```
     * We can assume that each call to `i18nExp` sets an internal `changeMask` bit depending on the
     * index of `i18nExp`.
     *
     * ### OpCodes
     * ```ts
     * <I18nUpdateOpCodes>[
     *   // The following OpCodes represent: `<div i18n-title="pre{{exp1}}in{{exp2}}post">`
     *   // If `changeMask & 0b11`
     *   //        has changed then execute update OpCodes.
     *   //        has NOT changed then skip `7` values and start processing next OpCodes.
     *   0b11, 7,
     *   // Concatenate `newValue = 'pre'+lView[bindIndex-4]+'in'+lView[bindIndex-3]+'post';`.
     *   'pre', -4, 'in', -3, 'post',
     *   // Update attribute: `elementAttribute(1, 'title', sanitizerFn(newValue));`
     *   1 << SHIFT_REF | Attr, 'title', sanitizerFn,
     *
     *   // The following OpCodes represent: `<div i18n>Hello {{exp3}}!">`
     *   // If `changeMask & 0b100`
     *   //        has changed then execute update OpCodes.
     *   //        has NOT changed then skip `4` values and start processing next OpCodes.
     *   0b100, 4,
     *   // Concatenate `newValue = 'Hello ' + lView[bindIndex -2] + '!';`.
     *   'Hello ', -2, '!',
     *   // Update text: `lView[1].textContent = newValue;`
     *   1 << SHIFT_REF | Text,
     *
     *   // The following OpCodes represent: `<div i18n>{exp4, plural, ... }">`
     *   // If `changeMask & 0b1000`
     *   //        has changed then execute update OpCodes.
     *   //        has NOT changed then skip `4` values and start processing next OpCodes.
     *   0b1000, 4,
     *   // Concatenate `newValue = lView[bindIndex -1];`.
     *   -1,
     *   // Switch ICU: `icuSwitchCase(lView[1], 0, newValue);`
     *   0 << SHIFT_ICU | 1 << SHIFT_REF | IcuSwitch,
     *
     *   // Note `changeMask & -1` is always true, so the IcuUpdate will always execute.
     *   -1, 1,
     *   // Update ICU: `icuUpdateCase(lView[1], 0);`
     *   0 << SHIFT_ICU | 1 << SHIFT_REF | IcuUpdate,
     *
     * ];
     * ```
     *
     * @record
     */

    function I18nUpdateOpCodes() {}
    /**
     * Store information for the i18n translation block.
     * @record
     */


    function TI18n() {}

    if (false) {}
    /** @enum {number} */


    const IcuType = {
      select: 0,
      plural: 1
    };
    /**
     * @record
     */

    function TIcu() {}

    if (false) {} // Note: This hack is necessary so we don't erroneously get a circular dependency
    // failure based on types.

    /** @type {?} */


    const unusedValueExportToPlacateAjd$6 = 1;
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     * @param {?} obj
     * @param {?} debug
     * @return {?}
     */

    function attachDebugObject(obj, debug) {
      Object.defineProperty(obj, 'debug', {
        value: debug,
        enumerable: false
      });
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Used to apply styling values presently within any map-based bindings on an element.
     *
     * Angular supports map-based styling bindings which can be applied via the
     * `[style]` and `[class]` bindings which can be placed on any HTML element.
     * These bindings can work independently, together or alongside prop-based
     * styling bindings (e.g. `<div [style]="x" [style.width]="w">`).
     *
     * If a map-based styling binding is detected by the compiler, the following
     * AOT code is produced:
     *
     * ```typescript
     * styleMap(ctx.styles); // styles = {key:value}
     * classMap(ctx.classes); // classes = {key:value}|string
     * ```
     *
     * If and when either of the instructions above are evaluated, then the code
     * present in this file is included into the bundle. The mechanism used, to
     * activate support for map-based bindings at runtime is possible via the
     * `activeStylingMapFeature` function (which is also present in this file).
     *
     * # The Algorithm
     * Whenever a map-based binding updates (which is when the identity of the
     * map-value changes) then the map is iterated over and a `StylingMapArray` array
     * is produced. The `StylingMapArray` instance is stored in the binding location
     * where the `BINDING_INDEX` is situated when the `styleMap()` or `classMap()`
     * instruction were called. Once the binding changes, then the internal `bitMask`
     * value is marked as dirty.
     *
     * Styling values are applied once CD exits the element (which happens when
     * the `select(n)` instruction is called or the template function exits). When
     * this occurs, all prop-based bindings are applied. If a map-based binding is
     * present then a special flushing function (called a sync function) is made
     * available and it will be called each time a styling property is flushed.
     *
     * The flushing algorithm is designed to apply styling for a property (which is
     * a CSS property or a className value) one by one. If map-based bindings
     * are present, then the flushing algorithm will keep calling the maps styling
     * sync function each time a property is visited. This way, the flushing
     * behavior of map-based bindings will always be at the same property level
     * as the current prop-based property being iterated over (because everything
     * is alphabetically sorted).
     *
     * Let's imagine we have the following HTML template code:
     *
     * ```html
     * <div [style]="{width:'100px', height:'200px', 'z-index':'10'}"
     *      [style.width.px]="200">...</div>
     * ```
     *
     * When CD occurs, both the `[style]` and `[style.width]` bindings
     * are evaluated. Then when the styles are flushed on screen, the
     * following operations happen:
     *
     * 1. `[style.width]` is attempted to be written to the element.
     *
     * 2.  Once that happens, the algorithm instructs the map-based
     *     entries (`[style]` in this case) to "catch up" and apply
     *     all values up to the `width` value. When this happens the
     *     `height` value is applied to the element (since it is
     *     alphabetically situated before the `width` property).
     *
     * 3. Since there are no more prop-based entries anymore, the
     *    loop exits and then, just before the flushing ends, it
     *    instructs all map-based bindings to "finish up" applying
     *    their values.
     *
     * 4. The only remaining value within the map-based entries is
     *    the `z-index` value (`width` got skipped because it was
     *    successfully applied via the prop-based `[style.width]`
     *    binding). Since all map-based entries are told to "finish up",
     *    the `z-index` value is iterated over and it is then applied
     *    to the element.
     *
     * The most important thing to take note of here is that prop-based
     * bindings are evaluated in order alongside map-based bindings.
     * This allows all styling across an element to be applied in O(n)
     * time (a similar algorithm is that of the array merge algorithm
     * in merge sort).
     * @type {?}
     */


    const syncStylingMap =
    /**
    * @param {?} context
    * @param {?} renderer
    * @param {?} element
    * @param {?} data
    * @param {?} applyStylingFn
    * @param {?} sanitizer
    * @param {?} mode
    * @param {?=} targetProp
    * @param {?=} defaultValue
    * @return {?}
    */
    (context, renderer, element, data, applyStylingFn, sanitizer, mode, targetProp, defaultValue) => {
      /** @type {?} */
      let targetPropValueWasApplied = false; // once the map-based styling code is activate it is never deactivated. For this reason a
      // check to see if the current styling context has any map based bindings is required.

      /** @type {?} */

      const totalMaps = getValuesCount(context, 3
      /* MapBindingsPosition */
      );

      if (totalMaps) {
        /** @type {?} */
        let runTheSyncAlgorithm = true;
        /** @type {?} */

        const loopUntilEnd = !targetProp; // If the code is told to finish up (run until the end), but the mode
        // hasn't been flagged to apply values (it only traverses values) then
        // there is no point in iterating over the array because nothing will
        // be applied to the element.

        if (loopUntilEnd && mode & ~1
        /* ApplyAllValues */
        ) {
          runTheSyncAlgorithm = false;
          targetPropValueWasApplied = true;
        }

        if (runTheSyncAlgorithm) {
          targetPropValueWasApplied = innerSyncStylingMap(context, renderer, element, data, applyStylingFn, sanitizer, mode, targetProp || null, 0, defaultValue || null);
        }

        if (loopUntilEnd) {
          resetSyncCursors();
        }
      }

      return targetPropValueWasApplied;
    };
    /**
     * Recursive function designed to apply map-based styling to an element one map at a time.
     *
     * This function is designed to be called from the `syncStylingMap` function and will
     * apply map-based styling data one map at a time to the provided `element`.
     *
     * This function is recursive and it will call itself if a follow-up map value is to be
     * processed. To learn more about how the algorithm works, see `syncStylingMap`.
     * @param {?} context
     * @param {?} renderer
     * @param {?} element
     * @param {?} data
     * @param {?} applyStylingFn
     * @param {?} sanitizer
     * @param {?} mode
     * @param {?} targetProp
     * @param {?} currentMapIndex
     * @param {?} defaultValue
     * @return {?}
     */


    function innerSyncStylingMap(context, renderer, element, data, applyStylingFn, sanitizer, mode, targetProp, currentMapIndex, defaultValue) {
      /** @type {?} */
      let targetPropValueWasApplied = false;
      /** @type {?} */

      const totalMaps = getValuesCount(context, 3
      /* MapBindingsPosition */
      );

      if (currentMapIndex < totalMaps) {
        /** @type {?} */
        const bindingIndex =
        /** @type {?} */
        getBindingValue(context, 3
        /* MapBindingsPosition */
        , currentMapIndex);
        /** @type {?} */

        const stylingMapArr =
        /** @type {?} */
        data[bindingIndex];
        /** @type {?} */

        let cursor = getCurrentSyncCursor(currentMapIndex);

        while (cursor < stylingMapArr.length) {
          /** @type {?} */
          const prop = getMapProp(stylingMapArr, cursor);
          /** @type {?} */

          const iteratedTooFar = targetProp && prop > targetProp;
          /** @type {?} */

          const isTargetPropMatched = !iteratedTooFar && prop === targetProp;
          /** @type {?} */

          const value = getMapValue(stylingMapArr, cursor);
          /** @type {?} */

          const valueIsDefined = isStylingValueDefined(value); // the recursive code is designed to keep applying until
          // it reaches or goes past the target prop. If and when
          // this happens then it will stop processing values, but
          // all other map values must also catch up to the same
          // point. This is why a recursive call is still issued
          // even if the code has iterated too far.

          /** @type {?} */

          const innerMode = iteratedTooFar ? mode : resolveInnerMapMode(mode, valueIsDefined, isTargetPropMatched);
          /** @type {?} */

          const innerProp = iteratedTooFar ? targetProp : prop;
          /** @type {?} */

          let valueApplied = innerSyncStylingMap(context, renderer, element, data, applyStylingFn, sanitizer, innerMode, innerProp, currentMapIndex + 1, defaultValue);

          if (iteratedTooFar) {
            if (!targetPropValueWasApplied) {
              targetPropValueWasApplied = valueApplied;
            }

            break;
          }

          if (!valueApplied && isValueAllowedToBeApplied(mode, isTargetPropMatched)) {
            /** @type {?} */
            const useDefault = isTargetPropMatched && !valueIsDefined;
            /** @type {?} */

            const valueToApply = useDefault ? defaultValue : value;
            /** @type {?} */

            const bindingIndexToApply = useDefault ? bindingIndex : null;
            /** @type {?} */

            const finalValue = sanitizer ? sanitizer(prop, valueToApply, 3
            /* ValidateAndSanitize */
            ) : valueToApply;
            applyStylingFn(renderer, element, prop, finalValue, bindingIndexToApply);
            valueApplied = true;
          }

          targetPropValueWasApplied = valueApplied && isTargetPropMatched;
          cursor += 2
          /* TupleSize */
          ;
        }

        setCurrentSyncCursor(currentMapIndex, cursor); // this is a fallback case in the event that the styling map is `null` for this
        // binding but there are other map-based bindings that need to be evaluated
        // afterwards. If the `prop` value is falsy then the intention is to cycle
        // through all of the properties in the remaining maps as well. If the current
        // styling map is too short then there are no values to iterate over. In either
        // case the follow-up maps need to be iterated over.

        if (stylingMapArr.length === 1
        /* ValuesStartPosition */
        || !targetProp) {
          return innerSyncStylingMap(context, renderer, element, data, applyStylingFn, sanitizer, mode, targetProp, currentMapIndex + 1, defaultValue);
        }
      }

      return targetPropValueWasApplied;
    }
    /**
     * Enables support for map-based styling bindings (e.g. `[style]` and `[class]` bindings).
     * @return {?}
     */


    function activateStylingMapFeature() {
      setStylingMapsSyncFn(syncStylingMap);
    }
    /**
     * Used to determine the mode for the inner recursive call.
     *
     * If an inner map is iterated on then this is done so for one
     * of two reasons:
     *
     * - value is being applied:
     *   if the value is being applied from this current styling
     *   map then there is no need to apply it in a deeper map.
     *
     * - value is being not applied:
     *   apply the value if it is found in a deeper map.
     *
     * When these reasons are encountered the flags will for the
     * inner map mode will be configured.
     * @param {?} currentMode
     * @param {?} valueIsDefined
     * @param {?} isExactMatch
     * @return {?}
     */


    function resolveInnerMapMode(currentMode, valueIsDefined, isExactMatch) {
      /** @type {?} */
      let innerMode = currentMode;

      if (!valueIsDefined && !(currentMode & 4
      /* SkipTargetProp */
      ) && (isExactMatch || currentMode & 1
      /* ApplyAllValues */
      )) {
        // case 1: set the mode to apply the targeted prop value if it
        // ends up being encountered in another map value
        innerMode |= 2
        /* ApplyTargetProp */
        ;
        innerMode &= ~4
        /* SkipTargetProp */
        ;
      } else {
        // case 2: set the mode to skip the targeted prop value if it
        // ends up being encountered in another map value
        innerMode |= 4
        /* SkipTargetProp */
        ;
        innerMode &= ~2
        /* ApplyTargetProp */
        ;
      }

      return innerMode;
    }
    /**
     * Decides whether or not a prop/value entry will be applied to an element.
     *
     * To determine whether or not a value is to be applied,
     * the following procedure is evaluated:
     *
     * First check to see the current `mode` status:
     *  1. If the mode value permits all props to be applied then allow.
     *    - But do not allow if the current prop is set to be skipped.
     *  2. Otherwise if the current prop is permitted then allow.
     * @param {?} mode
     * @param {?} isTargetPropMatched
     * @return {?}
     */


    function isValueAllowedToBeApplied(mode, isTargetPropMatched) {
      /** @type {?} */
      let doApplyValue = (mode & 1
      /* ApplyAllValues */
      ) > 0;

      if (!doApplyValue) {
        if (mode & 2
        /* ApplyTargetProp */
        ) {
            doApplyValue = isTargetPropMatched;
          }
      } else if (mode & 4
      /* SkipTargetProp */
      && isTargetPropMatched) {
        doApplyValue = false;
      }

      return doApplyValue;
    }
    /**
     * Used to keep track of concurrent cursor values for multiple map-based styling bindings present on
     * an element.
     * @type {?}
     */


    const MAP_CURSORS = [];
    /**
     * Used to reset the state of each cursor value being used to iterate over map-based styling
     * bindings.
     * @return {?}
     */

    function resetSyncCursors() {
      for (let i = 0; i < MAP_CURSORS.length; i++) {
        MAP_CURSORS[i] = 1
        /* ValuesStartPosition */
        ;
      }
    }
    /**
     * Returns an active cursor value at a given mapIndex location.
     * @param {?} mapIndex
     * @return {?}
     */


    function getCurrentSyncCursor(mapIndex) {
      if (mapIndex >= MAP_CURSORS.length) {
        MAP_CURSORS.push(1
        /* ValuesStartPosition */
        );
      }

      return MAP_CURSORS[mapIndex];
    }
    /**
     * Sets a cursor value at a given mapIndex location.
     * @param {?} mapIndex
     * @param {?} indexValue
     * @return {?}
     */


    function setCurrentSyncCursor(mapIndex, indexValue) {
      MAP_CURSORS[mapIndex] = indexValue;
    }
    /**
     * Used to convert a {key:value} map into a `StylingMapArray` array.
     *
     * This function will either generate a new `StylingMapArray` instance
     * or it will patch the provided `newValues` map value into an
     * existing `StylingMapArray` value (this only happens if `bindingValue`
     * is an instance of `StylingMapArray`).
     *
     * If a new key/value map is provided with an old `StylingMapArray`
     * value then all properties will be overwritten with their new
     * values or with `null`. This means that the array will never
     * shrink in size (but it will also not be created and thrown
     * away whenever the {key:value} map entries change).
     * @param {?} bindingValue
     * @param {?} newValues
     * @param {?=} normalizeProps
     * @return {?}
     */


    function normalizeIntoStylingMap(bindingValue, newValues, normalizeProps) {
      /** @type {?} */
      const stylingMapArr = Array.isArray(bindingValue) ? bindingValue : [null];
      stylingMapArr[0
      /* RawValuePosition */
      ] = newValues || null; // because the new values may not include all the properties
      // that the old ones had, all values are set to `null` before
      // the new values are applied. This way, when flushed, the
      // styling algorithm knows exactly what style/class values
      // to remove from the element (since they are `null`).

      for (let j = 1
      /* ValuesStartPosition */
      ; j < stylingMapArr.length; j += 2
      /* TupleSize */
      ) {
        setMapValue(stylingMapArr, j, null);
      }
      /** @type {?} */


      let props = null;
      /** @type {?} */

      let map;
      /** @type {?} */

      let allValuesTrue = false;

      if (typeof newValues === 'string') {
        // [class] bindings allow string values
        if (newValues.length) {
          props = newValues.split(/\s+/);
          allValuesTrue = true;
        }
      } else {
        props = newValues ? Object.keys(newValues) : null;
        map = newValues;
      }

      if (props) {
        for (let i = 0; i < props.length; i++) {
          /** @type {?} */
          const prop =
          /** @type {?} */
          props[i];
          /** @type {?} */

          const newProp = normalizeProps ? hyphenate(prop) : prop;
          /** @type {?} */

          const value = allValuesTrue ? true :
          /** @type {?} */
          map[prop];
          addItemToStylingMap(stylingMapArr, newProp, value, true);
        }
      }

      return stylingMapArr;
    }
    /**
     * Inserts the provided item into the provided styling array at the right spot.
     *
     * The `StylingMapArray` type is a sorted key/value array of entries. This means
     * that when a new entry is inserted it must be placed at the right spot in the
     * array. This function figures out exactly where to place it.
     * @param {?} stylingMapArr
     * @param {?} prop
     * @param {?} value
     * @param {?=} allowOverwrite
     * @return {?}
     */


    function addItemToStylingMap(stylingMapArr, prop, value, allowOverwrite) {
      for (let j = 1
      /* ValuesStartPosition */
      ; j < stylingMapArr.length; j += 2
      /* TupleSize */
      ) {
        /** @type {?} */
        const propAtIndex = getMapProp(stylingMapArr, j);

        if (prop <= propAtIndex) {
          /** @type {?} */
          let applied = false;

          if (propAtIndex === prop) {
            /** @type {?} */
            const valueAtIndex = stylingMapArr[j];

            if (allowOverwrite || !isStylingValueDefined(valueAtIndex)) {
              applied = true;
              setMapValue(stylingMapArr, j, value);
            }
          } else {
            applied = true;
            stylingMapArr.splice(j, 0, prop, value);
          }

          return applied;
        }
      }

      stylingMapArr.push(prop, value);
      return true;
    }
    /**
     * Converts the provided styling map array into a string.
     *
     * Classes => `one two three`
     * Styles => `prop:value; prop2:value2`
     * @param {?} map
     * @param {?} isClassBased
     * @return {?}
     */


    function stylingMapToString(map, isClassBased) {
      /** @type {?} */
      let str = '';

      for (let i = 1
      /* ValuesStartPosition */
      ; i < map.length; i += 2
      /* TupleSize */
      ) {
        /** @type {?} */
        const prop = getMapProp(map, i);
        /** @type {?} */

        const value =
        /** @type {?} */
        getMapValue(map, i);
        /** @type {?} */

        const attrValue = concatString(prop, isClassBased ? '' : value, ':');
        str = concatString(str, attrValue, isClassBased ? ' ' : '; ');
      }

      return str;
    }
    /**
     * Converts the provided styling map array into a key value map.
     * @param {?} map
     * @return {?}
     */


    function stylingMapToStringMap(map) {
      /** @type {?} */
      let stringMap = {};

      if (map) {
        for (let i = 1
        /* ValuesStartPosition */
        ; i < map.length; i += 2
        /* TupleSize */
        ) {
          /** @type {?} */
          const prop = getMapProp(map, i);
          /** @type {?} */

          const value =
          /** @type {?} */
          getMapValue(map, i);
          stringMap[prop] = value;
        }
      }

      return stringMap;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * A debug/testing-oriented summary of a styling entry.
     *
     * A value such as this is generated as an artifact of the `DebugStyling`
     * summary.
     * @record
     */


    function LStylingSummary() {}

    if (false) {}
    /**
     * A debug/testing-oriented summary of all styling entries for a `DebugNode` instance.
     * @record
     */


    function DebugStyling() {}

    if (false) {}
    /**
     * A debug/testing-oriented summary of all styling entries within a `TStylingContext`.
     * @record
     */


    function TStylingTupleSummary() {}

    if (false) {}
    /**
     * Instantiates and attaches an instance of `TStylingContextDebug` to the provided context.
     * @param {?} context
     * @return {?}
     */


    function attachStylingDebugObject(context) {
      /** @type {?} */
      const debug = new TStylingContextDebug(context);
      attachDebugObject(context, debug);
      return debug;
    }
    /**
     * A human-readable debug summary of the styling data present within `TStylingContext`.
     *
     * This class is designed to be used within testing code or when an
     * application has `ngDevMode` activated.
     */


    class TStylingContextDebug {
      /**
       * @param {?} context
       */
      constructor(context) {
        this.context = context;
      }
      /**
       * @return {?}
       */


      get isLocked() {
        return isContextLocked(this.context);
      }
      /**
       * Returns a detailed summary of each styling entry in the context.
       *
       * See `TStylingTupleSummary`.
       * @return {?}
       */


      get entries() {
        /** @type {?} */
        const context = this.context;
        /** @type {?} */

        const entries = {};
        /** @type {?} */

        const start = 3
        /* MapBindingsPosition */
        ;
        /** @type {?} */

        let i = start;

        while (i < context.length) {
          /** @type {?} */
          const valuesCount = getValuesCount(context, i); // the context may contain placeholder values which are populated ahead of time,
          // but contain no actual binding values. In this situation there is no point in
          // classifying this as an "entry" since no real data is stored here yet.

          if (valuesCount) {
            /** @type {?} */
            const prop = getProp(context, i);
            /** @type {?} */

            const guardMask = getGuardMask(context, i);
            /** @type {?} */

            const defaultValue = getDefaultValue(context, i);
            /** @type {?} */

            const sanitizationRequired = isSanitizationRequired(context, i);
            /** @type {?} */

            const bindingsStartPosition = i + 3
            /* BindingsStartOffset */
            ;
            /** @type {?} */

            const sources = [];

            for (let j = 0; j < valuesCount; j++) {
              sources.push(
              /** @type {?} */
              context[bindingsStartPosition + j]);
            }

            entries[prop] = {
              prop,
              guardMask,
              sanitizationRequired,
              valuesCount,
              defaultValue,
              sources
            };
          }

          i += 3
          /* BindingsStartOffset */
          + valuesCount;
        }

        return entries;
      }

    }

    if (false) {}
    /**
     * A human-readable debug summary of the styling data present for a `DebugNode` instance.
     *
     * This class is designed to be used within testing code or when an
     * application has `ngDevMode` activated.
     */


    class NodeStylingDebug {
      /**
       * @param {?} context
       * @param {?} _data
       * @param {?=} _isClassBased
       */
      constructor(context, _data, _isClassBased) {
        this.context = context;
        this._data = _data;
        this._isClassBased = _isClassBased;
        this._sanitizer = null;
      }
      /**
       * Overrides the sanitizer used to process styles.
       * @param {?} sanitizer
       * @return {?}
       */


      overrideSanitizer(sanitizer) {
        this._sanitizer = sanitizer;
      }
      /**
       * Returns a detailed summary of each styling entry in the context and
       * what their runtime representation is.
       *
       * See `LStylingSummary`.
       * @return {?}
       */


      get summary() {
        /** @type {?} */
        const entries = {};

        this._mapValues(
        /**
        * @param {?} prop
        * @param {?} value
        * @param {?} bindingIndex
        * @return {?}
        */
        (prop, value, bindingIndex) => {
          entries[prop] = {
            prop,
            value,
            bindingIndex
          };
        });

        return entries;
      }
      /**
       * Returns a key/value map of all the styles/classes that were last applied to the element.
       * @return {?}
       */


      get values() {
        /** @type {?} */
        const entries = {};

        this._mapValues(
        /**
        * @param {?} prop
        * @param {?} value
        * @return {?}
        */
        (prop, value) => {
          entries[prop] = value;
        });

        return entries;
      }
      /**
       * @private
       * @param {?} fn
       * @return {?}
       */


      _mapValues(fn) {
        // there is no need to store/track an element instance. The
        // element is only used when the styling algorithm attempts to
        // style the value (and we mock out the stylingApplyFn anyway).

        /** @type {?} */
        const mockElement =
        /** @type {?} */
        {};
        /** @type {?} */

        const hasMaps = getValuesCount(this.context, 3
        /* MapBindingsPosition */
        ) > 0;

        if (hasMaps) {
          activateStylingMapFeature();
        }
        /** @type {?} */


        const mapFn =
        /**
        * @param {?} renderer
        * @param {?} element
        * @param {?} prop
        * @param {?} value
        * @param {?=} bindingIndex
        * @return {?}
        */
        (renderer, element, prop, value, bindingIndex) => {
          fn(prop, value, bindingIndex || null);
        };
        /** @type {?} */


        const sanitizer = this._isClassBased ? null : this._sanitizer || getCurrentStyleSanitizer();
        applyStyling(this.context, null, mockElement, this._data, true, mapFn, sanitizer);
      }

    }

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /*
     * This file contains conditionally attached classes which provide human readable (debug) level
     * information for `LView`, `LContainer` and other internal data structures. These data structures
     * are stored internally as array which makes it very difficult during debugging to reason about the
     * current state of the system.
     *
     * Patching the array with extra property does change the array's hidden class' but it does not
     * change the cost of access, therefore this patching should not have significant if any impact in
     * `ngDevMode` mode. (see: https://jsperf.com/array-vs-monkey-patch-array)
     *
     * So instead of seeing:
     * ```
     * Array(30) [Object, 659, null, …]
     * ```
     *
     * You get to see:
     * ```
     * LViewDebug {
     *   views: [...],
     *   flags: {attached: true, ...}
     *   nodes: [
     *     {html: '<div id="123">', ..., nodes: [
     *       {html: '<span>', ..., nodes: null}
     *     ]}
     *   ]
     * }
     * ```
     */

    /** @type {?} */


    const LViewArray = ngDevMode && createNamedArrayType('LView');
    /** @type {?} */

    let LVIEW_EMPTY; // can't initialize here or it will not be tree shaken, because `LView`
    // constructor could have side-effects.

    /**
     * This function clones a blueprint and creates LView.
     *
     * Simple slice will keep the same type, and we need it to be LView
     * @param {?} list
     * @return {?}
     */

    function cloneToLView(list) {
      if (LVIEW_EMPTY === undefined) LVIEW_EMPTY = new
      /** @type {?} */
      LViewArray();
      return (
        /** @type {?} */
        LVIEW_EMPTY.concat(list)
      );
    }
    /**
     * This class is a debug version of Object literal so that we can have constructor name show up in
     * debug tools in ngDevMode.
     * @type {?}
     */


    const TViewConstructor = class TView {
      /**
       * @param {?} id
       * @param {?} blueprint
       * @param {?} template
       * @param {?} queries
       * @param {?} viewQuery
       * @param {?} node
       * @param {?} data
       * @param {?} bindingStartIndex
       * @param {?} expandoStartIndex
       * @param {?} expandoInstructions
       * @param {?} firstTemplatePass
       * @param {?} staticViewQueries
       * @param {?} staticContentQueries
       * @param {?} preOrderHooks
       * @param {?} preOrderCheckHooks
       * @param {?} contentHooks
       * @param {?} contentCheckHooks
       * @param {?} viewHooks
       * @param {?} viewCheckHooks
       * @param {?} destroyHooks
       * @param {?} cleanup
       * @param {?} contentQueries
       * @param {?} components
       * @param {?} directiveRegistry
       * @param {?} pipeRegistry
       * @param {?} firstChild
       * @param {?} schemas
       */
      constructor(id, //
      blueprint, //
      template, //
      queries, //
      viewQuery, //
      node, //
      data, //
      bindingStartIndex, //
      expandoStartIndex, //
      expandoInstructions, //
      firstTemplatePass, //
      staticViewQueries, //
      staticContentQueries, //
      preOrderHooks, //
      preOrderCheckHooks, //
      contentHooks, //
      contentCheckHooks, //
      viewHooks, //
      viewCheckHooks, //
      destroyHooks, //
      cleanup, //
      contentQueries, //
      components, //
      directiveRegistry, //
      pipeRegistry, //
      firstChild, //
      schemas) {
        this.id = id;
        this.blueprint = blueprint;
        this.template = template;
        this.queries = queries;
        this.viewQuery = viewQuery;
        this.node = node;
        this.data = data;
        this.bindingStartIndex = bindingStartIndex;
        this.expandoStartIndex = expandoStartIndex;
        this.expandoInstructions = expandoInstructions;
        this.firstTemplatePass = firstTemplatePass;
        this.staticViewQueries = staticViewQueries;
        this.staticContentQueries = staticContentQueries;
        this.preOrderHooks = preOrderHooks;
        this.preOrderCheckHooks = preOrderCheckHooks;
        this.contentHooks = contentHooks;
        this.contentCheckHooks = contentCheckHooks;
        this.viewHooks = viewHooks;
        this.viewCheckHooks = viewCheckHooks;
        this.destroyHooks = destroyHooks;
        this.cleanup = cleanup;
        this.contentQueries = contentQueries;
        this.components = components;
        this.directiveRegistry = directiveRegistry;
        this.pipeRegistry = pipeRegistry;
        this.firstChild = firstChild;
        this.schemas = schemas;
      }

    };
    /** @type {?} */

    const TNodeConstructor = class TNode {
      /**
       * @param {?} tView_
       * @param {?} type
       * @param {?} index
       * @param {?} injectorIndex
       * @param {?} directiveStart
       * @param {?} directiveEnd
       * @param {?} propertyMetadataStartIndex
       * @param {?} propertyMetadataEndIndex
       * @param {?} flags
       * @param {?} providerIndexes
       * @param {?} tagName
       * @param {?} attrs
       * @param {?} localNames
       * @param {?} initialInputs
       * @param {?} inputs
       * @param {?} outputs
       * @param {?} tViews
       * @param {?} next
       * @param {?} projectionNext
       * @param {?} child
       * @param {?} parent
       * @param {?} projection
       * @param {?} styles
       * @param {?} classes
       */
      constructor(tView_, //
      type, //
      index, //
      injectorIndex, //
      directiveStart, //
      directiveEnd, //
      propertyMetadataStartIndex, //
      propertyMetadataEndIndex, //
      flags, //
      providerIndexes, //
      tagName, //
      attrs, //
      localNames, //
      initialInputs, //
      inputs, //
      outputs, //
      tViews, //
      next, //
      projectionNext, //
      child, //
      parent, //
      projection, //
      styles, //
      classes) {
        this.tView_ = tView_;
        this.type = type;
        this.index = index;
        this.injectorIndex = injectorIndex;
        this.directiveStart = directiveStart;
        this.directiveEnd = directiveEnd;
        this.propertyMetadataStartIndex = propertyMetadataStartIndex;
        this.propertyMetadataEndIndex = propertyMetadataEndIndex;
        this.flags = flags;
        this.providerIndexes = providerIndexes;
        this.tagName = tagName;
        this.attrs = attrs;
        this.localNames = localNames;
        this.initialInputs = initialInputs;
        this.inputs = inputs;
        this.outputs = outputs;
        this.tViews = tViews;
        this.next = next;
        this.projectionNext = projectionNext;
        this.child = child;
        this.parent = parent;
        this.projection = projection;
        this.styles = styles;
        this.classes = classes;
      }
      /**
       * @return {?}
       */


      get type_() {
        switch (this.type) {
          case 0
          /* Container */
          :
            return 'TNodeType.Container';

          case 3
          /* Element */
          :
            return 'TNodeType.Element';

          case 4
          /* ElementContainer */
          :
            return 'TNodeType.ElementContainer';

          case 5
          /* IcuContainer */
          :
            return 'TNodeType.IcuContainer';

          case 1
          /* Projection */
          :
            return 'TNodeType.Projection';

          case 2
          /* View */
          :
            return 'TNodeType.View';

          default:
            return 'TNodeType.???';
        }
      }
      /**
       * @return {?}
       */


      get flags_() {
        /** @type {?} */
        const flags = [];
        if (this.flags & 8
        /* hasClassInput */
        ) flags.push('TNodeFlags.hasClassInput');
        if (this.flags & 4
        /* hasContentQuery */
        ) flags.push('TNodeFlags.hasContentQuery');
        if (this.flags & 16
        /* hasStyleInput */
        ) flags.push('TNodeFlags.hasStyleInput');
        if (this.flags & 1
        /* isComponent */
        ) flags.push('TNodeFlags.isComponent');
        if (this.flags & 32
        /* isDetached */
        ) flags.push('TNodeFlags.isDetached');
        if (this.flags & 2
        /* isProjected */
        ) flags.push('TNodeFlags.isProjected');
        return flags.join('|');
      }

    };
    /** @type {?} */

    const TViewData = ngDevMode && createNamedArrayType('TViewData');
    /** @type {?} */

    let TVIEWDATA_EMPTY; // can't initialize here or it will not be tree shaken, because `LView`
    // constructor could have side-effects.

    /**
     * This function clones a blueprint and creates TData.
     *
     * Simple slice will keep the same type, and we need it to be TData
     * @param {?} list
     * @return {?}
     */

    function cloneToTViewData(list) {
      if (TVIEWDATA_EMPTY === undefined) TVIEWDATA_EMPTY = new
      /** @type {?} */
      TViewData();
      return (
        /** @type {?} */
        TVIEWDATA_EMPTY.concat(list)
      );
    }
    /** @type {?} */


    const LViewBlueprint = ngDevMode && createNamedArrayType('LViewBlueprint');
    /** @type {?} */

    const MatchesArray = ngDevMode && createNamedArrayType('MatchesArray');
    /** @type {?} */

    const TViewComponents = ngDevMode && createNamedArrayType('TViewComponents');
    /** @type {?} */

    const TNodeLocalNames = ngDevMode && createNamedArrayType('TNodeLocalNames');
    /** @type {?} */

    const TNodeInitialInputs = ngDevMode && createNamedArrayType('TNodeInitialInputs');
    /** @type {?} */

    const TNodeInitialData = ngDevMode && createNamedArrayType('TNodeInitialData');
    /** @type {?} */

    const LCleanup = ngDevMode && createNamedArrayType('LCleanup');
    /** @type {?} */

    const TCleanup = ngDevMode && createNamedArrayType('TCleanup');
    /**
     * @param {?} lView
     * @return {?}
     */

    function attachLViewDebug(lView) {
      attachDebugObject(lView, new LViewDebug(lView));
    }
    /**
     * @param {?} lContainer
     * @return {?}
     */


    function attachLContainerDebug(lContainer) {
      attachDebugObject(lContainer, new LContainerDebug(lContainer));
    }
    /**
     * @param {?} obj
     * @return {?}
     */


    function toDebug(obj) {
      if (obj) {
        /** @type {?} */
        const debug =
        /** @type {?} */
        obj.debug;
        assertDefined(debug, 'Object does not have a debug representation.');
        return debug;
      } else {
        return obj;
      }
    }
    /**
     * Use this method to unwrap a native element in `LView` and convert it into HTML for easier
     * reading.
     *
     * @param {?} value possibly wrapped native DOM node.
     * @param {?=} includeChildren If `true` then the serialized HTML form will include child elements (same
     * as `outerHTML`). If `false` then the serialized HTML form will only contain the element itself
     * (will not serialize child elements).
     * @return {?}
     */


    function toHtml(value, includeChildren = false) {
      /** @type {?} */
      const node =
      /** @type {?} */
      unwrapRNode(value);

      if (node) {
        /** @type {?} */
        const isTextNode = node.nodeType === Node.TEXT_NODE;
        /** @type {?} */

        const outerHTML = (isTextNode ? node.textContent : node.outerHTML) || '';

        if (includeChildren || isTextNode) {
          return outerHTML;
        } else {
          /** @type {?} */
          const innerHTML = node.innerHTML;
          return outerHTML.split(innerHTML)[0] || null;
        }
      } else {
        return null;
      }
    }

    class LViewDebug {
      /**
       * @param {?} _raw_lView
       */
      constructor(_raw_lView) {
        this._raw_lView = _raw_lView;
      }
      /**
       * Flags associated with the `LView` unpacked into a more readable state.
       * @return {?}
       */


      get flags() {
        /** @type {?} */
        const flags = this._raw_lView[FLAGS];
        return {
          __raw__flags__: flags,
          initPhaseState: flags & 3
          /* InitPhaseStateMask */
          ,
          creationMode: !!(flags & 4
          /* CreationMode */
          ),
          firstViewPass: !!(flags & 8
          /* FirstLViewPass */
          ),
          checkAlways: !!(flags & 16
          /* CheckAlways */
          ),
          dirty: !!(flags & 64
          /* Dirty */
          ),
          attached: !!(flags & 128
          /* Attached */
          ),
          destroyed: !!(flags & 256
          /* Destroyed */
          ),
          isRoot: !!(flags & 512
          /* IsRoot */
          ),
          indexWithinInitPhase: flags >> 10
          /* IndexWithinInitPhaseShift */

        };
      }
      /**
       * @return {?}
       */


      get parent() {
        return toDebug(this._raw_lView[PARENT]);
      }
      /**
       * @return {?}
       */


      get host() {
        return toHtml(this._raw_lView[HOST], true);
      }
      /**
       * @return {?}
       */


      get context() {
        return this._raw_lView[CONTEXT];
      }
      /**
       * The tree of nodes associated with the current `LView`. The nodes have been normalized into a
       * tree structure with relevant details pulled out for readability.
       * @return {?}
       */


      get nodes() {
        /** @type {?} */
        const lView = this._raw_lView;
        /** @type {?} */

        const tNode = lView[TVIEW].firstChild;
        return toDebugNodes(tNode, lView);
      }
      /**
       * Additional information which is hidden behind a property. The extra level of indirection is
       * done so that the debug view would not be cluttered with properties which are only rarely
       * relevant to the developer.
       * @return {?}
       */


      get __other__() {
        return {
          tView: this._raw_lView[TVIEW],
          cleanup: this._raw_lView[CLEANUP],
          injector: this._raw_lView[INJECTOR$1],
          rendererFactory: this._raw_lView[RENDERER_FACTORY],
          renderer: this._raw_lView[RENDERER],
          sanitizer: this._raw_lView[SANITIZER],
          childHead: toDebug(this._raw_lView[CHILD_HEAD]),
          next: toDebug(this._raw_lView[NEXT]),
          childTail: toDebug(this._raw_lView[CHILD_TAIL]),
          declarationView: toDebug(this._raw_lView[DECLARATION_VIEW]),
          queries: null,
          tHost: this._raw_lView[T_HOST],
          bindingIndex: this._raw_lView[BINDING_INDEX]
        };
      }
      /**
       * Normalized view of child views (and containers) attached at this location.
       * @return {?}
       */


      get childViews() {
        /** @type {?} */
        const childViews = [];
        /** @type {?} */

        let child = this.__other__.childHead;

        while (child) {
          childViews.push(child);
          child = child.__other__.next;
        }

        return childViews;
      }

    }

    if (false) {}
    /**
     * @record
     */


    function DebugNode() {}

    if (false) {}
    /**
     * Turns a flat list of nodes into a tree by walking the associated `TNode` tree.
     *
     * @param {?} tNode
     * @param {?} lView
     * @return {?}
     */


    function toDebugNodes(tNode, lView) {
      if (tNode) {
        /** @type {?} */
        const debugNodes = [];
        /** @type {?} */

        let tNodeCursor = tNode;

        while (tNodeCursor) {
          /** @type {?} */
          const rawValue = lView[tNode.index];
          /** @type {?} */

          const native = unwrapRNode(rawValue);
          /** @type {?} */

          const componentLViewDebug = toDebug(readLViewValue(rawValue));
          /** @type {?} */

          const styles = isStylingContext(tNode.styles) ? new NodeStylingDebug(
          /** @type {?} */

          /** @type {?} */
          tNode.styles, lView) : null;
          /** @type {?} */

          const classes = isStylingContext(tNode.classes) ? new NodeStylingDebug(
          /** @type {?} */

          /** @type {?} */
          tNode.classes, lView, true) : null;
          debugNodes.push({
            html: toHtml(native),
            native:
            /** @type {?} */
            native,
            styles,
            classes,
            nodes: toDebugNodes(tNode.child, lView),
            component: componentLViewDebug
          });
          tNodeCursor = tNodeCursor.next;
        }

        return debugNodes;
      } else {
        return null;
      }
    }

    class LContainerDebug {
      /**
       * @param {?} _raw_lContainer
       */
      constructor(_raw_lContainer) {
        this._raw_lContainer = _raw_lContainer;
      }
      /**
       * @return {?}
       */


      get activeIndex() {
        return this._raw_lContainer[ACTIVE_INDEX];
      }
      /**
       * @return {?}
       */


      get views() {
        return this._raw_lContainer.slice(CONTAINER_HEADER_OFFSET).map(
        /** @type {?} */
        toDebug);
      }
      /**
       * @return {?}
       */


      get parent() {
        return toDebug(this._raw_lContainer[PARENT]);
      }
      /**
       * @return {?}
       */


      get movedViews() {
        return this._raw_lContainer[MOVED_VIEWS];
      }
      /**
       * @return {?}
       */


      get host() {
        return this._raw_lContainer[HOST];
      }
      /**
       * @return {?}
       */


      get native() {
        return this._raw_lContainer[NATIVE];
      }
      /**
       * @return {?}
       */


      get __other__() {
        return {
          next: toDebug(this._raw_lContainer[NEXT])
        };
      }

    }

    if (false) {}
    /**
     * Return an `LView` value if found.
     *
     * @param {?} value `LView` if any
     * @return {?}
     */


    function readLViewValue(value) {
      while (Array.isArray(value)) {
        // This check is not quite right, as it does not take into account `StylingContext`
        // This is why it is in debug, not in util.ts
        if (value.length >= HEADER_OFFSET - 1) return (
          /** @type {?} */
          value
        );
        value = value[HOST];
      }

      return null;
    }

    class I18NDebugItem {
      /**
       * @param {?} __raw_opCode
       * @param {?} _lView
       * @param {?} nodeIndex
       * @param {?} type
       */
      constructor(__raw_opCode, _lView, nodeIndex, type) {
        this.__raw_opCode = __raw_opCode;
        this._lView = _lView;
        this.nodeIndex = nodeIndex;
        this.type = type;
      }
      /**
       * @return {?}
       */


      get tNode() {
        return getTNode(this.nodeIndex, this._lView);
      }

    }

    if (false) {}
    /**
     * Turns a list of "Create" & "Update" OpCodes into a human-readable list of operations for
     * debugging purposes.
     * @param {?} mutateOpCodes mutation opCodes to read
     * @param {?} updateOpCodes update opCodes to read
     * @param {?} icus list of ICU expressions
     * @param {?} lView The view the opCodes are acting on
     * @return {?}
     */


    function attachI18nOpCodesDebug(mutateOpCodes, updateOpCodes, icus, lView) {
      attachDebugObject(mutateOpCodes, new I18nMutateOpCodesDebug(mutateOpCodes, lView));
      attachDebugObject(updateOpCodes, new I18nUpdateOpCodesDebug(updateOpCodes, icus, lView));

      if (icus) {
        icus.forEach(
        /**
        * @param {?} icu
        * @return {?}
        */
        icu => {
          icu.create.forEach(
          /**
          * @param {?} icuCase
          * @return {?}
          */
          icuCase => {
            attachDebugObject(icuCase, new I18nMutateOpCodesDebug(icuCase, lView));
          });
          icu.update.forEach(
          /**
          * @param {?} icuCase
          * @return {?}
          */
          icuCase => {
            attachDebugObject(icuCase, new I18nUpdateOpCodesDebug(icuCase, icus, lView));
          });
        });
      }
    }

    class I18nMutateOpCodesDebug {
      /**
       * @param {?} __raw_opCodes
       * @param {?} __lView
       */
      constructor(__raw_opCodes, __lView) {
        this.__raw_opCodes = __raw_opCodes;
        this.__lView = __lView;
      }
      /**
       * A list of operation information about how the OpCodes will act on the view.
       * @return {?}
       */


      get operations() {
        const {
          __lView,
          __raw_opCodes
        } = this;
        /** @type {?} */

        const results = [];

        for (let i = 0; i < __raw_opCodes.length; i++) {
          /** @type {?} */
          const opCode = __raw_opCodes[i];
          /** @type {?} */

          let result;

          if (typeof opCode === 'string') {
            result = {
              __raw_opCode: opCode,
              type: 'Create Text Node',
              nodeIndex: __raw_opCodes[++i],
              text: opCode
            };
          }

          if (typeof opCode === 'number') {
            switch (opCode & 7
            /* MASK_OPCODE */
            ) {
              case 1
              /* AppendChild */
              :
                /** @type {?} */
                const destinationNodeIndex = opCode >>> 17
                /* SHIFT_PARENT */
                ;
                result = new I18NDebugItem(opCode, __lView, destinationNodeIndex, 'AppendChild');
                break;

              case 0
              /* Select */
              :
                /** @type {?} */
                const nodeIndex = opCode >>> 3
                /* SHIFT_REF */
                ;
                result = new I18NDebugItem(opCode, __lView, nodeIndex, 'Select');
                break;

              case 5
              /* ElementEnd */
              :
                /** @type {?} */
                let elementIndex = opCode >>> 3
                /* SHIFT_REF */
                ;
                result = new I18NDebugItem(opCode, __lView, elementIndex, 'ElementEnd');
                break;

              case 4
              /* Attr */
              :
                elementIndex = opCode >>> 3
                /* SHIFT_REF */
                ;
                result = new I18NDebugItem(opCode, __lView, elementIndex, 'Attr');
                result['attrName'] = __raw_opCodes[++i];
                result['attrValue'] = __raw_opCodes[++i];
                break;
            }
          }

          if (!result) {
            switch (opCode) {
              case COMMENT_MARKER:
                result = {
                  __raw_opCode: opCode,
                  type: 'COMMENT_MARKER',
                  commentValue: __raw_opCodes[++i],
                  nodeIndex: __raw_opCodes[++i]
                };
                break;

              case ELEMENT_MARKER:
                result = {
                  __raw_opCode: opCode,
                  type: 'ELEMENT_MARKER'
                };
                break;
            }
          }

          if (!result) {
            result = {
              __raw_opCode: opCode,
              type: 'Unknown Op Code',
              code: opCode
            };
          }

          results.push(result);
        }

        return results;
      }

    }

    if (false) {}

    class I18nUpdateOpCodesDebug {
      /**
       * @param {?} __raw_opCodes
       * @param {?} icus
       * @param {?} __lView
       */
      constructor(__raw_opCodes, icus, __lView) {
        this.__raw_opCodes = __raw_opCodes;
        this.icus = icus;
        this.__lView = __lView;
      }
      /**
       * A list of operation information about how the OpCodes will act on the view.
       * @return {?}
       */


      get operations() {
        const {
          __lView,
          __raw_opCodes,
          icus
        } = this;
        /** @type {?} */

        const results = [];

        for (let i = 0; i < __raw_opCodes.length; i++) {
          // bit code to check if we should apply the next update

          /** @type {?} */
          const checkBit =
          /** @type {?} */
          __raw_opCodes[i]; // Number of opCodes to skip until next set of update codes

          /** @type {?} */

          const skipCodes =
          /** @type {?} */
          __raw_opCodes[++i];
          /** @type {?} */

          let value = '';

          for (let j = i + 1; j <= i + skipCodes; j++) {
            /** @type {?} */
            const opCode = __raw_opCodes[j];

            if (typeof opCode === 'string') {
              value += opCode;
            } else if (typeof opCode == 'number') {
              if (opCode < 0) {
                // It's a binding index whose value is negative
                // We cannot know the value of the binding so we only show the index
                value += "\uFFFD".concat(-opCode - 1, "\uFFFD");
              } else {
                /** @type {?} */
                const nodeIndex = opCode >>> 2
                /* SHIFT_REF */
                ;
                /** @type {?} */

                let tIcuIndex;
                /** @type {?} */

                let tIcu;

                switch (opCode & 3
                /* MASK_OPCODE */
                ) {
                  case 1
                  /* Attr */
                  :
                    /** @type {?} */
                    const attrName =
                    /** @type {?} */
                    __raw_opCodes[++j];
                    /** @type {?} */

                    const sanitizeFn = __raw_opCodes[++j];
                    results.push({
                      __raw_opCode: opCode,
                      checkBit,
                      type: 'Attr',
                      attrValue: value,
                      attrName,
                      sanitizeFn
                    });
                    break;

                  case 0
                  /* Text */
                  :
                    results.push({
                      __raw_opCode: opCode,
                      checkBit,
                      type: 'Text',
                      nodeIndex,
                      text: value
                    });
                    break;

                  case 2
                  /* IcuSwitch */
                  :
                    tIcuIndex =
                    /** @type {?} */
                    __raw_opCodes[++j];
                    tIcu =
                    /** @type {?} */
                    icus[tIcuIndex];
                    /** @type {?} */

                    let result = new I18NDebugItem(opCode, __lView, nodeIndex, 'IcuSwitch');
                    result['tIcuIndex'] = tIcuIndex;
                    result['checkBit'] = checkBit;
                    result['mainBinding'] = value;
                    result['tIcu'] = tIcu;
                    results.push(result);
                    break;

                  case 3
                  /* IcuUpdate */
                  :
                    tIcuIndex =
                    /** @type {?} */
                    __raw_opCodes[++j];
                    tIcu =
                    /** @type {?} */
                    icus[tIcuIndex];
                    result = new I18NDebugItem(opCode, __lView, nodeIndex, 'IcuUpdate');
                    result['tIcuIndex'] = tIcuIndex;
                    result['checkBit'] = checkBit;
                    result['tIcu'] = tIcu;
                    results.push(result);
                    break;
                }
              }
            }
          }

          i += skipCodes;
        }

        return results;
      }

    }

    if (false) {}
    /**
     * @record
     */


    function I18nOpCodesDebug() {}

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Selects an element for later binding instructions.
     *
     * Used in conjunction with instructions like {\@link property} to act on elements with specified
     * indices, for example those created with {\@link element} or {\@link elementStart}.
     *
     * ```ts
     * (rf: RenderFlags, ctx: any) => {
     *   if (rf & 1) {
     *     element(0, 'div');
     *   }
     *   if (rf & 2) {
     *     select(0); // Select the <div/> created above.
     *     property('title', 'test');
     *   }
     *  }
     * ```
     * \@codeGenApi
     * @param {?} index the index of the item to act on with the following instructions
     *
     * @return {?}
     */


    function ɵɵselect(index) {
      ngDevMode && assertGreaterThan(index, -1, 'Invalid index');
      ngDevMode && assertLessThan(index, getLView().length - HEADER_OFFSET, 'Should be within range for the view data');
      /** @type {?} */

      const lView = getLView();
      selectInternal(lView, index);
    }
    /**
     * @param {?} lView
     * @param {?} index
     * @return {?}
     */


    function selectInternal(lView, index) {
      // Flush the initial hooks for elements in the view that have been added up to this point.
      executePreOrderHooks(lView, lView[TVIEW], getCheckNoChangesMode(), index); // We must set the selected index *after* running the hooks, because hooks may have side-effects
      // that cause other template functions to run, thus updating the selected index, which is global
      // state. If we run `setSelectedIndex` *before* we run the hooks, in some cases the selected index
      // will be altered by the time we leave the `ɵɵselect` instruction.

      setSelectedIndex(index);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    const ɵ0$5 =
    /**
    * @return {?}
    */
    () => Promise.resolve(null);
    /**
     * A permanent marker promise which signifies that the current CD tree is
     * clean.
     * @type {?}
     */


    const _CLEAN_PROMISE = ɵ0$5();
    /** @enum {number} */


    const BindingDirection = {
      Input: 0,
      Output: 1
    };
    /**
     * Refreshes the view, executing the following steps in that order:
     * triggers init hooks, refreshes dynamic embedded views, triggers content hooks, sets host
     * bindings, refreshes child components.
     * Note: view hooks are triggered later when leaving the view.
     * @param {?} lView
     * @return {?}
     */

    function refreshDescendantViews(lView) {
      /** @type {?} */
      const tView = lView[TVIEW];
      /** @type {?} */

      const creationMode = isCreationMode(lView); // This needs to be set before children are processed to support recursive components

      tView.firstTemplatePass = false; // Resetting the bindingIndex of the current LView as the next steps may trigger change detection.

      lView[BINDING_INDEX] = tView.bindingStartIndex; // If this is a creation pass, we should not call lifecycle hooks or evaluate bindings.
      // This will be done in the update pass.

      if (!creationMode) {
        /** @type {?} */
        const checkNoChangesMode = getCheckNoChangesMode();
        executePreOrderHooks(lView, tView, checkNoChangesMode, undefined);
        refreshDynamicEmbeddedViews(lView); // Content query results must be refreshed before content hooks are called.

        refreshContentQueries(tView, lView);
        resetPreOrderHookFlags(lView);
        executeHooks(lView, tView.contentHooks, tView.contentCheckHooks, checkNoChangesMode, 1
        /* AfterContentInitHooksToBeRun */
        , undefined);
        setHostBindings(tView, lView);
      } // We resolve content queries specifically marked as `static` in creation mode. Dynamic
      // content queries are resolved during change detection (i.e. update mode), after embedded
      // views are refreshed (see block above).


      if (creationMode && tView.staticContentQueries) {
        refreshContentQueries(tView, lView);
      } // We must materialize query results before child components are processed
      // in case a child component has projected a container. The LContainer needs
      // to exist so the embedded views are properly attached by the container.


      if (!creationMode || tView.staticViewQueries) {
        executeViewQueryFn(2
        /* Update */
        , tView, lView[CONTEXT]);
      }

      refreshChildComponents(lView, tView.components);
    }
    /**
     * Sets the host bindings for the current view.
     * @param {?} tView
     * @param {?} viewData
     * @return {?}
     */


    function setHostBindings(tView, viewData) {
      /** @type {?} */
      const selectedIndex = getSelectedIndex();

      try {
        if (tView.expandoInstructions) {
          /** @type {?} */
          let bindingRootIndex = viewData[BINDING_INDEX] = tView.expandoStartIndex;
          setBindingRoot(bindingRootIndex);
          /** @type {?} */

          let currentDirectiveIndex = -1;
          /** @type {?} */

          let currentElementIndex = -1;

          for (let i = 0; i < tView.expandoInstructions.length; i++) {
            /** @type {?} */
            const instruction = tView.expandoInstructions[i];

            if (typeof instruction === 'number') {
              if (instruction <= 0) {
                // Negative numbers mean that we are starting new EXPANDO block and need to update
                // the current element and directive index.
                currentElementIndex = -instruction;
                setActiveHostElement(currentElementIndex); // Injector block and providers are taken into account.

                /** @type {?} */

                const providerCount =
                /** @type {?} */
                tView.expandoInstructions[++i];
                bindingRootIndex += INJECTOR_BLOOM_PARENT_SIZE + providerCount;
                currentDirectiveIndex = bindingRootIndex;
              } else {
                // This is either the injector size (so the binding root can skip over directives
                // and get to the first set of host bindings on this node) or the host var count
                // (to get to the next set of host bindings on this node).
                bindingRootIndex += instruction;
              }

              setBindingRoot(bindingRootIndex);
            } else {
              // If it's not a number, it's a host binding function that needs to be executed.
              if (instruction !== null) {
                viewData[BINDING_INDEX] = bindingRootIndex;
                /** @type {?} */

                const hostCtx = unwrapRNode(viewData[currentDirectiveIndex]);
                instruction(2
                /* Update */
                , hostCtx, currentElementIndex); // Each directive gets a uniqueId value that is the same for both
                // create and update calls when the hostBindings function is called. The
                // directive uniqueId is not set anywhere--it is just incremented between
                // each hostBindings call and is useful for helping instruction code
                // uniquely determine which directive is currently active when executed.

                incrementActiveDirectiveId();
              }

              currentDirectiveIndex++;
            }
          }
        }
      } finally {
        setActiveHostElement(selectedIndex);
      }
    }
    /**
     * Refreshes all content queries declared by directives in a given view
     * @param {?} tView
     * @param {?} lView
     * @return {?}
     */


    function refreshContentQueries(tView, lView) {
      /** @type {?} */
      const contentQueries = tView.contentQueries;

      if (contentQueries !== null) {
        for (let i = 0; i < contentQueries.length; i += 2) {
          /** @type {?} */
          const queryStartIdx = contentQueries[i];
          /** @type {?} */

          const directiveDefIdx = contentQueries[i + 1];

          if (directiveDefIdx !== -1) {
            /** @type {?} */
            const directiveDef =
            /** @type {?} */
            tView.data[directiveDefIdx];
            ngDevMode && assertDefined(directiveDef.contentQueries, 'contentQueries function should be defined');
            setCurrentQueryIndex(queryStartIdx);

            /** @type {?} */
            directiveDef.contentQueries(2
            /* Update */
            , lView[directiveDefIdx], directiveDefIdx);
          }
        }
      }
    }
    /**
     * Refreshes child components in the current view.
     * @param {?} hostLView
     * @param {?} components
     * @return {?}
     */


    function refreshChildComponents(hostLView, components) {
      if (components != null) {
        for (let i = 0; i < components.length; i++) {
          componentRefresh(hostLView, components[i]);
        }
      }
    }
    /**
     * Creates a native element from a tag name, using a renderer.
     * @param {?} name the tag name
     * @param {?=} overriddenRenderer Optional A renderer to override the default one
     * @return {?} the element created
     */


    function elementCreate(name, overriddenRenderer) {
      /** @type {?} */
      let native;
      /** @type {?} */

      const rendererToUse = overriddenRenderer || getLView()[RENDERER];
      /** @type {?} */

      const namespace = getNamespace();

      if (isProceduralRenderer(rendererToUse)) {
        native = rendererToUse.createElement(name, namespace);
      } else {
        if (namespace === null) {
          native = rendererToUse.createElement(name);
        } else {
          native = rendererToUse.createElementNS(namespace, name);
        }
      }

      return native;
    }
    /**
     * @template T
     * @param {?} parentLView
     * @param {?} tView
     * @param {?} context
     * @param {?} flags
     * @param {?} host
     * @param {?} tHostNode
     * @param {?=} rendererFactory
     * @param {?=} renderer
     * @param {?=} sanitizer
     * @param {?=} injector
     * @return {?}
     */


    function createLView(parentLView, tView, context, flags, host, tHostNode, rendererFactory, renderer, sanitizer, injector) {
      /** @type {?} */
      const lView = ngDevMode ? cloneToLView(tView.blueprint) :
      /** @type {?} */
      tView.blueprint.slice();
      lView[HOST] = host;
      lView[FLAGS] = flags | 4
      /* CreationMode */
      | 128
      /* Attached */
      | 8
      /* FirstLViewPass */
      ;
      resetPreOrderHookFlags(lView);
      lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;
      lView[CONTEXT] = context;
      lView[RENDERER_FACTORY] =
      /** @type {?} */
      rendererFactory || parentLView && parentLView[RENDERER_FACTORY];
      ngDevMode && assertDefined(lView[RENDERER_FACTORY], 'RendererFactory is required');
      lView[RENDERER] =
      /** @type {?} */
      renderer || parentLView && parentLView[RENDERER];
      ngDevMode && assertDefined(lView[RENDERER], 'Renderer is required');
      lView[SANITIZER] = sanitizer || parentLView && parentLView[SANITIZER] ||
      /** @type {?} */
      null;
      lView[
      /** @type {?} */
      INJECTOR$1] = injector || parentLView && parentLView[INJECTOR$1] || null;
      lView[T_HOST] = tHostNode;
      ngDevMode && attachLViewDebug(lView);
      return lView;
    }
    /**
     * @param {?} tView
     * @param {?} tHostNode
     * @param {?} index
     * @param {?} type
     * @param {?} name
     * @param {?} attrs
     * @return {?}
     */


    function getOrCreateTNode(tView, tHostNode, index, type, name, attrs) {
      // Keep this function short, so that the VM will inline it.

      /** @type {?} */
      const adjustedIndex = index + HEADER_OFFSET;
      /** @type {?} */

      const tNode =
      /** @type {?} */
      tView.data[adjustedIndex] || createTNodeAtIndex(tView, tHostNode, adjustedIndex, type, name, attrs, index);
      setPreviousOrParentTNode(tNode, true);
      return (
        /** @type {?} */
        tNode
      );
    }
    /**
     * @param {?} tView
     * @param {?} tHostNode
     * @param {?} adjustedIndex
     * @param {?} type
     * @param {?} name
     * @param {?} attrs
     * @param {?} index
     * @return {?}
     */


    function createTNodeAtIndex(tView, tHostNode, adjustedIndex, type, name, attrs, index) {
      /** @type {?} */
      const previousOrParentTNode = getPreviousOrParentTNode();
      /** @type {?} */

      const isParent = getIsParent();
      /** @type {?} */

      const parent = isParent ? previousOrParentTNode : previousOrParentTNode && previousOrParentTNode.parent; // Parents cannot cross component boundaries because components will be used in multiple places,
      // so it's only set if the view is the same.

      /** @type {?} */

      const parentInSameView = parent && parent !== tHostNode;
      /** @type {?} */

      const tParentNode = parentInSameView ?
      /** @type {?} */
      parent : null;
      /** @type {?} */

      const tNode = tView.data[adjustedIndex] = createTNode(tView, tParentNode, type, adjustedIndex, name, attrs); // The first node is not always the one at index 0, in case of i18n, index 0 can be the
      // instruction `i18nStart` and the first node has the index 1 or more

      if (index === 0 || !tView.firstChild) {
        tView.firstChild = tNode;
      } // Now link ourselves into the tree.


      if (previousOrParentTNode) {
        if (isParent && previousOrParentTNode.child == null && (tNode.parent !== null || previousOrParentTNode.type === 2
        /* View */
        )) {
          // We are in the same view, which means we are adding content node to the parent view.
          previousOrParentTNode.child = tNode;
        } else if (!isParent) {
          previousOrParentTNode.next = tNode;
        }
      }

      return tNode;
    }
    /**
     * @param {?} tView
     * @param {?} tParentNode
     * @param {?} index
     * @param {?} lView
     * @return {?}
     */


    function assignTViewNodeToLView(tView, tParentNode, index, lView) {
      // View nodes are not stored in data because they can be added / removed at runtime (which
      // would cause indices to change). Their TNodes are instead stored in tView.node.

      /** @type {?} */
      let tNode = tView.node;

      if (tNode == null) {
        ngDevMode && tParentNode && assertNodeOfPossibleTypes(tParentNode, 3
        /* Element */
        , 0
        /* Container */
        );
        tView.node = tNode =
        /** @type {?} */
        createTNode(tView,
        /** @type {?} */
        tParentNode, //
        2
        /* View */
        , index, null, null);
      }

      return lView[T_HOST] =
      /** @type {?} */
      tNode;
    }
    /**
     * When elements are created dynamically after a view blueprint is created (e.g. through
     * i18nApply() or ComponentFactory.create), we need to adjust the blueprint for future
     * template passes.
     *
     * @param {?} view The LView containing the blueprint to adjust
     * @param {?} numSlotsToAlloc The number of slots to alloc in the LView, should be >0
     * @return {?}
     */


    function allocExpando(view, numSlotsToAlloc) {
      ngDevMode && assertGreaterThan(numSlotsToAlloc, 0, 'The number of slots to alloc should be greater than 0');

      if (numSlotsToAlloc > 0) {
        /** @type {?} */
        const tView = view[TVIEW];

        if (tView.firstTemplatePass) {
          for (let i = 0; i < numSlotsToAlloc; i++) {
            tView.blueprint.push(null);
            tView.data.push(null);
            view.push(null);
          } // We should only increment the expando start index if there aren't already directives
          // and injectors saved in the "expando" section


          if (!tView.expandoInstructions) {
            tView.expandoStartIndex += numSlotsToAlloc;
          } else {
            // Since we're adding the dynamic nodes into the expando section, we need to let the host
            // bindings know that they should skip x slots
            tView.expandoInstructions.push(numSlotsToAlloc);
          }
        }
      }
    } //////////////////////////
    //// Render
    //////////////////////////

    /**
     * Used for creating the LViewNode of a dynamic embedded view,
     * either through ViewContainerRef.createEmbeddedView() or TemplateRef.createEmbeddedView().
     * Such lViewNode will then be renderer with renderEmbeddedTemplate() (see below).
     * @template T
     * @param {?} tView
     * @param {?} context
     * @param {?} declarationView
     * @param {?} injectorIndex
     * @return {?}
     */


    function createEmbeddedViewAndNode(tView, context, declarationView, injectorIndex) {
      /** @type {?} */
      const _isParent = getIsParent();
      /** @type {?} */


      const _previousOrParentTNode = getPreviousOrParentTNode();

      setPreviousOrParentTNode(
      /** @type {?} */
      null, true);
      /** @type {?} */

      const lView = createLView(declarationView, tView, context, 16
      /* CheckAlways */
      , null, null);
      lView[DECLARATION_VIEW] = declarationView;
      assignTViewNodeToLView(tView, null, -1, lView);

      if (tView.firstTemplatePass) {
        /** @type {?} */
        tView.node.injectorIndex = injectorIndex;
      }

      setPreviousOrParentTNode(_previousOrParentTNode, _isParent);
      return lView;
    }
    /**
     * Used for rendering embedded views (e.g. dynamically created views)
     *
     * Dynamically created views must store/retrieve their TViews differently from component views
     * because their template functions are nested in the template functions of their hosts, creating
     * closures. If their host template happens to be an embedded template in a loop (e.g. ngFor
     * inside
     * an ngFor), the nesting would mean we'd have multiple instances of the template function, so we
     * can't store TViews in the template function itself (as we do for comps). Instead, we store the
     * TView for dynamically created views on their host TNode, which only has one instance.
     * @template T
     * @param {?} viewToRender
     * @param {?} tView
     * @param {?} context
     * @return {?}
     */


    function renderEmbeddedTemplate(viewToRender, tView, context) {
      /** @type {?} */
      const _isParent = getIsParent();
      /** @type {?} */


      const _previousOrParentTNode = getPreviousOrParentTNode();
      /** @type {?} */


      let oldView;

      if (viewToRender[FLAGS] & 512
      /* IsRoot */
      ) {
          // This is a root view inside the view tree
          tickRootContext(getRootContext(viewToRender));
        } else {
        // Will become true if the `try` block executes with no errors.

        /** @type {?} */
        let safeToRunHooks = false;

        try {
          setPreviousOrParentTNode(
          /** @type {?} */
          null, true);
          oldView = enterView(viewToRender, viewToRender[T_HOST]);
          resetPreOrderHookFlags(viewToRender);
          executeTemplate(viewToRender,
          /** @type {?} */
          tView.template, getRenderFlags(viewToRender), context); // This must be set to false immediately after the first creation run because in an
          // ngFor loop, all the views will be created together before update mode runs and turns
          // off firstTemplatePass. If we don't set it here, instances will perform directive
          // matching, etc again and again.

          tView.firstTemplatePass = false;
          refreshDescendantViews(viewToRender);
          safeToRunHooks = true;
        } finally {
          leaveView(
          /** @type {?} */
          oldView, safeToRunHooks);
          setPreviousOrParentTNode(_previousOrParentTNode, _isParent);
        }
      }
    }
    /**
     * @template T
     * @param {?} hostView
     * @param {?} context
     * @param {?=} templateFn
     * @return {?}
     */


    function renderComponentOrTemplate(hostView, context, templateFn) {
      /** @type {?} */
      const rendererFactory = hostView[RENDERER_FACTORY];
      /** @type {?} */

      const oldView = enterView(hostView, hostView[T_HOST]);
      /** @type {?} */

      const normalExecutionPath = !getCheckNoChangesMode();
      /** @type {?} */

      const creationModeIsActive = isCreationMode(hostView); // Will become true if the `try` block executes with no errors.

      /** @type {?} */

      let safeToRunHooks = false;

      try {
        if (normalExecutionPath && !creationModeIsActive && rendererFactory.begin) {
          rendererFactory.begin();
        }

        if (creationModeIsActive) {
          // creation mode pass
          templateFn && executeTemplate(hostView, templateFn, 1
          /* Create */
          , context);
          refreshDescendantViews(hostView);
          hostView[FLAGS] &= ~4
          /* CreationMode */
          ;
        } // update mode pass


        resetPreOrderHookFlags(hostView);
        templateFn && executeTemplate(hostView, templateFn, 2
        /* Update */
        , context);
        refreshDescendantViews(hostView);
        safeToRunHooks = true;
      } finally {
        if (normalExecutionPath && !creationModeIsActive && rendererFactory.end) {
          rendererFactory.end();
        }

        leaveView(oldView, safeToRunHooks);
      }
    }
    /**
     * @template T
     * @param {?} lView
     * @param {?} templateFn
     * @param {?} rf
     * @param {?} context
     * @return {?}
     */


    function executeTemplate(lView, templateFn, rf, context) {
      namespaceHTMLInternal();
      /** @type {?} */

      const prevSelectedIndex = getSelectedIndex();

      try {
        setActiveHostElement(null);

        if (rf & 2
        /* Update */
        ) {
            // When we're updating, have an inherent ɵɵselect(0) so we don't have to generate that
            // instruction for most update blocks
            selectInternal(lView, 0);
          }

        templateFn(rf, context);
      } finally {
        setSelectedIndex(prevSelectedIndex);
      }
    }
    /**
     * This function returns the default configuration of rendering flags depending on when the
     * template is in creation mode or update mode. Update block and create block are
     * always run separately.
     * @param {?} view
     * @return {?}
     */


    function getRenderFlags(view) {
      return isCreationMode(view) ? 1
      /* Create */
      : 2
      /* Update */
      ;
    } //////////////////////////
    //// Element
    //////////////////////////

    /**
     * @param {?} tView
     * @param {?} tNode
     * @param {?} lView
     * @return {?}
     */


    function executeContentQueries(tView, tNode, lView) {
      if (isContentQueryHost(tNode)) {
        /** @type {?} */
        const start = tNode.directiveStart;
        /** @type {?} */

        const end = tNode.directiveEnd;

        for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {
          /** @type {?} */
          const def =
          /** @type {?} */
          tView.data[directiveIndex];

          if (def.contentQueries) {
            def.contentQueries(1
            /* Create */
            , lView[directiveIndex], directiveIndex);
          }
        }
      }
    }
    /**
     * Creates directive instances and populates local refs.
     *
     * @param {?} tView
     * @param {?} lView
     * @param {?} tNode
     * @param {?=} localRefExtractor mapping function that extracts local ref value from TNode
     * @return {?}
     */


    function createDirectivesAndLocals(tView, lView, tNode, localRefExtractor = getNativeByTNode) {
      if (!getBindingsEnabled()) return;
      instantiateAllDirectives(tView, lView, tNode);
      invokeDirectivesHostBindings(tView, lView, tNode);
      saveResolvedLocalsInData(lView, tNode, localRefExtractor);
      setActiveHostElement(null);
    }
    /**
     * Takes a list of local names and indices and pushes the resolved local variable values
     * to LView in the same order as they are loaded in the template with load().
     * @param {?} viewData
     * @param {?} tNode
     * @param {?} localRefExtractor
     * @return {?}
     */


    function saveResolvedLocalsInData(viewData, tNode, localRefExtractor) {
      /** @type {?} */
      const localNames = tNode.localNames;

      if (localNames) {
        /** @type {?} */
        let localIndex = tNode.index + 1;

        for (let i = 0; i < localNames.length; i += 2) {
          /** @type {?} */
          const index =
          /** @type {?} */
          localNames[i + 1];
          /** @type {?} */

          const value = index === -1 ? localRefExtractor(
          /** @type {?} */
          tNode, viewData) : viewData[index];
          viewData[localIndex++] = value;
        }
      }
    }
    /**
     * Gets TView from a template function or creates a new TView
     * if it doesn't already exist.
     *
     * @param {?} def ComponentDef
     * @return {?} TView
     */


    function getOrCreateTView(def) {
      return def.tView || (def.tView = createTView(-1, def.template, def.consts, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas));
    }
    /**
     * Creates a TView instance
     *
     * @param {?} viewIndex The viewBlockId for inline views, or -1 if it's a component/dynamic
     * @param {?} templateFn Template function
     * @param {?} consts The number of nodes, local refs, and pipes in this template
     * @param {?} vars
     * @param {?} directives Registry of directives for this view
     * @param {?} pipes Registry of pipes for this view
     * @param {?} viewQuery View queries for this view
     * @param {?} schemas Schemas for this view
     * @return {?}
     */


    function createTView(viewIndex, templateFn, consts, vars, directives, pipes, viewQuery, schemas) {
      ngDevMode && ngDevMode.tView++;
      /** @type {?} */

      const bindingStartIndex = HEADER_OFFSET + consts; // This length does not yet contain host bindings from child directives because at this point,
      // we don't know which directives are active on this template. As soon as a directive is matched
      // that has a host binding, we will update the blueprint with that def's hostVars count.

      /** @type {?} */

      const initialViewLength = bindingStartIndex + vars;
      /** @type {?} */

      const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);
      return blueprint[
      /** @type {?} */
      TVIEW] = ngDevMode ? new TViewConstructor(viewIndex, // id: number,
      blueprint, // blueprint: LView,
      templateFn, // template: ComponentTemplate<{}>|null,
      null, // queries: TQueries|null
      viewQuery,
      /** @type {?} */
      null, // node: TViewNode|TElementNode|null,
      cloneToTViewData(blueprint).fill(null, bindingStartIndex), // data: TData,
      bindingStartIndex, // bindingStartIndex: number,
      initialViewLength, // expandoStartIndex: number,
      null, // expandoInstructions: ExpandoInstructions|null,
      true, // firstTemplatePass: boolean,
      false, // staticViewQueries: boolean,
      false, // staticContentQueries: boolean,
      null, // preOrderHooks: HookData|null,
      null, // preOrderCheckHooks: HookData|null,
      null, // contentHooks: HookData|null,
      null, // contentCheckHooks: HookData|null,
      null, // viewHooks: HookData|null,
      null, // viewCheckHooks: HookData|null,
      null, // destroyHooks: HookData|null,
      null, // cleanup: any[]|null,
      null, // contentQueries: number[]|null,
      null, // components: number[]|null,
      typeof directives === 'function' ? directives() : directives, // directiveRegistry: DirectiveDefList|null,
      typeof pipes === 'function' ? pipes() : pipes, // pipeRegistry: PipeDefList|null,
      null, // firstChild: TNode|null,
      schemas) : {
        id: viewIndex,
        blueprint: blueprint,
        template: templateFn,
        queries: null,
        viewQuery: viewQuery,
        node:
        /** @type {?} */
        null,
        data: blueprint.slice().fill(null, bindingStartIndex),
        bindingStartIndex: bindingStartIndex,
        expandoStartIndex: initialViewLength,
        expandoInstructions: null,
        firstTemplatePass: true,
        staticViewQueries: false,
        staticContentQueries: false,
        preOrderHooks: null,
        preOrderCheckHooks: null,
        contentHooks: null,
        contentCheckHooks: null,
        viewHooks: null,
        viewCheckHooks: null,
        destroyHooks: null,
        cleanup: null,
        contentQueries: null,
        components: null,
        directiveRegistry: typeof directives === 'function' ? directives() : directives,
        pipeRegistry: typeof pipes === 'function' ? pipes() : pipes,
        firstChild: null,
        schemas: schemas
      };
    }
    /**
     * @param {?} bindingStartIndex
     * @param {?} initialViewLength
     * @return {?}
     */


    function createViewBlueprint(bindingStartIndex, initialViewLength) {
      /** @type {?} */
      const blueprint =
      /** @type {?} */
      new (ngDevMode ?
      /** @type {?} */
      LViewBlueprint : Array)(initialViewLength).fill(null, 0, bindingStartIndex).fill(NO_CHANGE, bindingStartIndex);
      blueprint[BINDING_INDEX] = bindingStartIndex;
      return blueprint;
    }
    /**
     * @param {?} text
     * @param {?} token
     * @return {?}
     */


    function createError(text, token) {
      return new Error("Renderer: ".concat(text, " [").concat(stringifyForError(token), "]"));
    }
    /**
     * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.
     *
     * @param {?} factory
     * @param {?} elementOrSelector Render element or CSS selector to locate the element.
     * @return {?}
     */


    function locateHostElement(factory, elementOrSelector) {
      /** @type {?} */
      const defaultRenderer = factory.createRenderer(null, null);
      /** @type {?} */

      const rNode = typeof elementOrSelector === 'string' ? isProceduralRenderer(defaultRenderer) ? defaultRenderer.selectRootElement(elementOrSelector) : defaultRenderer.querySelector(elementOrSelector) : elementOrSelector;

      if (ngDevMode && !rNode) {
        if (typeof elementOrSelector === 'string') {
          throw createError('Host node with selector not found:', elementOrSelector);
        } else {
          throw createError('Host node is required:', elementOrSelector);
        }
      }

      return rNode;
    }
    /**
     * Saves context for this cleanup function in LView.cleanupInstances.
     *
     * On the first template pass, saves in TView:
     * - Cleanup function
     * - Index of context we just saved in LView.cleanupInstances
     * @param {?} lView
     * @param {?} context
     * @param {?} cleanupFn
     * @return {?}
     */


    function storeCleanupWithContext(lView, context, cleanupFn) {
      /** @type {?} */
      const lCleanup = getCleanup(lView);
      lCleanup.push(context);

      if (lView[TVIEW].firstTemplatePass) {
        getTViewCleanup(lView).push(cleanupFn, lCleanup.length - 1);
      }
    }
    /**
     * Saves the cleanup function itself in LView.cleanupInstances.
     *
     * This is necessary for functions that are wrapped with their contexts, like in renderer2
     * listeners.
     *
     * On the first template pass, the index of the cleanup function is saved in TView.
     * @param {?} view
     * @param {?} cleanupFn
     * @return {?}
     */


    function storeCleanupFn(view, cleanupFn) {
      getCleanup(view).push(cleanupFn);

      if (view[TVIEW].firstTemplatePass) {
        getTViewCleanup(view).push(
        /** @type {?} */
        view[CLEANUP].length - 1, null);
      }
    }
    /**
     * Constructs a TNode object from the arguments.
     *
     * @param {?} tView `TView` to which this `TNode` belongs (used only in `ngDevMode`)
     * @param {?} tParent
     * @param {?} type The type of the node
     * @param {?} adjustedIndex The index of the TNode in TView.data, adjusted for HEADER_OFFSET
     * @param {?} tagName The tag name of the node
     * @param {?} attrs The attributes defined on this node
     * @return {?} the TNode object
     */


    function createTNode(tView, tParent, type, adjustedIndex, tagName, attrs) {
      ngDevMode && ngDevMode.tNode++;
      /** @type {?} */

      let injectorIndex = tParent ? tParent.injectorIndex : -1;
      return ngDevMode ? new TNodeConstructor(tView, // tView_: TView
      type, // type: TNodeType
      adjustedIndex, // index: number
      injectorIndex, // injectorIndex: number
      -1, // directiveStart: number
      -1, // directiveEnd: number
      -1, // propertyMetadataStartIndex: number
      -1, // propertyMetadataEndIndex: number
      0, // flags: TNodeFlags
      0, // providerIndexes: TNodeProviderIndexes
      tagName, // tagName: string|null
      attrs, // attrs: (string|AttributeMarker|(string|SelectorFlags)[])[]|null
      null, // localNames: (string|number)[]|null
      undefined, // initialInputs: (string[]|null)[]|null|undefined
      undefined, // inputs: PropertyAliases|null|undefined
      undefined, // outputs: PropertyAliases|null|undefined
      null, // tViews: ITView|ITView[]|null
      null, // next: ITNode|null
      null, // projectionNext: ITNode|null
      null, // child: ITNode|null
      tParent, // parent: TElementNode|TContainerNode|null
      null, // projection: number|(ITNode|RNode[])[]|null
      null, // styles: TStylingContext|null
      null) : {
        type: type,
        index: adjustedIndex,
        injectorIndex: injectorIndex,
        directiveStart: -1,
        directiveEnd: -1,
        propertyMetadataStartIndex: -1,
        propertyMetadataEndIndex: -1,
        flags: 0,
        providerIndexes: 0,
        tagName: tagName,
        attrs: attrs,
        localNames: null,
        initialInputs: undefined,
        inputs: undefined,
        outputs: undefined,
        tViews: null,
        next: null,
        projectionNext: null,
        child: null,
        parent: tParent,
        projection: null,
        styles: null,
        classes: null
      };
    }
    /**
     * Consolidates all inputs or outputs of all directives on this logical node.
     *
     * @param {?} tNode
     * @param {?} direction whether to consider inputs or outputs
     * @return {?} PropertyAliases|null aggregate of all properties if any, `null` otherwise
     */


    function generatePropertyAliases(tNode, direction) {
      /** @type {?} */
      const tView = getLView()[TVIEW];
      /** @type {?} */

      let propStore = null;
      /** @type {?} */

      const start = tNode.directiveStart;
      /** @type {?} */

      const end = tNode.directiveEnd;

      if (end > start) {
        /** @type {?} */
        const isInput = direction === 0
        /* Input */
        ;
        /** @type {?} */

        const defs = tView.data;

        for (let i = start; i < end; i++) {
          /** @type {?} */
          const directiveDef =
          /** @type {?} */
          defs[i];
          /** @type {?} */

          const propertyAliasMap = isInput ? directiveDef.inputs : directiveDef.outputs;

          for (let publicName in propertyAliasMap) {
            if (propertyAliasMap.hasOwnProperty(publicName)) {
              propStore = propStore || {};
              /** @type {?} */

              const internalName = propertyAliasMap[publicName];
              /** @type {?} */

              const hasProperty = propStore.hasOwnProperty(publicName);
              hasProperty ? propStore[publicName].push(i, publicName, internalName) : propStore[publicName] = [i, publicName, internalName];
            }
          }
        }
      }

      return propStore;
    }
    /**
     * Mapping between attributes names that don't correspond to their element property names.
     * Note: this mapping has to be kept in sync with the equally named mapping in the template
     * type-checking machinery of ngtsc.
     * @type {?}
     */


    const ATTR_TO_PROP = {
      'class': 'className',
      'for': 'htmlFor',
      'formaction': 'formAction',
      'innerHtml': 'innerHTML',
      'readonly': 'readOnly',
      'tabindex': 'tabIndex'
    };
    /**
     * @template T
     * @param {?} index
     * @param {?} propName
     * @param {?} value
     * @param {?=} sanitizer
     * @param {?=} nativeOnly
     * @param {?=} loadRendererFn
     * @return {?}
     */

    function elementPropertyInternal(index, propName, value, sanitizer, nativeOnly, loadRendererFn) {
      ngDevMode && assertNotSame(value,
      /** @type {?} */
      NO_CHANGE, 'Incoming value should never be NO_CHANGE.');
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const element =
      /** @type {?} */
      getNativeByIndex(index, lView);
      /** @type {?} */

      const tNode = getTNode(index, lView);
      /** @type {?} */

      let inputData;
      /** @type {?} */

      let dataValue;

      if (!nativeOnly && (inputData = initializeTNodeInputs(tNode)) && (dataValue = inputData[propName])) {
        setInputsForProperty(lView, dataValue, value);
        if (isComponent(tNode)) markDirtyIfOnPush(lView, index + HEADER_OFFSET);

        if (ngDevMode) {
          if (tNode.type === 3
          /* Element */
          || tNode.type === 0
          /* Container */
          ) {
              /**
               * dataValue is an array containing runtime input or output names for the directives:
               * i+0: directive instance index
               * i+1: publicName
               * i+2: privateName
               *
               * e.g. [0, 'change', 'change-minified']
               * we want to set the reflected property with the privateName: dataValue[i+2]
               */
              for (let i = 0; i < dataValue.length; i += 3) {
                setNgReflectProperty(lView, element, tNode.type,
                /** @type {?} */
                dataValue[i + 2], value);
              }
            }
        }
      } else if (tNode.type === 3
      /* Element */
      ) {
          propName = ATTR_TO_PROP[propName] || propName;

          if (ngDevMode) {
            validateAgainstEventProperties(propName);
            validateAgainstUnknownProperties(lView, element, propName, tNode);
            ngDevMode.rendererSetProperty++;
          }

          savePropertyDebugData(tNode, lView, propName, lView[TVIEW].data, nativeOnly);
          /** @type {?} */

          const renderer = loadRendererFn ? loadRendererFn(tNode, lView) : lView[RENDERER]; // It is assumed that the sanitizer is only added when the compiler determines that the
          // property
          // is risky, so sanitization can be done without further checks.

          value = sanitizer != null ?
          /** @type {?} */
          sanitizer(value, tNode.tagName || '', propName) : value;

          if (isProceduralRenderer(renderer)) {
            renderer.setProperty(
            /** @type {?} */
            element, propName, value);
          } else if (!isAnimationProp(propName)) {
            /** @type {?} */
            element.setProperty ?
            /** @type {?} */
            element.setProperty(propName, value) :
            /** @type {?} */
            element[propName] = value;
          }
        } else if (tNode.type === 0
      /* Container */
      ) {
          // If the node is a container and the property didn't
          // match any of the inputs or schemas we should throw.
          if (ngDevMode && !matchingSchemas(lView, tNode.tagName)) {
            throw createUnknownPropertyError(propName, tNode);
          }
        }
    }
    /**
     * If node is an OnPush component, marks its LView dirty.
     * @param {?} lView
     * @param {?} viewIndex
     * @return {?}
     */


    function markDirtyIfOnPush(lView, viewIndex) {
      ngDevMode && assertLView(lView);
      /** @type {?} */

      const childComponentLView = getComponentViewByIndex(viewIndex, lView);

      if (!(childComponentLView[FLAGS] & 16
      /* CheckAlways */
      )) {
        childComponentLView[FLAGS] |= 64
        /* Dirty */
        ;
      }
    }
    /**
     * @param {?} lView
     * @param {?} element
     * @param {?} type
     * @param {?} attrName
     * @param {?} value
     * @return {?}
     */


    function setNgReflectProperty(lView, element, type, attrName, value) {
      /** @type {?} */
      const renderer = lView[RENDERER];
      attrName = normalizeDebugBindingName(attrName);
      /** @type {?} */

      const debugValue = normalizeDebugBindingValue(value);

      if (type === 3
      /* Element */
      ) {
          if (value == null) {
            isProceduralRenderer(renderer) ? renderer.removeAttribute(
            /** @type {?} */
            element, attrName) :
            /** @type {?} */
            element.removeAttribute(attrName);
          } else {
            isProceduralRenderer(renderer) ? renderer.setAttribute(
            /** @type {?} */
            element, attrName, debugValue) :
            /** @type {?} */
            element.setAttribute(attrName, debugValue);
          }
        } else {
        /** @type {?} */
        const textContent = "bindings=".concat(JSON.stringify({
          [attrName]: debugValue
        }, null, 2));

        if (isProceduralRenderer(renderer)) {
          renderer.setValue(
          /** @type {?} */
          element, textContent);
        } else {
          /** @type {?} */
          element.textContent = textContent;
        }
      }
    }
    /**
     * @param {?} hostView
     * @param {?} element
     * @param {?} propName
     * @param {?} tNode
     * @return {?}
     */


    function validateAgainstUnknownProperties(hostView, element, propName, tNode) {
      // If the tag matches any of the schemas we shouldn't throw.
      if (matchingSchemas(hostView, tNode.tagName)) {
        return;
      } // If prop is not a known property of the HTML element...


      if (!(propName in element) && // and we are in a browser context... (web worker nodes should be skipped)
      typeof Node === 'function' && element instanceof Node && // and isn't a synthetic animation property...
      propName[0] !== ANIMATION_PROP_PREFIX) {
        // ... it is probably a user error and we should throw.
        throw createUnknownPropertyError(propName, tNode);
      }
    }
    /**
     * @param {?} hostView
     * @param {?} tagName
     * @return {?}
     */


    function matchingSchemas(hostView, tagName) {
      /** @type {?} */
      const schemas = hostView[TVIEW].schemas;

      if (schemas !== null) {
        for (let i = 0; i < schemas.length; i++) {
          /** @type {?} */
          const schema = schemas[i];

          if (schema === NO_ERRORS_SCHEMA || schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf('-') > -1) {
            return true;
          }
        }
      }

      return false;
    }
    /**
     * Stores debugging data for this property binding on first template pass.
     * This enables features like DebugElement.properties.
     * @param {?} tNode
     * @param {?} lView
     * @param {?} propName
     * @param {?} tData
     * @param {?} nativeOnly
     * @return {?}
     */


    function savePropertyDebugData(tNode, lView, propName, tData, nativeOnly) {
      /** @type {?} */
      const lastBindingIndex = lView[BINDING_INDEX] - 1; // Bind/interpolation functions save binding metadata in the last binding index,
      // but leave the property name blank. If the interpolation delimiter is at the 0
      // index, we know that this is our first pass and the property name still needs to
      // be set.

      /** @type {?} */

      const bindingMetadata =
      /** @type {?} */
      tData[lastBindingIndex];

      if (bindingMetadata[0] == INTERPOLATION_DELIMITER) {
        tData[lastBindingIndex] = propName + bindingMetadata; // We don't want to store indices for host bindings because they are stored in a
        // different part of LView (the expando section).

        if (!nativeOnly) {
          if (tNode.propertyMetadataStartIndex == -1) {
            tNode.propertyMetadataStartIndex = lastBindingIndex;
          }

          tNode.propertyMetadataEndIndex = lastBindingIndex + 1;
        }
      }
    }
    /**
     * Creates an error that should be thrown when encountering an unknown property on an element.
     * @param {?} propName Name of the invalid property.
     * @param {?} tNode Node on which we encountered the error.
     * @return {?}
     */


    function createUnknownPropertyError(propName, tNode) {
      return new Error("Template error: Can't bind to '".concat(propName, "' since it isn't a known property of '").concat(tNode.tagName, "'."));
    }
    /**
     * Instantiate a root component.
     * @template T
     * @param {?} tView
     * @param {?} viewData
     * @param {?} def
     * @return {?}
     */


    function instantiateRootComponent(tView, viewData, def) {
      /** @type {?} */
      const rootTNode = getPreviousOrParentTNode();

      if (tView.firstTemplatePass) {
        if (def.providersResolver) def.providersResolver(def);
        generateExpandoInstructionBlock(tView, rootTNode, 1);
        baseResolveDirective(tView, viewData, def, def.factory);
      }
      /** @type {?} */


      const directive = getNodeInjectable(tView.data, viewData, viewData.length - 1,
      /** @type {?} */
      rootTNode);
      postProcessBaseDirective(viewData, rootTNode, directive);
      return directive;
    }
    /**
     * Resolve the matched directives on a node.
     * @param {?} tView
     * @param {?} lView
     * @param {?} tNode
     * @param {?} localRefs
     * @return {?}
     */


    function resolveDirectives(tView, lView, tNode, localRefs) {
      // Please make sure to have explicit type for `exportsMap`. Inferred type triggers bug in
      // tsickle.
      ngDevMode && assertEqual(tView.firstTemplatePass, true, 'should run on first template pass only');
      if (!getBindingsEnabled()) return;
      /** @type {?} */

      const directives = findDirectiveMatches(tView, lView, tNode);
      /** @type {?} */

      const exportsMap = localRefs ? {
        '': -1
      } : null;

      if (directives) {
        initNodeFlags(tNode, tView.data.length, directives.length); // When the same token is provided by several directives on the same node, some rules apply in
        // the viewEngine:
        // - viewProviders have priority over providers
        // - the last directive in NgModule.declarations has priority over the previous one
        // So to match these rules, the order in which providers are added in the arrays is very
        // important.

        for (let i = 0; i < directives.length; i++) {
          /** @type {?} */
          const def =
          /** @type {?} */
          directives[i];
          if (def.providersResolver) def.providersResolver(def);
        }

        generateExpandoInstructionBlock(tView, tNode, directives.length);
        /** @type {?} */

        const initialPreOrderHooksLength = tView.preOrderHooks && tView.preOrderHooks.length || 0;
        /** @type {?} */

        const initialPreOrderCheckHooksLength = tView.preOrderCheckHooks && tView.preOrderCheckHooks.length || 0;
        /** @type {?} */

        const nodeIndex = tNode.index - HEADER_OFFSET;

        for (let i = 0; i < directives.length; i++) {
          /** @type {?} */
          const def =
          /** @type {?} */
          directives[i];
          /** @type {?} */

          const directiveDefIdx = tView.data.length;
          baseResolveDirective(tView, lView, def, def.factory);
          saveNameToExportMap(
          /** @type {?} */
          tView.data.length - 1, def, exportsMap); // Init hooks are queued now so ngOnInit is called in host components before
          // any projected components.

          registerPreOrderHooks(directiveDefIdx, def, tView, nodeIndex, initialPreOrderHooksLength, initialPreOrderCheckHooksLength);
        }
      }

      if (exportsMap) cacheMatchingLocalNames(tNode, localRefs, exportsMap);
    }
    /**
     * Instantiate all the directives that were previously resolved on the current node.
     * @param {?} tView
     * @param {?} lView
     * @param {?} tNode
     * @return {?}
     */


    function instantiateAllDirectives(tView, lView, tNode) {
      /** @type {?} */
      const start = tNode.directiveStart;
      /** @type {?} */

      const end = tNode.directiveEnd;

      if (!tView.firstTemplatePass && start < end) {
        getOrCreateNodeInjectorForNode(
        /** @type {?} */
        tNode, lView);
      }

      for (let i = start; i < end; i++) {
        /** @type {?} */
        const def =
        /** @type {?} */
        tView.data[i];

        if (isComponentDef(def)) {
          addComponentLogic(lView, tNode,
          /** @type {?} */
          def);
        }
        /** @type {?} */


        const directive = getNodeInjectable(tView.data,
        /** @type {?} */
        lView, i,
        /** @type {?} */
        tNode);
        postProcessDirective(lView, directive, def, i);
      }
    }
    /**
     * @param {?} tView
     * @param {?} viewData
     * @param {?} tNode
     * @return {?}
     */


    function invokeDirectivesHostBindings(tView, viewData, tNode) {
      /** @type {?} */
      const start = tNode.directiveStart;
      /** @type {?} */

      const end = tNode.directiveEnd;
      /** @type {?} */

      const expando =
      /** @type {?} */
      tView.expandoInstructions;
      /** @type {?} */

      const firstTemplatePass = tView.firstTemplatePass;
      /** @type {?} */

      const elementIndex = tNode.index - HEADER_OFFSET;
      /** @type {?} */

      const selectedIndex = getSelectedIndex();

      try {
        setActiveHostElement(elementIndex);

        for (let i = start; i < end; i++) {
          /** @type {?} */
          const def =
          /** @type {?} */
          tView.data[i];
          /** @type {?} */

          const directive = viewData[i];

          if (def.hostBindings) {
            invokeHostBindingsInCreationMode(def, expando, directive, tNode, firstTemplatePass); // Each directive gets a uniqueId value that is the same for both
            // create and update calls when the hostBindings function is called. The
            // directive uniqueId is not set anywhere--it is just incremented between
            // each hostBindings call and is useful for helping instruction code
            // uniquely determine which directive is currently active when executed.

            incrementActiveDirectiveId();
          } else if (firstTemplatePass) {
            expando.push(null);
          }
        }
      } finally {
        setActiveHostElement(selectedIndex);
      }
    }
    /**
     * @param {?} def
     * @param {?} expando
     * @param {?} directive
     * @param {?} tNode
     * @param {?} firstTemplatePass
     * @return {?}
     */


    function invokeHostBindingsInCreationMode(def, expando, directive, tNode, firstTemplatePass) {
      /** @type {?} */
      const previousExpandoLength = expando.length;
      setCurrentDirectiveDef(def);
      /** @type {?} */

      const elementIndex = tNode.index - HEADER_OFFSET;

      /** @type {?} */
      def.hostBindings(1
      /* Create */
      , directive, elementIndex);
      setCurrentDirectiveDef(null); // `hostBindings` function may or may not contain `allocHostVars` call
      // (e.g. it may not if it only contains host listeners), so we need to check whether
      // `expandoInstructions` has changed and if not - we still push `hostBindings` to
      // expando block, to make sure we execute it for DI cycle

      if (previousExpandoLength === expando.length && firstTemplatePass) {
        expando.push(def.hostBindings);
      }
    }
    /**
     * Generates a new block in TView.expandoInstructions for this node.
     *
     * Each expando block starts with the element index (turned negative so we can distinguish
     * it from the hostVar count) and the directive count. See more in VIEW_DATA.md.
     * @param {?} tView
     * @param {?} tNode
     * @param {?} directiveCount
     * @return {?}
     */


    function generateExpandoInstructionBlock(tView, tNode, directiveCount) {
      ngDevMode && assertEqual(tView.firstTemplatePass, true, 'Expando block should only be generated on first template pass.');
      /** @type {?} */

      const elementIndex = -(tNode.index - HEADER_OFFSET);
      /** @type {?} */

      const providerStartIndex = tNode.providerIndexes & 65535
      /* ProvidersStartIndexMask */
      ;
      /** @type {?} */

      const providerCount = tView.data.length - providerStartIndex;
      (tView.expandoInstructions || (tView.expandoInstructions = [])).push(elementIndex, providerCount, directiveCount);
    }
    /**
     * Process a directive on the current node after its creation.
     * @template T
     * @param {?} viewData
     * @param {?} directive
     * @param {?} def
     * @param {?} directiveDefIdx
     * @return {?}
     */


    function postProcessDirective(viewData, directive, def, directiveDefIdx) {
      /** @type {?} */
      const previousOrParentTNode = getPreviousOrParentTNode();
      postProcessBaseDirective(viewData, previousOrParentTNode, directive);
      ngDevMode && assertDefined(previousOrParentTNode, 'previousOrParentTNode');

      if (previousOrParentTNode && previousOrParentTNode.attrs) {
        setInputsFromAttrs(directiveDefIdx, directive, def, previousOrParentTNode);
      }

      if (viewData[TVIEW].firstTemplatePass && def.contentQueries) {
        previousOrParentTNode.flags |= 4
        /* hasContentQuery */
        ;
      }

      if (isComponentDef(def)) {
        /** @type {?} */
        const componentView = getComponentViewByIndex(previousOrParentTNode.index, viewData);
        componentView[CONTEXT] = directive;
      }
    }
    /**
     * A lighter version of postProcessDirective() that is used for the root component.
     * @template T
     * @param {?} lView
     * @param {?} previousOrParentTNode
     * @param {?} directive
     * @return {?}
     */


    function postProcessBaseDirective(lView, previousOrParentTNode, directive) {
      /** @type {?} */
      const native = getNativeByTNode(previousOrParentTNode, lView);
      ngDevMode && assertEqual(lView[BINDING_INDEX], lView[TVIEW].bindingStartIndex, 'directives should be created before any bindings');
      ngDevMode && assertPreviousIsParent(getIsParent());
      attachPatchData(directive, lView);

      if (native) {
        attachPatchData(native, lView);
      }
    }
    /**
     * Matches the current node against all available selectors.
     * If a component is matched (at most one), it is returned in first position in the array.
     * @param {?} tView
     * @param {?} viewData
     * @param {?} tNode
     * @return {?}
     */


    function findDirectiveMatches(tView, viewData, tNode) {
      ngDevMode && assertEqual(tView.firstTemplatePass, true, 'should run on first template pass only');
      /** @type {?} */

      const registry = tView.directiveRegistry;
      /** @type {?} */

      let matches = null;

      if (registry) {
        for (let i = 0; i < registry.length; i++) {
          /** @type {?} */
          const def =
          /** @type {?} */
          registry[i];

          if (isNodeMatchingSelectorList(tNode,
          /** @type {?} */
          def.selectors,
          /* isProjectionMode */
          false)) {
            matches || (matches = ngDevMode ? new
            /** @type {?} */
            MatchesArray() : []);
            diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, viewData), tView, def.type);

            if (isComponentDef(def)) {
              if (tNode.flags & 1
              /* isComponent */
              ) throwMultipleComponentError(tNode);
              tNode.flags = 1
              /* isComponent */
              ; // The component is always stored first with directives after.

              matches.unshift(def);
            } else {
              matches.push(def);
            }
          }
        }
      }

      return matches;
    }
    /**
     * Stores index of component's host element so it will be queued for view refresh during CD.
     * @param {?} previousOrParentTNode
     * @return {?}
     */


    function queueComponentIndexForCheck(previousOrParentTNode) {
      /** @type {?} */
      const tView = getLView()[TVIEW];
      ngDevMode && assertEqual(tView.firstTemplatePass, true, 'Should only be called in first template pass.');
      (tView.components || (tView.components = ngDevMode ? new
      /** @type {?} */
      TViewComponents() : [])).push(previousOrParentTNode.index);
    }
    /**
     * Caches local names and their matching directive indices for query and template lookups.
     * @param {?} tNode
     * @param {?} localRefs
     * @param {?} exportsMap
     * @return {?}
     */


    function cacheMatchingLocalNames(tNode, localRefs, exportsMap) {
      if (localRefs) {
        /** @type {?} */
        const localNames = tNode.localNames = ngDevMode ? new
        /** @type {?} */
        TNodeLocalNames() : []; // Local names must be stored in tNode in the same order that localRefs are defined
        // in the template to ensure the data is loaded in the same slots as their refs
        // in the template (for template queries).

        for (let i = 0; i < localRefs.length; i += 2) {
          /** @type {?} */
          const index = exportsMap[localRefs[i + 1]];
          if (index == null) throw new Error("Export of name '".concat(localRefs[i + 1], "' not found!"));
          localNames.push(localRefs[i], index);
        }
      }
    }
    /**
     * Builds up an export map as directives are created, so local refs can be quickly mapped
     * to their directive instances.
     * @param {?} index
     * @param {?} def
     * @param {?} exportsMap
     * @return {?}
     */


    function saveNameToExportMap(index, def, exportsMap) {
      if (exportsMap) {
        if (def.exportAs) {
          for (let i = 0; i < def.exportAs.length; i++) {
            exportsMap[def.exportAs[i]] = index;
          }
        }

        if (
        /** @type {?} */
        def.template) exportsMap[''] = index;
      }
    }
    /**
     * Initializes the flags on the current node, setting all indices to the initial index,
     * the directive count to 0, and adding the isComponent flag.
     * @param {?} tNode
     * @param {?} index the initial index
     * @param {?} numberOfDirectives
     * @return {?}
     */


    function initNodeFlags(tNode, index, numberOfDirectives) {
      /** @type {?} */
      const flags = tNode.flags;
      ngDevMode && assertEqual(flags === 0 || flags === 1
      /* isComponent */
      , true, 'expected node flags to not be initialized');
      ngDevMode && assertNotEqual(numberOfDirectives, tNode.directiveEnd - tNode.directiveStart, 'Reached the max number of directives'); // When the first directive is created on a node, save the index

      tNode.flags = flags & 1
      /* isComponent */
      ;
      tNode.directiveStart = index;
      tNode.directiveEnd = index + numberOfDirectives;
      tNode.providerIndexes = index;
    }
    /**
     * @template T
     * @param {?} tView
     * @param {?} viewData
     * @param {?} def
     * @param {?} directiveFactory
     * @return {?}
     */


    function baseResolveDirective(tView, viewData, def, directiveFactory) {
      tView.data.push(def);
      /** @type {?} */

      const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), null);
      tView.blueprint.push(nodeInjectorFactory);
      viewData.push(nodeInjectorFactory);
    }
    /**
     * @template T
     * @param {?} lView
     * @param {?} previousOrParentTNode
     * @param {?} def
     * @return {?}
     */


    function addComponentLogic(lView, previousOrParentTNode, def) {
      /** @type {?} */
      const native = getNativeByTNode(previousOrParentTNode, lView);
      /** @type {?} */

      const tView = getOrCreateTView(def); // Only component views should be added to the view tree directly. Embedded views are
      // accessed through their containers because they may be removed / re-added later.

      /** @type {?} */

      const rendererFactory = lView[RENDERER_FACTORY];
      /** @type {?} */

      const componentView = addToViewTree(lView, createLView(lView, tView, null, def.onPush ? 64
      /* Dirty */
      : 16
      /* CheckAlways */
      , lView[previousOrParentTNode.index],
      /** @type {?} */
      previousOrParentTNode, rendererFactory, rendererFactory.createRenderer(
      /** @type {?} */
      native, def)));
      componentView[T_HOST] =
      /** @type {?} */
      previousOrParentTNode; // Component view will always be created before any injected LContainers,
      // so this is a regular element, wrap it with the component view

      lView[previousOrParentTNode.index] = componentView;

      if (lView[TVIEW].firstTemplatePass) {
        queueComponentIndexForCheck(previousOrParentTNode);
      }
    }
    /**
     * @param {?} index
     * @param {?} name
     * @param {?} value
     * @param {?} lView
     * @param {?=} sanitizer
     * @param {?=} namespace
     * @return {?}
     */


    function elementAttributeInternal(index, name, value, lView, sanitizer, namespace) {
      ngDevMode && assertNotSame(value,
      /** @type {?} */
      NO_CHANGE, 'Incoming value should never be NO_CHANGE.');
      ngDevMode && validateAgainstEventAttributes(name);
      /** @type {?} */

      const element =
      /** @type {?} */
      getNativeByIndex(index, lView);
      /** @type {?} */

      const renderer = lView[RENDERER];

      if (value == null) {
        ngDevMode && ngDevMode.rendererRemoveAttribute++;
        isProceduralRenderer(renderer) ? renderer.removeAttribute(element, name, namespace) : element.removeAttribute(name);
      } else {
        ngDevMode && ngDevMode.rendererSetAttribute++;
        /** @type {?} */

        const tNode = getTNode(index, lView);
        /** @type {?} */

        const strValue = sanitizer == null ? renderStringify(value) : sanitizer(value, tNode.tagName || '', name);

        if (isProceduralRenderer(renderer)) {
          renderer.setAttribute(element, name, strValue, namespace);
        } else {
          namespace ? element.setAttributeNS(namespace, name, strValue) : element.setAttribute(name, strValue);
        }
      }
    }
    /**
     * Sets initial input properties on directive instances from attribute data
     *
     * @template T
     * @param {?} directiveIndex Index of the directive in directives array
     * @param {?} instance Instance of the directive on which to set the initial inputs
     * @param {?} def The directive def that contains the list of inputs
     * @param {?} tNode The static data for this node
     * @return {?}
     */


    function setInputsFromAttrs(directiveIndex, instance, def, tNode) {
      /** @type {?} */
      let initialInputData =
      /** @type {?} */
      tNode.initialInputs;

      if (initialInputData === undefined || directiveIndex >= initialInputData.length) {
        initialInputData = generateInitialInputs(directiveIndex, def.inputs, tNode);
      }
      /** @type {?} */


      const initialInputs = initialInputData[directiveIndex];

      if (initialInputs) {
        /** @type {?} */
        const setInput = def.setInput;

        for (let i = 0; i < initialInputs.length;) {
          /** @type {?} */
          const publicName = initialInputs[i++];
          /** @type {?} */

          const privateName = initialInputs[i++];
          /** @type {?} */

          const value = initialInputs[i++];

          if (setInput) {
            /** @type {?} */
            def.setInput(instance, value, publicName, privateName);
          } else {
            /** @type {?} */
            instance[privateName] = value;
          }

          if (ngDevMode) {
            /** @type {?} */
            const lView = getLView();
            /** @type {?} */

            const nativeElement =
            /** @type {?} */
            getNativeByTNode(tNode, lView);
            setNgReflectProperty(lView, nativeElement, tNode.type, privateName, value);
          }
        }
      }
    }
    /**
     * Generates initialInputData for a node and stores it in the template's static storage
     * so subsequent template invocations don't have to recalculate it.
     *
     * initialInputData is an array containing values that need to be set as input properties
     * for directives on this node, but only once on creation. We need this array to support
     * the case where you set an \@Input property of a directive using attribute-like syntax.
     * e.g. if you have a `name` \@Input, you can set it once like this:
     *
     * <my-component name="Bess"></my-component>
     *
     * @param {?} directiveIndex Index to store the initial input data
     * @param {?} inputs The list of inputs from the directive def
     * @param {?} tNode The static data on this node
     * @return {?}
     */


    function generateInitialInputs(directiveIndex, inputs, tNode) {
      /** @type {?} */
      const initialInputData = tNode.initialInputs || (tNode.initialInputs = ngDevMode ? new
      /** @type {?} */
      TNodeInitialInputs() : []); // Ensure that we don't create sparse arrays

      for (let i = initialInputData.length; i <= directiveIndex; i++) {
        initialInputData.push(null);
      }
      /** @type {?} */


      const attrs =
      /** @type {?} */
      tNode.attrs;
      /** @type {?} */

      let i = 0;

      while (i < attrs.length) {
        /** @type {?} */
        const attrName = attrs[i];

        if (attrName === 0
        /* NamespaceURI */
        ) {
            // We do not allow inputs on namespaced attributes.
            i += 4;
            continue;
          } else if (attrName === 5
        /* ProjectAs */
        ) {
            // Skip over the `ngProjectAs` value.
            i += 2;
            continue;
          } // If we hit any other attribute markers, we're done anyway. None of those are valid inputs.


        if (typeof attrName === 'number') break;
        /** @type {?} */

        const minifiedInputName = inputs[
        /** @type {?} */
        attrName];
        /** @type {?} */

        const attrValue = attrs[i + 1];

        if (minifiedInputName !== undefined) {
          /** @type {?} */
          const inputsToStore = initialInputData[directiveIndex] || (initialInputData[directiveIndex] = ngDevMode ? new
          /** @type {?} */
          TNodeInitialData() : []);
          inputsToStore.push(
          /** @type {?} */
          attrName, minifiedInputName,
          /** @type {?} */
          attrValue);
        }

        i += 2;
      }

      return initialInputData;
    } //////////////////////////
    //// ViewContainer & View
    //////////////////////////
    // Not sure why I need to do `any` here but TS complains later.

    /** @type {?} */


    const LContainerArray = ngDevMode && createNamedArrayType('LContainer');
    /**
     * Creates a LContainer, either from a container instruction, or for a ViewContainerRef.
     *
     * @param {?} hostNative The host element for the LContainer
     * @param {?} currentView The parent view of the LContainer
     * @param {?} native The native comment element
     * @param {?} tNode
     * @param {?=} isForViewContainerRef Optional a flag indicating the ViewContainerRef case
     * @return {?} LContainer
     */

    function createLContainer(hostNative, currentView, native, tNode, isForViewContainerRef) {
      ngDevMode && assertDomNode(native);
      ngDevMode && assertLView(currentView); // https://jsperf.com/array-literal-vs-new-array-really

      /** @type {?} */

      const lContainer = new (ngDevMode ? LContainerArray : Array)(hostNative, // host native
      true, // Boolean `true` in this position signifies that this is an `LContainer`
      isForViewContainerRef ? -1 : 0, // active index
      currentView, // parent
      null, // next
      null, // queries
      tNode, // t_host
      native, // native,
      null);
      ngDevMode && attachLContainerDebug(lContainer);
      return lContainer;
    }
    /**
     * Goes over dynamic embedded views (ones created through ViewContainerRef APIs) and refreshes
     * them
     * by executing an associated template function.
     * @param {?} lView
     * @return {?}
     */


    function refreshDynamicEmbeddedViews(lView) {
      for (let current = lView[CHILD_HEAD]; current !== null; current = current[NEXT]) {
        // Note: current can be an LView or an LContainer instance, but here we are only interested
        // in LContainer. We can tell it's an LContainer because its length is less than the LView
        // header.
        if (current[ACTIVE_INDEX] === -1 && isLContainer(current)) {
          for (let i = CONTAINER_HEADER_OFFSET; i < current.length; i++) {
            /** @type {?} */
            const dynamicViewData = current[i]; // The directives and pipes are not needed here as an existing view is only being
            // refreshed.

            ngDevMode && assertDefined(dynamicViewData[TVIEW], 'TView must be allocated');
            renderEmbeddedTemplate(dynamicViewData, dynamicViewData[TVIEW],
            /** @type {?} */
            dynamicViewData[CONTEXT]);
          }
        }
      }
    } /////////////

    /**
     * Refreshes components by entering the component view and processing its bindings, queries, etc.
     *
     * @param {?} hostLView
     * @param {?} adjustedElementIndex  Element index in LView[] (adjusted for HEADER_OFFSET)
     * @return {?}
     */


    function componentRefresh(hostLView, adjustedElementIndex) {
      ngDevMode && assertDataInRange(hostLView, adjustedElementIndex);
      /** @type {?} */

      const componentView = getComponentViewByIndex(adjustedElementIndex, hostLView);
      ngDevMode && assertNodeType(
      /** @type {?} */
      hostLView[TVIEW].data[adjustedElementIndex], 3
      /* Element */
      ); // Only components in creation mode, attached CheckAlways
      // components or attached, dirty OnPush components should be checked

      if ((viewAttachedToChangeDetector(componentView) || isCreationMode(hostLView)) && componentView[FLAGS] & (16
      /* CheckAlways */
      | 64
      /* Dirty */
      )) {
        syncViewWithBlueprint(componentView);
        checkView(componentView, componentView[CONTEXT]);
      }
    }
    /**
     * Syncs an LView instance with its blueprint if they have gotten out of sync.
     *
     * Typically, blueprints and their view instances should always be in sync, so the loop here
     * will be skipped. However, consider this case of two components side-by-side:
     *
     * App template:
     * ```
     * <comp></comp>
     * <comp></comp>
     * ```
     *
     * The following will happen:
     * 1. App template begins processing.
     * 2. First <comp> is matched as a component and its LView is created.
     * 3. Second <comp> is matched as a component and its LView is created.
     * 4. App template completes processing, so it's time to check child templates.
     * 5. First <comp> template is checked. It has a directive, so its def is pushed to blueprint.
     * 6. Second <comp> template is checked. Its blueprint has been updated by the first
     * <comp> template, but its LView was created before this update, so it is out of sync.
     *
     * Note that embedded views inside ngFor loops will never be out of sync because these views
     * are processed as soon as they are created.
     *
     * @param {?} componentView The view to sync
     * @return {?}
     */


    function syncViewWithBlueprint(componentView) {
      /** @type {?} */
      const componentTView = componentView[TVIEW];

      for (let i = componentView.length; i < componentTView.blueprint.length; i++) {
        componentView[i] = componentTView.blueprint[i];
      }
    }
    /**
     * Adds LView or LContainer to the end of the current view tree.
     *
     * This structure will be used to traverse through nested views to remove listeners
     * and call onDestroy callbacks.
     *
     * @template T
     * @param {?} lView The view where LView or LContainer should be added
     * @param {?} lViewOrLContainer The LView or LContainer to add to the view tree
     * @return {?} The state passed in
     */


    function addToViewTree(lView, lViewOrLContainer) {
      // TODO(benlesh/misko): This implementation is incorrect, because it always adds the LContainer
      // to
      // the end of the queue, which means if the developer retrieves the LContainers from RNodes out
      // of
      // order, the change detection will run out of order, as the act of retrieving the the
      // LContainer
      // from the RNode is what adds it to the queue.
      if (lView[CHILD_HEAD]) {
        /** @type {?} */
        lView[CHILD_TAIL][NEXT] = lViewOrLContainer;
      } else {
        lView[CHILD_HEAD] = lViewOrLContainer;
      }

      lView[CHILD_TAIL] = lViewOrLContainer;
      return lViewOrLContainer;
    } ///////////////////////////////
    //// Change detection
    ///////////////////////////////

    /**
     * Marks current view and all ancestors dirty.
     *
     * Returns the root view because it is found as a byproduct of marking the view tree
     * dirty, and can be used by methods that consume markViewDirty() to easily schedule
     * change detection. Otherwise, such methods would need to traverse up the view tree
     * an additional time to get the root view and schedule a tick on it.
     *
     * @param {?} lView The starting LView to mark dirty
     * @return {?} the root LView
     */


    function markViewDirty(lView) {
      while (lView) {
        lView[FLAGS] |= 64
        /* Dirty */
        ;
        /** @type {?} */

        const parent = getLViewParent(lView); // Stop traversing up as soon as you find a root view that wasn't attached to any container

        if (isRootView(lView) && !parent) {
          return lView;
        } // continue otherwise


        lView =
        /** @type {?} */
        parent;
      }

      return null;
    }
    /**
     * Used to schedule change detection on the whole application.
     *
     * Unlike `tick`, `scheduleTick` coalesces multiple calls into one change detection run.
     * It is usually called indirectly by calling `markDirty` when the view needs to be
     * re-rendered.
     *
     * Typically `scheduleTick` uses `requestAnimationFrame` to coalesce multiple
     * `scheduleTick` requests. The scheduling function can be overridden in
     * `renderComponent`'s `scheduler` option.
     * @param {?} rootContext
     * @param {?} flags
     * @return {?}
     */


    function scheduleTick(rootContext, flags) {
      /** @type {?} */
      const nothingScheduled = rootContext.flags === 0
      /* Empty */
      ;
      rootContext.flags |= flags;

      if (nothingScheduled && rootContext.clean == _CLEAN_PROMISE) {
        /** @type {?} */
        let res;
        rootContext.clean = new Promise(
        /**
        * @param {?} r
        * @return {?}
        */
        r => res = r);
        rootContext.scheduler(
        /**
        * @return {?}
        */
        () => {
          if (rootContext.flags & 1
          /* DetectChanges */
          ) {
              rootContext.flags &= ~1
              /* DetectChanges */
              ;
              tickRootContext(rootContext);
            }

          if (rootContext.flags & 2
          /* FlushPlayers */
          ) {
              rootContext.flags &= ~2
              /* FlushPlayers */
              ;
              /** @type {?} */

              const playerHandler = rootContext.playerHandler;

              if (playerHandler) {
                playerHandler.flushPlayers();
              }
            }

          rootContext.clean = _CLEAN_PROMISE;

          /** @type {?} */
          res(null);
        });
      }
    }
    /**
     * @param {?} rootContext
     * @return {?}
     */


    function tickRootContext(rootContext) {
      for (let i = 0; i < rootContext.components.length; i++) {
        /** @type {?} */
        const rootComponent = rootContext.components[i];
        renderComponentOrTemplate(
        /** @type {?} */
        readPatchedLView(rootComponent), rootComponent);
      }
    }
    /**
     * @template T
     * @param {?} view
     * @param {?} context
     * @return {?}
     */


    function detectChangesInternal(view, context) {
      /** @type {?} */
      const rendererFactory = view[RENDERER_FACTORY];
      if (rendererFactory.begin) rendererFactory.begin();

      try {
        if (isCreationMode(view)) {
          checkView(view, context); // creation mode pass
        }

        checkView(view, context); // update mode pass
      } catch (error) {
        handleError(view, error);
        throw error;
      } finally {
        if (rendererFactory.end) rendererFactory.end();
      }
    }
    /**
     * Synchronously perform change detection on a root view and its components.
     *
     * @param {?} lView The view which the change detection should be performed on.
     * @return {?}
     */


    function detectChangesInRootView(lView) {
      tickRootContext(
      /** @type {?} */
      lView[CONTEXT]);
    }
    /**
     * Checks the change detector and its children, and throws if any changes are detected.
     *
     * This is used in development mode to verify that running change detection doesn't
     * introduce other changes.
     * @template T
     * @param {?} component
     * @return {?}
     */


    function checkNoChanges(component) {
      /** @type {?} */
      const view = getComponentViewByInstance(component);
      checkNoChangesInternal(view, component);
    }
    /**
     * @template T
     * @param {?} view
     * @param {?} context
     * @return {?}
     */


    function checkNoChangesInternal(view, context) {
      setCheckNoChangesMode(true);

      try {
        detectChangesInternal(view, context);
      } finally {
        setCheckNoChangesMode(false);
      }
    }
    /**
     * Checks the change detector on a root view and its components, and throws if any changes are
     * detected.
     *
     * This is used in development mode to verify that running change detection doesn't
     * introduce other changes.
     *
     * @param {?} lView The view which the change detection should be checked on.
     * @return {?}
     */


    function checkNoChangesInRootView(lView) {
      setCheckNoChangesMode(true);

      try {
        detectChangesInRootView(lView);
      } finally {
        setCheckNoChangesMode(false);
      }
    }
    /**
     * Checks the view of the component provided. Does not gate on dirty checks or execute doCheck.
     * @template T
     * @param {?} hostView
     * @param {?} component
     * @return {?}
     */


    function checkView(hostView, component) {
      /** @type {?} */
      const hostTView = hostView[TVIEW];
      /** @type {?} */

      const oldView = enterView(hostView, hostView[T_HOST]);
      /** @type {?} */

      const templateFn =
      /** @type {?} */
      hostTView.template;
      /** @type {?} */

      const creationMode = isCreationMode(hostView); // Will become true if the `try` block executes with no errors.

      /** @type {?} */

      let safeToRunHooks = false;

      try {
        resetPreOrderHookFlags(hostView);
        creationMode && executeViewQueryFn(1
        /* Create */
        , hostTView, component);
        executeTemplate(hostView, templateFn, getRenderFlags(hostView), component);
        refreshDescendantViews(hostView);
        safeToRunHooks = true;
      } finally {
        leaveView(oldView, safeToRunHooks);
      }
    }
    /**
     * @template T
     * @param {?} flags
     * @param {?} tView
     * @param {?} component
     * @return {?}
     */


    function executeViewQueryFn(flags, tView, component) {
      /** @type {?} */
      const viewQuery = tView.viewQuery;

      if (viewQuery !== null) {
        setCurrentQueryIndex(0);
        viewQuery(flags, component);
      }
    } ///////////////////////////////
    //// Bindings & interpolations
    ///////////////////////////////

    /**
     * Creates binding metadata for a particular binding and stores it in
     * TView.data. These are generated in order to support DebugElement.properties.
     *
     * Each binding / interpolation will have one (including attribute bindings)
     * because at the time of binding, we don't know to which instruction the binding
     * belongs. It is always stored in TView.data at the index of the last binding
     * value in LView (e.g. for interpolation8, it would be stored at the index of
     * the 8th value).
     *
     * @param {?} lView The LView that contains the current binding index.
     * @param {?=} prefix The static prefix string
     * @param {?=} suffix The static suffix string
     *
     * @return {?} Newly created binding metadata string for this binding or null
     */


    function storeBindingMetadata(lView, prefix = '', suffix = '') {
      /** @type {?} */
      const tData = lView[TVIEW].data;
      /** @type {?} */

      const lastBindingIndex = lView[BINDING_INDEX] - 1;
      /** @type {?} */

      const value = INTERPOLATION_DELIMITER + prefix + INTERPOLATION_DELIMITER + suffix;
      return tData[lastBindingIndex] == null ? tData[lastBindingIndex] = value : null;
    }
    /** @type {?} */


    const CLEAN_PROMISE = _CLEAN_PROMISE;
    /**
     * @param {?} tNode
     * @return {?}
     */

    function initializeTNodeInputs(tNode) {
      // If tNode.inputs is undefined, a listener has created outputs, but inputs haven't
      // yet been checked.
      if (tNode.inputs === undefined) {
        // mark inputs as checked
        tNode.inputs = generatePropertyAliases(tNode, 0
        /* Input */
        );
      }

      return tNode.inputs;
    }
    /**
     * @param {?} view
     * @return {?}
     */


    function getCleanup(view) {
      // top level variables should not be exported for performance reasons (PERF_NOTES.md)
      return view[CLEANUP] || (view[CLEANUP] = ngDevMode ? new
      /** @type {?} */
      LCleanup() : []);
    }
    /**
     * @param {?} view
     * @return {?}
     */


    function getTViewCleanup(view) {
      return view[TVIEW].cleanup || (view[TVIEW].cleanup = ngDevMode ? new
      /** @type {?} */
      TCleanup() : []);
    }
    /**
     * There are cases where the sub component's renderer needs to be included
     * instead of the current renderer (see the componentSyntheticHost* instructions).
     * @param {?} tNode
     * @param {?} lView
     * @return {?}
     */


    function loadComponentRenderer(tNode, lView) {
      /** @type {?} */
      const componentLView =
      /** @type {?} */
      lView[tNode.index];
      return componentLView[RENDERER];
    }
    /**
     * Handles an error thrown in an LView.
     * @param {?} lView
     * @param {?} error
     * @return {?}
     */


    function handleError(lView, error) {
      /** @type {?} */
      const injector = lView[INJECTOR$1];
      /** @type {?} */

      const errorHandler = injector ? injector.get(ErrorHandler, null) : null;
      errorHandler && errorHandler.handleError(error);
    }
    /**
     * Set the inputs of directives at the current node to corresponding value.
     *
     * @param {?} lView the `LView` which contains the directives.
     * @param {?} inputs mapping between the public "input" name and privately-known,
     * possibly minified, property names to write to.
     * @param {?} value Value to set.
     * @return {?}
     */


    function setInputsForProperty(lView, inputs, value) {
      /** @type {?} */
      const tView = lView[TVIEW];

      for (let i = 0; i < inputs.length;) {
        /** @type {?} */
        const index =
        /** @type {?} */
        inputs[i++];
        /** @type {?} */

        const publicName =
        /** @type {?} */
        inputs[i++];
        /** @type {?} */

        const privateName =
        /** @type {?} */
        inputs[i++];
        /** @type {?} */

        const instance = lView[index];
        ngDevMode && assertDataInRange(lView, index);
        /** @type {?} */

        const def =
        /** @type {?} */
        tView.data[index];
        /** @type {?} */

        const setInput = def.setInput;

        if (setInput) {
          /** @type {?} */
          def.setInput(instance, value, publicName, privateName);
        } else {
          instance[privateName] = value;
        }
      }
    }
    /**
     * Updates a text binding at a given index in a given LView.
     * @param {?} lView
     * @param {?} index
     * @param {?} value
     * @return {?}
     */


    function textBindingInternal(lView, index, value) {
      ngDevMode && assertNotSame(value,
      /** @type {?} */
      NO_CHANGE, 'value should not be NO_CHANGE');
      ngDevMode && assertDataInRange(lView, index + HEADER_OFFSET);
      /** @type {?} */

      const element =
      /** @type {?} */

      /** @type {?} */
      getNativeByIndex(index, lView);
      ngDevMode && assertDefined(element, 'native element should exist');
      ngDevMode && ngDevMode.rendererSetText++;
      /** @type {?} */

      const renderer = lView[RENDERER];
      isProceduralRenderer(renderer) ? renderer.setValue(element, value) : element.textContent = value;
    }
    /**
     * Renders all initial styling (class and style values) on to the element from the tNode.
     *
     * All initial styling data (i.e. any values extracted from the `style` or `class` attributes
     * on an element) are collected into the `tNode.styles` and `tNode.classes` data structures.
     * These values are populated during the creation phase of an element and are then later
     * applied once the element is instantiated. This function applies each of the static
     * style and class entries to the element.
     * @param {?} renderer
     * @param {?} native
     * @param {?} tNode
     * @return {?}
     */


    function renderInitialStyling(renderer, native, tNode) {
      renderStylingMap(renderer, native, tNode.classes, true);
      renderStylingMap(renderer, native, tNode.styles, false);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    const unusedValueToPlacateAjd$1 = unusedValueExportToPlacateAjd$1 + unusedValueExportToPlacateAjd$4 + unusedValueExportToPlacateAjd$5 + unusedValueExportToPlacateAjd$3 + unusedValueExportToPlacateAjd;
    /**
     * @param {?} tNode
     * @param {?} embeddedView
     * @return {?}
     */

    function getLContainer(tNode, embeddedView) {
      ngDevMode && assertLView(embeddedView);
      /** @type {?} */

      const container =
      /** @type {?} */
      embeddedView[PARENT];

      if (tNode.index === -1) {
        // This is a dynamically created view inside a dynamic container.
        // The parent isn't an LContainer if the embedded view hasn't been attached yet.
        return isLContainer(container) ? container : null;
      } else {
        ngDevMode && assertLContainer(container); // This is a inline view node (e.g. embeddedViewStart)

        return container;
      }
    }
    /**
     * Retrieves render parent for a given view.
     * Might be null if a view is not yet attached to any container.
     * @param {?} tViewNode
     * @param {?} view
     * @return {?}
     */


    function getContainerRenderParent(tViewNode, view) {
      /** @type {?} */
      const container = getLContainer(tViewNode, view);
      return container ? nativeParentNode(view[RENDERER], container[NATIVE]) : null;
    }
    /** @enum {number} */


    const WalkTNodeTreeAction = {
      /** node insert in the native environment */
      Insert: 0,

      /** node detach from the native environment */
      Detach: 1,

      /** node destruction using the renderer's API */
      Destroy: 2
    };
    /**
     * NOTE: for performance reasons, the possible actions are inlined within the function instead of
     * being passed as an argument.
     * @param {?} action
     * @param {?} renderer
     * @param {?} parent
     * @param {?} lNodeToHandle
     * @param {?=} beforeNode
     * @return {?}
     */

    function executeActionOnElementOrContainer(action, renderer, parent, lNodeToHandle, beforeNode) {
      // If this slot was allocated for a text node dynamically created by i18n, the text node itself
      // won't be created until i18nApply() in the update block, so this node should be skipped.
      // For more info, see "ICU expressions should work inside an ngTemplateOutlet inside an ngFor"
      // in `i18n_spec.ts`.
      if (lNodeToHandle != null) {
        /** @type {?} */
        let lContainer;
        /** @type {?} */

        let isComponent = false; // We are expecting an RNode, but in the case of a component or LContainer the `RNode` is
        // wrapped
        // in an array which needs to be unwrapped. We need to know if it is a component and if
        // it has LContainer so that we can process all of those cases appropriately.

        if (isLContainer(lNodeToHandle)) {
          lContainer = lNodeToHandle;
        } else if (isLView(lNodeToHandle)) {
          isComponent = true;
          ngDevMode && assertDefined(lNodeToHandle[HOST], 'HOST must be defined for a component LView');
          lNodeToHandle =
          /** @type {?} */
          lNodeToHandle[HOST];
        }
        /** @type {?} */


        const rNode = unwrapRNode(lNodeToHandle);
        ngDevMode && assertDomNode(rNode);

        if (action === 0
        /* Insert */
        ) {
            nativeInsertBefore(renderer,
            /** @type {?} */
            parent, rNode, beforeNode || null);
          } else if (action === 1
        /* Detach */
        ) {
            nativeRemoveNode(renderer, rNode, isComponent);
          } else if (action === 2
        /* Destroy */
        ) {
            ngDevMode && ngDevMode.rendererDestroyNode++;

            /** @type {?} */

            /** @type {?} */
            renderer.destroyNode(rNode);
          }

        if (lContainer != null) {
          executeActionOnContainer(renderer, action, lContainer, parent, beforeNode);
        }
      }
    }
    /**
     * @param {?} value
     * @param {?} renderer
     * @return {?}
     */


    function createTextNode(value, renderer) {
      return isProceduralRenderer(renderer) ? renderer.createText(renderStringify(value)) : renderer.createTextNode(renderStringify(value));
    }
    /**
     * @param {?} lView
     * @param {?} insertMode
     * @param {?=} beforeNode
     * @return {?}
     */


    function addRemoveViewFromContainer(lView, insertMode, beforeNode) {
      /** @type {?} */
      const renderParent = getContainerRenderParent(
      /** @type {?} */
      lView[TVIEW].node, lView);
      ngDevMode && assertNodeType(
      /** @type {?} */
      lView[TVIEW].node, 2
      /* View */
      );

      if (renderParent) {
        /** @type {?} */
        const renderer = lView[RENDERER];
        /** @type {?} */

        const action = insertMode ? 0
        /* Insert */
        : 1
        /* Detach */
        ;
        executeActionOnView(renderer, action, lView, renderParent, beforeNode);
      }
    }
    /**
     * Detach a `LView` from the DOM by detaching its nodes.
     *
     * @param {?} lView the `LView` to be detached.
     * @return {?}
     */


    function renderDetachView(lView) {
      executeActionOnView(lView[RENDERER], 1
      /* Detach */
      , lView, null, null);
    }
    /**
     * Traverses down and up the tree of views and containers to remove listeners and
     * call onDestroy callbacks.
     *
     * Notes:
     *  - Because it's used for onDestroy calls, it needs to be bottom-up.
     *  - Must process containers instead of their views to avoid splicing
     *  when views are destroyed and re-added.
     *  - Using a while loop because it's faster than recursion
     *  - Destroy only called on movement to sibling or movement to parent (laterally or up)
     *
     * @param {?} rootView The view to destroy
     * @return {?}
     */


    function destroyViewTree(rootView) {
      // If the view has no children, we can clean it up and return early.

      /** @type {?} */
      let lViewOrLContainer = rootView[CHILD_HEAD];

      if (!lViewOrLContainer) {
        return cleanUpView(rootView);
      }

      while (lViewOrLContainer) {
        /** @type {?} */
        let next = null;

        if (isLView(lViewOrLContainer)) {
          // If LView, traverse down to child.
          next = lViewOrLContainer[CHILD_HEAD];
        } else {
          ngDevMode && assertLContainer(lViewOrLContainer); // If container, traverse down to its first LView.

          /** @type {?} */

          const firstView = lViewOrLContainer[CONTAINER_HEADER_OFFSET];
          if (firstView) next = firstView;
        }

        if (!next) {
          // Only clean up view when moving to the side or up, as destroy hooks
          // should be called in order from the bottom up.
          while (lViewOrLContainer && !
          /** @type {?} */
          lViewOrLContainer[NEXT] && lViewOrLContainer !== rootView) {
            cleanUpView(lViewOrLContainer);
            lViewOrLContainer = getParentState(lViewOrLContainer, rootView);
          }

          cleanUpView(lViewOrLContainer || rootView);
          next = lViewOrLContainer &&
          /** @type {?} */
          lViewOrLContainer[NEXT];
        }

        lViewOrLContainer = next;
      }
    }
    /**
     * Inserts a view into a container.
     *
     * This adds the view to the container's array of active views in the correct
     * position. It also adds the view's elements to the DOM if the container isn't a
     * root node of another view (in that case, the view's elements will be added when
     * the container's parent view is added later).
     *
     * @param {?} lView The view to insert
     * @param {?} lContainer The container into which the view should be inserted
     * @param {?} index Which index in the container to insert the child view into
     * @return {?}
     */


    function insertView(lView, lContainer, index) {
      ngDevMode && assertLView(lView);
      ngDevMode && assertLContainer(lContainer);
      /** @type {?} */

      const indexInContainer = CONTAINER_HEADER_OFFSET + index;
      /** @type {?} */

      const containerLength = lContainer.length;

      if (index > 0) {
        // This is a new view, we need to add it to the children.
        lContainer[indexInContainer - 1][NEXT] = lView;
      }

      if (index < containerLength - CONTAINER_HEADER_OFFSET) {
        lView[NEXT] = lContainer[indexInContainer];
        addToArray(lContainer, CONTAINER_HEADER_OFFSET + index, lView);
      } else {
        lContainer.push(lView);
        lView[NEXT] = null;
      }

      lView[PARENT] = lContainer; // track views where declaration and insertion points are different

      /** @type {?} */

      const declarationLContainer = lView[DECLARATION_LCONTAINER];

      if (declarationLContainer !== null && lContainer !== declarationLContainer) {
        trackMovedView(declarationLContainer, lView);
      } // notify query that a new view has been added

      /** @type {?} */


      const lQueries = lView[QUERIES];

      if (lQueries !== null) {
        lQueries.insertView(lView[TVIEW]);
      } // Sets the attached flag


      lView[FLAGS] |= 128
      /* Attached */
      ;
    }
    /**
     * Track views created from the declaration container (TemplateRef) and inserted into a
     * different LContainer.
     * @param {?} declarationContainer
     * @param {?} lView
     * @return {?}
     */


    function trackMovedView(declarationContainer, lView) {
      ngDevMode && assertLContainer(declarationContainer);
      /** @type {?} */

      const declaredViews = declarationContainer[MOVED_VIEWS];

      if (declaredViews === null) {
        declarationContainer[MOVED_VIEWS] = [lView];
      } else {
        declaredViews.push(lView);
      }
    }
    /**
     * @param {?} declarationContainer
     * @param {?} lView
     * @return {?}
     */


    function detachMovedView(declarationContainer, lView) {
      ngDevMode && assertLContainer(declarationContainer);
      ngDevMode && assertDefined(declarationContainer[MOVED_VIEWS], 'A projected view should belong to a non-empty projected views collection');
      /** @type {?} */

      const projectedViews =
      /** @type {?} */
      declarationContainer[MOVED_VIEWS];
      /** @type {?} */

      const declaredViewIndex = projectedViews.indexOf(lView);
      projectedViews.splice(declaredViewIndex, 1);
    }
    /**
     * Detaches a view from a container.
     *
     * This method removes the view from the container's array of active views. It also
     * removes the view's elements from the DOM.
     *
     * @param {?} lContainer The container from which to detach a view
     * @param {?} removeIndex The index of the view to detach
     * @return {?} Detached LView instance.
     */


    function detachView(lContainer, removeIndex) {
      if (lContainer.length <= CONTAINER_HEADER_OFFSET) return;
      /** @type {?} */

      const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex;
      /** @type {?} */

      const viewToDetach = lContainer[indexInContainer];

      if (viewToDetach) {
        /** @type {?} */
        const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];

        if (declarationLContainer !== null && declarationLContainer !== lContainer) {
          detachMovedView(declarationLContainer, viewToDetach);
        }

        if (removeIndex > 0) {
          lContainer[indexInContainer - 1][NEXT] =
          /** @type {?} */
          viewToDetach[NEXT];
        }
        /** @type {?} */


        const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);
        addRemoveViewFromContainer(viewToDetach, false); // notify query that a view has been removed

        /** @type {?} */

        const lQueries = removedLView[QUERIES];

        if (lQueries !== null) {
          lQueries.detachView(removedLView[TVIEW]);
        }

        viewToDetach[PARENT] = null;
        viewToDetach[NEXT] = null; // Unsets the attached flag

        viewToDetach[FLAGS] &= ~128
        /* Attached */
        ;
      }

      return viewToDetach;
    }
    /**
     * Removes a view from a container, i.e. detaches it and then destroys the underlying LView.
     *
     * @param {?} lContainer The container from which to remove a view
     * @param {?} removeIndex The index of the view to remove
     * @return {?}
     */


    function removeView(lContainer, removeIndex) {
      /** @type {?} */
      const detachedView = detachView(lContainer, removeIndex);
      detachedView && destroyLView(detachedView);
    }
    /**
     * A standalone function which destroys an LView,
     * conducting cleanup (e.g. removing listeners, calling onDestroys).
     *
     * @param {?} lView The view to be destroyed.
     * @return {?}
     */


    function destroyLView(lView) {
      if (!(lView[FLAGS] & 256
      /* Destroyed */
      )) {
        /** @type {?} */
        const renderer = lView[RENDERER];

        if (isProceduralRenderer(renderer) && renderer.destroyNode) {
          executeActionOnView(renderer, 2
          /* Destroy */
          , lView, null, null);
        }

        destroyViewTree(lView);
      }
    }
    /**
     * Determines which LViewOrLContainer to jump to when traversing back up the
     * tree in destroyViewTree.
     *
     * Normally, the view's parent LView should be checked, but in the case of
     * embedded views, the container (which is the view node's parent, but not the
     * LView's parent) needs to be checked for a possible next property.
     *
     * @param {?} lViewOrLContainer The LViewOrLContainer for which we need a parent state
     * @param {?} rootView The rootView, so we don't propagate too far up the view tree
     * @return {?} The correct parent LViewOrLContainer
     */


    function getParentState(lViewOrLContainer, rootView) {
      /** @type {?} */
      let tNode;

      if (isLView(lViewOrLContainer) && (tNode = lViewOrLContainer[T_HOST]) && tNode.type === 2
      /* View */
      ) {
          // if it's an embedded view, the state needs to go up to the container, in case the
          // container has a next
          return getLContainer(
          /** @type {?} */
          tNode, lViewOrLContainer);
        } else {
        // otherwise, use parent view for containers or component views
        return lViewOrLContainer[PARENT] === rootView ? null : lViewOrLContainer[PARENT];
      }
    }
    /**
     * Calls onDestroys hooks for all directives and pipes in a given view and then removes all
     * listeners. Listeners are removed as the last step so events delivered in the onDestroys hooks
     * can be propagated to \@Output listeners.
     *
     * @param {?} view The LView to clean up
     * @return {?}
     */


    function cleanUpView(view) {
      if (isLView(view) && !(view[FLAGS] & 256
      /* Destroyed */
      )) {
        // Usually the Attached flag is removed when the view is detached from its parent, however
        // if it's a root view, the flag won't be unset hence why we're also removing on destroy.
        view[FLAGS] &= ~128
        /* Attached */
        ; // Mark the LView as destroyed *before* executing the onDestroy hooks. An onDestroy hook
        // runs arbitrary user code, which could include its own `viewRef.destroy()` (or similar). If
        // We don't flag the view as destroyed before the hooks, this could lead to an infinite loop.
        // This also aligns with the ViewEngine behavior. It also means that the onDestroy hook is
        // really more of an "afterDestroy" hook if you think about it.

        view[FLAGS] |= 256
        /* Destroyed */
        ;
        executeOnDestroys(view);
        removeListeners(view);
        /** @type {?} */

        const hostTNode = view[T_HOST]; // For component views only, the local renderer is destroyed as clean up time.

        if (hostTNode && hostTNode.type === 3
        /* Element */
        && isProceduralRenderer(view[RENDERER])) {
          ngDevMode && ngDevMode.rendererDestroy++;

          /** @type {?} */
          view[RENDERER].destroy();
        }
        /** @type {?} */


        const declarationContainer = view[DECLARATION_LCONTAINER]; // we are dealing with an embedded view that is still inserted into a container

        if (declarationContainer !== null && isLContainer(view[PARENT])) {
          // and this is a projected view
          if (declarationContainer !== view[PARENT]) {
            detachMovedView(declarationContainer, view);
          } // For embedded views still attached to a container: remove query result from this view.

          /** @type {?} */


          const lQueries = view[QUERIES];

          if (lQueries !== null) {
            lQueries.detachView(view[TVIEW]);
          }
        }
      }
    }
    /**
     * Removes listeners and unsubscribes from output subscriptions
     * @param {?} lView
     * @return {?}
     */


    function removeListeners(lView) {
      /** @type {?} */
      const tCleanup = lView[TVIEW].cleanup;

      if (tCleanup !== null) {
        /** @type {?} */
        const lCleanup =
        /** @type {?} */
        lView[CLEANUP];

        for (let i = 0; i < tCleanup.length - 1; i += 2) {
          if (typeof tCleanup[i] === 'string') {
            // This is a native DOM listener

            /** @type {?} */
            const idxOrTargetGetter = tCleanup[i + 1];
            /** @type {?} */

            const target = typeof idxOrTargetGetter === 'function' ? idxOrTargetGetter(lView) : unwrapRNode(lView[idxOrTargetGetter]);
            /** @type {?} */

            const listener = lCleanup[tCleanup[i + 2]];
            /** @type {?} */

            const useCaptureOrSubIdx = tCleanup[i + 3];

            if (typeof useCaptureOrSubIdx === 'boolean') {
              // native DOM listener registered with Renderer3
              target.removeEventListener(tCleanup[i], listener, useCaptureOrSubIdx);
            } else {
              if (useCaptureOrSubIdx >= 0) {
                // unregister
                lCleanup[useCaptureOrSubIdx]();
              } else {
                // Subscription
                lCleanup[-useCaptureOrSubIdx].unsubscribe();
              }
            }

            i += 2;
          } else {
            // This is a cleanup function that is grouped with the index of its context

            /** @type {?} */
            const context = lCleanup[tCleanup[i + 1]];
            tCleanup[i].call(context);
          }
        }

        lView[CLEANUP] = null;
      }
    }
    /**
     * Calls onDestroy hooks for this view
     * @param {?} view
     * @return {?}
     */


    function executeOnDestroys(view) {
      /** @type {?} */
      const tView = view[TVIEW];
      /** @type {?} */

      let destroyHooks;

      if (tView != null && (destroyHooks = tView.destroyHooks) != null) {
        for (let i = 0; i < destroyHooks.length; i += 2) {
          /** @type {?} */
          const context = view[
          /** @type {?} */
          destroyHooks[i]]; // Only call the destroy hook if the context has been requested.

          if (!(context instanceof NodeInjectorFactory)) {
            /** @type {?} */
            destroyHooks[i + 1].call(context);
          }
        }
      }
    }
    /**
     * Returns a native element if a node can be inserted into the given parent.
     *
     * There are two reasons why we may not be able to insert a element immediately.
     * - Projection: When creating a child content element of a component, we have to skip the
     *   insertion because the content of a component will be projected.
     *   `<component><content>delayed due to projection</content></component>`
     * - Parent container is disconnected: This can happen when we are inserting a view into
     *   parent container, which itself is disconnected. For example the parent container is part
     *   of a View which has not be inserted or is made for projection but has not been inserted
     *   into destination.
     * @param {?} tNode
     * @param {?} currentView
     * @return {?}
     */


    function getRenderParent(tNode, currentView) {
      // Nodes of the top-most view can be inserted eagerly.
      if (isRootView(currentView)) {
        return nativeParentNode(currentView[RENDERER], getNativeByTNode(tNode, currentView));
      } // Skip over element and ICU containers as those are represented by a comment node and
      // can't be used as a render parent.

      /** @type {?} */


      const parent = getHighestElementOrICUContainer(tNode);
      /** @type {?} */

      const renderParent = parent.parent; // If the parent is null, then we are inserting across views: either into an embedded view or a
      // component view.

      if (renderParent == null) {
        /** @type {?} */
        const hostTNode =
        /** @type {?} */
        currentView[T_HOST];

        if (hostTNode.type === 2
        /* View */
        ) {
            // We are inserting a root element of an embedded view We might delay insertion of children
            // for a given view if it is disconnected. This might happen for 2 main reasons:
            // - view is not inserted into any container(view was created but not inserted yet)
            // - view is inserted into a container but the container itself is not inserted into the DOM
            // (container might be part of projection or child of a view that is not inserted yet).
            // In other words we can insert children of a given view if this view was inserted into a
            // container and the container itself has its render parent determined.
            return getContainerRenderParent(
            /** @type {?} */
            hostTNode, currentView);
          } else {
          // We are inserting a root element of the component view into the component host element and
          // it should always be eager.
          return getHostNative(currentView);
        }
      } else {
        /** @type {?} */
        const isIcuCase = parent && parent.type === 5
        /* IcuContainer */
        ; // If the parent of this node is an ICU container, then it is represented by comment node and we
        // need to use it as an anchor. If it is projected then its direct parent node is the renderer.

        if (isIcuCase && parent.flags & 2
        /* isProjected */
        ) {
            return (
              /** @type {?} */
              getNativeByTNode(parent, currentView).parentNode
            );
          }

        ngDevMode && assertNodeType(renderParent, 3
        /* Element */
        );

        if (renderParent.flags & 1
        /* isComponent */
        && !isIcuCase) {
          /** @type {?} */
          const tData = currentView[TVIEW].data;
          /** @type {?} */

          const tNode =
          /** @type {?} */
          tData[renderParent.index];
          /** @type {?} */

          const encapsulation =
          /** @type {?} */
          tData[tNode.directiveStart].encapsulation; // We've got a parent which is an element in the current view. We just need to verify if the
          // parent element is not a component. Component's content nodes are not inserted immediately
          // because they will be projected, and so doing insert at this point would be wasteful.
          // Since the projection would then move it to its final destination. Note that we can't
          // make this assumption when using the Shadow DOM, because the native projection placeholders
          // (<content> or <slot>) have to be in place as elements are being inserted.

          if (encapsulation !== ViewEncapsulation.ShadowDom && encapsulation !== ViewEncapsulation.Native) {
            return null;
          }
        }

        return (
          /** @type {?} */
          getNativeByTNode(renderParent, currentView)
        );
      }
    }
    /**
     * Gets the native host element for a given view. Will return null if the current view does not have
     * a host element.
     * @param {?} currentView
     * @return {?}
     */


    function getHostNative(currentView) {
      ngDevMode && assertLView(currentView);
      /** @type {?} */

      const hostTNode = currentView[T_HOST];
      return hostTNode && hostTNode.type === 3
      /* Element */
      ?
      /** @type {?} */
      getNativeByTNode(hostTNode,
      /** @type {?} */
      getLViewParent(currentView)) : null;
    }
    /**
     * Inserts a native node before another native node for a given parent using {\@link Renderer3}.
     * This is a utility function that can be used when native nodes were determined - it abstracts an
     * actual renderer being used.
     * @param {?} renderer
     * @param {?} parent
     * @param {?} child
     * @param {?} beforeNode
     * @return {?}
     */


    function nativeInsertBefore(renderer, parent, child, beforeNode) {
      ngDevMode && ngDevMode.rendererInsertBefore++;

      if (isProceduralRenderer(renderer)) {
        renderer.insertBefore(parent, child, beforeNode);
      } else {
        parent.insertBefore(child, beforeNode, true);
      }
    }
    /**
     * @param {?} renderer
     * @param {?} parent
     * @param {?} child
     * @return {?}
     */


    function nativeAppendChild(renderer, parent, child) {
      ngDevMode && ngDevMode.rendererAppendChild++;

      if (isProceduralRenderer(renderer)) {
        renderer.appendChild(parent, child);
      } else {
        parent.appendChild(child);
      }
    }
    /**
     * @param {?} renderer
     * @param {?} parent
     * @param {?} child
     * @param {?} beforeNode
     * @return {?}
     */


    function nativeAppendOrInsertBefore(renderer, parent, child, beforeNode) {
      if (beforeNode !== null) {
        nativeInsertBefore(renderer, parent, child, beforeNode);
      } else {
        nativeAppendChild(renderer, parent, child);
      }
    }
    /**
     * Removes a node from the DOM given its native parent.
     * @param {?} renderer
     * @param {?} parent
     * @param {?} child
     * @param {?=} isHostElement
     * @return {?}
     */


    function nativeRemoveChild(renderer, parent, child, isHostElement) {
      if (isProceduralRenderer(renderer)) {
        renderer.removeChild(parent, child, isHostElement);
      } else {
        parent.removeChild(child);
      }
    }
    /**
     * Returns a native parent of a given native node.
     * @param {?} renderer
     * @param {?} node
     * @return {?}
     */


    function nativeParentNode(renderer, node) {
      return (
        /** @type {?} */
        isProceduralRenderer(renderer) ? renderer.parentNode(node) : node.parentNode
      );
    }
    /**
     * Returns a native sibling of a given native node.
     * @param {?} renderer
     * @param {?} node
     * @return {?}
     */


    function nativeNextSibling(renderer, node) {
      return isProceduralRenderer(renderer) ? renderer.nextSibling(node) : node.nextSibling;
    }
    /**
     * Finds a native "anchor" node for cases where we can't append a native child directly
     * (`appendChild`) and need to use a reference (anchor) node for the `insertBefore` operation.
     * @param {?} parentTNode
     * @param {?} lView
     * @return {?}
     */


    function getNativeAnchorNode(parentTNode, lView) {
      if (parentTNode.type === 2
      /* View */
      ) {
          /** @type {?} */
          const lContainer =
          /** @type {?} */
          getLContainer(
          /** @type {?} */
          parentTNode, lView);
          /** @type {?} */

          const index = lContainer.indexOf(lView, CONTAINER_HEADER_OFFSET) - CONTAINER_HEADER_OFFSET;
          return getBeforeNodeForView(index, lContainer);
        } else if (parentTNode.type === 4
      /* ElementContainer */
      || parentTNode.type === 5
      /* IcuContainer */
      ) {
          return getNativeByTNode(parentTNode, lView);
        }

      return null;
    }
    /**
     * Appends the `child` native node (or a collection of nodes) to the `parent`.
     *
     * The element insertion might be delayed {\@link canInsertNativeNode}.
     *
     * @param {?} childEl The native child (or children) that should be appended
     * @param {?} childTNode The TNode of the child element
     * @param {?} currentView The current LView
     * @return {?} Whether or not the child was appended
     */


    function appendChild(childEl, childTNode, currentView) {
      /** @type {?} */
      const renderParent = getRenderParent(childTNode, currentView);

      if (renderParent != null) {
        /** @type {?} */
        const renderer = currentView[RENDERER];
        /** @type {?} */

        const parentTNode = childTNode.parent ||
        /** @type {?} */
        currentView[T_HOST];
        /** @type {?} */

        const anchorNode = getNativeAnchorNode(parentTNode, currentView);

        if (Array.isArray(childEl)) {
          for (let nativeNode of childEl) {
            nativeAppendOrInsertBefore(renderer, renderParent, nativeNode, anchorNode);
          }
        } else {
          nativeAppendOrInsertBefore(renderer, renderParent, childEl, anchorNode);
        }
      }
    }
    /**
     * Gets the top-level element or an ICU container if those containers are nested.
     *
     * @param {?} tNode The starting TNode for which we should skip element and ICU containers
     * @return {?} The TNode of the highest level ICU container or element container
     */


    function getHighestElementOrICUContainer(tNode) {
      while (tNode.parent != null && (tNode.parent.type === 4
      /* ElementContainer */
      || tNode.parent.type === 5
      /* IcuContainer */
      )) {
        tNode = tNode.parent;
      }

      return tNode;
    }
    /**
     * @param {?} viewIndexInContainer
     * @param {?} lContainer
     * @return {?}
     */


    function getBeforeNodeForView(viewIndexInContainer, lContainer) {
      /** @type {?} */
      const nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;

      if (nextViewIndex < lContainer.length) {
        /** @type {?} */
        const lView =
        /** @type {?} */
        lContainer[nextViewIndex];
        ngDevMode && assertDefined(lView[T_HOST], 'Missing Host TNode');
        /** @type {?} */

        const tViewNodeChild =
        /** @type {?} */
        lView[T_HOST].child;
        return tViewNodeChild !== null ? getNativeByTNodeOrNull(tViewNodeChild, lView) : lContainer[NATIVE];
      } else {
        return lContainer[NATIVE];
      }
    }
    /**
     * Removes a native node itself using a given renderer. To remove the node we are looking up its
     * parent from the native tree as not all platforms / browsers support the equivalent of
     * node.remove().
     *
     * @param {?} renderer A renderer to be used
     * @param {?} rNode The native node that should be removed
     * @param {?=} isHostElement A flag indicating if a node to be removed is a host of a component.
     * @return {?}
     */


    function nativeRemoveNode(renderer, rNode, isHostElement) {
      /** @type {?} */
      const nativeParent = nativeParentNode(renderer, rNode);

      if (nativeParent) {
        nativeRemoveChild(renderer, nativeParent, rNode, isHostElement);
      }
    }
    /**
     * Appends nodes to a target projection place. Nodes to insert were previously re-distribution and
     * stored on a component host level.
     * @param {?} lView A LView where nodes are inserted (target LView)
     * @param {?} tProjectionNode A projection node where previously re-distribution should be appended
     * (target insertion place)
     * @param {?} selectorIndex A bucket from where nodes to project should be taken
     * @param {?} componentView A where projectable nodes were initially created (source view)
     * @return {?}
     */


    function appendProjectedNodes(lView, tProjectionNode, selectorIndex, componentView) {
      /** @type {?} */
      const projectedView =
      /** @type {?} */

      /** @type {?} */
      componentView[PARENT];
      /** @type {?} */

      const componentNode =
      /** @type {?} */
      componentView[T_HOST];
      /** @type {?} */

      let nodeToProject =
      /** @type {?} */
      componentNode.projection[selectorIndex];

      if (Array.isArray(nodeToProject)) {
        appendChild(nodeToProject, tProjectionNode, lView);
      } else {
        while (nodeToProject) {
          if (!(nodeToProject.flags & 32
          /* isDetached */
          )) {
            if (nodeToProject.type === 1
            /* Projection */
            ) {
                appendProjectedNodes(lView, tProjectionNode,
                /** @type {?} */
                nodeToProject.projection, findComponentView(projectedView));
              } else {
              // This flag must be set now or we won't know that this node is projected
              // if the nodes are inserted into a container later.
              nodeToProject.flags |= 2
              /* isProjected */
              ;
              appendProjectedNode(nodeToProject, tProjectionNode, lView, projectedView);
            }
          }

          nodeToProject = nodeToProject.projectionNext;
        }
      }
    }
    /**
     * Loops over all children of a TNode container and appends them to the DOM
     *
     * @param {?} ngContainerChildTNode The first child of the TNode container
     * @param {?} tProjectionNode The projection (ng-content) TNode
     * @param {?} currentView Current LView
     * @param {?} projectionView Projection view (view above current)
     * @return {?}
     */


    function appendProjectedChildren(ngContainerChildTNode, tProjectionNode, currentView, projectionView) {
      while (ngContainerChildTNode) {
        appendProjectedNode(ngContainerChildTNode, tProjectionNode, currentView, projectionView);
        ngContainerChildTNode = ngContainerChildTNode.next;
      }
    }
    /**
     * Appends a projected node to the DOM, or in the case of a projected container,
     * appends the nodes from all of the container's active views to the DOM.
     *
     * @param {?} projectedTNode The TNode to be projected
     * @param {?} tProjectionNode The projection (ng-content) TNode
     * @param {?} currentView Current LView
     * @param {?} projectionView Projection view (view above current)
     * @return {?}
     */


    function appendProjectedNode(projectedTNode, tProjectionNode, currentView, projectionView) {
      /** @type {?} */
      const native = getNativeByTNode(projectedTNode, projectionView);
      appendChild(native, tProjectionNode, currentView); // the projected contents are processed while in the shadow view (which is the currentView)
      // therefore we need to extract the view where the host element lives since it's the
      // logical container of the content projected views

      attachPatchData(native, projectionView);
      /** @type {?} */

      const nodeOrContainer = projectionView[projectedTNode.index];

      if (projectedTNode.type === 0
      /* Container */
      ) {
          // The node we are adding is a container and we are adding it to an element which
          // is not a component (no more re-projection).
          // Alternatively a container is projected at the root of a component's template
          // and can't be re-projected (as not content of any component).
          // Assign the final projection location in those cases.
          for (let i = CONTAINER_HEADER_OFFSET; i < nodeOrContainer.length; i++) {
            addRemoveViewFromContainer(nodeOrContainer[i], true, nodeOrContainer[NATIVE]);
          }
        } else if (projectedTNode.type === 5
      /* IcuContainer */
      ) {
          // The node we are adding is an ICU container which is why we also need to project all the
          // children nodes that might have been created previously and are linked to this anchor

          /** @type {?} */
          let ngContainerChildTNode =
          /** @type {?} */
          projectedTNode.child;
          appendProjectedChildren(ngContainerChildTNode, ngContainerChildTNode, projectionView, projectionView);
        } else {
        if (projectedTNode.type === 4
        /* ElementContainer */
        ) {
            appendProjectedChildren(projectedTNode.child, tProjectionNode, currentView, projectionView);
          }

        if (isLContainer(nodeOrContainer)) {
          appendChild(nodeOrContainer[NATIVE], tProjectionNode, currentView);
        }
      }
    }
    /**
     * `executeActionOnView` performs an operation on the view as specified in `action` (insert, detach,
     * destroy)
     *
     * Inserting a view without projection or containers at top level is simple. Just iterate over the
     * root nodes of the View, and for each node perform the `action`.
     *
     * Things get more complicated with containers and projections. That is because coming across:
     * - Container: implies that we have to insert/remove/destroy the views of that container as well
     *              which in turn can have their own Containers at the View roots.
     * - Projection: implies that we have to insert/remove/destroy the nodes of the projection. The
     *               complication is that the nodes we are projecting can themselves have Containers
     *               or other Projections.
     *
     * As you can see this is a very recursive problem. While the recursive implementation is not the
     * most efficient one, trying to unroll the nodes non-recursively results in very complex code that
     * is very hard (to maintain). We are sacrificing a bit of performance for readability using a
     * recursive implementation.
     *
     * @param {?} renderer Renderer to use
     * @param {?} action action to perform (insert, detach, destroy)
     * @param {?} lView The LView which needs to be inserted, detached, destroyed.
     * @param {?} renderParent parent DOM element for insertion/removal.
     * @param {?} beforeNode Before which node the insertions should happen.
     * @return {?}
     */


    function executeActionOnView(renderer, action, lView, renderParent, beforeNode) {
      /** @type {?} */
      const tView = lView[TVIEW];
      ngDevMode && assertNodeType(
      /** @type {?} */
      tView.node, 2
      /* View */
      );
      /** @type {?} */

      let viewRootTNode =
      /** @type {?} */
      tView.node.child;

      while (viewRootTNode !== null) {
        executeActionOnNode(renderer, action, lView, viewRootTNode, renderParent, beforeNode);
        viewRootTNode = viewRootTNode.next;
      }
    }
    /**
     * `executeActionOnProjection` performs an operation on the projection specified by `action`
     * (insert, detach, destroy).
     *
     * Inserting a projection requires us to locate the projected nodes from the parent component. The
     * complication is that those nodes themselves could be re-projected from their parent component.
     *
     * @param {?} renderer Renderer to use
     * @param {?} action action to perform (insert, detach, destroy)
     * @param {?} lView The LView which needs to be inserted, detached, destroyed.
     * @param {?} tProjectionNode projection TNode to process
     * @param {?} renderParent parent DOM element for insertion/removal.
     * @param {?} beforeNode Before which node the insertions should happen.
     * @return {?}
     */


    function executeActionOnProjection(renderer, action, lView, tProjectionNode, renderParent, beforeNode) {
      /** @type {?} */
      const componentLView = findComponentView(lView);
      /** @type {?} */

      const componentNode =
      /** @type {?} */
      componentLView[T_HOST];
      ngDevMode && assertDefined(componentNode.projection, 'Element nodes for which projection is processed must have projection defined.');
      /** @type {?} */

      const nodeToProject =
      /** @type {?} */
      componentNode.projection[tProjectionNode.projection];

      if (nodeToProject !== undefined) {
        if (Array.isArray(nodeToProject)) {
          for (let i = 0; i < nodeToProject.length; i++) {
            /** @type {?} */
            const rNode = nodeToProject[i];
            ngDevMode && assertDomNode(rNode);
            executeActionOnElementOrContainer(action, renderer, renderParent, rNode, beforeNode);
          }
        } else {
          /** @type {?} */
          let projectionTNode = nodeToProject;
          /** @type {?} */

          const projectedComponentLView =
          /** @type {?} */
          componentLView[PARENT];

          while (projectionTNode !== null) {
            executeActionOnNode(renderer, action, projectedComponentLView, projectionTNode, renderParent, beforeNode);
            projectionTNode = projectionTNode.projectionNext;
          }
        }
      }
    }
    /**
     * `executeActionOnContainer` performs an operation on the container and its views as specified by
     * `action` (insert, detach, destroy)
     *
     * Inserting a Container is complicated by the fact that the container may have Views which
     * themselves have containers or projections.
     *
     * @param {?} renderer Renderer to use
     * @param {?} action action to perform (insert, detach, destroy)
     * @param {?} lContainer The LContainer which needs to be inserted, detached, destroyed.
     * @param {?} renderParent parent DOM element for insertion/removal.
     * @param {?} beforeNode Before which node the insertions should happen.
     * @return {?}
     */


    function executeActionOnContainer(renderer, action, lContainer, renderParent, beforeNode) {
      ngDevMode && assertLContainer(lContainer);
      /** @type {?} */

      const anchor = lContainer[NATIVE]; // LContainer has its own before node.

      /** @type {?} */

      const native = unwrapRNode(lContainer); // An LContainer can be created dynamically on any node by injecting ViewContainerRef.
      // Asking for a ViewContainerRef on an element will result in a creation of a separate anchor node
      // (comment in the DOM) that will be different from the LContainer's host node. In this particular
      // case we need to execute action on 2 nodes:
      // - container's host node (this is done in the executeNodeAction)
      // - container's host node (this is done here)

      if (anchor !== native) {
        executeActionOnElementOrContainer(action, renderer, renderParent, anchor, beforeNode);
      }

      for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
        /** @type {?} */
        const lView =
        /** @type {?} */
        lContainer[i];
        executeActionOnView(renderer, action, lView, renderParent, anchor);
      }
    }
    /**
     * `executeActionOnElementContainerOrIcuContainer` performs an operation on the ng-container node
     * and its child nodes as specified by the `action` (insert, detach, destroy).
     *
     * @param {?} renderer Renderer to use
     * @param {?} action action to perform (insert, detach, destroy)
     * @param {?} lView The LView which needs to be inserted, detached, destroyed.
     * @param {?} tNode The TNode associated with the `ElementContainer` or `IcuContainer`.
     * @param {?} renderParent parent DOM element for insertion/removal.
     * @param {?} beforeNode Before which node the insertions should happen.
     * @return {?}
     */


    function executeActionOnElementContainerOrIcuContainer(renderer, action, lView, tNode, renderParent, beforeNode) {
      /** @type {?} */
      const node = lView[tNode.index];
      executeActionOnElementOrContainer(action, renderer, renderParent, node, beforeNode);
      /** @type {?} */

      let childTNode = tNode.child;

      while (childTNode) {
        executeActionOnNode(renderer, action, lView, childTNode, renderParent, beforeNode);
        childTNode = childTNode.next;
      }
    }
    /**
     * @param {?} renderer
     * @param {?} action
     * @param {?} lView
     * @param {?} tNode
     * @param {?} renderParent
     * @param {?} beforeNode
     * @return {?}
     */


    function executeActionOnNode(renderer, action, lView, tNode, renderParent, beforeNode) {
      /** @type {?} */
      const nodeType = tNode.type;

      if (!(tNode.flags & 32
      /* isDetached */
      )) {
        if (nodeType === 4
        /* ElementContainer */
        || nodeType === 5
        /* IcuContainer */
        ) {
            executeActionOnElementContainerOrIcuContainer(renderer, action, lView,
            /** @type {?} */
            tNode, renderParent, beforeNode);
          } else if (nodeType === 1
        /* Projection */
        ) {
            executeActionOnProjection(renderer, action, lView,
            /** @type {?} */
            tNode, renderParent, beforeNode);
          } else {
          ngDevMode && assertNodeOfPossibleTypes(tNode, 3
          /* Element */
          , 0
          /* Container */
          );
          executeActionOnElementOrContainer(action, renderer, renderParent, lView[tNode.index], beforeNode);
        }
      }
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Unwraps a parent injector location number to find the view offset from the current injector,
     * then walks up the declaration view tree until the TNode of the parent injector is found.
     *
     * @param {?} location The location of the parent injector, which contains the view offset
     * @param {?} startView The LView instance from which to start walking up the view tree
     * @param {?} startTNode The TNode instance of the starting element
     * @return {?} The TNode of the parent injector
     */


    function getParentInjectorTNode(location, startView, startTNode) {
      if (startTNode.parent && startTNode.parent.injectorIndex !== -1) {
        // view offset is 0

        /** @type {?} */
        const injectorIndex = startTNode.parent.injectorIndex;
        /** @type {?} */

        let parentTNode = startTNode.parent;

        while (parentTNode.parent != null && injectorIndex == parentTNode.injectorIndex) {
          parentTNode = parentTNode.parent;
        }

        return parentTNode;
      }
      /** @type {?} */


      let viewOffset = getParentInjectorViewOffset(location); // view offset is 1

      /** @type {?} */

      let parentView = startView;
      /** @type {?} */

      let parentTNode =
      /** @type {?} */
      startView[T_HOST]; // view offset is superior to 1

      while (viewOffset > 1) {
        parentView =
        /** @type {?} */
        parentView[DECLARATION_VIEW];
        parentTNode =
        /** @type {?} */
        parentView[T_HOST];
        viewOffset--;
      }

      return parentTNode;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @record
     */


    function viewEngine_ChangeDetectorRef_interface() {}
    /**
     * @template T
     */


    class ViewRef {
      /**
       * @param {?} _lView
       * @param {?} _context
       * @param {?} _componentIndex
       */
      constructor(_lView, _context, _componentIndex) {
        this._context = _context;
        this._componentIndex = _componentIndex;
        this._appRef = null;
        this._viewContainerRef = null;
        /**
         * \@internal
         */

        this._tViewNode = null;
        this._lView = _lView;
      }
      /**
       * @return {?}
       */


      get rootNodes() {
        if (this._lView[HOST] == null) {
          /** @type {?} */
          const tView =
          /** @type {?} */
          this._lView[T_HOST];
          return collectNativeNodes(this._lView, tView, []);
        }

        return [];
      }
      /**
       * @return {?}
       */


      get context() {
        return this._context ? this._context : this._lookUpContext();
      }
      /**
       * @return {?}
       */


      get destroyed() {
        return (this._lView[FLAGS] & 256
        /* Destroyed */
        ) === 256
        /* Destroyed */
        ;
      }
      /**
       * @return {?}
       */


      destroy() {
        if (this._appRef) {
          this._appRef.detachView(this);
        } else if (this._viewContainerRef) {
          /** @type {?} */
          const index = this._viewContainerRef.indexOf(this);

          if (index > -1) {
            this._viewContainerRef.detach(index);
          }

          this._viewContainerRef = null;
        }

        destroyLView(this._lView);
      }
      /**
       * @param {?} callback
       * @return {?}
       */


      onDestroy(callback) {
        storeCleanupFn(this._lView, callback);
      }
      /**
       * Marks a view and all of its ancestors dirty.
       *
       * It also triggers change detection by calling `scheduleTick` internally, which coalesces
       * multiple `markForCheck` calls to into one change detection run.
       *
       * This can be used to ensure an {\@link ChangeDetectionStrategy#OnPush OnPush} component is
       * checked when it needs to be re-rendered but the two normal triggers haven't marked it
       * dirty (i.e. inputs haven't changed and events haven't fired in the view).
       *
       * <!-- TODO: Add a link to a chapter on OnPush components -->
       *
       * \@usageNotes
       * ### Example
       *
       * ```typescript
       * \@Component({
       *   selector: 'my-app',
       *   template: `Number of ticks: {{numberOfTicks}}`
       *   changeDetection: ChangeDetectionStrategy.OnPush,
       * })
       * class AppComponent {
       *   numberOfTicks = 0;
       *
       *   constructor(private ref: ChangeDetectorRef) {
       *     setInterval(() => {
       *       this.numberOfTicks++;
       *       // the following is required, otherwise the view will not be updated
       *       this.ref.markForCheck();
       *     }, 1000);
       *   }
       * }
       * ```
       * @return {?}
       */


      markForCheck() {
        markViewDirty(this._lView);
      }
      /**
       * Detaches the view from the change detection tree.
       *
       * Detached views will not be checked during change detection runs until they are
       * re-attached, even if they are dirty. `detach` can be used in combination with
       * {\@link ChangeDetectorRef#detectChanges detectChanges} to implement local change
       * detection checks.
       *
       * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
       * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
       *
       * \@usageNotes
       * ### Example
       *
       * The following example defines a component with a large list of readonly data.
       * Imagine the data changes constantly, many times per second. For performance reasons,
       * we want to check and update the list every five seconds. We can do that by detaching
       * the component's change detector and doing a local check every five seconds.
       *
       * ```typescript
       * class DataProvider {
       *   // in a real application the returned data will be different every time
       *   get data() {
       *     return [1,2,3,4,5];
       *   }
       * }
       *
       * \@Component({
       *   selector: 'giant-list',
       *   template: `
       *     <li *ngFor="let d of dataProvider.data">Data {{d}}</li>
       *   `,
       * })
       * class GiantList {
       *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {
       *     ref.detach();
       *     setInterval(() => {
       *       this.ref.detectChanges();
       *     }, 5000);
       *   }
       * }
       *  /
       *   selector: 'app',
       *   providers: [DataProvider],
       *   template: `
       *     <giant-list><giant-list>
       *   `,
       * })
       * class App {
       * }
       * ```
       * @return {?}
       */


      detach() {
        this._lView[FLAGS] &= ~128
        /* Attached */
        ;
      }
      /**
       * Re-attaches a view to the change detection tree.
       *
       * This can be used to re-attach views that were previously detached from the tree
       * using {\@link ChangeDetectorRef#detach detach}. Views are attached to the tree by default.
       *
       * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
       *
       * \@usageNotes
       * ### Example
       *
       * The following example creates a component displaying `live` data. The component will detach
       * its change detector from the main change detector tree when the component's live property
       * is set to false.
       *
       * ```typescript
       * class DataProvider {
       *   data = 1;
       *
       *   constructor() {
       *     setInterval(() => {
       *       this.data = this.data * 2;
       *     }, 500);
       *   }
       * }
       *
       * \@Component({
       *   selector: 'live-data',
       *   inputs: ['live'],
       *   template: 'Data: {{dataProvider.data}}'
       * })
       * class LiveData {
       *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}
       *
       *   set live(value) {
       *     if (value) {
       *       this.ref.reattach();
       *     } else {
       *       this.ref.detach();
       *     }
       *   }
       * }
       *  /
       *   selector: 'my-app',
       *   providers: [DataProvider],
       *   template: `
       *     Live Update: <input type="checkbox" [(ngModel)]="live">
       *     <live-data [live]="live"><live-data>
       *   `,
       * })
       * class AppComponent {
       *   live = true;
       * }
       * ```
       * @return {?}
       */


      reattach() {
        this._lView[FLAGS] |= 128
        /* Attached */
        ;
      }
      /**
       * Checks the view and its children.
       *
       * This can also be used in combination with {\@link ChangeDetectorRef#detach detach} to implement
       * local change detection checks.
       *
       * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->
       * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->
       *
       * \@usageNotes
       * ### Example
       *
       * The following example defines a component with a large list of readonly data.
       * Imagine, the data changes constantly, many times per second. For performance reasons,
       * we want to check and update the list every five seconds.
       *
       * We can do that by detaching the component's change detector and doing a local change detection
       * check every five seconds.
       *
       * See {\@link ChangeDetectorRef#detach detach} for more information.
       * @return {?}
       */


      detectChanges() {
        detectChangesInternal(this._lView, this.context);
      }
      /**
       * Checks the change detector and its children, and throws if any changes are detected.
       *
       * This is used in development mode to verify that running change detection doesn't
       * introduce other changes.
       * @return {?}
       */


      checkNoChanges() {
        checkNoChangesInternal(this._lView, this.context);
      }
      /**
       * @param {?} vcRef
       * @return {?}
       */


      attachToViewContainerRef(vcRef) {
        if (this._appRef) {
          throw new Error('This view is already attached directly to the ApplicationRef!');
        }

        this._viewContainerRef = vcRef;
      }
      /**
       * @return {?}
       */


      detachFromAppRef() {
        this._appRef = null;
        renderDetachView(this._lView);
      }
      /**
       * @param {?} appRef
       * @return {?}
       */


      attachToAppRef(appRef) {
        if (this._viewContainerRef) {
          throw new Error('This view is already attached to a ViewContainer!');
        }

        this._appRef = appRef;
      }
      /**
       * @private
       * @return {?}
       */


      _lookUpContext() {
        return this._context =
        /** @type {?} */

        /** @type {?} */
        getLViewParent(this._lView)[this._componentIndex];
      }

    }

    if (false) {}
    /**
     * \@internal
     * @template T
     */


    class RootViewRef extends ViewRef {
      /**
       * @param {?} _view
       */
      constructor(_view) {
        super(_view, null, -1);
        this._view = _view;
      }
      /**
       * @return {?}
       */


      detectChanges() {
        detectChangesInRootView(this._view);
      }
      /**
       * @return {?}
       */


      checkNoChanges() {
        checkNoChangesInRootView(this._view);
      }
      /**
       * @return {?}
       */


      get context() {
        return (
          /** @type {?} */
          null
        );
      }

    }

    if (false) {}
    /**
     * @param {?} lView
     * @param {?} parentTNode
     * @param {?} result
     * @return {?}
     */


    function collectNativeNodes(lView, parentTNode, result) {
      /** @type {?} */
      let tNodeChild = parentTNode.child;

      while (tNodeChild) {
        /** @type {?} */
        const nativeNode = getNativeByTNodeOrNull(tNodeChild, lView);
        nativeNode && result.push(nativeNode);

        if (tNodeChild.type === 4
        /* ElementContainer */
        ) {
            collectNativeNodes(lView, tNodeChild, result);
          } else if (tNodeChild.type === 1
        /* Projection */
        ) {
            /** @type {?} */
            const componentView = findComponentView(lView);
            /** @type {?} */

            const componentHost =
            /** @type {?} */
            componentView[T_HOST];
            /** @type {?} */

            const parentView = getLViewParent(componentView);
            /** @type {?} */

            let currentProjectedNode =
            /** @type {?} */
            componentHost.projection[
            /** @type {?} */
            tNodeChild.projection];

            while (currentProjectedNode && parentView) {
              result.push(getNativeByTNode(currentProjectedNode, parentView));
              currentProjectedNode = currentProjectedNode.next;
            }
          }

        tNodeChild = tNodeChild.next;
      }

      return result;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Creates an ElementRef from the most recent node.
     *
     * @param {?} ElementRefToken
     * @return {?} The ElementRef instance to use
     */


    function injectElementRef(ElementRefToken) {
      return createElementRef(ElementRefToken, getPreviousOrParentTNode(), getLView());
    }
    /** @type {?} */


    let R3ElementRef;
    /**
     * Creates an ElementRef given a node.
     *
     * @param {?} ElementRefToken The ElementRef type
     * @param {?} tNode The node for which you'd like an ElementRef
     * @param {?} view The view to which the node belongs
     * @return {?} The ElementRef instance to use
     */

    function createElementRef(ElementRefToken, tNode, view) {
      if (!R3ElementRef) {
        // TODO: Fix class name, should be ElementRef, but there appears to be a rollup bug
        R3ElementRef = class ElementRef_ extends ElementRefToken {};
      }

      return new R3ElementRef(
      /** @type {?} */
      getNativeByTNode(tNode, view));
    }
    /** @type {?} */


    let R3TemplateRef;
    /**
     * Creates a TemplateRef given a node.
     *
     * @template T
     * @param {?} TemplateRefToken
     * @param {?} ElementRefToken
     * @return {?} The TemplateRef instance to use
     */

    function injectTemplateRef(TemplateRefToken, ElementRefToken) {
      return createTemplateRef(TemplateRefToken, ElementRefToken, getPreviousOrParentTNode(), getLView());
    }
    /**
     * Creates a TemplateRef and stores it on the injector.
     *
     * @template T
     * @param {?} TemplateRefToken The TemplateRef type
     * @param {?} ElementRefToken The ElementRef type
     * @param {?} hostTNode The node on which a TemplateRef is requested
     * @param {?} hostView The view to which the node belongs
     * @return {?} The TemplateRef instance or null if we can't create a TemplateRef on a given node type
     */


    function createTemplateRef(TemplateRefToken, ElementRefToken, hostTNode, hostView) {
      if (!R3TemplateRef) {
        // TODO: Fix class name, should be TemplateRef, but there appears to be a rollup bug
        R3TemplateRef = class TemplateRef_ extends TemplateRefToken {
          /**
           * @param {?} _declarationView
           * @param {?} _declarationTContainer
           * @param {?} elementRef
           */
          constructor(_declarationView, _declarationTContainer, elementRef) {
            super();
            this._declarationView = _declarationView;
            this._declarationTContainer = _declarationTContainer;
            this.elementRef = elementRef;
          }
          /**
           * @param {?} context
           * @return {?}
           */


          createEmbeddedView(context) {
            /** @type {?} */
            const embeddedTView =
            /** @type {?} */
            this._declarationTContainer.tViews;
            /** @type {?} */

            const lView = createEmbeddedViewAndNode(embeddedTView, context, this._declarationView, this._declarationTContainer.injectorIndex);
            /** @type {?} */

            const declarationLContainer = this._declarationView[this._declarationTContainer.index];
            ngDevMode && assertLContainer(declarationLContainer);
            lView[DECLARATION_LCONTAINER] = declarationLContainer;
            /** @type {?} */

            const declarationViewLQueries = this._declarationView[QUERIES];

            if (declarationViewLQueries !== null) {
              lView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);
            }

            renderEmbeddedTemplate(lView, embeddedTView, context);
            /** @type {?} */

            const viewRef = new ViewRef(lView, context, -1);
            viewRef._tViewNode =
            /** @type {?} */
            lView[T_HOST];
            return viewRef;
          }

        };
      }

      if (hostTNode.type === 0
      /* Container */
      ) {
          ngDevMode && assertDefined(hostTNode.tViews, 'TView must be allocated');
          return new R3TemplateRef(hostView,
          /** @type {?} */
          hostTNode, createElementRef(ElementRefToken, hostTNode, hostView));
        } else {
        return null;
      }
    }
    /** @type {?} */


    let R3ViewContainerRef;
    /**
     * Creates a ViewContainerRef and stores it on the injector. Or, if the ViewContainerRef
     * already exists, retrieves the existing ViewContainerRef.
     *
     * @param {?} ViewContainerRefToken
     * @param {?} ElementRefToken
     * @return {?} The ViewContainerRef instance to use
     */

    function injectViewContainerRef(ViewContainerRefToken, ElementRefToken) {
      /** @type {?} */
      const previousTNode =
      /** @type {?} */
      getPreviousOrParentTNode();
      return createContainerRef(ViewContainerRefToken, ElementRefToken, previousTNode, getLView());
    }
    /**
     * Creates a ViewContainerRef and stores it on the injector.
     *
     * @param {?} ViewContainerRefToken The ViewContainerRef type
     * @param {?} ElementRefToken The ElementRef type
     * @param {?} hostTNode The node that is requesting a ViewContainerRef
     * @param {?} hostView The view to which the node belongs
     * @return {?} The ViewContainerRef instance to use
     */


    function createContainerRef(ViewContainerRefToken, ElementRefToken, hostTNode, hostView) {
      if (!R3ViewContainerRef) {
        // TODO: Fix class name, should be ViewContainerRef, but there appears to be a rollup bug
        R3ViewContainerRef = class ViewContainerRef_ extends ViewContainerRefToken {
          /**
           * @param {?} _lContainer
           * @param {?} _hostTNode
           * @param {?} _hostView
           */
          constructor(_lContainer, _hostTNode, _hostView) {
            super();
            this._lContainer = _lContainer;
            this._hostTNode = _hostTNode;
            this._hostView = _hostView;
          }
          /**
           * @return {?}
           */


          get element() {
            return createElementRef(ElementRefToken, this._hostTNode, this._hostView);
          }
          /**
           * @return {?}
           */


          get injector() {
            return new NodeInjector(this._hostTNode, this._hostView);
          }
          /**
           * @deprecated No replacement
           * @return {?}
           */


          get parentInjector() {
            /** @type {?} */
            const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostView);
            /** @type {?} */

            const parentView = getParentInjectorView(parentLocation, this._hostView);
            /** @type {?} */

            const parentTNode = getParentInjectorTNode(parentLocation, this._hostView, this._hostTNode);
            return !hasParentInjector(parentLocation) || parentTNode == null ? new NodeInjector(null, this._hostView) : new NodeInjector(parentTNode, parentView);
          }
          /**
           * @return {?}
           */


          clear() {
            while (this.length > 0) {
              this.remove(this.length - 1);
            }
          }
          /**
           * @param {?} index
           * @return {?}
           */


          get(index) {
            return this._lContainer[VIEW_REFS] !== null &&
            /** @type {?} */
            this._lContainer[VIEW_REFS][index] || null;
          }
          /**
           * @return {?}
           */


          get length() {
            return this._lContainer.length - CONTAINER_HEADER_OFFSET;
          }
          /**
           * @template C
           * @param {?} templateRef
           * @param {?=} context
           * @param {?=} index
           * @return {?}
           */


          createEmbeddedView(templateRef, context, index) {
            /** @type {?} */
            const viewRef = templateRef.createEmbeddedView(context ||
            /** @type {?} */
            {});
            this.insert(viewRef, index);
            return viewRef;
          }
          /**
           * @template C
           * @param {?} componentFactory
           * @param {?=} index
           * @param {?=} injector
           * @param {?=} projectableNodes
           * @param {?=} ngModuleRef
           * @return {?}
           */


          createComponent(componentFactory, index, injector, projectableNodes, ngModuleRef) {
            /** @type {?} */
            const contextInjector = injector || this.parentInjector;

            if (!ngModuleRef &&
            /** @type {?} */
            componentFactory.ngModule == null && contextInjector) {
              ngModuleRef = contextInjector.get(NgModuleRef, null);
            }
            /** @type {?} */


            const componentRef = componentFactory.create(contextInjector, projectableNodes, undefined, ngModuleRef);
            this.insert(componentRef.hostView, index);
            return componentRef;
          }
          /**
           * @param {?} viewRef
           * @param {?=} index
           * @return {?}
           */


          insert(viewRef, index) {
            if (viewRef.destroyed) {
              throw new Error('Cannot insert a destroyed View in a ViewContainer!');
            }

            this.allocateContainerIfNeeded();
            /** @type {?} */

            const lView =
            /** @type {?} */

            /** @type {?} */
            viewRef._lView;
            /** @type {?} */

            const adjustedIdx = this._adjustIndex(index);

            if (viewAttachedToContainer(lView)) {
              // If view is already attached, fall back to move() so we clean up
              // references appropriately.
              return this.move(viewRef, adjustedIdx);
            }

            insertView(lView, this._lContainer, adjustedIdx);
            /** @type {?} */

            const beforeNode = getBeforeNodeForView(adjustedIdx, this._lContainer);
            addRemoveViewFromContainer(lView, true, beforeNode);

            /** @type {?} */
            viewRef.attachToViewContainerRef(this);
            addToArray(
            /** @type {?} */
            this._lContainer[VIEW_REFS], adjustedIdx, viewRef);
            return viewRef;
          }
          /**
           * @param {?} viewRef
           * @param {?} newIndex
           * @return {?}
           */


          move(viewRef, newIndex) {
            if (viewRef.destroyed) {
              throw new Error('Cannot move a destroyed View in a ViewContainer!');
            }
            /** @type {?} */


            const index = this.indexOf(viewRef);
            if (index !== -1) this.detach(index);
            this.insert(viewRef, newIndex);
            return viewRef;
          }
          /**
           * @param {?} viewRef
           * @return {?}
           */


          indexOf(viewRef) {
            return this._lContainer[VIEW_REFS] !== null ?
            /** @type {?} */
            this._lContainer[VIEW_REFS].indexOf(viewRef) : 0;
          }
          /**
           * @param {?=} index
           * @return {?}
           */


          remove(index) {
            this.allocateContainerIfNeeded();
            /** @type {?} */

            const adjustedIdx = this._adjustIndex(index, -1);

            removeView(this._lContainer, adjustedIdx);
            removeFromArray(
            /** @type {?} */
            this._lContainer[VIEW_REFS], adjustedIdx);
          }
          /**
           * @param {?=} index
           * @return {?}
           */


          detach(index) {
            this.allocateContainerIfNeeded();
            /** @type {?} */

            const adjustedIdx = this._adjustIndex(index, -1);
            /** @type {?} */


            const view = detachView(this._lContainer, adjustedIdx);
            /** @type {?} */

            const wasDetached = view && removeFromArray(
            /** @type {?} */
            this._lContainer[VIEW_REFS], adjustedIdx) != null;
            return wasDetached ? new ViewRef(
            /** @type {?} */
            view,
            /** @type {?} */
            view[CONTEXT], -1) : null;
          }
          /**
           * @private
           * @param {?=} index
           * @param {?=} shift
           * @return {?}
           */


          _adjustIndex(index, shift = 0) {
            if (index == null) {
              return this.length + shift;
            }

            if (ngDevMode) {
              assertGreaterThan(index, -1, 'index must be positive'); // +1 because it's legal to insert at the end.

              assertLessThan(index, this.length + 1 + shift, 'index');
            }

            return index;
          }
          /**
           * @private
           * @return {?}
           */


          allocateContainerIfNeeded() {
            if (this._lContainer[VIEW_REFS] === null) {
              this._lContainer[VIEW_REFS] = [];
            }
          }

        };
      }

      ngDevMode && assertNodeOfPossibleTypes(hostTNode, 0
      /* Container */
      , 3
      /* Element */
      , 4
      /* ElementContainer */
      );
      /** @type {?} */

      let lContainer;
      /** @type {?} */

      const slotValue = hostView[hostTNode.index];

      if (isLContainer(slotValue)) {
        // If the host is a container, we don't need to create a new LContainer
        lContainer = slotValue;
        lContainer[ACTIVE_INDEX] = -1;
      } else {
        /** @type {?} */
        let commentNode; // If the host is an element container, the native host element is guaranteed to be a
        // comment and we can reuse that comment as anchor element for the new LContainer.

        if (hostTNode.type === 4
        /* ElementContainer */
        ) {
            commentNode =
            /** @type {?} */
            unwrapRNode(slotValue);
          } else {
          ngDevMode && ngDevMode.rendererCreateComment++;
          commentNode = hostView[RENDERER].createComment(ngDevMode ? 'container' : '');
        } // A container can be created on the root (topmost / bootstrapped) component and in this case we
        // can't use LTree to insert container's marker node (both parent of a comment node and the
        // commend node itself is located outside of elements hold by LTree). In this specific case we
        // use low-level DOM manipulation to insert container's marker (comment) node.


        if (isRootView(hostView)) {
          /** @type {?} */
          const renderer = hostView[RENDERER];
          /** @type {?} */

          const hostNative =
          /** @type {?} */
          getNativeByTNode(hostTNode, hostView);
          /** @type {?} */

          const parentOfHostNative = nativeParentNode(renderer, hostNative);
          nativeInsertBefore(renderer,
          /** @type {?} */
          parentOfHostNative, commentNode, nativeNextSibling(renderer, hostNative));
        } else {
          appendChild(commentNode, hostTNode, hostView);
        }

        hostView[hostTNode.index] = lContainer = createLContainer(slotValue, hostView, commentNode, hostTNode, true);
        addToViewTree(hostView, lContainer);
      }

      return new R3ViewContainerRef(lContainer, hostTNode, hostView);
    }
    /**
     * Returns a ChangeDetectorRef (a.k.a. a ViewRef)
     * @param {?=} isPipe
     * @return {?}
     */


    function injectChangeDetectorRef(isPipe = false) {
      return createViewRef(getPreviousOrParentTNode(), getLView(), isPipe);
    }
    /**
     * Creates a ViewRef and stores it on the injector as ChangeDetectorRef (public alias).
     *
     * @param {?} hostTNode The node that is requesting a ChangeDetectorRef
     * @param {?} hostView The view to which the node belongs
     * @param {?} isPipe Whether the view is being injected into a pipe.
     * @return {?} The ChangeDetectorRef to use
     */


    function createViewRef(hostTNode, hostView, isPipe) {
      if (isComponent(hostTNode) && !isPipe) {
        /** @type {?} */
        const componentIndex = hostTNode.directiveStart;
        /** @type {?} */

        const componentView = getComponentViewByIndex(hostTNode.index, hostView);
        return new ViewRef(componentView, null, componentIndex);
      } else if (hostTNode.type === 3
      /* Element */
      || hostTNode.type === 0
      /* Container */
      || hostTNode.type === 4
      /* ElementContainer */
      ) {
          /** @type {?} */
          const hostComponentView = findComponentView(hostView);
          return new ViewRef(hostComponentView, hostComponentView[CONTEXT], -1);
        }

      return (
        /** @type {?} */
        null
      );
    }
    /**
     * Returns a Renderer2 (or throws when application was bootstrapped with Renderer3)
     * @param {?} view
     * @return {?}
     */


    function getOrCreateRenderer2(view) {
      /** @type {?} */
      const renderer = view[RENDERER];

      if (isProceduralRenderer(renderer)) {
        return (
          /** @type {?} */
          renderer
        );
      } else {
        throw new Error('Cannot inject Renderer2 when the application uses Renderer3!');
      }
    }
    /**
     * Injects a Renderer2 for the current component.
     * @return {?}
     */


    function injectRenderer2() {
      // We need the Renderer to be based on the component that it's being injected into, however since
      // DI happens before we've entered its view, `getLView` will return the parent view instead.

      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const tNode = getPreviousOrParentTNode();
      /** @type {?} */

      const nodeAtIndex = getComponentViewByIndex(tNode.index, lView);
      return getOrCreateRenderer2(isLView(nodeAtIndex) ? nodeAtIndex : lView);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Base class for Angular Views, provides change detection functionality.
     * A change-detection tree collects all views that are to be checked for changes.
     * Use the methods to add and remove views from the tree, initiate change-detection,
     * and explicitly mark views as _dirty_, meaning that they have changed and need to be rerendered.
     *
     * \@usageNotes
     *
     * The following examples demonstrate how to modify default change-detection behavior
     * to perform explicit detection when needed.
     *
     * ### Use `markForCheck()` with `CheckOnce` strategy
     *
     * The following example sets the `OnPush` change-detection strategy for a component
     * (`CheckOnce`, rather than the default `CheckAlways`), then forces a second check
     * after an interval. See [live demo](http://plnkr.co/edit/GC512b?p=preview).
     *
     * <code-example path="core/ts/change_detect/change-detection.ts"
     * region="mark-for-check"></code-example>
     *
     * ### Detach change detector to limit how often check occurs
     *
     * The following example defines a component with a large list of read-only data
     * that is expected to change constantly, many times per second.
     * To improve performance, we want to check and update the list
     * less often than the changes actually occur. To do that, we detach
     * the component's change detector and perform an explicit local check every five seconds.
     *
     * <code-example path="core/ts/change_detect/change-detection.ts" region="detach"></code-example>
     *
     *
     * ### Reattaching a detached component
     *
     * The following example creates a component displaying live data.
     * The component detaches its change detector from the main change detector tree
     * when the `live` property is set to false, and reattaches it when the property
     * becomes true.
     *
     * <code-example path="core/ts/change_detect/change-detection.ts" region="reattach"></code-example>
     *
     * \@publicApi
     * @abstract
     */


    class ChangeDetectorRef {}
    /**
     * \@internal
     * @nocollapse
     */


    ChangeDetectorRef.__NG_ELEMENT_ID__ =
    /**
    * @return {?}
    */
    () => SWITCH_CHANGE_DETECTOR_REF_FACTORY();

    if (false) {}
    /** @type {?} */


    const SWITCH_CHANGE_DETECTOR_REF_FACTORY__POST_R3__ = injectChangeDetectorRef;
    /** @type {?} */

    const SWITCH_CHANGE_DETECTOR_REF_FACTORY__PRE_R3__ =
    /**
    * @param {...?} args
    * @return {?}
    */
    (...args) => {};

    const ɵ0$6 = SWITCH_CHANGE_DETECTOR_REF_FACTORY__PRE_R3__;
    /** @type {?} */

    const SWITCH_CHANGE_DETECTOR_REF_FACTORY = SWITCH_CHANGE_DETECTOR_REF_FACTORY__PRE_R3__;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * @description
     *
     * Represents a type that a Component or other object is instances of.
     *
     * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
     * the `MyCustomComponent` constructor function.
     *
     * @publicApi
     */

    const Type = Function;

    function isType(v) {
      return typeof v === 'function';
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Attention: These regex has to hold even if the code is minified!
     */


    const DELEGATE_CTOR = /^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*arguments\)/;
    const INHERITED_CLASS = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/;
    const INHERITED_CLASS_WITH_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/;
    const INHERITED_CLASS_WITH_DELEGATE_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{\s+super\(\.\.\.arguments\)/;
    /**
     * Determine whether a stringified type is a class which delegates its constructor
     * to its parent.
     *
     * This is not trivial since compiled code can actually contain a constructor function
     * even if the original source code did not. For instance, when the child class contains
     * an initialized instance property.
     */

    function isDelegateCtor(typeStr) {
      return DELEGATE_CTOR.test(typeStr) || INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) || INHERITED_CLASS.test(typeStr) && !INHERITED_CLASS_WITH_CTOR.test(typeStr);
    }

    class ReflectionCapabilities {
      constructor(reflect) {
        this._reflect = reflect || _global['Reflect'];
      }

      isReflectionEnabled() {
        return true;
      }

      factory(t) {
        return (...args) => new t(...args);
      }
      /** @internal */


      _zipTypesAndAnnotations(paramTypes, paramAnnotations) {
        let result;

        if (typeof paramTypes === 'undefined') {
          result = new Array(paramAnnotations.length);
        } else {
          result = new Array(paramTypes.length);
        }

        for (let i = 0; i < result.length; i++) {
          // TS outputs Object for parameters without types, while Traceur omits
          // the annotations. For now we preserve the Traceur behavior to aid
          // migration, but this can be revisited.
          if (typeof paramTypes === 'undefined') {
            result[i] = [];
          } else if (paramTypes[i] && paramTypes[i] != Object) {
            result[i] = [paramTypes[i]];
          } else {
            result[i] = [];
          }

          if (paramAnnotations && paramAnnotations[i] != null) {
            result[i] = result[i].concat(paramAnnotations[i]);
          }
        }

        return result;
      }

      _ownParameters(type, parentCtor) {
        const typeStr = type.toString(); // If we have no decorators, we only have function.length as metadata.
        // In that case, to detect whether a child class declared an own constructor or not,
        // we need to look inside of that constructor to check whether it is
        // just calling the parent.
        // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439
        // that sets 'design:paramtypes' to []
        // if a class inherits from another class but has no ctor declared itself.

        if (isDelegateCtor(typeStr)) {
          return null;
        } // Prefer the direct API.


        if (type.parameters && type.parameters !== parentCtor.parameters) {
          return type.parameters;
        } // API of tsickle for lowering decorators to properties on the class.


        const tsickleCtorParams = type.ctorParameters;

        if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {
          // Newer tsickle uses a function closure
          // Retain the non-function case for compatibility with older tsickle
          const ctorParameters = typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;
          const paramTypes = ctorParameters.map(ctorParam => ctorParam && ctorParam.type);
          const paramAnnotations = ctorParameters.map(ctorParam => ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));
          return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
        } // API for metadata created by invoking the decorators.


        const paramAnnotations = type.hasOwnProperty(PARAMETERS) && type[PARAMETERS];

        const paramTypes = this._reflect && this._reflect.getOwnMetadata && this._reflect.getOwnMetadata('design:paramtypes', type);

        if (paramTypes || paramAnnotations) {
          return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);
        } // If a class has no decorators, at least create metadata
        // based on function.length.
        // Note: We know that this is a real constructor as we checked
        // the content of the constructor above.


        return new Array(type.length).fill(undefined);
      }

      parameters(type) {
        // Note: only report metadata if we have at least one class decorator
        // to stay in sync with the static reflector.
        if (!isType(type)) {
          return [];
        }

        const parentCtor = getParentCtor(type);

        let parameters = this._ownParameters(type, parentCtor);

        if (!parameters && parentCtor !== Object) {
          parameters = this.parameters(parentCtor);
        }

        return parameters || [];
      }

      _ownAnnotations(typeOrFunc, parentCtor) {
        // Prefer the direct API.
        if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {
          let annotations = typeOrFunc.annotations;

          if (typeof annotations === 'function' && annotations.annotations) {
            annotations = annotations.annotations;
          }

          return annotations;
        } // API of tsickle for lowering decorators to properties on the class.


        if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) {
          return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);
        } // API for metadata created by invoking the decorators.


        if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {
          return typeOrFunc[ANNOTATIONS];
        }

        return null;
      }

      annotations(typeOrFunc) {
        if (!isType(typeOrFunc)) {
          return [];
        }

        const parentCtor = getParentCtor(typeOrFunc);
        const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];
        const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];
        return parentAnnotations.concat(ownAnnotations);
      }

      _ownPropMetadata(typeOrFunc, parentCtor) {
        // Prefer the direct API.
        if (typeOrFunc.propMetadata && typeOrFunc.propMetadata !== parentCtor.propMetadata) {
          let propMetadata = typeOrFunc.propMetadata;

          if (typeof propMetadata === 'function' && propMetadata.propMetadata) {
            propMetadata = propMetadata.propMetadata;
          }

          return propMetadata;
        } // API of tsickle for lowering decorators to properties on the class.


        if (typeOrFunc.propDecorators && typeOrFunc.propDecorators !== parentCtor.propDecorators) {
          const propDecorators = typeOrFunc.propDecorators;
          const propMetadata = {};
          Object.keys(propDecorators).forEach(prop => {
            propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);
          });
          return propMetadata;
        } // API for metadata created by invoking the decorators.


        if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {
          return typeOrFunc[PROP_METADATA];
        }

        return null;
      }

      propMetadata(typeOrFunc) {
        if (!isType(typeOrFunc)) {
          return {};
        }

        const parentCtor = getParentCtor(typeOrFunc);
        const propMetadata = {};

        if (parentCtor !== Object) {
          const parentPropMetadata = this.propMetadata(parentCtor);
          Object.keys(parentPropMetadata).forEach(propName => {
            propMetadata[propName] = parentPropMetadata[propName];
          });
        }

        const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);

        if (ownPropMetadata) {
          Object.keys(ownPropMetadata).forEach(propName => {
            const decorators = [];

            if (propMetadata.hasOwnProperty(propName)) {
              decorators.push(...propMetadata[propName]);
            }

            decorators.push(...ownPropMetadata[propName]);
            propMetadata[propName] = decorators;
          });
        }

        return propMetadata;
      }

      ownPropMetadata(typeOrFunc) {
        if (!isType(typeOrFunc)) {
          return {};
        }

        return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};
      }

      hasLifecycleHook(type, lcProperty) {
        return type instanceof Type && lcProperty in type.prototype;
      }

      guards(type) {
        return {};
      }

      getter(name) {
        return new Function('o', 'return o.' + name + ';');
      }

      setter(name) {
        return new Function('o', 'v', 'return o.' + name + ' = v;');
      }

      method(name) {
        const functionBody = "if (!o.".concat(name, ") throw new Error('\"").concat(name, "\" is undefined');\n        return o.").concat(name, ".apply(o, args);");
        return new Function('o', 'args', functionBody);
      } // There is not a concept of import uri in Js, but this is useful in developing Dart applications.


      importUri(type) {
        // StaticSymbol
        if (typeof type === 'object' && type['filePath']) {
          return type['filePath'];
        } // Runtime type


        return "./".concat(stringify(type));
      }

      resourceUri(type) {
        return "./".concat(stringify(type));
      }

      resolveIdentifier(name, moduleUrl, members, runtime) {
        return runtime;
      }

      resolveEnum(enumIdentifier, name) {
        return enumIdentifier[name];
      }

    }

    function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
      if (!decoratorInvocations) {
        return [];
      }

      return decoratorInvocations.map(decoratorInvocation => {
        const decoratorType = decoratorInvocation.type;
        const annotationCls = decoratorType.annotationCls;
        const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];
        return new annotationCls(...annotationArgs);
      });
    }

    function getParentCtor(ctor) {
      const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;
      const parentCtor = parentProto ? parentProto.constructor : null; // Note: We always use `Object` as the null value
      // to simplify checking later on.

      return parentCtor || Object;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    let _reflect = null;
    /**
     * @return {?}
     */

    function getReflect() {
      return _reflect = _reflect || new ReflectionCapabilities();
    }
    /**
     * @param {?} type
     * @return {?}
     */


    function reflectDependencies(type) {
      return convertDependencies(getReflect().parameters(type));
    }
    /**
     * @param {?} deps
     * @return {?}
     */


    function convertDependencies(deps) {
      /** @type {?} */
      const compiler = getCompilerFacade();
      return deps.map(
      /**
      * @param {?} dep
      * @return {?}
      */
      dep => reflectDependency(compiler, dep));
    }
    /**
     * @param {?} compiler
     * @param {?} dep
     * @return {?}
     */


    function reflectDependency(compiler, dep) {
      /** @type {?} */
      const meta = {
        token: null,
        host: false,
        optional: false,
        resolved: compiler.R3ResolvedDependencyType.Token,
        self: false,
        skipSelf: false
      };
      /**
       * @param {?} token
       * @return {?}
       */

      function setTokenAndResolvedType(token) {
        meta.resolved = compiler.R3ResolvedDependencyType.Token;
        meta.token = token;
      }

      if (Array.isArray(dep)) {
        if (dep.length === 0) {
          throw new Error('Dependency array must have arguments.');
        }

        for (let j = 0; j < dep.length; j++) {
          /** @type {?} */
          const param = dep[j];

          if (param === undefined) {
            // param may be undefined if type of dep is not set by ngtsc
            continue;
          } else if (param instanceof Optional || param.__proto__.ngMetadataName === 'Optional') {
            meta.optional = true;
          } else if (param instanceof SkipSelf || param.__proto__.ngMetadataName === 'SkipSelf') {
            meta.skipSelf = true;
          } else if (param instanceof Self || param.__proto__.ngMetadataName === 'Self') {
            meta.self = true;
          } else if (param instanceof Host || param.__proto__.ngMetadataName === 'Host') {
            meta.host = true;
          } else if (param instanceof Inject) {
            meta.token = param.token;
          } else if (param instanceof Attribute) {
            if (param.attributeName === undefined) {
              throw new Error("Attribute name must be defined.");
            }

            meta.token = param.attributeName;
            meta.resolved = compiler.R3ResolvedDependencyType.Attribute;
          } else if (param === ChangeDetectorRef) {
            meta.token = param;
            meta.resolved = compiler.R3ResolvedDependencyType.ChangeDetectorRef;
          } else {
            setTokenAndResolvedType(param);
          }
        }
      } else {
        setTokenAndResolvedType(dep);
      }

      return meta;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Compile an Angular injectable according to its `Injectable` metadata, and patch the resulting
     * `ngInjectableDef` onto the injectable type.
     * @param {?} type
     * @param {?=} srcMeta
     * @return {?}
     */


    function compileInjectable(type, srcMeta) {
      /** @type {?} */
      let def = null; // if NG_INJECTABLE_DEF is already defined on this class then don't overwrite it

      if (type.hasOwnProperty(NG_INJECTABLE_DEF)) return;
      Object.defineProperty(type, NG_INJECTABLE_DEF, {
        get:
        /**
        * @return {?}
        */
        () => {
          if (def === null) {
            // Allow the compilation of a class with a `@Injectable()` decorator without parameters

            /** @type {?} */
            const meta = srcMeta || {
              providedIn: null
            };
            /** @type {?} */

            const hasAProvider = isUseClassProvider(meta) || isUseFactoryProvider(meta) || isUseValueProvider(meta) || isUseExistingProvider(meta);
            /** @type {?} */

            const compilerMeta = {
              name: type.name,
              type: type,
              typeArgumentCount: 0,
              providedIn: meta.providedIn,
              ctorDeps: reflectDependencies(type),
              userDeps: undefined
            };

            if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== undefined) {
              compilerMeta.userDeps = convertDependencies(meta.deps);
            }

            if (!hasAProvider) {
              // In the case the user specifies a type provider, treat it as {provide: X, useClass: X}.
              // The deps will have been reflected above, causing the factory to create the class by
              // calling
              // its constructor with injected deps.
              compilerMeta.useClass = type;
            } else if (isUseClassProvider(meta)) {
              // The user explicitly specified useClass, and may or may not have provided deps.
              compilerMeta.useClass = meta.useClass;
            } else if (isUseValueProvider(meta)) {
              // The user explicitly specified useValue.
              compilerMeta.useValue = meta.useValue;
            } else if (isUseFactoryProvider(meta)) {
              // The user explicitly specified useFactory.
              compilerMeta.useFactory = meta.useFactory;
            } else if (isUseExistingProvider(meta)) {
              // The user explicitly specified useExisting.
              compilerMeta.useExisting = meta.useExisting;
            } else {
              // Can't happen - either hasAProvider will be false, or one of the providers will be set.
              throw new Error("Unreachable state.");
            }

            def = getCompilerFacade().compileInjectable(angularCoreDiEnv, "ng:///".concat(type.name, "/ngInjectableDef.js"), compilerMeta);
          }

          return def;
        }
      });
    }

    const ɵ0$7 = getClosureSafeProperty;
    /** @type {?} */

    const USE_VALUE$1 = getClosureSafeProperty({
      provide: String,
      useValue: ɵ0$7
    });
    /**
     * @param {?} meta
     * @return {?}
     */

    function isUseClassProvider(meta) {
      return (
        /** @type {?} */
        meta.useClass !== undefined
      );
    }
    /**
     * @param {?} meta
     * @return {?}
     */


    function isUseValueProvider(meta) {
      return USE_VALUE$1 in meta;
    }
    /**
     * @param {?} meta
     * @return {?}
     */


    function isUseFactoryProvider(meta) {
      return (
        /** @type {?} */
        meta.useFactory !== undefined
      );
    }
    /**
     * @param {?} meta
     * @return {?}
     */


    function isUseExistingProvider(meta) {
      return (
        /** @type {?} */
        meta.useExisting !== undefined
      );
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    const ɵ0$8 = getClosureSafeProperty;
    /** @type {?} */

    const USE_VALUE$2 = getClosureSafeProperty({
      provide: String,
      useValue: ɵ0$8
    });
    /** @type {?} */

    const EMPTY_ARRAY$1 = [];
    /**
     * @param {?} type
     * @param {?=} provider
     * @return {?}
     */

    function convertInjectableProviderToFactory(type, provider) {
      if (!provider) {
        /** @type {?} */
        const reflectionCapabilities = new ReflectionCapabilities();
        /** @type {?} */

        const deps = reflectionCapabilities.parameters(type); // TODO - convert to flags.

        return (
          /**
          * @return {?}
          */
          () => new type(...injectArgs(
          /** @type {?} */
          deps))
        );
      }

      if (USE_VALUE$2 in provider) {
        /** @type {?} */
        const valueProvider =
        /** @type {?} */
        provider;
        return (
          /**
          * @return {?}
          */
          () => valueProvider.useValue
        );
      } else if (
      /** @type {?} */
      provider.useExisting) {
        /** @type {?} */
        const existingProvider =
        /** @type {?} */
        provider;
        return (
          /**
          * @return {?}
          */
          () => ɵɵinject(existingProvider.useExisting)
        );
      } else if (
      /** @type {?} */
      provider.useFactory) {
        /** @type {?} */
        const factoryProvider =
        /** @type {?} */
        provider;
        return (
          /**
          * @return {?}
          */
          () => factoryProvider.useFactory(...injectArgs(factoryProvider.deps || EMPTY_ARRAY$1))
        );
      } else if (
      /** @type {?} */
      provider.useClass) {
        /** @type {?} */
        const classProvider =
        /** @type {?} */
        provider;
        /** @type {?} */

        let deps =
        /** @type {?} */
        provider.deps;

        if (!deps) {
          /** @type {?} */
          const reflectionCapabilities = new ReflectionCapabilities();
          deps = reflectionCapabilities.parameters(type);
        }

        return (
          /**
          * @return {?}
          */
          () => new classProvider.useClass(...injectArgs(deps))
        );
      } else {
        /** @type {?} */
        let deps =
        /** @type {?} */
        provider.deps;

        if (!deps) {
          /** @type {?} */
          const reflectionCapabilities = new ReflectionCapabilities();
          deps = reflectionCapabilities.parameters(type);
        }

        return (
          /**
          * @return {?}
          */
          () => new type(...injectArgs(
          /** @type {?} */
          deps))
        );
      }
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Type of the Injectable decorator / constructor function.
     *
     * \@publicApi
     * @record
     */


    function InjectableDecorator() {} // WARNING: interface has both a type and a value, skipping emit


    const ɵ0$9 =
    /**
    * @param {?} type
    * @param {?} meta
    * @return {?}
    */
    (type, meta) => SWITCH_COMPILE_INJECTABLE(
    /** @type {?} */
    type, meta);
    /**
     * Injectable decorator and metadata.
     *
     * \@Annotation
     * \@publicApi
     * @type {?}
     */


    const Injectable = makeDecorator('Injectable', undefined, undefined, undefined, ɵ0$9);
    /**
     * Type representing injectable service.
     *
     * \@publicApi
     * @record
     * @template T
     */

    function InjectableType() {}

    if (false) {}
    /**
     * Supports \@Injectable() in JIT mode for Render2.
     * @param {?} injectableType
     * @param {?=} options
     * @return {?}
     */


    function render2CompileInjectable(injectableType, options) {
      if (options && options.providedIn !== undefined && !getInjectableDef(injectableType)) {
        /** @type {?} */
        injectableType.ngInjectableDef = ɵɵdefineInjectable({
          token: injectableType,
          providedIn: options.providedIn,
          factory: convertInjectableProviderToFactory(injectableType, options)
        });
      }
    }
    /** @type {?} */


    const SWITCH_COMPILE_INJECTABLE__POST_R3__ = compileInjectable;
    /** @type {?} */

    const SWITCH_COMPILE_INJECTABLE__PRE_R3__ = render2CompileInjectable;
    /** @type {?} */

    const SWITCH_COMPILE_INJECTABLE = SWITCH_COMPILE_INJECTABLE__PRE_R3__;
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * An internal token whose presence in an injector indicates that the injector should treat itself
     * as a root scoped injector when processing requests for unknown tokens which may indicate
     * they are provided in the root scope.
     * @type {?}
     */

    const APP_ROOT = new InjectionToken('The presence of this token marks an injector as being the root injector.');
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Marker which indicates that a value has not yet been created from the factory function.
     * @type {?}
     */

    const NOT_YET = {};
    /**
     * Marker which indicates that the factory function for a token is in the process of being called.
     *
     * If the injector is asked to inject a token with its value set to CIRCULAR, that indicates
     * injection of a dependency has recursively attempted to inject the original token, and there is
     * a circular dependency among the providers.
     * @type {?}
     */

    const CIRCULAR = {};
    /** @type {?} */

    const EMPTY_ARRAY$2 =
    /** @type {?} */
    [];
    /**
     * A lazily initialized NullInjector.
     * @type {?}
     */

    let NULL_INJECTOR = undefined;
    /**
     * @return {?}
     */

    function getNullInjector() {
      if (NULL_INJECTOR === undefined) {
        NULL_INJECTOR = new NullInjector();
      }

      return NULL_INJECTOR;
    }
    /**
     * An entry in the injector which tracks information about the given token, including a possible
     * current value.
     * @record
     * @template T
     */


    function Record() {}

    if (false) {}
    /**
     * Create a new `Injector` which is configured using a `defType` of `InjectorType<any>`s.
     *
     * \@publicApi
     * @param {?} defType
     * @param {?=} parent
     * @param {?=} additionalProviders
     * @param {?=} name
     * @return {?}
     */


    function createInjector(defType, parent = null, additionalProviders = null, name) {
      parent = parent || getNullInjector();
      return new R3Injector(defType, additionalProviders, parent, name);
    }

    class R3Injector {
      /**
       * @param {?} def
       * @param {?} additionalProviders
       * @param {?} parent
       * @param {?=} source
       */
      constructor(def, additionalProviders, parent, source = null) {
        this.parent = parent;
        /**
         * Map of tokens to records which contain the instances of those tokens.
         */

        this.records = new Map();
        /**
         * The transitive set of `InjectorType`s which define this injector.
         */

        this.injectorDefTypes = new Set();
        /**
         * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.
         */

        this.onDestroy = new Set();
        this._destroyed = false; // Start off by creating Records for every provider declared in every InjectorType
        // included transitively in `def`.

        /** @type {?} */

        const dedupStack = [];
        deepForEach([def],
        /**
        * @param {?} injectorDef
        * @return {?}
        */
        injectorDef => this.processInjectorType(injectorDef, [], dedupStack));
        additionalProviders && deepForEach(additionalProviders,
        /**
        * @param {?} provider
        * @return {?}
        */
        provider => this.processProvider(provider, def, additionalProviders)); // Make sure the INJECTOR token provides this injector.

        this.records.set(INJECTOR, makeRecord(undefined, this)); // Detect whether this injector has the APP_ROOT_SCOPE token and thus should provide
        // any injectable scoped to APP_ROOT_SCOPE.

        this.isRootInjector = this.records.has(APP_ROOT); // Eagerly instantiate the InjectorType classes themselves.

        this.injectorDefTypes.forEach(
        /**
        * @param {?} defType
        * @return {?}
        */
        defType => this.get(defType)); // Source name, used for debugging

        this.source = source || (typeof def === 'object' ? null : stringify(def));
      }
      /**
       * Flag indicating that this injector was previously destroyed.
       * @return {?}
       */


      get destroyed() {
        return this._destroyed;
      }
      /**
       * Destroy the injector and release references to every instance or provider associated with it.
       *
       * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a
       * hook was found.
       * @return {?}
       */


      destroy() {
        this.assertNotDestroyed(); // Set destroyed = true first, in case lifecycle hooks re-enter destroy().

        this._destroyed = true;

        try {
          // Call all the lifecycle hooks.
          this.onDestroy.forEach(
          /**
          * @param {?} service
          * @return {?}
          */
          service => service.ngOnDestroy());
        } finally {
          // Release all references.
          this.records.clear();
          this.onDestroy.clear();
          this.injectorDefTypes.clear();
        }
      }
      /**
       * @template T
       * @param {?} token
       * @param {?=} notFoundValue
       * @param {?=} flags
       * @return {?}
       */


      get(token, notFoundValue = THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {
        this.assertNotDestroyed(); // Set the injection context.

        /** @type {?} */

        const previousInjector = setCurrentInjector(this);

        try {
          // Check for the SkipSelf flag.
          if (!(flags & InjectFlags.SkipSelf)) {
            // SkipSelf isn't set, check if the record belongs to this injector.

            /** @type {?} */
            let record = this.records.get(token);

            if (record === undefined) {
              // No record, but maybe the token is scoped to this injector. Look for an ngInjectableDef
              // with a scope matching this injector.

              /** @type {?} */
              const def = couldBeInjectableType(token) && getInjectableDef(token);

              if (def && this.injectableDefInScope(def)) {
                // Found an ngInjectableDef and it's scoped to this injector. Pretend as if it was here
                // all along.
                record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);
                this.records.set(token, record);
              }
            } // If a record was found, get the instance for it and return it.


            if (record !== undefined) {
              return this.hydrate(token, record);
            }
          } // Select the next injector based on the Self flag - if self is set, the next injector is
          // the NullInjector, otherwise it's the parent.

          /** @type {?} */


          const nextInjector = !(flags & InjectFlags.Self) ? this.parent : getNullInjector();
          return nextInjector.get(token, flags & InjectFlags.Optional ? null : notFoundValue);
        } catch (e) {
          if (e.name === 'NullInjectorError') {
            /** @type {?} */
            const path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];
            path.unshift(stringify(token));

            if (previousInjector) {
              // We still have a parent injector, keep throwing
              throw e;
            } else {
              // Format & throw the final error message when we don't have any previous injector
              return catchInjectorError(e, token, 'R3InjectorError', this.source);
            }
          } else {
            throw e;
          }
        } finally {
          // Lastly, clean up the state by restoring the previous injector.
          setCurrentInjector(previousInjector);
        }
      }
      /**
       * @return {?}
       */


      toString() {
        /** @type {?} */
        const tokens =
        /** @type {?} */
        [];
        /** @type {?} */

        const records = this.records;
        records.forEach(
        /**
        * @param {?} v
        * @param {?} token
        * @return {?}
        */
        (v, token) => tokens.push(stringify(token)));
        return "R3Injector[".concat(tokens.join(', '), "]");
      }
      /**
       * @private
       * @return {?}
       */


      assertNotDestroyed() {
        if (this._destroyed) {
          throw new Error('Injector has already been destroyed.');
        }
      }
      /**
       * Add an `InjectorType` or `InjectorTypeWithProviders` and all of its transitive providers
       * to this injector.
       *
       * If an `InjectorTypeWithProviders` that declares providers besides the type is specified,
       * the function will return "true" to indicate that the providers of the type definition need
       * to be processed. This allows us to process providers of injector types after all imports of
       * an injector definition are processed. (following View Engine semantics: see FW-1349)
       * @private
       * @param {?} defOrWrappedDef
       * @param {?} parents
       * @param {?} dedupStack
       * @return {?}
       */


      processInjectorType(defOrWrappedDef, parents, dedupStack) {
        defOrWrappedDef = resolveForwardRef(defOrWrappedDef);
        if (!defOrWrappedDef) return false; // Either the defOrWrappedDef is an InjectorType (with ngInjectorDef) or an
        // InjectorDefTypeWithProviders (aka ModuleWithProviders). Detecting either is a megamorphic
        // read, so care is taken to only do the read once.
        // First attempt to read the ngInjectorDef.

        /** @type {?} */

        let def = getInjectorDef(defOrWrappedDef); // If that's not present, then attempt to read ngModule from the InjectorDefTypeWithProviders.

        /** @type {?} */

        const ngModule = def == null &&
        /** @type {?} */
        defOrWrappedDef.ngModule || undefined; // Determine the InjectorType. In the case where `defOrWrappedDef` is an `InjectorType`,
        // then this is easy. In the case of an InjectorDefTypeWithProviders, then the definition type
        // is the `ngModule`.

        /** @type {?} */

        const defType = ngModule === undefined ?
        /** @type {?} */
        defOrWrappedDef : ngModule; // Check for circular dependencies.

        if (ngDevMode && parents.indexOf(defType) !== -1) {
          /** @type {?} */
          const defName = stringify(defType);
          throw new Error("Circular dependency in DI detected for type ".concat(defName, ". Dependency path: ").concat(parents.map(
          /**
          * @param {?} defType
          * @return {?}
          */
          defType => stringify(defType)).join(' > '), " > ").concat(defName, "."));
        } // Check for multiple imports of the same module

        /** @type {?} */


        const isDuplicate = dedupStack.indexOf(defType) !== -1; // Finally, if defOrWrappedType was an `InjectorDefTypeWithProviders`, then the actual
        // `InjectorDef` is on its `ngModule`.

        if (ngModule !== undefined) {
          def = getInjectorDef(ngModule);
        } // If no definition was found, it might be from exports. Remove it.


        if (def == null) {
          return false;
        } // Track the InjectorType and add a provider for it.


        this.injectorDefTypes.add(defType);
        this.records.set(defType, makeRecord(def.factory, NOT_YET)); // Add providers in the same way that @NgModule resolution did:
        // First, include providers from any imports.

        if (def.imports != null && !isDuplicate) {
          // Before processing defType's imports, add it to the set of parents. This way, if it ends
          // up deeply importing itself, this can be detected.
          ngDevMode && parents.push(defType); // Add it to the set of dedups. This way we can detect multiple imports of the same module

          dedupStack.push(defType);
          /** @type {?} */

          let importTypesWithProviders;

          try {
            deepForEach(def.imports,
            /**
            * @param {?} imported
            * @return {?}
            */
            imported => {
              if (this.processInjectorType(imported, parents, dedupStack)) {
                if (importTypesWithProviders === undefined) importTypesWithProviders = []; // If the processed import is an injector type with providers, we store it in the
                // list of import types with providers, so that we can process those afterwards.

                importTypesWithProviders.push(imported);
              }
            });
          } finally {
            // Remove it from the parents set when finished.
            ngDevMode && parents.pop();
          } // Imports which are declared with providers (TypeWithProviders) need to be processed
          // after all imported modules are processed. This is similar to how View Engine
          // processes/merges module imports in the metadata resolver. See: FW-1349.


          if (importTypesWithProviders !== undefined) {
            for (let i = 0; i < importTypesWithProviders.length; i++) {
              const {
                ngModule,
                providers
              } = importTypesWithProviders[i];
              deepForEach(
              /** @type {?} */
              providers,
              /**
              * @param {?} provider
              * @return {?}
              */
              provider => this.processProvider(provider, ngModule, providers || EMPTY_ARRAY$2));
            }
          }
        } // Next, include providers listed on the definition itself.

        /** @type {?} */


        const defProviders = def.providers;

        if (defProviders != null && !isDuplicate) {
          /** @type {?} */
          const injectorType =
          /** @type {?} */
          defOrWrappedDef;
          deepForEach(defProviders,
          /**
          * @param {?} provider
          * @return {?}
          */
          provider => this.processProvider(provider, injectorType, defProviders));
        }

        return ngModule !== undefined &&
        /** @type {?} */
        defOrWrappedDef.providers !== undefined;
      }
      /**
       * Process a `SingleProvider` and add it.
       * @private
       * @param {?} provider
       * @param {?} ngModuleType
       * @param {?} providers
       * @return {?}
       */


      processProvider(provider, ngModuleType, providers) {
        // Determine the token from the provider. Either it's its own token, or has a {provide: ...}
        // property.
        provider = resolveForwardRef(provider);
        /** @type {?} */

        let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide); // Construct a `Record` for the provider.

        /** @type {?} */

        const record = providerToRecord(provider, ngModuleType, providers);

        if (!isTypeProvider(provider) && provider.multi === true) {
          // If the provider indicates that it's a multi-provider, process it specially.
          // First check whether it's been defined already.

          /** @type {?} */
          let multiRecord = this.records.get(token);

          if (multiRecord) {
            // It has. Throw a nice error if
            if (multiRecord.multi === undefined) {
              throwMixedMultiProviderError();
            }
          } else {
            multiRecord = makeRecord(undefined, NOT_YET, true);

            multiRecord.factory =
            /**
            * @return {?}
            */
            () => injectArgs(
            /** @type {?} */

            /** @type {?} */
            multiRecord.multi);

            this.records.set(token, multiRecord);
          }

          token = provider;

          /** @type {?} */
          multiRecord.multi.push(provider);
        } else {
          /** @type {?} */
          const existing = this.records.get(token);

          if (existing && existing.multi !== undefined) {
            throwMixedMultiProviderError();
          }
        }

        this.records.set(token, record);
      }
      /**
       * @private
       * @template T
       * @param {?} token
       * @param {?} record
       * @return {?}
       */


      hydrate(token, record) {
        if (record.value === CIRCULAR) {
          throwCyclicDependencyError(stringify(token));
        } else if (record.value === NOT_YET) {
          record.value = CIRCULAR;
          record.value =
          /** @type {?} */
          record.factory();
        }

        if (typeof record.value === 'object' && record.value && hasOnDestroy(record.value)) {
          this.onDestroy.add(record.value);
        }

        return (
          /** @type {?} */
          record.value
        );
      }
      /**
       * @private
       * @param {?} def
       * @return {?}
       */


      injectableDefInScope(def) {
        if (!def.providedIn) {
          return false;
        } else if (typeof def.providedIn === 'string') {
          return def.providedIn === 'any' || def.providedIn === 'root' && this.isRootInjector;
        } else {
          return this.injectorDefTypes.has(def.providedIn);
        }
      }

    }

    if (false) {}
    /**
     * @param {?} token
     * @return {?}
     */


    function injectableDefOrInjectorDefFactory(token) {
      // Most tokens will have an ngInjectableDef directly on them, which specifies a factory directly.

      /** @type {?} */
      const injectableDef = getInjectableDef(token);

      if (injectableDef !== null) {
        return injectableDef.factory;
      } // If the token is an NgModule, it's also injectable but the factory is on its ngInjectorDef.

      /** @type {?} */


      const injectorDef = getInjectorDef(token);

      if (injectorDef !== null) {
        return injectorDef.factory;
      } // InjectionTokens should have an ngInjectableDef and thus should be handled above.
      // If it's missing that, it's an error.


      if (token instanceof InjectionToken) {
        throw new Error("Token ".concat(stringify(token), " is missing an ngInjectableDef definition."));
      } // Undecorated types can sometimes be created if they have no constructor arguments.


      if (token instanceof Function) {
        return getUndecoratedInjectableFactory(token);
      } // There was no way to resolve a factory for this token.


      throw new Error('unreachable');
    }
    /**
     * @param {?} token
     * @return {?}
     */


    function getUndecoratedInjectableFactory(token) {
      // If the token has parameters then it has dependencies that we cannot resolve implicitly.

      /** @type {?} */
      const paramLength = token.length;

      if (paramLength > 0) {
        /** @type {?} */
        const args = new Array(paramLength).fill('?');
        throw new Error("Can't resolve all parameters for ".concat(stringify(token), ": (").concat(args.join(', '), ")."));
      } // The constructor function appears to have no parameters.
      // This might be because it inherits from a super-class. In which case, use an ngInjectableDef
      // from an ancestor if there is one.
      // Otherwise this really is a simple class with no dependencies, so return a factory that
      // just instantiates the zero-arg constructor.

      /** @type {?} */


      const inheritedInjectableDef = getInheritedInjectableDef(token);

      if (inheritedInjectableDef !== null) {
        return (
          /**
          * @return {?}
          */
          () => inheritedInjectableDef.factory(
          /** @type {?} */
          token)
        );
      } else {
        return (
          /**
          * @return {?}
          */
          () => new
          /** @type {?} */
          token()
        );
      }
    }
    /**
     * @param {?} provider
     * @param {?} ngModuleType
     * @param {?} providers
     * @return {?}
     */


    function providerToRecord(provider, ngModuleType, providers) {
      /** @type {?} */
      let factory = providerToFactory(provider, ngModuleType, providers);

      if (isValueProvider(provider)) {
        return makeRecord(undefined, provider.useValue);
      } else {
        return makeRecord(factory, NOT_YET);
      }
    }
    /**
     * Converts a `SingleProvider` into a factory function.
     *
     * @param {?} provider provider to convert to factory
     * @param {?=} ngModuleType
     * @param {?=} providers
     * @return {?}
     */


    function providerToFactory(provider, ngModuleType, providers) {
      /** @type {?} */
      let factory = undefined;

      if (isTypeProvider(provider)) {
        return injectableDefOrInjectorDefFactory(resolveForwardRef(provider));
      } else {
        if (isValueProvider(provider)) {
          factory =
          /**
          * @return {?}
          */
          () => resolveForwardRef(provider.useValue);
        } else if (isExistingProvider(provider)) {
          factory =
          /**
          * @return {?}
          */
          () => ɵɵinject(resolveForwardRef(provider.useExisting));
        } else if (isFactoryProvider(provider)) {
          factory =
          /**
          * @return {?}
          */
          () => provider.useFactory(...injectArgs(provider.deps || []));
        } else {
          /** @type {?} */
          const classRef = resolveForwardRef(provider && (
          /** @type {?} */
          provider.useClass || provider.provide));

          if (!classRef) {
            throwInvalidProviderError(ngModuleType, providers, provider);
          }

          if (hasDeps(provider)) {
            factory =
            /**
            * @return {?}
            */
            () => new classRef(...injectArgs(provider.deps));
          } else {
            return injectableDefOrInjectorDefFactory(classRef);
          }
        }
      }

      return factory;
    }
    /**
     * @template T
     * @param {?} factory
     * @param {?} value
     * @param {?=} multi
     * @return {?}
     */


    function makeRecord(factory, value, multi = false) {
      return {
        factory: factory,
        value: value,
        multi: multi ? [] : undefined
      };
    }
    /**
     * @param {?} value
     * @return {?}
     */


    function isValueProvider(value) {
      return value !== null && typeof value == 'object' && USE_VALUE in value;
    }
    /**
     * @param {?} value
     * @return {?}
     */


    function isExistingProvider(value) {
      return !!(value &&
      /** @type {?} */
      value.useExisting);
    }
    /**
     * @param {?} value
     * @return {?}
     */


    function isFactoryProvider(value) {
      return !!(value &&
      /** @type {?} */
      value.useFactory);
    }
    /**
     * @param {?} value
     * @return {?}
     */


    function isTypeProvider(value) {
      return typeof value === 'function';
    }
    /**
     * @param {?} value
     * @return {?}
     */


    function isClassProvider(value) {
      return !!
      /** @type {?} */
      value.useClass;
    }
    /**
     * @param {?} value
     * @return {?}
     */


    function hasDeps(value) {
      return !!
      /** @type {?} */
      value.deps;
    }
    /**
     * @param {?} value
     * @return {?}
     */


    function hasOnDestroy(value) {
      return value !== null && typeof value === 'object' && typeof
      /** @type {?} */
      value.ngOnDestroy === 'function';
    }
    /**
     * @param {?} value
     * @return {?}
     */


    function couldBeInjectableType(value) {
      return typeof value === 'function' || typeof value === 'object' && value instanceof InjectionToken;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} providers
     * @param {?} parent
     * @param {?} name
     * @return {?}
     */


    function INJECTOR_IMPL__PRE_R3__(providers, parent, name) {
      return new StaticInjector(providers, parent, name);
    }
    /**
     * @param {?} providers
     * @param {?} parent
     * @param {?} name
     * @return {?}
     */


    function INJECTOR_IMPL__POST_R3__(providers, parent, name) {
      return createInjector({
        name: name
      }, parent, providers, name);
    }
    /** @type {?} */


    const INJECTOR_IMPL = INJECTOR_IMPL__PRE_R3__;
    /**
     * Concrete injectors implement this interface.
     *
     * For more details, see the ["Dependency Injection Guide"](guide/dependency-injection).
     *
     * \@usageNotes
     * ### Example
     *
     * {\@example core/di/ts/injector_spec.ts region='Injector'}
     *
     * `Injector` returns itself when given `Injector` as a token:
     *
     * {\@example core/di/ts/injector_spec.ts region='injectInjector'}
     *
     * \@publicApi
     * @abstract
     */

    class Injector {
      /**
       * Create a new Injector which is configure using `StaticProvider`s.
       *
       * \@usageNotes
       * ### Example
       *
       * {\@example core/di/ts/provider_spec.ts region='ConstructorProvider'}
       * @param {?} options
       * @param {?=} parent
       * @return {?}
       */
      static create(options, parent) {
        if (Array.isArray(options)) {
          return INJECTOR_IMPL(options, parent, '');
        } else {
          return INJECTOR_IMPL(options.providers, options.parent, options.name || '');
        }
      }

    }

    Injector.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;
    Injector.NULL = new NullInjector();
    /** @nocollapse */

    /** @nocollapse */

    Injector.ngInjectableDef = ɵɵdefineInjectable({
      token: Injector,
      providedIn:
      /** @type {?} */
      'any',
      factory:
      /**
      * @return {?}
      */
      () => ɵɵinject(INJECTOR)
    });
    /**
     * \@internal
     * @nocollapse
     */

    Injector.__NG_ELEMENT_ID__ = -1;

    if (false) {}
    /** @type {?} */


    const IDENT =
    /**
    * @template T
    * @param {?} value
    * @return {?}
    */
    function IDENT(value) {
      return value;
    };

    const ɵ0$a = IDENT;
    /** @type {?} */

    const EMPTY =
    /** @type {?} */
    [];
    /** @type {?} */

    const CIRCULAR$1 = IDENT;
    /** @type {?} */

    const MULTI_PROVIDER_FN =
    /**
    * @return {?}
    */
    function MULTI_PROVIDER_FN() {
      return Array.prototype.slice.call(arguments);
    };

    const ɵ1$2 = MULTI_PROVIDER_FN;
    /** @enum {number} */

    const OptionFlags = {
      Optional: 1,
      CheckSelf: 2,
      CheckParent: 4,
      Default: 6
    };
    /** @type {?} */

    const NO_NEW_LINE$1 = 'ɵ';

    class StaticInjector {
      /**
       * @param {?} providers
       * @param {?=} parent
       * @param {?=} source
       */
      constructor(providers, parent = Injector.NULL, source = null) {
        this.parent = parent;
        this.source = source;
        /** @type {?} */

        const records = this._records = new Map();
        records.set(Injector,
        /** @type {?} */
        {
          token: Injector,
          fn: IDENT,
          deps: EMPTY,
          value: this,
          useNew: false
        });
        records.set(INJECTOR,
        /** @type {?} */
        {
          token: INJECTOR,
          fn: IDENT,
          deps: EMPTY,
          value: this,
          useNew: false
        });
        recursivelyProcessProviders(records, providers);
      }
      /**
       * @param {?} token
       * @param {?=} notFoundValue
       * @param {?=} flags
       * @return {?}
       */


      get(token, notFoundValue, flags = InjectFlags.Default) {
        /** @type {?} */
        const record = this._records.get(token);

        try {
          return tryResolveToken(token, record, this._records, this.parent, notFoundValue, flags);
        } catch (e) {
          return catchInjectorError(e, token, 'StaticInjectorError', this.source);
        }
      }
      /**
       * @return {?}
       */


      toString() {
        /** @type {?} */
        const tokens =
        /** @type {?} */
        [];
        /** @type {?} */

        const records = this._records;
        records.forEach(
        /**
        * @param {?} v
        * @param {?} token
        * @return {?}
        */
        (v, token) => tokens.push(stringify(token)));
        return "StaticInjector[".concat(tokens.join(', '), "]");
      }

    }

    if (false) {}
    /**
     * @record
     */


    function Record$1() {}

    if (false) {}
    /**
     * @record
     */


    function DependencyRecord() {}

    if (false) {}
    /**
     * @param {?} provider
     * @return {?}
     */


    function resolveProvider(provider) {
      /** @type {?} */
      const deps = computeDeps(provider);
      /** @type {?} */

      let fn = IDENT;
      /** @type {?} */

      let value = EMPTY;
      /** @type {?} */

      let useNew = false;
      /** @type {?} */

      let provide = resolveForwardRef(provider.provide);

      if (USE_VALUE in provider) {
        // We need to use USE_VALUE in provider since provider.useValue could be defined as undefined.
        value =
        /** @type {?} */
        provider.useValue;
      } else if (
      /** @type {?} */
      provider.useFactory) {
        fn =
        /** @type {?} */
        provider.useFactory;
      } else if (
      /** @type {?} */
      provider.useExisting) {// Just use IDENT
      } else if (
      /** @type {?} */
      provider.useClass) {
        useNew = true;
        fn = resolveForwardRef(
        /** @type {?} */
        provider.useClass);
      } else if (typeof provide == 'function') {
        useNew = true;
        fn = provide;
      } else {
        throw staticError('StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable', provider);
      }

      return {
        deps,
        fn,
        useNew,
        value
      };
    }
    /**
     * @param {?} token
     * @return {?}
     */


    function multiProviderMixError(token) {
      return staticError('Cannot mix multi providers and regular providers', token);
    }
    /**
     * @param {?} records
     * @param {?} provider
     * @return {?}
     */


    function recursivelyProcessProviders(records, provider) {
      if (provider) {
        provider = resolveForwardRef(provider);

        if (provider instanceof Array) {
          // if we have an array recurse into the array
          for (let i = 0; i < provider.length; i++) {
            recursivelyProcessProviders(records, provider[i]);
          }
        } else if (typeof provider === 'function') {
          // Functions were supported in ReflectiveInjector, but are not here. For safety give useful
          // error messages
          throw staticError('Function/Class not supported', provider);
        } else if (provider && typeof provider === 'object' && provider.provide) {
          // At this point we have what looks like a provider: {provide: ?, ....}

          /** @type {?} */
          let token = resolveForwardRef(provider.provide);
          /** @type {?} */

          const resolvedProvider = resolveProvider(provider);

          if (provider.multi === true) {
            // This is a multi provider.

            /** @type {?} */
            let multiProvider = records.get(token);

            if (multiProvider) {
              if (multiProvider.fn !== MULTI_PROVIDER_FN) {
                throw multiProviderMixError(token);
              }
            } else {
              // Create a placeholder factory which will look up the constituents of the multi provider.
              records.set(token, multiProvider =
              /** @type {?} */
              {
                token: provider.provide,
                deps: [],
                useNew: false,
                fn: MULTI_PROVIDER_FN,
                value: EMPTY
              });
            } // Treat the provider as the token.


            token = provider;
            multiProvider.deps.push({
              token,
              options: 6
              /* Default */

            });
          }
          /** @type {?} */


          const record = records.get(token);

          if (record && record.fn == MULTI_PROVIDER_FN) {
            throw multiProviderMixError(token);
          }

          records.set(token, resolvedProvider);
        } else {
          throw staticError('Unexpected provider', provider);
        }
      }
    }
    /**
     * @param {?} token
     * @param {?} record
     * @param {?} records
     * @param {?} parent
     * @param {?} notFoundValue
     * @param {?} flags
     * @return {?}
     */


    function tryResolveToken(token, record, records, parent, notFoundValue, flags) {
      try {
        return resolveToken(token, record, records, parent, notFoundValue, flags);
      } catch (e) {
        // ensure that 'e' is of type Error.
        if (!(e instanceof Error)) {
          e = new Error(e);
        }
        /** @type {?} */


        const path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];
        path.unshift(token);

        if (record && record.value == CIRCULAR$1) {
          // Reset the Circular flag.
          record.value = EMPTY;
        }

        throw e;
      }
    }
    /**
     * @param {?} token
     * @param {?} record
     * @param {?} records
     * @param {?} parent
     * @param {?} notFoundValue
     * @param {?} flags
     * @return {?}
     */


    function resolveToken(token, record, records, parent, notFoundValue, flags) {
      /** @type {?} */
      let value;

      if (record && !(flags & InjectFlags.SkipSelf)) {
        // If we don't have a record, this implies that we don't own the provider hence don't know how
        // to resolve it.
        value = record.value;

        if (value == CIRCULAR$1) {
          throw Error(NO_NEW_LINE$1 + 'Circular dependency');
        } else if (value === EMPTY) {
          record.value = CIRCULAR$1;
          /** @type {?} */

          let obj = undefined;
          /** @type {?} */

          let useNew = record.useNew;
          /** @type {?} */

          let fn = record.fn;
          /** @type {?} */

          let depRecords = record.deps;
          /** @type {?} */

          let deps = EMPTY;

          if (depRecords.length) {
            deps = [];

            for (let i = 0; i < depRecords.length; i++) {
              /** @type {?} */
              const depRecord = depRecords[i];
              /** @type {?} */

              const options = depRecord.options;
              /** @type {?} */

              const childRecord = options & 2
              /* CheckSelf */
              ? records.get(depRecord.token) : undefined;
              deps.push(tryResolveToken( // Current Token to resolve
              depRecord.token, // A record which describes how to resolve the token.
              // If undefined, this means we don't have such a record
              childRecord, // Other records we know about.
              records, // If we don't know how to resolve dependency and we should not check parent for it,
              // than pass in Null injector.
              !childRecord && !(options & 4
              /* CheckParent */
              ) ? Injector.NULL : parent, options & 1
              /* Optional */
              ? null : Injector.THROW_IF_NOT_FOUND, InjectFlags.Default));
            }
          }

          record.value = value = useNew ? new
          /** @type {?} */
          fn(...deps) : fn.apply(obj, deps);
        }
      } else if (!(flags & InjectFlags.Self)) {
        value = parent.get(token, notFoundValue, InjectFlags.Default);
      }

      return value;
    }
    /**
     * @param {?} provider
     * @return {?}
     */


    function computeDeps(provider) {
      /** @type {?} */
      let deps = EMPTY;
      /** @type {?} */

      const providerDeps =
      /** @type {?} */
      provider.deps;

      if (providerDeps && providerDeps.length) {
        deps = [];

        for (let i = 0; i < providerDeps.length; i++) {
          /** @type {?} */
          let options = 6
          /* Default */
          ;
          /** @type {?} */

          let token = resolveForwardRef(providerDeps[i]);

          if (token instanceof Array) {
            for (let j = 0, annotations = token; j < annotations.length; j++) {
              /** @type {?} */
              const annotation = annotations[j];

              if (annotation instanceof Optional || annotation == Optional) {
                options = options | 1
                /* Optional */
                ;
              } else if (annotation instanceof SkipSelf || annotation == SkipSelf) {
                options = options & ~2
                /* CheckSelf */
                ;
              } else if (annotation instanceof Self || annotation == Self) {
                options = options & ~4
                /* CheckParent */
                ;
              } else if (annotation instanceof Inject) {
                token =
                /** @type {?} */
                annotation.token;
              } else {
                token = resolveForwardRef(annotation);
              }
            }
          }

          deps.push({
            token,
            options
          });
        }
      } else if (
      /** @type {?} */
      provider.useExisting) {
        /** @type {?} */
        const token = resolveForwardRef(
        /** @type {?} */
        provider.useExisting);
        deps = [{
          token,
          options: 6
          /* Default */

        }];
      } else if (!providerDeps && !(USE_VALUE in provider)) {
        // useValue & useExisting are the only ones which are exempt from deps all others need it.
        throw staticError('\'deps\' required', provider);
      }

      return deps;
    }
    /**
     * @param {?} text
     * @param {?} obj
     * @return {?}
     */


    function staticError(text, obj) {
      return new Error(formatError(text, obj, 'StaticInjectorError'));
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} keys
     * @return {?}
     */


    function findFirstClosedCycle(keys) {
      /** @type {?} */
      const res = [];

      for (let i = 0; i < keys.length; ++i) {
        if (res.indexOf(keys[i]) > -1) {
          res.push(keys[i]);
          return res;
        }

        res.push(keys[i]);
      }

      return res;
    }
    /**
     * @param {?} keys
     * @return {?}
     */


    function constructResolvingPath(keys) {
      if (keys.length > 1) {
        /** @type {?} */
        const reversed = findFirstClosedCycle(keys.slice().reverse());
        /** @type {?} */

        const tokenStrs = reversed.map(
        /**
        * @param {?} k
        * @return {?}
        */
        k => stringify(k.token));
        return ' (' + tokenStrs.join(' -> ') + ')';
      }

      return '';
    }
    /**
     * @record
     */


    function InjectionError() {}

    if (false) {}
    /**
     * @param {?} injector
     * @param {?} key
     * @param {?} constructResolvingMessage
     * @param {?=} originalError
     * @return {?}
     */


    function injectionError(injector, key, constructResolvingMessage, originalError) {
      /** @type {?} */
      const keys = [key];
      /** @type {?} */

      const errMsg = constructResolvingMessage(keys);
      /** @type {?} */

      const error =
      /** @type {?} */
      originalError ? wrappedError(errMsg, originalError) : Error(errMsg);
      error.addKey = addKey;
      error.keys = keys;
      error.injectors = [injector];
      error.constructResolvingMessage = constructResolvingMessage;

      /** @type {?} */
      error[ERROR_ORIGINAL_ERROR] = originalError;
      return error;
    }
    /**
     * @this {?}
     * @param {?} injector
     * @param {?} key
     * @return {?}
     */


    function addKey(injector, key) {
      this.injectors.push(injector);
      this.keys.push(key); // Note: This updated message won't be reflected in the `.stack` property

      this.message = this.constructResolvingMessage(this.keys);
    }
    /**
     * Thrown when trying to retrieve a dependency by key from {\@link Injector}, but the
     * {\@link Injector} does not have a {\@link Provider} for the given key.
     *
     * \@usageNotes
     * ### Example
     *
     * ```typescript
     * class A {
     *   constructor(b:B) {}
     * }
     *
     * expect(() => Injector.resolveAndCreate([A])).toThrowError();
     * ```
     * @param {?} injector
     * @param {?} key
     * @return {?}
     */


    function noProviderError(injector, key) {
      return injectionError(injector, key,
      /**
      * @param {?} keys
      * @return {?}
      */
      function (keys) {
        /** @type {?} */
        const first = stringify(keys[0].token);
        return "No provider for ".concat(first, "!").concat(constructResolvingPath(keys));
      });
    }
    /**
     * Thrown when dependencies form a cycle.
     *
     * \@usageNotes
     * ### Example
     *
     * ```typescript
     * var injector = Injector.resolveAndCreate([
     *   {provide: "one", useFactory: (two) => "two", deps: [[new Inject("two")]]},
     *   {provide: "two", useFactory: (one) => "one", deps: [[new Inject("one")]]}
     * ]);
     *
     * expect(() => injector.get("one")).toThrowError();
     * ```
     *
     * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.
     * @param {?} injector
     * @param {?} key
     * @return {?}
     */


    function cyclicDependencyError(injector, key) {
      return injectionError(injector, key,
      /**
      * @param {?} keys
      * @return {?}
      */
      function (keys) {
        return "Cannot instantiate cyclic dependency!".concat(constructResolvingPath(keys));
      });
    }
    /**
     * Thrown when a constructing type returns with an Error.
     *
     * The `InstantiationError` class contains the original error plus the dependency graph which caused
     * this object to be instantiated.
     *
     * \@usageNotes
     * ### Example
     *
     * ```typescript
     * class A {
     *   constructor() {
     *     throw new Error('message');
     *   }
     * }
     *
     * var injector = Injector.resolveAndCreate([A]);
     * try {
     *   injector.get(A);
     * } catch (e) {
     *   expect(e instanceof InstantiationError).toBe(true);
     *   expect(e.originalException.message).toEqual("message");
     *   expect(e.originalStack).toBeDefined();
     * }
     * ```
     * @param {?} injector
     * @param {?} originalException
     * @param {?} originalStack
     * @param {?} key
     * @return {?}
     */


    function instantiationError(injector, originalException, originalStack, key) {
      return injectionError(injector, key,
      /**
      * @param {?} keys
      * @return {?}
      */
      function (keys) {
        /** @type {?} */
        const first = stringify(keys[0].token);
        return "".concat(originalException.message, ": Error during instantiation of ").concat(first, "!").concat(constructResolvingPath(keys), ".");
      }, originalException);
    }
    /**
     * Thrown when an object other then {\@link Provider} (or `Type`) is passed to {\@link Injector}
     * creation.
     *
     * \@usageNotes
     * ### Example
     *
     * ```typescript
     * expect(() => Injector.resolveAndCreate(["not a type"])).toThrowError();
     * ```
     * @param {?} provider
     * @return {?}
     */


    function invalidProviderError(provider) {
      return Error("Invalid provider - only instances of Provider and Type are allowed, got: ".concat(provider));
    }
    /**
     * Thrown when the class has no annotation information.
     *
     * Lack of annotation information prevents the {\@link Injector} from determining which dependencies
     * need to be injected into the constructor.
     *
     * \@usageNotes
     * ### Example
     *
     * ```typescript
     * class A {
     *   constructor(b) {}
     * }
     *
     * expect(() => Injector.resolveAndCreate([A])).toThrowError();
     * ```
     *
     * This error is also thrown when the class not marked with {\@link Injectable} has parameter types.
     *
     * ```typescript
     * class B {}
     *
     * class A {
     *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.
     * }
     *
     * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();
     * ```
     *
     * @param {?} typeOrFunc
     * @param {?} params
     * @return {?}
     */


    function noAnnotationError(typeOrFunc, params) {
      /** @type {?} */
      const signature = [];

      for (let i = 0, ii = params.length; i < ii; i++) {
        /** @type {?} */
        const parameter = params[i];

        if (!parameter || parameter.length == 0) {
          signature.push('?');
        } else {
          signature.push(parameter.map(stringify).join(' '));
        }
      }

      return Error('Cannot resolve all parameters for \'' + stringify(typeOrFunc) + '\'(' + signature.join(', ') + '). ' + 'Make sure that all the parameters are decorated with Inject or have valid type annotations and that \'' + stringify(typeOrFunc) + '\' is decorated with Injectable.');
    }
    /**
     * Thrown when getting an object by index.
     *
     * \@usageNotes
     * ### Example
     *
     * ```typescript
     * class A {}
     *
     * var injector = Injector.resolveAndCreate([A]);
     *
     * expect(() => injector.getAt(100)).toThrowError();
     * ```
     *
     * @param {?} index
     * @return {?}
     */


    function outOfBoundsError(index) {
      return Error("Index ".concat(index, " is out-of-bounds."));
    } // TODO: add a working example after alpha38 is released

    /**
     * Thrown when a multi provider and a regular provider are bound to the same token.
     *
     * \@usageNotes
     * ### Example
     *
     * ```typescript
     * expect(() => Injector.resolveAndCreate([
     *   { provide: "Strings", useValue: "string1", multi: true},
     *   { provide: "Strings", useValue: "string2", multi: false}
     * ])).toThrowError();
     * ```
     * @param {?} provider1
     * @param {?} provider2
     * @return {?}
     */


    function mixingMultiProvidersWithRegularProvidersError(provider1, provider2) {
      return Error("Cannot mix multi providers and regular providers, got: ".concat(provider1, " ").concat(provider2));
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * A unique object used for retrieving items from the {\@link ReflectiveInjector}.
     *
     * Keys have:
     * - a system-wide unique `id`.
     * - a `token`.
     *
     * `Key` is used internally by {\@link ReflectiveInjector} because its system-wide unique `id` allows
     * the
     * injector to store created objects in a more efficient way.
     *
     * `Key` should not be created directly. {\@link ReflectiveInjector} creates keys automatically when
     * resolving
     * providers.
     *
     * @deprecated No replacement
     * \@publicApi
     */


    class ReflectiveKey {
      /**
       * Private
       * @param {?} token
       * @param {?} id
       */
      constructor(token, id) {
        this.token = token;
        this.id = id;

        if (!token) {
          throw new Error('Token must be defined!');
        }

        this.displayName = stringify(this.token);
      }
      /**
       * Retrieves a `Key` for a token.
       * @param {?} token
       * @return {?}
       */


      static get(token) {
        return _globalKeyRegistry.get(resolveForwardRef(token));
      }
      /**
       * @return {?} the number of keys registered in the system.
       */


      static get numberOfKeys() {
        return _globalKeyRegistry.numberOfKeys;
      }

    }

    if (false) {}

    class KeyRegistry {
      constructor() {
        this._allKeys = new Map();
      }
      /**
       * @param {?} token
       * @return {?}
       */


      get(token) {
        if (token instanceof ReflectiveKey) return token;

        if (this._allKeys.has(token)) {
          return (
            /** @type {?} */
            this._allKeys.get(token)
          );
        }
        /** @type {?} */


        const newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);

        this._allKeys.set(token, newKey);

        return newKey;
      }
      /**
       * @return {?}
       */


      get numberOfKeys() {
        return this._allKeys.size;
      }

    }

    if (false) {}
    /** @type {?} */


    const _globalKeyRegistry = new KeyRegistry();
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Provides access to reflection data about symbols. Used internally by Angular
     * to power dependency injection and compilation.
     */


    class Reflector {
      constructor(reflectionCapabilities) {
        this.reflectionCapabilities = reflectionCapabilities;
      }

      updateCapabilities(caps) {
        this.reflectionCapabilities = caps;
      }

      factory(type) {
        return this.reflectionCapabilities.factory(type);
      }

      parameters(typeOrFunc) {
        return this.reflectionCapabilities.parameters(typeOrFunc);
      }

      annotations(typeOrFunc) {
        return this.reflectionCapabilities.annotations(typeOrFunc);
      }

      propMetadata(typeOrFunc) {
        return this.reflectionCapabilities.propMetadata(typeOrFunc);
      }

      hasLifecycleHook(type, lcProperty) {
        return this.reflectionCapabilities.hasLifecycleHook(type, lcProperty);
      }

      getter(name) {
        return this.reflectionCapabilities.getter(name);
      }

      setter(name) {
        return this.reflectionCapabilities.setter(name);
      }

      method(name) {
        return this.reflectionCapabilities.method(name);
      }

      importUri(type) {
        return this.reflectionCapabilities.importUri(type);
      }

      resourceUri(type) {
        return this.reflectionCapabilities.resourceUri(type);
      }

      resolveIdentifier(name, moduleUrl, members, runtime) {
        return this.reflectionCapabilities.resolveIdentifier(name, moduleUrl, members, runtime);
      }

      resolveEnum(identifier, name) {
        return this.reflectionCapabilities.resolveEnum(identifier, name);
      }

    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * The {@link Reflector} used internally in Angular to access metadata
     * about symbols.
     */


    const reflector = new Reflector(new ReflectionCapabilities());
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @record
     */

    function NormalizedProvider() {}
    /**
     * `Dependency` is used by the framework to extend DI.
     * This is internal to Angular and should not be used directly.
     */


    class ReflectiveDependency {
      /**
       * @param {?} key
       * @param {?} optional
       * @param {?} visibility
       */
      constructor(key, optional, visibility) {
        this.key = key;
        this.optional = optional;
        this.visibility = visibility;
      }
      /**
       * @param {?} key
       * @return {?}
       */


      static fromKey(key) {
        return new ReflectiveDependency(key, false, null);
      }

    }

    if (false) {}
    /** @type {?} */


    const _EMPTY_LIST = [];
    /**
     * An internal resolved representation of a `Provider` used by the `Injector`.
     *
     * \@usageNotes
     * This is usually created automatically by `Injector.resolveAndCreate`.
     *
     * It can be created manually, as follows:
     *
     * ### Example
     *
     * ```typescript
     * var resolvedProviders = Injector.resolve([{ provide: 'message', useValue: 'Hello' }]);
     * var injector = Injector.fromResolvedProviders(resolvedProviders);
     *
     * expect(injector.get('message')).toEqual('Hello');
     * ```
     *
     * \@publicApi
     * @record
     */

    function ResolvedReflectiveProvider() {}

    if (false) {}

    class ResolvedReflectiveProvider_ {
      /**
       * @param {?} key
       * @param {?} resolvedFactories
       * @param {?} multiProvider
       */
      constructor(key, resolvedFactories, multiProvider) {
        this.key = key;
        this.resolvedFactories = resolvedFactories;
        this.multiProvider = multiProvider;
        this.resolvedFactory = this.resolvedFactories[0];
      }

    }

    if (false) {}
    /**
     * An internal resolved representation of a factory function created by resolving `Provider`.
     * \@publicApi
     */


    class ResolvedReflectiveFactory {
      /**
       * @param {?} factory
       * @param {?} dependencies
       */
      constructor(factory, dependencies) {
        this.factory = factory;
        this.dependencies = dependencies;
      }

    }

    if (false) {}
    /**
     * Resolve a single provider.
     * @param {?} provider
     * @return {?}
     */


    function resolveReflectiveFactory(provider) {
      /** @type {?} */
      let factoryFn;
      /** @type {?} */

      let resolvedDeps;

      if (provider.useClass) {
        /** @type {?} */
        const useClass = resolveForwardRef(provider.useClass);
        factoryFn = reflector.factory(useClass);
        resolvedDeps = _dependenciesFor(useClass);
      } else if (provider.useExisting) {
        factoryFn =
        /**
        * @param {?} aliasInstance
        * @return {?}
        */
        aliasInstance => aliasInstance;

        resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];
      } else if (provider.useFactory) {
        factoryFn = provider.useFactory;
        resolvedDeps = constructDependencies(provider.useFactory, provider.deps);
      } else {
        factoryFn =
        /**
        * @return {?}
        */
        () => provider.useValue;

        resolvedDeps = _EMPTY_LIST;
      }

      return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);
    }
    /**
     * Converts the `Provider` into `ResolvedProvider`.
     *
     * `Injector` internally only uses `ResolvedProvider`, `Provider` contains convenience provider
     * syntax.
     * @param {?} provider
     * @return {?}
     */


    function resolveReflectiveProvider(provider) {
      return new ResolvedReflectiveProvider_(ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)], provider.multi || false);
    }
    /**
     * Resolve a list of Providers.
     * @param {?} providers
     * @return {?}
     */


    function resolveReflectiveProviders(providers) {
      /** @type {?} */
      const normalized = _normalizeProviders(providers, []);
      /** @type {?} */


      const resolved = normalized.map(resolveReflectiveProvider);
      /** @type {?} */

      const resolvedProviderMap = mergeResolvedReflectiveProviders(resolved, new Map());
      return Array.from(resolvedProviderMap.values());
    }
    /**
     * Merges a list of ResolvedProviders into a list where each key is contained exactly once and
     * multi providers have been merged.
     * @param {?} providers
     * @param {?} normalizedProvidersMap
     * @return {?}
     */


    function mergeResolvedReflectiveProviders(providers, normalizedProvidersMap) {
      for (let i = 0; i < providers.length; i++) {
        /** @type {?} */
        const provider = providers[i];
        /** @type {?} */

        const existing = normalizedProvidersMap.get(provider.key.id);

        if (existing) {
          if (provider.multiProvider !== existing.multiProvider) {
            throw mixingMultiProvidersWithRegularProvidersError(existing, provider);
          }

          if (provider.multiProvider) {
            for (let j = 0; j < provider.resolvedFactories.length; j++) {
              existing.resolvedFactories.push(provider.resolvedFactories[j]);
            }
          } else {
            normalizedProvidersMap.set(provider.key.id, provider);
          }
        } else {
          /** @type {?} */
          let resolvedProvider;

          if (provider.multiProvider) {
            resolvedProvider = new ResolvedReflectiveProvider_(provider.key, provider.resolvedFactories.slice(), provider.multiProvider);
          } else {
            resolvedProvider = provider;
          }

          normalizedProvidersMap.set(provider.key.id, resolvedProvider);
        }
      }

      return normalizedProvidersMap;
    }
    /**
     * @param {?} providers
     * @param {?} res
     * @return {?}
     */


    function _normalizeProviders(providers, res) {
      providers.forEach(
      /**
      * @param {?} b
      * @return {?}
      */
      b => {
        if (b instanceof Type) {
          res.push(
          /** @type {?} */
          {
            provide: b,
            useClass: b
          });
        } else if (b && typeof b == 'object' &&
        /** @type {?} */
        b.provide !== undefined) {
          res.push(
          /** @type {?} */
          b);
        } else if (b instanceof Array) {
          _normalizeProviders(b, res);
        } else {
          throw invalidProviderError(b);
        }
      });
      return res;
    }
    /**
     * @param {?} typeOrFunc
     * @param {?=} dependencies
     * @return {?}
     */


    function constructDependencies(typeOrFunc, dependencies) {
      if (!dependencies) {
        return _dependenciesFor(typeOrFunc);
      } else {
        /** @type {?} */
        const params = dependencies.map(
        /**
        * @param {?} t
        * @return {?}
        */
        t => [t]);
        return dependencies.map(
        /**
        * @param {?} t
        * @return {?}
        */
        t => _extractToken(typeOrFunc, t, params));
      }
    }
    /**
     * @param {?} typeOrFunc
     * @return {?}
     */


    function _dependenciesFor(typeOrFunc) {
      /** @type {?} */
      const params = reflector.parameters(typeOrFunc);
      if (!params) return [];

      if (params.some(
      /**
      * @param {?} p
      * @return {?}
      */
      p => p == null)) {
        throw noAnnotationError(typeOrFunc, params);
      }

      return params.map(
      /**
      * @param {?} p
      * @return {?}
      */
      p => _extractToken(typeOrFunc, p, params));
    }
    /**
     * @param {?} typeOrFunc
     * @param {?} metadata
     * @param {?} params
     * @return {?}
     */


    function _extractToken(typeOrFunc, metadata, params) {
      /** @type {?} */
      let token = null;
      /** @type {?} */

      let optional = false;

      if (!Array.isArray(metadata)) {
        if (metadata instanceof Inject) {
          return _createDependency(metadata.token, optional, null);
        } else {
          return _createDependency(metadata, optional, null);
        }
      }
      /** @type {?} */


      let visibility = null;

      for (let i = 0; i < metadata.length; ++i) {
        /** @type {?} */
        const paramMetadata = metadata[i];

        if (paramMetadata instanceof Type) {
          token = paramMetadata;
        } else if (paramMetadata instanceof Inject) {
          token = paramMetadata.token;
        } else if (paramMetadata instanceof Optional) {
          optional = true;
        } else if (paramMetadata instanceof Self || paramMetadata instanceof SkipSelf) {
          visibility = paramMetadata;
        } else if (paramMetadata instanceof InjectionToken) {
          token = paramMetadata;
        }
      }

      token = resolveForwardRef(token);

      if (token != null) {
        return _createDependency(token, optional, visibility);
      } else {
        throw noAnnotationError(typeOrFunc, params);
      }
    }
    /**
     * @param {?} token
     * @param {?} optional
     * @param {?} visibility
     * @return {?}
     */


    function _createDependency(token, optional, visibility) {
      return new ReflectiveDependency(ReflectiveKey.get(token), optional, visibility);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // Threshold for the dynamic version

    /** @type {?} */


    const UNDEFINED = new Object();
    /**
     * A ReflectiveDependency injection container used for instantiating objects and resolving
     * dependencies.
     *
     * An `Injector` is a replacement for a `new` operator, which can automatically resolve the
     * constructor dependencies.
     *
     * In typical use, application code asks for the dependencies in the constructor and they are
     * resolved by the `Injector`.
     *
     * \@usageNotes
     * ### Example
     *
     * The following example creates an `Injector` configured to create `Engine` and `Car`.
     *
     * ```typescript
     * \@Injectable()
     * class Engine {
     * }
     *
     * \@Injectable()
     * class Car {
     *   constructor(public engine:Engine) {}
     * }
     *
     * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
     * var car = injector.get(Car);
     * expect(car instanceof Car).toBe(true);
     * expect(car.engine instanceof Engine).toBe(true);
     * ```
     *
     * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`
     * resolve all of the object's dependencies automatically.
     *
     * @deprecated from v5 - slow and brings in a lot of code, Use `Injector.create` instead.
     * \@publicApi
     * @abstract
     */

    class ReflectiveInjector {
      /**
       * Turns an array of provider definitions into an array of resolved providers.
       *
       * A resolution is a process of flattening multiple nested arrays and converting individual
       * providers into an array of `ResolvedReflectiveProvider`s.
       *
       * \@usageNotes
       * ### Example
       *
       * ```typescript
       * \@Injectable()
       * class Engine {
       * }
       *  /
       * class Car {
       *   constructor(public engine:Engine) {}
       * }
       *
       * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);
       *
       * expect(providers.length).toEqual(2);
       *
       * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);
       * expect(providers[0].key.displayName).toBe("Car");
       * expect(providers[0].dependencies.length).toEqual(1);
       * expect(providers[0].factory).toBeDefined();
       *
       * expect(providers[1].key.displayName).toBe("Engine");
       * });
       * ```
       *
       * @param {?} providers
       * @return {?}
       */
      static resolve(providers) {
        return resolveReflectiveProviders(providers);
      }
      /**
       * Resolves an array of providers and creates an injector from those providers.
       *
       * The passed-in providers can be an array of `Type`, `Provider`,
       * or a recursive array of more providers.
       *
       * \@usageNotes
       * ### Example
       *
       * ```typescript
       * \@Injectable()
       * class Engine {
       * }
       *  /
       * class Car {
       *   constructor(public engine:Engine) {}
       * }
       *
       * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);
       * expect(injector.get(Car) instanceof Car).toBe(true);
       * ```
       * @param {?} providers
       * @param {?=} parent
       * @return {?}
       */


      static resolveAndCreate(providers, parent) {
        /** @type {?} */
        const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
        return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);
      }
      /**
       * Creates an injector from previously resolved providers.
       *
       * This API is the recommended way to construct injectors in performance-sensitive parts.
       *
       * \@usageNotes
       * ### Example
       *
       * ```typescript
       * \@Injectable()
       * class Engine {
       * }
       *  /
       * class Car {
       *   constructor(public engine:Engine) {}
       * }
       *
       * var providers = ReflectiveInjector.resolve([Car, Engine]);
       * var injector = ReflectiveInjector.fromResolvedProviders(providers);
       * expect(injector.get(Car) instanceof Car).toBe(true);
       * ```
       * @param {?} providers
       * @param {?=} parent
       * @return {?}
       */


      static fromResolvedProviders(providers, parent) {
        return new ReflectiveInjector_(providers, parent);
      }

    }

    if (false) {}

    class ReflectiveInjector_ {
      /**
       * Private
       * @param {?} _providers
       * @param {?=} _parent
       */
      constructor(_providers, _parent) {
        /**
         * \@internal
         */
        this._constructionCounter = 0;
        this._providers = _providers;
        this.parent = _parent || null;
        /** @type {?} */

        const len = _providers.length;
        this.keyIds = new Array(len);
        this.objs = new Array(len);

        for (let i = 0; i < len; i++) {
          this.keyIds[i] = _providers[i].key.id;
          this.objs[i] = UNDEFINED;
        }
      }
      /**
       * @param {?} token
       * @param {?=} notFoundValue
       * @return {?}
       */


      get(token, notFoundValue = THROW_IF_NOT_FOUND) {
        return this._getByKey(ReflectiveKey.get(token), null, notFoundValue);
      }
      /**
       * @param {?} providers
       * @return {?}
       */


      resolveAndCreateChild(providers) {
        /** @type {?} */
        const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
        return this.createChildFromResolved(ResolvedReflectiveProviders);
      }
      /**
       * @param {?} providers
       * @return {?}
       */


      createChildFromResolved(providers) {
        /** @type {?} */
        const inj = new ReflectiveInjector_(providers);

        /** @type {?} */
        inj.parent = this;
        return inj;
      }
      /**
       * @param {?} provider
       * @return {?}
       */


      resolveAndInstantiate(provider) {
        return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);
      }
      /**
       * @param {?} provider
       * @return {?}
       */


      instantiateResolved(provider) {
        return this._instantiateProvider(provider);
      }
      /**
       * @param {?} index
       * @return {?}
       */


      getProviderAtIndex(index) {
        if (index < 0 || index >= this._providers.length) {
          throw outOfBoundsError(index);
        }

        return this._providers[index];
      }
      /**
       * \@internal
       * @param {?} provider
       * @return {?}
       */


      _new(provider) {
        if (this._constructionCounter++ > this._getMaxNumberOfObjects()) {
          throw cyclicDependencyError(this, provider.key);
        }

        return this._instantiateProvider(provider);
      }
      /**
       * @private
       * @return {?}
       */


      _getMaxNumberOfObjects() {
        return this.objs.length;
      }
      /**
       * @private
       * @param {?} provider
       * @return {?}
       */


      _instantiateProvider(provider) {
        if (provider.multiProvider) {
          /** @type {?} */
          const res = new Array(provider.resolvedFactories.length);

          for (let i = 0; i < provider.resolvedFactories.length; ++i) {
            res[i] = this._instantiate(provider, provider.resolvedFactories[i]);
          }

          return res;
        } else {
          return this._instantiate(provider, provider.resolvedFactories[0]);
        }
      }
      /**
       * @private
       * @param {?} provider
       * @param {?} ResolvedReflectiveFactory
       * @return {?}
       */


      _instantiate(provider, ResolvedReflectiveFactory) {
        /** @type {?} */
        const factory = ResolvedReflectiveFactory.factory;
        /** @type {?} */

        let deps;

        try {
          deps = ResolvedReflectiveFactory.dependencies.map(
          /**
          * @param {?} dep
          * @return {?}
          */
          dep => this._getByReflectiveDependency(dep));
        } catch (e) {
          if (e.addKey) {
            e.addKey(this, provider.key);
          }

          throw e;
        }
        /** @type {?} */


        let obj;

        try {
          obj = factory(...deps);
        } catch (e) {
          throw instantiationError(this, e, e.stack, provider.key);
        }

        return obj;
      }
      /**
       * @private
       * @param {?} dep
       * @return {?}
       */


      _getByReflectiveDependency(dep) {
        return this._getByKey(dep.key, dep.visibility, dep.optional ? null : THROW_IF_NOT_FOUND);
      }
      /**
       * @private
       * @param {?} key
       * @param {?} visibility
       * @param {?} notFoundValue
       * @return {?}
       */


      _getByKey(key, visibility, notFoundValue) {
        if (key === ReflectiveInjector_.INJECTOR_KEY) {
          return this;
        }

        if (visibility instanceof Self) {
          return this._getByKeySelf(key, notFoundValue);
        } else {
          return this._getByKeyDefault(key, notFoundValue, visibility);
        }
      }
      /**
       * @private
       * @param {?} keyId
       * @return {?}
       */


      _getObjByKeyId(keyId) {
        for (let i = 0; i < this.keyIds.length; i++) {
          if (this.keyIds[i] === keyId) {
            if (this.objs[i] === UNDEFINED) {
              this.objs[i] = this._new(this._providers[i]);
            }

            return this.objs[i];
          }
        }

        return UNDEFINED;
      }
      /**
       * \@internal
       * @param {?} key
       * @param {?} notFoundValue
       * @return {?}
       */


      _throwOrNull(key, notFoundValue) {
        if (notFoundValue !== THROW_IF_NOT_FOUND) {
          return notFoundValue;
        } else {
          throw noProviderError(this, key);
        }
      }
      /**
       * \@internal
       * @param {?} key
       * @param {?} notFoundValue
       * @return {?}
       */


      _getByKeySelf(key, notFoundValue) {
        /** @type {?} */
        const obj = this._getObjByKeyId(key.id);

        return obj !== UNDEFINED ? obj : this._throwOrNull(key, notFoundValue);
      }
      /**
       * \@internal
       * @param {?} key
       * @param {?} notFoundValue
       * @param {?} visibility
       * @return {?}
       */


      _getByKeyDefault(key, notFoundValue, visibility) {
        /** @type {?} */
        let inj;

        if (visibility instanceof SkipSelf) {
          inj = this.parent;
        } else {
          inj = this;
        }

        while (inj instanceof ReflectiveInjector_) {
          /** @type {?} */
          const inj_ =
          /** @type {?} */
          inj;
          /** @type {?} */

          const obj = inj_._getObjByKeyId(key.id);

          if (obj !== UNDEFINED) return obj;
          inj = inj_.parent;
        }

        if (inj !== null) {
          return inj.get(key.token, notFoundValue);
        } else {
          return this._throwOrNull(key, notFoundValue);
        }
      }
      /**
       * @return {?}
       */


      get displayName() {
        /** @type {?} */
        const providers = _mapProviders(this,
        /**
        * @param {?} b
        * @return {?}
        */
        b => ' "' + b.key.displayName + '" ').join(', ');

        return "ReflectiveInjector(providers: [".concat(providers, "])");
      }
      /**
       * @return {?}
       */


      toString() {
        return this.displayName;
      }

    }

    ReflectiveInjector_.INJECTOR_KEY = ReflectiveKey.get(Injector);

    if (false) {}
    /**
     * @param {?} injector
     * @param {?} fn
     * @return {?}
     */


    function _mapProviders(injector, fn) {
      /** @type {?} */
      const res = new Array(injector._providers.length);

      for (let i = 0; i < injector._providers.length; ++i) {
        res[i] = fn(injector.getProviderAtIndex(i));
      }

      return res;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * A DI token that you can use to create a virtual [provider](guide/glossary#provider)
     * that will populate the `entryComponents` field of components and NgModules
     * based on its `useValue` property value.
     * All components that are referenced in the `useValue` value (either directly
     * or in a nested array or map) are added to the `entryComponents` property.
     *
     * \@usageNotes
     *
     * The following example shows how the router can populate the `entryComponents`
     * field of an NgModule based on a router configuration that refers
     * to components.
     *
     * ```typescript
     * // helper function inside the router
     * function provideRoutes(routes) {
     *   return [
     *     {provide: ROUTES, useValue: routes},
     *     {provide: ANALYZE_FOR_ENTRY_COMPONENTS, useValue: routes, multi: true}
     *   ];
     * }
     *
     * // user code
     * let routes = [
     *   {path: '/root', component: RootComp},
     *   {path: '/teams', component: TeamsComp}
     * ];
     *
     * \@NgModule({
     *   providers: [provideRoutes(routes)]
     * })
     * class ModuleWithRoutes {}
     * ```
     *
     * \@publicApi
     * @type {?}
     */


    const ANALYZE_FOR_ENTRY_COMPONENTS = new InjectionToken('AnalyzeForEntryComponents');
    /**
     * Type of the `Attribute` decorator / constructor function.
     *
     * \@publicApi
     * @record
     */

    function AttributeDecorator$1() {}
    /**
     * Type of the Attribute metadata.
     *
     * \@publicApi
     * @record
     */


    function Attribute$1() {}

    if (false) {} // WARNING: interface has both a type and a value, skipping emit

    /**
     * Base class for query metadata.
     *
     * @see `ContentChildren`.
     * @see `ContentChild`.
     * @see `ViewChildren`.
     * @see `ViewChild`.
     *
     * \@publicApi
     * @abstract
     */


    class Query {}
    /**
     * Type of the ContentChildren decorator / constructor function.
     *
     * @see `ContentChildren`.
     * \@publicApi
     * @record
     */


    function ContentChildrenDecorator() {}

    const ɵ0$b =
    /**
    * @param {?=} selector
    * @param {?=} data
    * @return {?}
    */
    (selector, data = {}) => Object.assign({
      selector,
      first: false,
      isViewQuery: false,
      descendants: false
    }, data);
    /**
     * ContentChildren decorator and metadata.
     *
     *
     * \@Annotation
     * \@publicApi
     * @type {?}
     */


    const ContentChildren = makePropDecorator('ContentChildren', ɵ0$b, Query);
    /**
     * Type of the ContentChild decorator / constructor function.
     *
     * \@publicApi
     * @record
     */

    function ContentChildDecorator() {}

    const ɵ1$3 =
    /**
    * @param {?=} selector
    * @param {?=} data
    * @return {?}
    */
    (selector, data = {}) => Object.assign({
      selector,
      first: true,
      isViewQuery: false,
      descendants: true
    }, data);
    /**
     * ContentChild decorator and metadata.
     *
     *
     * \@Annotation
     *
     * \@publicApi
     * @type {?}
     */


    const ContentChild = makePropDecorator('ContentChild', ɵ1$3, Query);
    /**
     * Type of the ViewChildren decorator / constructor function.
     *
     * @see `ViewChildren`.
     *
     * \@publicApi
     * @record
     */

    function ViewChildrenDecorator() {}

    const ɵ2 =
    /**
    * @param {?=} selector
    * @param {?=} data
    * @return {?}
    */
    (selector, data = {}) => Object.assign({
      selector,
      first: false,
      isViewQuery: true,
      descendants: true
    }, data);
    /**
     * ViewChildren decorator and metadata.
     *
     * \@Annotation
     * \@publicApi
     * @type {?}
     */


    const ViewChildren = makePropDecorator('ViewChildren', ɵ2, Query);
    /**
     * Type of the ViewChild decorator / constructor function.
     *
     * @see `ViewChild`.
     * \@publicApi
     * @record
     */

    function ViewChildDecorator() {}

    const ɵ3 =
    /**
    * @param {?} selector
    * @param {?} data
    * @return {?}
    */
    (selector, data) => Object.assign({
      selector,
      first: true,
      isViewQuery: true,
      descendants: true
    }, data);
    /**
     * ViewChild decorator and metadata.
     *
     * \@Annotation
     * \@publicApi
     * @type {?}
     */


    const ViewChild = makePropDecorator('ViewChild', ɵ3, Query);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Used to resolve resource URLs on `\@Component` when used with JIT compilation.
     *
     * Example:
     * ```
     * \@Component({
     *   selector: 'my-comp',
     *   templateUrl: 'my-comp.html', // This requires asynchronous resolution
     * })
     * class MyComponent{
     * }
     *
     * // Calling `renderComponent` will fail because `renderComponent` is a synchronous process
     * // and `MyComponent`'s `\@Component.templateUrl` needs to be resolved asynchronously.
     *
     * // Calling `resolveComponentResources()` will resolve `\@Component.templateUrl` into
     * // `\@Component.template`, which allows `renderComponent` to proceed in a synchronous manner.
     *
     * // Use browser's `fetch()` function as the default resource resolution strategy.
     * resolveComponentResources(fetch).then(() => {
     *   // After resolution all URLs have been converted into `template` strings.
     *   renderComponent(MyComponent);
     * });
     *
     * ```
     *
     * NOTE: In AOT the resolution happens during compilation, and so there should be no need
     * to call this method outside JIT mode.
     *
     * @param {?} resourceResolver a function which is responsible for returning a `Promise` to the
     * contents of the resolved URL. Browser's `fetch()` method is a good default implementation.
     * @return {?}
     */

    function resolveComponentResources(resourceResolver) {
      // Store all promises which are fetching the resources.

      /** @type {?} */
      const componentResolved = []; // Cache so that we don't fetch the same resource more than once.

      /** @type {?} */

      const urlMap = new Map();
      /**
       * @param {?} url
       * @return {?}
       */

      function cachedResourceResolve(url) {
        /** @type {?} */
        let promise = urlMap.get(url);

        if (!promise) {
          /** @type {?} */
          const resp = resourceResolver(url);
          urlMap.set(url, promise = resp.then(unwrapResponse));
        }

        return promise;
      }

      componentResourceResolutionQueue.forEach(
      /**
      * @param {?} component
      * @param {?} type
      * @return {?}
      */
      (component, type) => {
        /** @type {?} */
        const promises = [];

        if (component.templateUrl) {
          promises.push(cachedResourceResolve(component.templateUrl).then(
          /**
          * @param {?} template
          * @return {?}
          */
          template => {
            component.template = template;
          }));
        }
        /** @type {?} */


        const styleUrls = component.styleUrls;
        /** @type {?} */

        const styles = component.styles || (component.styles = []);
        /** @type {?} */

        const styleOffset = component.styles.length;
        styleUrls && styleUrls.forEach(
        /**
        * @param {?} styleUrl
        * @param {?} index
        * @return {?}
        */
        (styleUrl, index) => {
          styles.push(''); // pre-allocate array.

          promises.push(cachedResourceResolve(styleUrl).then(
          /**
          * @param {?} style
          * @return {?}
          */
          style => {
            styles[styleOffset + index] = style;
            styleUrls.splice(styleUrls.indexOf(styleUrl), 1);

            if (styleUrls.length == 0) {
              component.styleUrls = undefined;
            }
          }));
        });
        /** @type {?} */

        const fullyResolved = Promise.all(promises).then(
        /**
        * @return {?}
        */
        () => componentDefResolved(type));
        componentResolved.push(fullyResolved);
      });
      clearResolutionOfComponentResourcesQueue();
      return Promise.all(componentResolved).then(
      /**
      * @return {?}
      */
      () => undefined);
    }
    /** @type {?} */


    let componentResourceResolutionQueue = new Map(); // Track when existing ngComponentDef for a Type is waiting on resources.

    /** @type {?} */

    const componentDefPendingResolution = new Set();
    /**
     * @param {?} type
     * @param {?} metadata
     * @return {?}
     */

    function maybeQueueResolutionOfComponentResources(type, metadata) {
      if (componentNeedsResolution(metadata)) {
        componentResourceResolutionQueue.set(type, metadata);
        componentDefPendingResolution.add(type);
      }
    }
    /**
     * @param {?} type
     * @return {?}
     */


    function isComponentDefPendingResolution(type) {
      return componentDefPendingResolution.has(type);
    }
    /**
     * @param {?} component
     * @return {?}
     */


    function componentNeedsResolution(component) {
      return !!(component.templateUrl && !component.hasOwnProperty('template') || component.styleUrls && component.styleUrls.length);
    }
    /**
     * @return {?}
     */


    function clearResolutionOfComponentResourcesQueue() {
      /** @type {?} */
      const old = componentResourceResolutionQueue;
      componentResourceResolutionQueue = new Map();
      return old;
    }
    /**
     * @param {?} queue
     * @return {?}
     */


    function restoreComponentResolutionQueue(queue) {
      componentDefPendingResolution.clear();
      queue.forEach(
      /**
      * @param {?} _
      * @param {?} type
      * @return {?}
      */
      (_, type) => componentDefPendingResolution.add(type));
      componentResourceResolutionQueue = queue;
    }
    /**
     * @return {?}
     */


    function isComponentResourceResolutionQueueEmpty() {
      return componentResourceResolutionQueue.size === 0;
    }
    /**
     * @param {?} response
     * @return {?}
     */


    function unwrapResponse(response) {
      return typeof response == 'string' ? response : response.text();
    }
    /**
     * @param {?} type
     * @return {?}
     */


    function componentDefResolved(type) {
      componentDefPendingResolution.delete(type);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Allocates the necessary amount of slots for host vars.
     *
     * \@codeGenApi
     * @param {?} count Amount of vars to be allocated
     *
     * @return {?}
     */


    function ɵɵallocHostVars(count) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const tView = lView[TVIEW];
      if (!tView.firstTemplatePass) return;
      queueHostBindingForCheck(tView,
      /** @type {?} */
      getCurrentDirectiveDef(), count);
      prefillHostVars(tView, lView, count);
    }
    /**
     * Stores host binding fn and number of host vars so it will be queued for binding refresh during
     * CD.
     * @param {?} tView
     * @param {?} def
     * @param {?} hostVars
     * @return {?}
     */


    function queueHostBindingForCheck(tView, def, hostVars) {
      ngDevMode && assertEqual(tView.firstTemplatePass, true, 'Should only be called in first template pass.');
      /** @type {?} */

      const expando =
      /** @type {?} */
      tView.expandoInstructions;
      /** @type {?} */

      const length = expando.length; // Check whether a given `hostBindings` function already exists in expandoInstructions,
      // which can happen in case directive definition was extended from base definition (as a part of
      // the `InheritDefinitionFeature` logic). If we found the same `hostBindings` function in the
      // list, we just increase the number of host vars associated with that function, but do not add it
      // into the list again.

      if (length >= 2 && expando[length - 2] === def.hostBindings) {
        expando[length - 1] =
        /** @type {?} */
        expando[length - 1] + hostVars;
      } else {
        expando.push(
        /** @type {?} */
        def.hostBindings, hostVars);
      }
    }
    /**
     * On the first template pass, we need to reserve space for host binding values
     * after directives are matched (so all directives are saved, then bindings).
     * Because we are updating the blueprint, we only need to do this once.
     * @param {?} tView
     * @param {?} lView
     * @param {?} totalHostVars
     * @return {?}
     */


    function prefillHostVars(tView, lView, totalHostVars) {
      ngDevMode && assertEqual(tView.firstTemplatePass, true, 'Should only be called in first template pass.');

      for (let i = 0; i < totalHostVars; i++) {
        lView.push(NO_CHANGE);
        tView.blueprint.push(NO_CHANGE);
        tView.data.push(null);
      }
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    let _symbolIterator = null;

    function getSymbolIterator() {
      if (!_symbolIterator) {
        const Symbol = _global['Symbol'];

        if (Symbol && Symbol.iterator) {
          _symbolIterator = Symbol.iterator;
        } else {
          // es6-shim specific logic
          const keys = Object.getOwnPropertyNames(Map.prototype);

          for (let i = 0; i < keys.length; ++i) {
            const key = keys[i];

            if (key !== 'entries' && key !== 'size' && Map.prototype[key] === Map.prototype['entries']) {
              _symbolIterator = key;
            }
          }
        }
      }

      return _symbolIterator;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    function isListLikeIterable(obj) {
      if (!isJsObject(obj)) return false;
      return Array.isArray(obj) || !(obj instanceof Map) && // JS Map are iterables but return entries as [k, v]
      getSymbolIterator() in obj; // JS Iterable have a Symbol.iterator prop
    }

    function areIterablesEqual(a, b, comparator) {
      const iterator1 = a[getSymbolIterator()]();
      const iterator2 = b[getSymbolIterator()]();

      while (true) {
        const item1 = iterator1.next();
        const item2 = iterator2.next();
        if (item1.done && item2.done) return true;
        if (item1.done || item2.done) return false;
        if (!comparator(item1.value, item2.value)) return false;
      }
    }

    function iterateListLike(obj, fn) {
      if (Array.isArray(obj)) {
        for (let i = 0; i < obj.length; i++) {
          fn(obj[i]);
        }
      } else {
        const iterator = obj[getSymbolIterator()]();
        let item;

        while (!(item = iterator.next()).done) {
          fn(item.value);
        }
      }
    }

    function isJsObject(o) {
      return o !== null && (typeof o === 'function' || typeof o === 'object');
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // JS has NaN !== NaN


    function looseIdentical(a, b) {
      return a === b || typeof a === 'number' && typeof b === 'number' && isNaN(a) && isNaN(b);
    }

    function devModeEqual(a, b) {
      const isListLikeIterableA = isListLikeIterable(a);
      const isListLikeIterableB = isListLikeIterable(b);

      if (isListLikeIterableA && isListLikeIterableB) {
        return areIterablesEqual(a, b, devModeEqual);
      } else {
        const isAObject = a && (typeof a === 'object' || typeof a === 'function');
        const isBObject = b && (typeof b === 'object' || typeof b === 'function');

        if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {
          return true;
        } else {
          return looseIdentical(a, b);
        }
      }
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */


    function devModeEqual$1(a, b) {
      /** @type {?} */
      const isListLikeIterableA = isListLikeIterable$1(a);
      /** @type {?} */

      const isListLikeIterableB = isListLikeIterable$1(b);

      if (isListLikeIterableA && isListLikeIterableB) {
        return areIterablesEqual$1(a, b, devModeEqual$1);
      } else {
        /** @type {?} */
        const isAObject = a && (typeof a === 'object' || typeof a === 'function');
        /** @type {?} */

        const isBObject = b && (typeof b === 'object' || typeof b === 'function');

        if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {
          return true;
        } else {
          return looseIdentical(a, b);
        }
      }
    }
    /**
     * Indicates that the result of a {\@link Pipe} transformation has changed even though the
     * reference has not changed.
     *
     * Wrapped values are unwrapped automatically during the change detection, and the unwrapped value
     * is stored.
     *
     * Example:
     *
     * ```
     * if (this._latestValue === this._latestReturnedValue) {
     *    return this._latestReturnedValue;
     *  } else {
     *    this._latestReturnedValue = this._latestValue;
     *    return WrappedValue.wrap(this._latestValue); // this will force update
     *  }
     * ```
     *
     * \@publicApi
     */


    class WrappedValue {
      /**
       * @param {?} value
       */
      constructor(value) {
        this.wrapped = value;
      }
      /**
       * Creates a wrapped value.
       * @param {?} value
       * @return {?}
       */


      static wrap(value) {
        return new WrappedValue(value);
      }
      /**
       * Returns the underlying value of a wrapped value.
       * Returns the given `value` when it is not wrapped.
       *
       * @param {?} value
       * @return {?}
       */


      static unwrap(value) {
        return WrappedValue.isWrapped(value) ? value.wrapped : value;
      }
      /**
       * Returns true if `value` is a wrapped value.
       * @param {?} value
       * @return {?}
       */


      static isWrapped(value) {
        return value instanceof WrappedValue;
      }

    }

    if (false) {}
    /**
     * @param {?} obj
     * @return {?}
     */


    function isListLikeIterable$1(obj) {
      if (!isJsObject$1(obj)) return false;
      return Array.isArray(obj) || !(obj instanceof Map) && // JS Map are iterables but return entries as [k, v]
      getSymbolIterator() in obj; // JS Iterable have a Symbol.iterator prop
    }
    /**
     * @param {?} a
     * @param {?} b
     * @param {?} comparator
     * @return {?}
     */


    function areIterablesEqual$1(a, b, comparator) {
      /** @type {?} */
      const iterator1 = a[getSymbolIterator()]();
      /** @type {?} */

      const iterator2 = b[getSymbolIterator()]();

      while (true) {
        /** @type {?} */
        const item1 = iterator1.next();
        /** @type {?} */

        const item2 = iterator2.next();
        if (item1.done && item2.done) return true;
        if (item1.done || item2.done) return false;
        if (!comparator(item1.value, item2.value)) return false;
      }
    }
    /**
     * @param {?} obj
     * @param {?} fn
     * @return {?}
     */


    function iterateListLike$1(obj, fn) {
      if (Array.isArray(obj)) {
        for (let i = 0; i < obj.length; i++) {
          fn(obj[i]);
        }
      } else {
        /** @type {?} */
        const iterator = obj[getSymbolIterator()]();
        /** @type {?} */

        let item;

        while (!(item = iterator.next()).done) {
          fn(item.value);
        }
      }
    }
    /**
     * @param {?} o
     * @return {?}
     */


    function isJsObject$1(o) {
      return o !== null && (typeof o === 'function' || typeof o === 'object');
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */
    // TODO(misko): consider inlining

    /**
     * Updates binding and returns the value.
     * @param {?} lView
     * @param {?} bindingIndex
     * @param {?} value
     * @return {?}
     */


    function updateBinding(lView, bindingIndex, value) {
      return lView[bindingIndex] = value;
    }
    /**
     * Gets the current binding value.
     * @param {?} lView
     * @param {?} bindingIndex
     * @return {?}
     */


    function getBinding(lView, bindingIndex) {
      ngDevMode && assertDataInRange(lView, bindingIndex);
      ngDevMode && assertNotSame(lView[bindingIndex], NO_CHANGE, 'Stored value should never be NO_CHANGE.');
      return lView[bindingIndex];
    }
    /**
     * Updates binding if changed, then returns whether it was updated.
     * @param {?} lView
     * @param {?} bindingIndex
     * @param {?} value
     * @return {?}
     */


    function bindingUpdated(lView, bindingIndex, value) {
      ngDevMode && assertNotSame(value, NO_CHANGE, 'Incoming value should never be NO_CHANGE.');
      ngDevMode && assertLessThan(bindingIndex, lView.length, "Slot should have been initialized to NO_CHANGE");
      /** @type {?} */

      const oldValue = lView[bindingIndex];

      if (isDifferent(oldValue, value)) {
        if (ngDevMode && getCheckNoChangesMode()) {
          // View engine didn't report undefined values as changed on the first checkNoChanges pass
          // (before the change detection was run).

          /** @type {?} */
          const oldValueToCompare = oldValue !== NO_CHANGE ? oldValue : undefined;

          if (!devModeEqual$1(oldValueToCompare, value)) {
            throwErrorIfNoChangesMode(oldValue === NO_CHANGE, oldValueToCompare, value);
          }
        }

        lView[bindingIndex] = value;
        return true;
      }

      return false;
    }
    /**
     * Updates 2 bindings if changed, then returns whether either was updated.
     * @param {?} lView
     * @param {?} bindingIndex
     * @param {?} exp1
     * @param {?} exp2
     * @return {?}
     */


    function bindingUpdated2(lView, bindingIndex, exp1, exp2) {
      /** @type {?} */
      const different = bindingUpdated(lView, bindingIndex, exp1);
      return bindingUpdated(lView, bindingIndex + 1, exp2) || different;
    }
    /**
     * Updates 3 bindings if changed, then returns whether any was updated.
     * @param {?} lView
     * @param {?} bindingIndex
     * @param {?} exp1
     * @param {?} exp2
     * @param {?} exp3
     * @return {?}
     */


    function bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) {
      /** @type {?} */
      const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
      return bindingUpdated(lView, bindingIndex + 2, exp3) || different;
    }
    /**
     * Updates 4 bindings if changed, then returns whether any was updated.
     * @param {?} lView
     * @param {?} bindingIndex
     * @param {?} exp1
     * @param {?} exp2
     * @param {?} exp3
     * @param {?} exp4
     * @return {?}
     */


    function bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) {
      /** @type {?} */
      const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);
      return bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Update a property on a selected element.
     *
     * Operates on the element selected by index via the {\@link select} instruction.
     *
     * If the property name also exists as an input property on one of the element's directives,
     * the component property will be set instead of the element property. This check must
     * be conducted at runtime so child components that add new `\@Inputs` don't have to be re-compiled
     *
     * \@codeGenApi
     * @template T
     * @param {?} propName Name of property. Because it is going to DOM, this is not subject to
     *        renaming as part of minification.
     * @param {?} value New value to write.
     * @param {?=} sanitizer An optional function used to sanitize the value.
     * @return {?} This function returns itself so that it may be chained
     * (e.g. `property('name', ctx.name)('title', ctx.title)`)
     *
     */


    function ɵɵproperty(propName, value, sanitizer) {
      /** @type {?} */
      const index = getSelectedIndex();
      ngDevMode && assertNotEqual(index, -1, 'selected index cannot be -1');
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const bindReconciledValue = bind(lView, value);

      if (bindReconciledValue !== NO_CHANGE) {
        elementPropertyInternal(index, propName, bindReconciledValue, sanitizer);
      }

      return ɵɵproperty;
    }
    /**
     * Creates a single value binding.
     *
     * @template T
     * @param {?} lView Current view
     * @param {?} value Value to diff
     * @return {?}
     */


    function bind(lView, value) {
      /** @type {?} */
      const bindingIndex = lView[BINDING_INDEX]++;
      storeBindingMetadata(lView);
      return bindingUpdated(lView, bindingIndex, value) ? value : NO_CHANGE;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Updates the value of or removes a bound attribute on an Element.
     *
     * Used in the case of `[attr.title]="value"`
     *
     * \@codeGenApi
     * @param {?} name name The name of the attribute.
     * @param {?} value value The attribute is removed when value is `null` or `undefined`.
     *                  Otherwise the attribute value is set to the stringified value.
     * @param {?=} sanitizer An optional function used to sanitize the value.
     * @param {?=} namespace Optional namespace to use when setting the attribute.
     *
     * @return {?}
     */


    function ɵɵattribute(name, value, sanitizer, namespace) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const bound = bind(lView, value);

      if (bound !== NO_CHANGE) {
        elementAttributeInternal(index, name, bound, lView, sanitizer, namespace);
      }

      return ɵɵattribute;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Create interpolation bindings with a variable number of expressions.
     *
     * If there are 1 to 8 expressions `interpolation1()` to `interpolation8()` should be used instead.
     * Those are faster because there is no need to create an array of expressions and iterate over it.
     *
     * `values`:
     * - has static text at even indexes,
     * - has evaluated expressions at odd indexes.
     *
     * Returns the concatenated string when any of the arguments changes, `NO_CHANGE` otherwise.
     * @param {?} lView
     * @param {?} values
     * @return {?}
     */


    function interpolationV(lView, values) {
      ngDevMode && assertLessThan(2, values.length, 'should have at least 3 values');
      ngDevMode && assertEqual(values.length % 2, 1, 'should have an odd number of values');
      /** @type {?} */

      let isBindingUpdated = false;
      /** @type {?} */

      const tData = lView[TVIEW].data;
      /** @type {?} */

      let bindingIndex = lView[BINDING_INDEX];

      if (tData[bindingIndex] == null) {
        // 2 is the index of the first static interstitial value (ie. not prefix)
        for (let i = 2; i < values.length; i += 2) {
          tData[bindingIndex++] = values[i];
        }

        bindingIndex = lView[BINDING_INDEX];
      }

      for (let i = 1; i < values.length; i += 2) {
        // Check if bindings (odd indexes) have changed
        isBindingUpdated = bindingUpdated(lView, bindingIndex++, values[i]) || isBindingUpdated;
      }

      lView[BINDING_INDEX] = bindingIndex;
      storeBindingMetadata(lView, values[0], values[values.length - 1]);

      if (!isBindingUpdated) {
        return NO_CHANGE;
      } // Build the updated content

      /** @type {?} */


      let content = values[0];

      for (let i = 1; i < values.length; i += 2) {
        content += renderStringify(values[i]) + values[i + 1];
      }

      return content;
    }
    /**
     * Creates an interpolation binding with 1 expression.
     *
     * @param {?} lView
     * @param {?} prefix static value used for concatenation only.
     * @param {?} v0 value checked for change.
     * @param {?} suffix static value used for concatenation only.
     * @return {?}
     */


    function interpolation1(lView, prefix, v0, suffix) {
      /** @type {?} */
      const different = bindingUpdated(lView, lView[BINDING_INDEX]++, v0);
      storeBindingMetadata(lView, prefix, suffix);
      return different ? prefix + renderStringify(v0) + suffix : NO_CHANGE;
    }
    /**
     * Creates an interpolation binding with 2 expressions.
     * @param {?} lView
     * @param {?} prefix
     * @param {?} v0
     * @param {?} i0
     * @param {?} v1
     * @param {?} suffix
     * @return {?}
     */


    function interpolation2(lView, prefix, v0, i0, v1, suffix) {
      /** @type {?} */
      const bindingIndex = lView[BINDING_INDEX];
      /** @type {?} */

      const different = bindingUpdated2(lView, bindingIndex, v0, v1);
      lView[BINDING_INDEX] += 2; // Only set static strings the first time (data will be null subsequent runs).

      /** @type {?} */

      const data = storeBindingMetadata(lView, prefix, suffix);

      if (data) {
        lView[TVIEW].data[bindingIndex] = i0;
      }

      return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + suffix : NO_CHANGE;
    }
    /**
     * Creates an interpolation binding with 3 expressions.
     * @param {?} lView
     * @param {?} prefix
     * @param {?} v0
     * @param {?} i0
     * @param {?} v1
     * @param {?} i1
     * @param {?} v2
     * @param {?} suffix
     * @return {?}
     */


    function interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix) {
      /** @type {?} */
      const bindingIndex = lView[BINDING_INDEX];
      /** @type {?} */

      const different = bindingUpdated3(lView, bindingIndex, v0, v1, v2);
      lView[BINDING_INDEX] += 3; // Only set static strings the first time (data will be null subsequent runs).

      /** @type {?} */

      const data = storeBindingMetadata(lView, prefix, suffix);

      if (data) {
        /** @type {?} */
        const tData = lView[TVIEW].data;
        tData[bindingIndex] = i0;
        tData[bindingIndex + 1] = i1;
      }

      return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + suffix : NO_CHANGE;
    }
    /**
     * Create an interpolation binding with 4 expressions.
     * @param {?} lView
     * @param {?} prefix
     * @param {?} v0
     * @param {?} i0
     * @param {?} v1
     * @param {?} i1
     * @param {?} v2
     * @param {?} i2
     * @param {?} v3
     * @param {?} suffix
     * @return {?}
     */


    function interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
      /** @type {?} */
      const bindingIndex = lView[BINDING_INDEX];
      /** @type {?} */

      const different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
      lView[BINDING_INDEX] += 4; // Only set static strings the first time (data will be null subsequent runs).

      /** @type {?} */

      const data = storeBindingMetadata(lView, prefix, suffix);

      if (data) {
        /** @type {?} */
        const tData = lView[TVIEW].data;
        tData[bindingIndex] = i0;
        tData[bindingIndex + 1] = i1;
        tData[bindingIndex + 2] = i2;
      }

      return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + suffix : NO_CHANGE;
    }
    /**
     * Creates an interpolation binding with 5 expressions.
     * @param {?} lView
     * @param {?} prefix
     * @param {?} v0
     * @param {?} i0
     * @param {?} v1
     * @param {?} i1
     * @param {?} v2
     * @param {?} i2
     * @param {?} v3
     * @param {?} i3
     * @param {?} v4
     * @param {?} suffix
     * @return {?}
     */


    function interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
      /** @type {?} */
      const bindingIndex = lView[BINDING_INDEX];
      /** @type {?} */

      let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
      different = bindingUpdated(lView, bindingIndex + 4, v4) || different;
      lView[BINDING_INDEX] += 5; // Only set static strings the first time (data will be null subsequent runs).

      /** @type {?} */

      const data = storeBindingMetadata(lView, prefix, suffix);

      if (data) {
        /** @type {?} */
        const tData = lView[TVIEW].data;
        tData[bindingIndex] = i0;
        tData[bindingIndex + 1] = i1;
        tData[bindingIndex + 2] = i2;
        tData[bindingIndex + 3] = i3;
      }

      return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + suffix : NO_CHANGE;
    }
    /**
     * Creates an interpolation binding with 6 expressions.
     * @param {?} lView
     * @param {?} prefix
     * @param {?} v0
     * @param {?} i0
     * @param {?} v1
     * @param {?} i1
     * @param {?} v2
     * @param {?} i2
     * @param {?} v3
     * @param {?} i3
     * @param {?} v4
     * @param {?} i4
     * @param {?} v5
     * @param {?} suffix
     * @return {?}
     */


    function interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
      /** @type {?} */
      const bindingIndex = lView[BINDING_INDEX];
      /** @type {?} */

      let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
      different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;
      lView[BINDING_INDEX] += 6; // Only set static strings the first time (data will be null subsequent runs).

      /** @type {?} */

      const data = storeBindingMetadata(lView, prefix, suffix);

      if (data) {
        /** @type {?} */
        const tData = lView[TVIEW].data;
        tData[bindingIndex] = i0;
        tData[bindingIndex + 1] = i1;
        tData[bindingIndex + 2] = i2;
        tData[bindingIndex + 3] = i3;
        tData[bindingIndex + 4] = i4;
      }

      return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + suffix : NO_CHANGE;
    }
    /**
     * Creates an interpolation binding with 7 expressions.
     * @param {?} lView
     * @param {?} prefix
     * @param {?} v0
     * @param {?} i0
     * @param {?} v1
     * @param {?} i1
     * @param {?} v2
     * @param {?} i2
     * @param {?} v3
     * @param {?} i3
     * @param {?} v4
     * @param {?} i4
     * @param {?} v5
     * @param {?} i5
     * @param {?} v6
     * @param {?} suffix
     * @return {?}
     */


    function interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
      /** @type {?} */
      const bindingIndex = lView[BINDING_INDEX];
      /** @type {?} */

      let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
      different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;
      lView[BINDING_INDEX] += 7; // Only set static strings the first time (data will be null subsequent runs).

      /** @type {?} */

      const data = storeBindingMetadata(lView, prefix, suffix);

      if (data) {
        /** @type {?} */
        const tData = lView[TVIEW].data;
        tData[bindingIndex] = i0;
        tData[bindingIndex + 1] = i1;
        tData[bindingIndex + 2] = i2;
        tData[bindingIndex + 3] = i3;
        tData[bindingIndex + 4] = i4;
        tData[bindingIndex + 5] = i5;
      }

      return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + suffix : NO_CHANGE;
    }
    /**
     * Creates an interpolation binding with 8 expressions.
     * @param {?} lView
     * @param {?} prefix
     * @param {?} v0
     * @param {?} i0
     * @param {?} v1
     * @param {?} i1
     * @param {?} v2
     * @param {?} i2
     * @param {?} v3
     * @param {?} i3
     * @param {?} v4
     * @param {?} i4
     * @param {?} v5
     * @param {?} i5
     * @param {?} v6
     * @param {?} i6
     * @param {?} v7
     * @param {?} suffix
     * @return {?}
     */


    function interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
      /** @type {?} */
      const bindingIndex = lView[BINDING_INDEX];
      /** @type {?} */

      let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);
      different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;
      lView[BINDING_INDEX] += 8; // Only set static strings the first time (data will be null subsequent runs).

      /** @type {?} */

      const data = storeBindingMetadata(lView, prefix, suffix);

      if (data) {
        /** @type {?} */
        const tData = lView[TVIEW].data;
        tData[bindingIndex] = i0;
        tData[bindingIndex + 1] = i1;
        tData[bindingIndex + 2] = i2;
        tData[bindingIndex + 3] = i3;
        tData[bindingIndex + 4] = i4;
        tData[bindingIndex + 5] = i5;
        tData[bindingIndex + 6] = i6;
      }

      return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + i6 + renderStringify(v7) + suffix : NO_CHANGE;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     *
     * Update an interpolated attribute on an element with single bound value surrounded by text.
     *
     * Used when the value passed to a property has 1 interpolated value in it:
     *
     * ```html
     * <div attr.title="prefix{{v0}}suffix"></div>
     * ```
     *
     * Its compiled representation is::
     *
     * ```ts
     * ɵɵattributeInterpolate1('title', 'prefix', v0, 'suffix');
     * ```
     *
     * \@codeGenApi
     * @param {?} attrName The name of the attribute to update
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @param {?=} sanitizer An optional sanitizer function
     * @param {?=} namespace
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵattributeInterpolate1(attrName, prefix, v0, suffix, sanitizer, namespace) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const interpolatedValue = interpolation1(lView, prefix, v0, suffix);

      if (interpolatedValue !== NO_CHANGE) {
        elementAttributeInternal(index, attrName, interpolatedValue, lView, sanitizer, namespace);
      }

      return ɵɵattributeInterpolate1;
    }
    /**
     *
     * Update an interpolated attribute on an element with 2 bound values surrounded by text.
     *
     * Used when the value passed to a property has 2 interpolated values in it:
     *
     * ```html
     * <div attr.title="prefix{{v0}}-{{v1}}suffix"></div>
     * ```
     *
     * Its compiled representation is::
     *
     * ```ts
     * ɵɵattributeInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');
     * ```
     *
     * \@codeGenApi
     * @param {?} attrName The name of the attribute to update
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @param {?=} sanitizer An optional sanitizer function
     * @param {?=} namespace
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵattributeInterpolate2(attrName, prefix, v0, i0, v1, suffix, sanitizer, namespace) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);

      if (interpolatedValue !== NO_CHANGE) {
        elementAttributeInternal(index, attrName, interpolatedValue, lView, sanitizer, namespace);
      }

      return ɵɵattributeInterpolate2;
    }
    /**
     *
     * Update an interpolated attribute on an element with 3 bound values surrounded by text.
     *
     * Used when the value passed to a property has 3 interpolated values in it:
     *
     * ```html
     * <div attr.title="prefix{{v0}}-{{v1}}-{{v2}}suffix"></div>
     * ```
     *
     * Its compiled representation is::
     *
     * ```ts
     * ɵɵattributeInterpolate3(
     * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');
     * ```
     *
     * \@codeGenApi
     * @param {?} attrName The name of the attribute to update
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} i1 Static value used for concatenation only.
     * @param {?} v2 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @param {?=} sanitizer An optional sanitizer function
     * @param {?=} namespace
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵattributeInterpolate3(attrName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer, namespace) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);

      if (interpolatedValue !== NO_CHANGE) {
        elementAttributeInternal(index, attrName, interpolatedValue, lView, sanitizer, namespace);
      }

      return ɵɵattributeInterpolate3;
    }
    /**
     *
     * Update an interpolated attribute on an element with 4 bound values surrounded by text.
     *
     * Used when the value passed to a property has 4 interpolated values in it:
     *
     * ```html
     * <div attr.title="prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix"></div>
     * ```
     *
     * Its compiled representation is::
     *
     * ```ts
     * ɵɵattributeInterpolate4(
     * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');
     * ```
     *
     * \@codeGenApi
     * @param {?} attrName The name of the attribute to update
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} i1 Static value used for concatenation only.
     * @param {?} v2 Value checked for change.
     * @param {?} i2 Static value used for concatenation only.
     * @param {?} v3 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @param {?=} sanitizer An optional sanitizer function
     * @param {?=} namespace
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵattributeInterpolate4(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer, namespace) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);

      if (interpolatedValue !== NO_CHANGE) {
        elementAttributeInternal(index, attrName, interpolatedValue, lView, sanitizer, namespace);
      }

      return ɵɵattributeInterpolate4;
    }
    /**
     *
     * Update an interpolated attribute on an element with 5 bound values surrounded by text.
     *
     * Used when the value passed to a property has 5 interpolated values in it:
     *
     * ```html
     * <div attr.title="prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix"></div>
     * ```
     *
     * Its compiled representation is::
     *
     * ```ts
     * ɵɵattributeInterpolate5(
     * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');
     * ```
     *
     * \@codeGenApi
     * @param {?} attrName The name of the attribute to update
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} i1 Static value used for concatenation only.
     * @param {?} v2 Value checked for change.
     * @param {?} i2 Static value used for concatenation only.
     * @param {?} v3 Value checked for change.
     * @param {?} i3 Static value used for concatenation only.
     * @param {?} v4 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @param {?=} sanitizer An optional sanitizer function
     * @param {?=} namespace
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵattributeInterpolate5(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer, namespace) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);

      if (interpolatedValue !== NO_CHANGE) {
        elementAttributeInternal(index, attrName, interpolatedValue, lView, sanitizer, namespace);
      }

      return ɵɵattributeInterpolate5;
    }
    /**
     *
     * Update an interpolated attribute on an element with 6 bound values surrounded by text.
     *
     * Used when the value passed to a property has 6 interpolated values in it:
     *
     * ```html
     * <div attr.title="prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix"></div>
     * ```
     *
     * Its compiled representation is::
     *
     * ```ts
     * ɵɵattributeInterpolate6(
     *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');
     * ```
     *
     * \@codeGenApi
     * @param {?} attrName The name of the attribute to update
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} i1 Static value used for concatenation only.
     * @param {?} v2 Value checked for change.
     * @param {?} i2 Static value used for concatenation only.
     * @param {?} v3 Value checked for change.
     * @param {?} i3 Static value used for concatenation only.
     * @param {?} v4 Value checked for change.
     * @param {?} i4 Static value used for concatenation only.
     * @param {?} v5 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @param {?=} sanitizer An optional sanitizer function
     * @param {?=} namespace
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵattributeInterpolate6(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer, namespace) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);

      if (interpolatedValue !== NO_CHANGE) {
        elementAttributeInternal(index, attrName, interpolatedValue, lView, sanitizer, namespace);
      }

      return ɵɵattributeInterpolate6;
    }
    /**
     *
     * Update an interpolated attribute on an element with 7 bound values surrounded by text.
     *
     * Used when the value passed to a property has 7 interpolated values in it:
     *
     * ```html
     * <div attr.title="prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix"></div>
     * ```
     *
     * Its compiled representation is::
     *
     * ```ts
     * ɵɵattributeInterpolate7(
     *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');
     * ```
     *
     * \@codeGenApi
     * @param {?} attrName The name of the attribute to update
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} i1 Static value used for concatenation only.
     * @param {?} v2 Value checked for change.
     * @param {?} i2 Static value used for concatenation only.
     * @param {?} v3 Value checked for change.
     * @param {?} i3 Static value used for concatenation only.
     * @param {?} v4 Value checked for change.
     * @param {?} i4 Static value used for concatenation only.
     * @param {?} v5 Value checked for change.
     * @param {?} i5 Static value used for concatenation only.
     * @param {?} v6 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @param {?=} sanitizer An optional sanitizer function
     * @param {?=} namespace
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵattributeInterpolate7(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer, namespace) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);

      if (interpolatedValue !== NO_CHANGE) {
        elementAttributeInternal(index, attrName, interpolatedValue, lView, sanitizer, namespace);
      }

      return ɵɵattributeInterpolate7;
    }
    /**
     *
     * Update an interpolated attribute on an element with 8 bound values surrounded by text.
     *
     * Used when the value passed to a property has 8 interpolated values in it:
     *
     * ```html
     * <div attr.title="prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix"></div>
     * ```
     *
     * Its compiled representation is::
     *
     * ```ts
     * ɵɵattributeInterpolate8(
     *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');
     * ```
     *
     * \@codeGenApi
     * @param {?} attrName The name of the attribute to update
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} i1 Static value used for concatenation only.
     * @param {?} v2 Value checked for change.
     * @param {?} i2 Static value used for concatenation only.
     * @param {?} v3 Value checked for change.
     * @param {?} i3 Static value used for concatenation only.
     * @param {?} v4 Value checked for change.
     * @param {?} i4 Static value used for concatenation only.
     * @param {?} v5 Value checked for change.
     * @param {?} i5 Static value used for concatenation only.
     * @param {?} v6 Value checked for change.
     * @param {?} i6 Static value used for concatenation only.
     * @param {?} v7 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @param {?=} sanitizer An optional sanitizer function
     * @param {?=} namespace
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵattributeInterpolate8(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer, namespace) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);

      if (interpolatedValue !== NO_CHANGE) {
        elementAttributeInternal(index, attrName, interpolatedValue, lView, sanitizer, namespace);
      }

      return ɵɵattributeInterpolate8;
    }
    /**
     * Update an interpolated attribute on an element with 8 or more bound values surrounded by text.
     *
     * Used when the number of interpolated values exceeds 7.
     *
     * ```html
     * <div
     *  title="prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix"></div>
     * ```
     *
     * Its compiled representation is::
     *
     * ```ts
     * ɵɵattributeInterpolateV(
     *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,
     *  'suffix']);
     * ```
     *
     * \@codeGenApi
     * @param {?} attrName The name of the attribute to update.
     * @param {?} values The a collection of values and the strings in-between those values, beginning with
     * a string prefix and ending with a string suffix.
     * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)
     * @param {?=} sanitizer An optional sanitizer function
     * @param {?=} namespace
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵattributeInterpolateV(attrName, values, sanitizer, namespace) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const interpolated = interpolationV(lView, values);

      if (interpolated !== NO_CHANGE) {
        elementAttributeInternal(index, attrName, interpolated, lView, sanitizer, namespace);
      }

      return ɵɵattributeInterpolateV;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Synchronously perform change detection on a component (and possibly its sub-components).
     *
     * This function triggers change detection in a synchronous way on a component. There should
     * be very little reason to call this function directly since a preferred way to do change
     * detection is to {\@link markDirty} the component and wait for the scheduler to call this method
     * at some future point in time. This is because a single user action often results in many
     * components being invalidated and calling change detection on each component synchronously
     * would be inefficient. It is better to wait until all components are marked as dirty and
     * then perform single change detection across all of the components
     *
     * @template T
     * @param {?} component The component which the change detection should be performed on.
     * @return {?}
     */


    function detectChanges(component) {
      /** @type {?} */
      const view = getComponentViewByInstance(component);
      detectChangesInternal(view, component);
    }
    /**
     * Mark the component as dirty (needing change detection).
     *
     * Marking a component dirty will schedule a change detection on this
     * component at some point in the future. Marking an already dirty
     * component as dirty is a noop. Only one outstanding change detection
     * can be scheduled per component tree. (Two components bootstrapped with
     * separate `renderComponent` will have separate schedulers)
     *
     * When the root component is bootstrapped with `renderComponent`, a scheduler
     * can be provided.
     *
     * \@publicApi
     * @template T
     * @param {?} component Component to mark as dirty.
     *
     * @return {?}
     */


    function markDirty(component) {
      ngDevMode && assertDefined(component, 'component');
      /** @type {?} */

      const rootView =
      /** @type {?} */
      markViewDirty(getComponentViewByInstance(component));
      ngDevMode && assertDefined(rootView[CONTEXT], 'rootContext should be defined');
      scheduleTick(
      /** @type {?} */
      rootView[CONTEXT], 1
      /* DetectChanges */
      );
    }
    /**
     * Used to perform change detection on the whole application.
     *
     * This is equivalent to `detectChanges`, but invoked on root component. Additionally, `tick`
     * executes lifecycle hooks and conditionally checks components based on their
     * `ChangeDetectionStrategy` and dirtiness.
     *
     * The preferred way to trigger change detection is to call `markDirty`. `markDirty` internally
     * schedules `tick` using a scheduler in order to coalesce multiple `markDirty` calls into a
     * single change detection run. By default, the scheduler is `requestAnimationFrame`, but can
     * be changed when calling `renderComponent` and providing the `scheduler` option.
     * @template T
     * @param {?} component
     * @return {?}
     */


    function tick(component) {
      /** @type {?} */
      const rootView = getRootView(component);
      /** @type {?} */

      const rootContext =
      /** @type {?} */
      rootView[CONTEXT];
      tickRootContext(rootContext);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Creates an LContainer for inline views, e.g.
     *
     * % if (showing) {
     *   <div></div>
     * % }
     *
     * \@codeGenApi
     * @param {?} index The index of the container in the data array
     *
     * @return {?}
     */


    function ɵɵcontainer(index) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const tNode = containerInternal(lView, index, null, null);

      if (lView[TVIEW].firstTemplatePass) {
        tNode.tViews = [];
      }

      setIsNotParent();
    }
    /**
     * Creates an LContainer for an ng-template (dynamically-inserted view), e.g.
     *
     * <ng-template #foo>
     *    <div></div>
     * </ng-template>
     *
     * \@codeGenApi
     * @param {?} index The index of the container in the data array
     * @param {?} templateFn Inline template
     * @param {?} consts The number of nodes, local refs, and pipes for this template
     * @param {?} vars The number of bindings for this template
     * @param {?=} tagName The name of the container element, if applicable
     * @param {?=} attrs The attrs attached to the container, if applicable
     * @param {?=} localRefs A set of local reference bindings on the element.
     * @param {?=} localRefExtractor A function which extracts local-refs values from the template.
     *        Defaults to the current element associated with the local-ref.
     *
     * @return {?}
     */


    function ɵɵtemplate(index, templateFn, consts, vars, tagName, attrs, localRefs, localRefExtractor) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const tView = lView[TVIEW]; // TODO: consider a separate node type for templates

      /** @type {?} */

      const tContainerNode = containerInternal(lView, index, tagName || null, attrs || null);

      if (tView.firstTemplatePass) {
        ngDevMode && ngDevMode.firstTemplatePass++;
        resolveDirectives(tView, lView, tContainerNode, localRefs || null);
        /** @type {?} */

        const embeddedTView = tContainerNode.tViews = createTView(-1, templateFn, consts, vars, tView.directiveRegistry, tView.pipeRegistry, null, null);

        if (tView.queries !== null) {
          tView.queries.template(tView, tContainerNode);
          embeddedTView.queries = tView.queries.embeddedTView(tContainerNode);
        }
      }

      createDirectivesAndLocals(tView, lView, tContainerNode, localRefExtractor);
      attachPatchData(getNativeByTNode(tContainerNode, lView), lView);
      registerPostOrderHooks(tView, tContainerNode);
      setIsNotParent();
    }
    /**
     * Sets a container up to receive views.
     *
     * \@codeGenApi
     * @param {?} index The index of the container in the data array
     *
     * @return {?}
     */


    function ɵɵcontainerRefreshStart(index) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const tView = lView[TVIEW];
      /** @type {?} */

      let previousOrParentTNode =
      /** @type {?} */
      loadInternal(tView.data, index);
      ngDevMode && assertNodeType(previousOrParentTNode, 0
      /* Container */
      );
      setPreviousOrParentTNode(previousOrParentTNode, true);
      lView[index + HEADER_OFFSET][ACTIVE_INDEX] = 0; // We need to execute init hooks here so ngOnInit hooks are called in top level views
      // before they are called in embedded views (for backwards compatibility).

      executePreOrderHooks(lView, tView, getCheckNoChangesMode(), undefined);
    }
    /**
     * Marks the end of the LContainer.
     *
     * Marking the end of LContainer is the time when to child views get inserted or removed.
     *
     * \@codeGenApi
     * @return {?}
     */


    function ɵɵcontainerRefreshEnd() {
      /** @type {?} */
      let previousOrParentTNode = getPreviousOrParentTNode();

      if (getIsParent()) {
        setIsNotParent();
      } else {
        ngDevMode && assertNodeType(previousOrParentTNode, 2
        /* View */
        );
        ngDevMode && assertHasParent(previousOrParentTNode);
        previousOrParentTNode =
        /** @type {?} */
        previousOrParentTNode.parent;
        setPreviousOrParentTNode(previousOrParentTNode, false);
      }

      ngDevMode && assertNodeType(previousOrParentTNode, 0
      /* Container */
      );
      /** @type {?} */

      const lContainer = getLView()[previousOrParentTNode.index];
      /** @type {?} */

      const nextIndex = lContainer[ACTIVE_INDEX]; // remove extra views at the end of the container

      while (nextIndex < lContainer.length - CONTAINER_HEADER_OFFSET) {
        removeView(lContainer, nextIndex);
      }
    }
    /**
     * @param {?} lView
     * @param {?} nodeIndex
     * @param {?} tagName
     * @param {?} attrs
     * @return {?}
     */


    function containerInternal(lView, nodeIndex, tagName, attrs) {
      ngDevMode && assertEqual(lView[BINDING_INDEX], lView[TVIEW].bindingStartIndex, 'container nodes should be created before any bindings');
      /** @type {?} */

      const adjustedIndex = nodeIndex + HEADER_OFFSET;
      ngDevMode && assertDataInRange(lView, nodeIndex + HEADER_OFFSET);
      ngDevMode && ngDevMode.rendererCreateComment++;
      /** @type {?} */

      const comment = lView[adjustedIndex] = lView[RENDERER].createComment(ngDevMode ? 'container' : '');
      /** @type {?} */

      const tNode = getOrCreateTNode(lView[TVIEW], lView[T_HOST], nodeIndex, 0
      /* Container */
      , tagName, attrs);
      /** @type {?} */

      const lContainer = lView[adjustedIndex] = createLContainer(comment, lView, comment, tNode);
      appendChild(comment, tNode, lView); // Containers are added to the current view tree instead of their embedded views
      // because views can be removed and re-inserted.

      addToViewTree(lView, lContainer);
      ngDevMode && assertNodeType(getPreviousOrParentTNode(), 0
      /* Container */
      );
      return tNode;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Store a value in the `data` at a given `index`.
     * @template T
     * @param {?} index
     * @param {?} value
     * @return {?}
     */


    function store(index, value) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const tView = lView[TVIEW]; // We don't store any static data for local variables, so the first time
      // we see the template, we should store as null to avoid a sparse array

      /** @type {?} */

      const adjustedIndex = index + HEADER_OFFSET;

      if (adjustedIndex >= tView.data.length) {
        tView.data[adjustedIndex] = null;
        tView.blueprint[adjustedIndex] = null;
      }

      lView[adjustedIndex] = value;
    }
    /**
     * Retrieves a local reference from the current contextViewData.
     *
     * If the reference to retrieve is in a parent view, this instruction is used in conjunction
     * with a nextContext() call, which walks up the tree and updates the contextViewData instance.
     *
     * \@codeGenApi
     * @template T
     * @param {?} index The index of the local ref in contextViewData.
     *
     * @return {?}
     */


    function ɵɵreference(index) {
      /** @type {?} */
      const contextLView = getContextLView();
      return loadInternal(contextLView, index);
    }
    /**
     * Retrieves a value from current `viewData`.
     *
     * \@codeGenApi
     * @template T
     * @param {?} index
     * @return {?}
     */


    function ɵɵload(index) {
      return loadInternal(getLView(), index);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @template T
     * @param {?} token
     * @param {?=} flags
     * @return {?}
     */


    function ɵɵdirectiveInject(token, flags = InjectFlags.Default) {
      token = resolveForwardRef(token);
      /** @type {?} */

      const lView = getLView(); // Fall back to inject() if view hasn't been created. This situation can happen in tests
      // if inject utilities are used before bootstrapping.

      if (lView == null) return ɵɵinject(token, flags);
      return getOrCreateInjectable(
      /** @type {?} */
      getPreviousOrParentTNode(), lView, token, flags);
    }
    /**
     * Facade for the attribute injection from DI.
     *
     * \@codeGenApi
     * @param {?} attrNameToInject
     * @return {?}
     */


    function ɵɵinjectAttribute(attrNameToInject) {
      return injectAttributeImpl(getPreviousOrParentTNode(), attrNameToInject);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * --------
     *
     * This file contains the core logic for how styling instructions are processed in Angular.
     *
     * To learn more about the algorithm see `TStylingContext`.
     *
     * --------
     */

    /**
     * Temporary function to bridge styling functionality between this new
     * refactor (which is here inside of `styling_next/`) and the old
     * implementation (which lives inside of `styling/`).
     *
     * This function is executed during the creation block of an element.
     * Because the existing styling implementation issues a call to the
     * `styling()` instruction, this instruction will also get run. The
     * central idea here is that the directive index values are bound
     * into the context. The directive index is temporary and is only
     * required until the `select(n)` instruction is fully functional.
     *
     * \@codeGenApi
     * @return {?}
     */


    function ɵɵstyling() {
      /** @type {?} */
      const tView = getLView()[TVIEW];

      if (tView.firstTemplatePass) {
        updateLastDirectiveIndex$1(getPreviousOrParentTNode(), getActiveDirectiveStylingIndex());
      }
    }
    /**
     * Sets the current style sanitizer function which will then be used
     * within all follow-up prop and map-based style binding instructions
     * for the given element.
     *
     * Note that once styling has been applied to the element (i.e. once
     * `select(n)` is executed or the hostBindings/template function exits)
     * then the active `sanitizerFn` will be set to `null`. This means that
     * once styling is applied to another element then a another call to
     * `styleSanitizer` will need to be made.
     *
     * \@codeGenApi
     * @param {?} sanitizer
     * @return {?}
     */


    function ɵɵstyleSanitizer(sanitizer) {
      setCurrentStyleSanitizer(sanitizer);
    }
    /**
     * Update a style binding on an element with the provided value.
     *
     * If the style value is falsy then it will be removed from the element
     * (or assigned a different value depending if there are any styles placed
     * on the element with `styleMap` or any static styles that are
     * present from when the element was created with `styling`).
     *
     * Note that the styling element is updated as part of `stylingApply`.
     *
     * \@codeGenApi
     * @param {?} prop A valid CSS property.
     * @param {?} value New value to write (`null` or an empty string to remove).
     * @param {?=} suffix Optional suffix. Used with scalar values to add unit such as `px`.
     *        Note that when a suffix is provided then the underlying sanitizer will
     *        be ignored.
     *
     * Note that this will apply the provided style value to the host element if this function is called
     * within a host binding.
     *
     * @return {?}
     */


    function ɵɵstyleProp(prop, value, suffix) {
      stylePropInternal(getSelectedIndex(), prop, value, suffix);
    }
    /**
     * @param {?} elementIndex
     * @param {?} prop
     * @param {?} value
     * @param {?=} suffix
     * @return {?}
     */


    function stylePropInternal(elementIndex, prop, value, suffix) {
      /** @type {?} */
      const lView = getLView(); // if a value is interpolated then it may render a `NO_CHANGE` value.
      // in this case we do not need to do anything, but the binding index
      // still needs to be incremented because all styling binding values
      // are stored inside of the lView.

      /** @type {?} */

      const bindingIndex = lView[BINDING_INDEX]++;
      /** @type {?} */

      const updated = _stylingProp(elementIndex, bindingIndex, prop, resolveStylePropValue(value, suffix), false, deferStylingUpdate());

      if (ngDevMode) {
        ngDevMode.styleProp++;

        if (updated) {
          ngDevMode.stylePropCacheMiss++;
        }
      }
    }
    /**
     * Update a class binding on an element with the provided value.
     *
     * This instruction is meant to handle the `[class.foo]="exp"` case and,
     * therefore, the class binding itself must already be allocated using
     * `styling` within the creation block.
     *
     * \@codeGenApi
     * @param {?} className
     * @param {?} value A true/false value which will turn the class on or off.
     *
     * Note that this will apply the provided class value to the host element if this function
     * is called within a host binding.
     *
     * @return {?}
     */


    function ɵɵclassProp(className, value) {
      /** @type {?} */
      const lView = getLView(); // if a value is interpolated then it may render a `NO_CHANGE` value.
      // in this case we do not need to do anything, but the binding index
      // still needs to be incremented because all styling binding values
      // are stored inside of the lView.

      /** @type {?} */

      const bindingIndex = lView[BINDING_INDEX]++;
      /** @type {?} */

      const updated = _stylingProp(getSelectedIndex(), bindingIndex, className, value, true, deferStylingUpdate());

      if (ngDevMode) {
        ngDevMode.classProp++;

        if (updated) {
          ngDevMode.classPropCacheMiss++;
        }
      }
    }
    /**
     * Shared function used to update a prop-based styling binding for an element.
     * @param {?} elementIndex
     * @param {?} bindingIndex
     * @param {?} prop
     * @param {?} value
     * @param {?} isClassBased
     * @param {?} defer
     * @return {?}
     */


    function _stylingProp(elementIndex, bindingIndex, prop, value, isClassBased, defer) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const tNode = getTNode(elementIndex, lView);
      /** @type {?} */

      const native =
      /** @type {?} */
      getNativeByTNode(tNode, lView);
      /** @type {?} */

      let updated = false;

      if (value !== NO_CHANGE) {
        if (isClassBased) {
          updated = updateClassBinding(getClassesContext(tNode), lView, native, prop, bindingIndex,
          /** @type {?} */
          value, defer, false);
        } else {
          /** @type {?} */
          const sanitizer = getCurrentStyleSanitizer();
          updated = updateStyleBinding(getStylesContext(tNode), lView, native, prop, bindingIndex,
          /** @type {?} */
          value, sanitizer, defer, false);
        }
      }

      return updated;
    }
    /**
     * Update style bindings using an object literal on an element.
     *
     * This instruction is meant to apply styling via the `[style]="exp"` template bindings.
     * When styles are applied to the element they will then be updated with respect to
     * any styles/classes set via `styleProp`. If any styles are set to falsy
     * then they will be removed from the element.
     *
     * Note that the styling instruction will not be applied until `stylingApply` is called.
     *
     * \@codeGenApi
     * @param {?} styles A key/value style map of the styles that will be applied to the given element.
     *        Any missing styles (that have already been applied to the element beforehand) will be
     *        removed (unset) from the element's styling.
     *
     * Note that this will apply the provided styleMap value to the host element if this function
     * is called within a host binding.
     *
     * @return {?}
     */


    function ɵɵstyleMap(styles) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const tNode = getTNode(index, lView);
      /** @type {?} */

      const context = getStylesContext(tNode);
      /** @type {?} */

      const directiveIndex = getActiveDirectiveStylingIndex(); // if a value is interpolated then it may render a `NO_CHANGE` value.
      // in this case we do not need to do anything, but the binding index
      // still needs to be incremented because all styling binding values
      // are stored inside of the lView.

      /** @type {?} */

      const bindingIndex = lView[BINDING_INDEX]++; // inputs are only evaluated from a template binding into a directive, therefore,
      // there should not be a situation where a directive host bindings function
      // evaluates the inputs (this should only happen in the template function)

      if (!directiveIndex && hasStyleInput(tNode) && styles !== NO_CHANGE) {
        updateDirectiveInputValue(context, lView, tNode, bindingIndex, styles, false);
        styles = NO_CHANGE;
      }
      /** @type {?} */


      const updated = _stylingMap(index, context, bindingIndex, styles, false, deferStylingUpdate());

      if (ngDevMode) {
        ngDevMode.styleMap++;

        if (updated) {
          ngDevMode.styleMapCacheMiss++;
        }
      }
    }
    /**
     * Update class bindings using an object literal or class-string on an element.
     *
     * This instruction is meant to apply styling via the `[class]="exp"` template bindings.
     * When classes are applied to the element they will then be updated with
     * respect to any styles/classes set via `classProp`. If any
     * classes are set to falsy then they will be removed from the element.
     *
     * Note that the styling instruction will not be applied until `stylingApply` is called.
     * Note that this will the provided classMap value to the host element if this function is called
     * within a host binding.
     *
     * \@codeGenApi
     * @param {?} classes A key/value map or string of CSS classes that will be added to the
     *        given element. Any missing classes (that have already been applied to the element
     *        beforehand) will be removed (unset) from the element's list of CSS classes.
     *
     * @return {?}
     */


    function ɵɵclassMap(classes) {
      classMapInternal(getSelectedIndex(), classes);
    }
    /**
     * @param {?} elementIndex
     * @param {?} classes
     * @return {?}
     */


    function classMapInternal(elementIndex, classes) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const tNode = getTNode(elementIndex, lView);
      /** @type {?} */

      const context = getClassesContext(tNode);
      /** @type {?} */

      const directiveIndex = getActiveDirectiveStylingIndex(); // if a value is interpolated then it may render a `NO_CHANGE` value.
      // in this case we do not need to do anything, but the binding index
      // still needs to be incremented because all styling binding values
      // are stored inside of the lView.

      /** @type {?} */

      const bindingIndex = lView[BINDING_INDEX]++; // inputs are only evaluated from a template binding into a directive, therefore,
      // there should not be a situation where a directive host bindings function
      // evaluates the inputs (this should only happen in the template function)

      if (!directiveIndex && hasClassInput(tNode) && classes !== NO_CHANGE) {
        updateDirectiveInputValue(context, lView, tNode, bindingIndex, classes, true);
        classes = NO_CHANGE;
      }
      /** @type {?} */


      const updated = _stylingMap(elementIndex, context, bindingIndex, classes, true, deferStylingUpdate());

      if (ngDevMode) {
        ngDevMode.classMap++;

        if (updated) {
          ngDevMode.classMapCacheMiss++;
        }
      }
    }
    /**
     * Shared function used to update a map-based styling binding for an element.
     *
     * When this function is called it will activate support for `[style]` and
     * `[class]` bindings in Angular.
     * @param {?} elementIndex
     * @param {?} context
     * @param {?} bindingIndex
     * @param {?} value
     * @param {?} isClassBased
     * @param {?} defer
     * @return {?}
     */


    function _stylingMap(elementIndex, context, bindingIndex, value, isClassBased, defer) {
      activateStylingMapFeature();
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      let valueHasChanged = false;

      if (value !== NO_CHANGE) {
        /** @type {?} */
        const tNode = getTNode(elementIndex, lView);
        /** @type {?} */

        const native =
        /** @type {?} */
        getNativeByTNode(tNode, lView);
        /** @type {?} */

        const oldValue = lView[bindingIndex];
        valueHasChanged = hasValueChanged(oldValue, value);
        /** @type {?} */

        const stylingMapArr = normalizeIntoStylingMap(oldValue, value, !isClassBased);

        if (isClassBased) {
          updateClassBinding(context, lView, native, null, bindingIndex, stylingMapArr, defer, valueHasChanged);
        } else {
          /** @type {?} */
          const sanitizer = getCurrentStyleSanitizer();
          updateStyleBinding(context, lView, native, null, bindingIndex, stylingMapArr, sanitizer, defer, valueHasChanged);
        }
      }

      return valueHasChanged;
    }
    /**
     * Writes a value to a directive's `style` or `class` input binding (if it has changed).
     *
     * If a directive has a `\@Input` binding that is set on `style` or `class` then that value
     * will take priority over the underlying style/class styling bindings. This value will
     * be updated for the binding each time during change detection.
     *
     * When this occurs this function will attempt to write the value to the input binding
     * depending on the following situations:
     *
     * - If `oldValue !== newValue`
     * - If `newValue` is `null` (but this is skipped if it is during the first update pass--
     *    which is when the context is not locked yet)
     * @param {?} context
     * @param {?} lView
     * @param {?} tNode
     * @param {?} bindingIndex
     * @param {?} newValue
     * @param {?} isClassBased
     * @return {?}
     */


    function updateDirectiveInputValue(context, lView, tNode, bindingIndex, newValue, isClassBased) {
      /** @type {?} */
      const oldValue = lView[bindingIndex];

      if (oldValue !== newValue) {
        // even if the value has changed we may not want to emit it to the
        // directive input(s) in the event that it is falsy during the
        // first update pass.
        if (newValue || isContextLocked(context)) {
          /** @type {?} */
          const inputs =
          /** @type {?} */

          /** @type {?} */
          tNode.inputs[isClassBased ? 'class' : 'style'];
          /** @type {?} */

          const initialValue = getInitialStylingValue(context);
          /** @type {?} */

          const value = normalizeStylingDirectiveInputValue(initialValue, newValue, isClassBased);
          setInputsForProperty(lView, inputs, value);
        }

        lView[bindingIndex] = newValue;
      }
    }
    /**
     * Returns the appropriate directive input value for `style` or `class`.
     *
     * Earlier versions of Angular expect a binding value to be passed into directive code
     * exactly as it is unless there is a static value present (in which case both values
     * will be stringified and concatenated).
     * @param {?} initialValue
     * @param {?} bindingValue
     * @param {?} isClassBased
     * @return {?}
     */


    function normalizeStylingDirectiveInputValue(initialValue, bindingValue, isClassBased) {
      /** @type {?} */
      let value = bindingValue; // we only concat values if there is an initial value, otherwise we return the value as is.
      // Note that this is to satisfy backwards-compatibility in Angular.

      if (initialValue.length > 0) {
        if (isClassBased) {
          value = concatString(initialValue, forceClassesAsString(bindingValue));
        } else {
          value = concatString(initialValue, forceStylesAsString(
          /** @type {?} */
          bindingValue), ';');
        }
      }

      return value;
    }
    /**
     * Flushes all styling code to the element.
     *
     * This function is designed to be called from the template and hostBindings
     * functions and may be called multiple times depending whether multiple
     * sources of styling exist. If called multiple times, only the last call
     * to `stlyingApply()` will render styling to the element.
     *
     * \@codeGenApi
     * @return {?}
     */


    function ɵɵstylingApply() {
      /** @type {?} */
      const elementIndex = getSelectedIndex();
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const tNode = getTNode(elementIndex, lView);
      /** @type {?} */

      const renderer = getRenderer(tNode, lView);
      /** @type {?} */

      const native =
      /** @type {?} */
      getNativeByTNode(tNode, lView);
      /** @type {?} */

      const directiveIndex = getActiveDirectiveStylingIndex();
      /** @type {?} */

      const sanitizer = getCurrentStyleSanitizer();
      flushStyling(renderer, lView, getClassesContext(tNode), getStylesContext(tNode), native, directiveIndex, sanitizer);
      setCurrentStyleSanitizer(null);
    }
    /**
     * @param {?} tNode
     * @param {?} lView
     * @return {?}
     */


    function getRenderer(tNode, lView) {
      return tNode.type === 3
      /* Element */
      ? lView[RENDERER] : null;
    }
    /**
     * Searches and assigns provided all static style/class entries (found in the `attrs` value)
     * and registers them in their respective styling contexts.
     * @param {?} tNode
     * @param {?} attrs
     * @param {?} startIndex
     * @return {?}
     */


    function registerInitialStylingOnTNode(tNode, attrs, startIndex) {
      /** @type {?} */
      let hasAdditionalInitialStyling = false;
      /** @type {?} */

      let styles = getStylingMapArray(tNode.styles);
      /** @type {?} */

      let classes = getStylingMapArray(tNode.classes);
      /** @type {?} */

      let mode = -1;

      for (let i = startIndex; i < attrs.length; i++) {
        /** @type {?} */
        const attr =
        /** @type {?} */
        attrs[i];

        if (typeof attr == 'number') {
          mode = attr;
        } else if (mode == 1
        /* Classes */
        ) {
            classes = classes || [''];
            addItemToStylingMap(classes, attr, true);
            hasAdditionalInitialStyling = true;
          } else if (mode == 2
        /* Styles */
        ) {
            /** @type {?} */
            const value =
            /** @type {?} */
            attrs[++i];
            styles = styles || [''];
            addItemToStylingMap(styles, attr, value);
            hasAdditionalInitialStyling = true;
          }
      }

      if (classes && classes.length > 1
      /* ValuesStartPosition */
      ) {
          if (!tNode.classes) {
            tNode.classes = classes;
          }

          updateRawValueOnContext(tNode.classes, stylingMapToString(classes, true));
        }

      if (styles && styles.length > 1
      /* ValuesStartPosition */
      ) {
          if (!tNode.styles) {
            tNode.styles = styles;
          }

          updateRawValueOnContext(tNode.styles, stylingMapToString(styles, false));
        }

      return hasAdditionalInitialStyling;
    }
    /**
     * @param {?} context
     * @param {?} value
     * @return {?}
     */


    function updateRawValueOnContext(context, value) {
      /** @type {?} */
      const stylingMapArr =
      /** @type {?} */
      getStylingMapArray(context);
      stylingMapArr[0
      /* RawValuePosition */
      ] = value;
    }
    /**
     * @return {?}
     */


    function getActiveDirectiveStylingIndex() {
      // whenever a directive's hostBindings function is called a uniqueId value
      // is assigned. Normally this is enough to help distinguish one directive
      // from another for the styling context, but there are situations where a
      // sub-class directive could inherit and assign styling in concert with a
      // parent directive. To help the styling code distinguish between a parent
      // sub-classed directive the inheritance depth is taken into account as well.
      return getActiveDirectiveId() + getActiveDirectiveSuperClassDepth();
    }
    /**
     * Temporary function that will update the max directive index value in
     * both the classes and styles contexts present on the provided `tNode`.
     *
     * This code is only used because the `select(n)` code functionality is not
     * yet 100% functional. The `select(n)` instruction cannot yet evaluate host
     * bindings function code in sync with the associated template function code.
     * For this reason the styling algorithm needs to track the last directive index
     * value so that it knows exactly when to render styling to the element since
     * `stylingApply()` is called multiple times per CD (`stylingApply` will be
     * removed once `select(n)` is fixed).
     * @param {?} tNode
     * @param {?} directiveIndex
     * @return {?}
     */


    function updateLastDirectiveIndex$1(tNode, directiveIndex) {
      updateLastDirectiveIndex(getClassesContext(tNode), directiveIndex);
      updateLastDirectiveIndex(getStylesContext(tNode), directiveIndex);
    }
    /**
     * @param {?} tNode
     * @return {?}
     */


    function getStylesContext(tNode) {
      return getContext(tNode, false);
    }
    /**
     * @param {?} tNode
     * @return {?}
     */


    function getClassesContext(tNode) {
      return getContext(tNode, true);
    }
    /**
     * Returns/instantiates a styling context from/to a `tNode` instance.
     * @param {?} tNode
     * @param {?} isClassBased
     * @return {?}
     */


    function getContext(tNode, isClassBased) {
      /** @type {?} */
      let context = isClassBased ? tNode.classes : tNode.styles;

      if (!isStylingContext(context)) {
        context = allocTStylingContext(context);

        if (ngDevMode) {
          attachStylingDebugObject(
          /** @type {?} */
          context);
        }

        if (isClassBased) {
          tNode.classes = context;
        } else {
          tNode.styles = context;
        }
      }

      return (
        /** @type {?} */
        context
      );
    }
    /**
     * @param {?} value
     * @param {?} suffix
     * @return {?}
     */


    function resolveStylePropValue(value, suffix) {
      if (value === NO_CHANGE) return value;
      /** @type {?} */

      let resolvedValue = null;

      if (value !== null) {
        if (suffix) {
          // when a suffix is applied then it will bypass
          // sanitization entirely (b/c a new string is created)
          resolvedValue = renderStringify(value) + suffix;
        } else {
          // sanitization happens by dealing with a String value
          // this means that the string value will be passed through
          // into the style rendering later (which is where the value
          // will be sanitized before it is applied)
          resolvedValue =
          /** @type {?} */

          /** @type {?} */
          value;
        }
      }

      return resolvedValue;
    }
    /**
     * Whether or not a style/class binding update should be applied later.
     *
     * This function will decide whether a binding should be applied immediately
     * or later (just before the styles/classes are flushed to the element). The
     * reason why this feature exists is because of super/sub directive inheritance.
     * Angular will evaluate host bindings on the super directive first and the sub
     * directive, but the styling bindings on the sub directive are of higher priority
     * than the super directive. For this reason all styling bindings that take place
     * in this circumstance will need to be deferred until later so that they can be
     * applied together and in a different order (the algorithm handles that part).
     * @return {?}
     */


    function deferStylingUpdate() {
      return getActiveDirectiveSuperClassHeight() > 0;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Create DOM element. The instruction must later be followed by `elementEnd()` call.
     *
     * \@codeGenApi
     * @param {?} index Index of the element in the LView array
     * @param {?} name Name of the DOM Node
     * @param {?=} attrs Statically bound set of attributes, classes, and styles to be written into the DOM
     *              element on creation. Use [AttributeMarker] to denote the meaning of this array.
     * @param {?=} localRefs A set of local reference bindings on the element.
     *
     * Attributes and localRefs are passed as an array of strings where elements with an even index
     * hold an attribute name and elements with an odd index hold an attribute value, ex.:
     * ['id', 'warning5', 'class', 'alert']
     *
     * @return {?}
     */


    function ɵɵelementStart(index, name, attrs, localRefs) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const tView = lView[TVIEW];
      ngDevMode && assertEqual(lView[BINDING_INDEX], tView.bindingStartIndex, 'elements should be created before any bindings ');
      ngDevMode && ngDevMode.rendererCreateElement++;
      ngDevMode && assertDataInRange(lView, index + HEADER_OFFSET);
      /** @type {?} */

      const native = lView[index + HEADER_OFFSET] = elementCreate(name);
      /** @type {?} */

      const renderer = lView[RENDERER];
      /** @type {?} */

      const tNode = getOrCreateTNode(tView, lView[T_HOST], index, 3
      /* Element */
      , name, attrs || null);

      if (attrs != null) {
        /** @type {?} */
        const lastAttrIndex = setUpAttributes(native, attrs);

        if (tView.firstTemplatePass) {
          registerInitialStylingOnTNode(tNode, attrs, lastAttrIndex);
        }
      }

      renderInitialStyling(renderer, native, tNode);
      appendChild(native, tNode, lView); // any immediate children of a component or template container must be pre-emptively
      // monkey-patched with the component view data so that the element can be inspected
      // later on using any element discovery utility methods (see `element_discovery.ts`)

      if (getElementDepthCount() === 0) {
        attachPatchData(native, lView);
      }

      increaseElementDepthCount(); // if a directive contains a host binding for "class" then all class-based data will
      // flow through that (except for `[class.prop]` bindings). This also includes initial
      // static class values as well. (Note that this will be fixed once map-based `[style]`
      // and `[class]` bindings work for multiple directives.)

      if (tView.firstTemplatePass) {
        ngDevMode && ngDevMode.firstTemplatePass++;
        resolveDirectives(tView, lView, tNode, localRefs || null);
        /** @type {?} */

        const inputData = initializeTNodeInputs(tNode);

        if (inputData && inputData.hasOwnProperty('class')) {
          tNode.flags |= 8
          /* hasClassInput */
          ;
        }

        if (inputData && inputData.hasOwnProperty('style')) {
          tNode.flags |= 16
          /* hasStyleInput */
          ;
        }

        if (tView.queries !== null) {
          tView.queries.elementStart(tView, tNode);
        }
      }

      createDirectivesAndLocals(tView, lView, tNode);
      executeContentQueries(tView, tNode, lView);
    }
    /**
     * Mark the end of the element.
     *
     * \@codeGenApi
     * @return {?}
     */


    function ɵɵelementEnd() {
      /** @type {?} */
      let previousOrParentTNode = getPreviousOrParentTNode();
      ngDevMode && assertDefined(previousOrParentTNode, 'No parent node to close.');

      if (getIsParent()) {
        setIsNotParent();
      } else {
        ngDevMode && assertHasParent(getPreviousOrParentTNode());
        previousOrParentTNode =
        /** @type {?} */
        previousOrParentTNode.parent;
        setPreviousOrParentTNode(previousOrParentTNode, false);
      }
      /** @type {?} */


      const tNode = previousOrParentTNode;
      ngDevMode && assertNodeType(tNode, 3
      /* Element */
      );
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const tView = lView[TVIEW];
      registerPostOrderHooks(tView, previousOrParentTNode);
      decreaseElementDepthCount();

      if (tView.firstTemplatePass && tView.queries !== null && isContentQueryHost(previousOrParentTNode)) {
        /** @type {?} */
        tView.queries.elementEnd(previousOrParentTNode);
      }

      if (hasClassInput(tNode) && tNode.classes) {
        setDirectiveStylingInput(tNode.classes, lView,
        /** @type {?} */
        tNode.inputs['class']);
      }

      if (hasStyleInput(tNode) && tNode.styles) {
        setDirectiveStylingInput(tNode.styles, lView,
        /** @type {?} */
        tNode.inputs['style']);
      }
    }
    /**
     * Creates an empty element using {\@link elementStart} and {\@link elementEnd}
     *
     * \@codeGenApi
     * @param {?} index Index of the element in the data array
     * @param {?} name Name of the DOM Node
     * @param {?=} attrs Statically bound set of attributes, classes, and styles to be written into the DOM
     *              element on creation. Use [AttributeMarker] to denote the meaning of this array.
     * @param {?=} localRefs A set of local reference bindings on the element.
     *
     * @return {?}
     */


    function ɵɵelement(index, name, attrs, localRefs) {
      ɵɵelementStart(index, name, attrs, localRefs);
      ɵɵelementEnd();
    }
    /**
     * Assign static attribute values to a host element.
     *
     * This instruction will assign static attribute values as well as class and style
     * values to an element within the host bindings function. Since attribute values
     * can consist of different types of values, the `attrs` array must include the values in
     * the following format:
     *
     * attrs = [
     *   // static attributes (like `title`, `name`, `id`...)
     *   attr1, value1, attr2, value,
     *
     *   // a single namespace value (like `x:id`)
     *   NAMESPACE_MARKER, namespaceUri1, name1, value1,
     *
     *   // another single namespace value (like `x:name`)
     *   NAMESPACE_MARKER, namespaceUri2, name2, value2,
     *
     *   // a series of CSS classes that will be applied to the element (no spaces)
     *   CLASSES_MARKER, class1, class2, class3,
     *
     *   // a series of CSS styles (property + value) that will be applied to the element
     *   STYLES_MARKER, prop1, value1, prop2, value2
     * ]
     *
     * All non-class and non-style attributes must be defined at the start of the list
     * first before all class and style values are set. When there is a change in value
     * type (like when classes and styles are introduced) a marker must be used to separate
     * the entries. The marker values themselves are set via entries found in the
     * [AttributeMarker] enum.
     *
     * NOTE: This instruction is meant to used from `hostBindings` function only.
     *
     * \@codeGenApi
     * @param {?} attrs An array of static values (attributes, classes and styles) with the correct marker
     * values.
     *
     * @return {?}
     */


    function ɵɵelementHostAttrs(attrs) {
      /** @type {?} */
      const hostElementIndex = getSelectedIndex();
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const tView = lView[TVIEW];
      /** @type {?} */

      const tNode = getTNode(hostElementIndex, lView); // non-element nodes (e.g. `<ng-container>`) are not rendered as actual
      // element nodes and adding styles/classes on to them will cause runtime
      // errors...

      if (tNode.type === 3
      /* Element */
      ) {
          /** @type {?} */
          const native =
          /** @type {?} */
          getNativeByTNode(tNode, lView);
          /** @type {?} */

          const lastAttrIndex = setUpAttributes(native, attrs);

          if (tView.firstTemplatePass) {
            /** @type {?} */
            const stylingNeedsToBeRendered = registerInitialStylingOnTNode(tNode, attrs, lastAttrIndex); // this is only called during the first template pass in the
            // event that this current directive assigned initial style/class
            // host attribute values to the element. Because initial styling
            // values are applied before directives are first rendered (within
            // `createElement`) this means that initial styling for any directives
            // still needs to be applied. Note that this will only happen during
            // the first template pass and not each time a directive applies its
            // attribute values to the element.

            if (stylingNeedsToBeRendered) {
              /** @type {?} */
              const renderer = lView[RENDERER];
              renderInitialStyling(renderer, native, tNode);
            }
          }
        }
    }
    /**
     * @param {?} context
     * @param {?} lView
     * @param {?} stylingInputs
     * @return {?}
     */


    function setDirectiveStylingInput(context, lView, stylingInputs) {
      // older versions of Angular treat the input as `null` in the
      // event that the value does not exist at all. For this reason
      // we can't have a styling value be an empty string.

      /** @type {?} */
      const value = getInitialStylingValue(context) || null; // Ivy does an extra `[class]` write with a falsy value since the value
      // is applied during creation mode. This is a deviation from VE and should
      // be (Jira Issue = FW-1467).

      setInputsForProperty(lView, stylingInputs, value);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Creates a logical container for other nodes (<ng-container>) backed by a comment node in the DOM.
     * The instruction must later be followed by `elementContainerEnd()` call.
     *
     * \@codeGenApi
     * @param {?} index Index of the element in the LView array
     * @param {?=} attrs Set of attributes to be used when matching directives.
     * @param {?=} localRefs A set of local reference bindings on the element.
     *
     * Even if this instruction accepts a set of attributes no actual attribute values are propagated to
     * the DOM (as a comment node can't have attributes). Attributes are here only for directive
     * matching purposes and setting initial inputs of directives.
     *
     * @return {?}
     */


    function ɵɵelementContainerStart(index, attrs, localRefs) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const tView = lView[TVIEW];
      /** @type {?} */

      const renderer = lView[RENDERER];
      /** @type {?} */

      const tagName = 'ng-container';
      ngDevMode && assertEqual(lView[BINDING_INDEX], tView.bindingStartIndex, 'element containers should be created before any bindings');
      ngDevMode && ngDevMode.rendererCreateComment++;
      ngDevMode && assertDataInRange(lView, index + HEADER_OFFSET);
      /** @type {?} */

      const native = lView[index + HEADER_OFFSET] = renderer.createComment(ngDevMode ? tagName : '');
      ngDevMode && assertDataInRange(lView, index - 1);
      /** @type {?} */

      const tNode = getOrCreateTNode(tView, lView[T_HOST], index, 4
      /* ElementContainer */
      , tagName, attrs || null);

      if (attrs && tView.firstTemplatePass) {
        // While ng-container doesn't necessarily support styling, we use the style context to identify
        // and execute directives on the ng-container.
        registerInitialStylingOnTNode(tNode,
        /** @type {?} */
        attrs, 0);
      }

      appendChild(native, tNode, lView);

      if (tView.firstTemplatePass) {
        ngDevMode && ngDevMode.firstTemplatePass++;
        resolveDirectives(tView, lView, tNode, localRefs || null);

        if (tView.queries) {
          tView.queries.elementStart(tView, tNode);
        }
      }

      createDirectivesAndLocals(tView, lView, tNode);
      attachPatchData(native, lView);
      executeContentQueries(tView, tNode, lView);
    }
    /**
     * Mark the end of the <ng-container>.
     *
     * \@codeGenApi
     * @return {?}
     */


    function ɵɵelementContainerEnd() {
      /** @type {?} */
      let previousOrParentTNode = getPreviousOrParentTNode();
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const tView = lView[TVIEW];

      if (getIsParent()) {
        setIsNotParent();
      } else {
        ngDevMode && assertHasParent(previousOrParentTNode);
        previousOrParentTNode =
        /** @type {?} */
        previousOrParentTNode.parent;
        setPreviousOrParentTNode(previousOrParentTNode, false);
      }

      ngDevMode && assertNodeType(previousOrParentTNode, 4
      /* ElementContainer */
      );
      registerPostOrderHooks(tView, previousOrParentTNode);

      if (tView.firstTemplatePass && tView.queries !== null && isContentQueryHost(previousOrParentTNode)) {
        tView.queries.elementEnd(previousOrParentTNode);
      }
    }
    /**
     * Creates an empty logical container using {\@link elementContainerStart}
     * and {\@link elementContainerEnd}
     *
     * \@codeGenApi
     * @param {?} index Index of the element in the LView array
     * @param {?=} attrs Set of attributes to be used when matching directives.
     * @param {?=} localRefs A set of local reference bindings on the element.
     *
     * @return {?}
     */


    function ɵɵelementContainer(index, attrs, localRefs) {
      ɵɵelementContainerStart(index, attrs, localRefs);
      ɵɵelementContainerEnd();
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Marks the start of an embedded view.
     *
     * \@codeGenApi
     * @param {?} viewBlockId The ID of this view
     * @param {?} consts
     * @param {?} vars
     * @return {?} boolean Whether or not this view is in creation mode
     *
     */


    function ɵɵembeddedViewStart(viewBlockId, consts, vars) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const previousOrParentTNode = getPreviousOrParentTNode(); // The previous node can be a view node if we are processing an inline for loop

      /** @type {?} */

      const containerTNode = previousOrParentTNode.type === 2
      /* View */
      ?
      /** @type {?} */
      previousOrParentTNode.parent : previousOrParentTNode;
      /** @type {?} */

      const lContainer =
      /** @type {?} */
      lView[containerTNode.index];
      ngDevMode && assertNodeType(containerTNode, 0
      /* Container */
      );
      /** @type {?} */

      let viewToRender = scanForView(lContainer,
      /** @type {?} */
      lContainer[ACTIVE_INDEX], viewBlockId);

      if (viewToRender) {
        setIsParent();
        enterView(viewToRender, viewToRender[TVIEW].node);
      } else {
        // When we create a new LView, we always reset the state of the instructions.
        viewToRender = createLView(lView, getOrCreateEmbeddedTView(viewBlockId, consts, vars,
        /** @type {?} */
        containerTNode), null, 16
        /* CheckAlways */
        , null, null);
        /** @type {?} */

        const tParentNode = getIsParent() ? previousOrParentTNode : previousOrParentTNode && previousOrParentTNode.parent;
        assignTViewNodeToLView(viewToRender[TVIEW], tParentNode, viewBlockId, viewToRender);
        enterView(viewToRender, viewToRender[TVIEW].node);
      }

      if (lContainer) {
        if (isCreationMode(viewToRender)) {
          // it is a new view, insert it into collection of views for a given container
          insertView(viewToRender, lContainer,
          /** @type {?} */
          lContainer[ACTIVE_INDEX]);
        }

        /** @type {?} */lContainer[ACTIVE_INDEX]++;
      }

      return isCreationMode(viewToRender) ? 1
      /* Create */
      | 2
      /* Update */
      : 2
      /* Update */
      ;
    }
    /**
     * Initialize the TView (e.g. static data) for the active embedded view.
     *
     * Each embedded view block must create or retrieve its own TView. Otherwise, the embedded view's
     * static data for a particular node would overwrite the static data for a node in the view above
     * it with the same index (since it's in the same template).
     *
     * @param {?} viewIndex The index of the TView in TNode.tViews
     * @param {?} consts The number of nodes, local refs, and pipes in this template
     * @param {?} vars The number of bindings and pure function bindings in this template
     * @param {?} parent
     * @return {?} TView
     */


    function getOrCreateEmbeddedTView(viewIndex, consts, vars, parent) {
      /** @type {?} */
      const tView = getLView()[TVIEW];
      ngDevMode && assertNodeType(parent, 0
      /* Container */
      );
      /** @type {?} */

      const containerTViews =
      /** @type {?} */
      parent.tViews;
      ngDevMode && assertDefined(containerTViews, 'TView expected');
      ngDevMode && assertEqual(Array.isArray(containerTViews), true, 'TViews should be in an array');

      if (viewIndex >= containerTViews.length || containerTViews[viewIndex] == null) {
        containerTViews[viewIndex] = createTView(viewIndex, null, consts, vars, tView.directiveRegistry, tView.pipeRegistry, null, null);
      }

      return containerTViews[viewIndex];
    }
    /**
     * Looks for a view with a given view block id inside a provided LContainer.
     * Removes views that need to be deleted in the process.
     *
     * @param {?} lContainer to search for views
     * @param {?} startIdx starting index in the views array to search from
     * @param {?} viewBlockId exact view block id to look for
     * @return {?}
     */


    function scanForView(lContainer, startIdx, viewBlockId) {
      for (let i = startIdx + CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
        /** @type {?} */
        const viewAtPositionId = lContainer[i][TVIEW].id;

        if (viewAtPositionId === viewBlockId) {
          return lContainer[i];
        } else if (viewAtPositionId < viewBlockId) {
          // found a view that should not be at this position - remove
          removeView(lContainer, i - CONTAINER_HEADER_OFFSET);
        } else {
          // found a view with id greater than the one we are searching for
          // which means that required view doesn't exist and can't be found at
          // later positions in the views array - stop the searchdef.cont here
          break;
        }
      }

      return null;
    }
    /**
     * Marks the end of an embedded view.
     *
     * \@codeGenApi
     * @return {?}
     */


    function ɵɵembeddedViewEnd() {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const viewHost = lView[T_HOST];

      if (isCreationMode(lView)) {
        refreshDescendantViews(lView); // creation mode pass

        lView[FLAGS] &= ~4
        /* CreationMode */
        ;
      }

      resetPreOrderHookFlags(lView);
      refreshDescendantViews(lView); // update mode pass
      // update mode pass

      /** @type {?} */

      const lContainer =
      /** @type {?} */
      lView[PARENT];
      ngDevMode && assertLContainerOrUndefined(lContainer); // It's always safe to run hooks here, as `leaveView` is not called during the 'finally' block
      // of a try-catch-finally statement, so it can never be reached while unwinding the stack due to
      // an error being thrown.

      leaveView(
      /** @type {?} */
      lContainer[PARENT],
      /* safeToRunHooks */
      true);
      setPreviousOrParentTNode(
      /** @type {?} */
      viewHost, false);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Returns the current OpaqueViewState instance.
     *
     * Used in conjunction with the restoreView() instruction to save a snapshot
     * of the current view and restore it when listeners are invoked. This allows
     * walking the declaration view tree in listeners to get vars from parent views.
     *
     * \@codeGenApi
     * @return {?}
     */


    function ɵɵgetCurrentView() {
      return (
        /** @type {?} */

        /** @type {?} */
        getLView()
      );
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Determine if the argument is shaped like a Promise
     */


    function isPromise(obj) {
      // allow any Promise/A+ compliant thenable.
      // It's up to the caller to ensure that obj.then conforms to the spec
      return !!obj && typeof obj.then === 'function';
    }
    /**
     * Determine if the argument is an Observable
     */


    function isObservable(obj) {
      // TODO: use isObservable once we update pass rxjs 6.1
      // https://github.com/ReactiveX/rxjs/blob/master/CHANGELOG.md#610-2018-05-03
      return !!obj && typeof obj.subscribe === 'function';
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Adds an event listener to the current node.
     *
     * If an output exists on one of the node's directives, it also subscribes to the output
     * and saves the subscription for later cleanup.
     *
     * \@codeGenApi
     * @param {?} eventName Name of the event
     * @param {?} listenerFn The function to be called when event emits
     * @param {?=} useCapture Whether or not to use capture in event listener
     * @param {?=} eventTargetResolver Function that returns global target information in case this listener
     * should be attached to a global object like window, document or body
     *
     * @return {?}
     */


    function ɵɵlistener(eventName, listenerFn, useCapture = false, eventTargetResolver) {
      listenerInternal(eventName, listenerFn, useCapture, eventTargetResolver);
    }
    /**
     * Registers a synthetic host listener (e.g. `(\@foo.start)`) on a component.
     *
     * This instruction is for compatibility purposes and is designed to ensure that a
     * synthetic host listener (e.g. `\@HostListener('\@foo.start')`) properly gets rendered
     * in the component's renderer. Normally all host listeners are evaluated with the
     * parent component's renderer, but, in the case of animation \@triggers, they need
     * to be evaluated with the sub component's renderer (because that's where the
     * animation triggers are defined).
     *
     * Do not use this instruction as a replacement for `listener`. This instruction
     * only exists to ensure compatibility with the ViewEngine's host binding behavior.
     *
     * \@codeGenApi
     * @param {?} eventName Name of the event
     * @param {?} listenerFn The function to be called when event emits
     * @param {?=} useCapture Whether or not to use capture in event listener
     * @param {?=} eventTargetResolver Function that returns global target information in case this listener
     * should be attached to a global object like window, document or body
     *
     * @return {?}
     */


    function ɵɵcomponentHostSyntheticListener(eventName, listenerFn, useCapture = false, eventTargetResolver) {
      listenerInternal(eventName, listenerFn, useCapture, eventTargetResolver, loadComponentRenderer);
    }
    /**
     * A utility function that checks if a given element has already an event handler registered for an
     * event with a specified name. The TView.cleanup data structure is used to find out which events
     * are registered for a given element.
     * @param {?} lView
     * @param {?} eventName
     * @param {?} tNodeIdx
     * @return {?}
     */


    function findExistingListener(lView, eventName, tNodeIdx) {
      /** @type {?} */
      const tView = lView[TVIEW];
      /** @type {?} */

      const tCleanup = tView.cleanup;

      if (tCleanup != null) {
        for (let i = 0; i < tCleanup.length - 1; i += 2) {
          /** @type {?} */
          const cleanupEventName = tCleanup[i];

          if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIdx) {
            // We have found a matching event name on the same node but it might not have been
            // registered yet, so we must explicitly verify entries in the LView cleanup data
            // structures.

            /** @type {?} */
            const lCleanup =
            /** @type {?} */
            lView[CLEANUP];
            /** @type {?} */

            const listenerIdxInLCleanup = tCleanup[i + 2];
            return lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;
          } // TView.cleanup can have a mix of 4-elements entries (for event handler cleanups) or
          // 2-element entries (for directive and queries destroy hooks). As such we can encounter
          // blocks of 4 or 2 items in the tView.cleanup and this is why we iterate over 2 elements
          // first and jump another 2 elements if we detect listeners cleanup (4 elements). Also check
          // documentation of TView.cleanup for more details of this data structure layout.


          if (typeof cleanupEventName === 'string') {
            i += 2;
          }
        }
      }

      return null;
    }
    /**
     * @param {?} eventName
     * @param {?} listenerFn
     * @param {?=} useCapture
     * @param {?=} eventTargetResolver
     * @param {?=} loadRendererFn
     * @return {?}
     */


    function listenerInternal(eventName, listenerFn, useCapture = false, eventTargetResolver, loadRendererFn) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const tNode = getPreviousOrParentTNode();
      /** @type {?} */

      const tView = lView[TVIEW];
      /** @type {?} */

      const firstTemplatePass = tView.firstTemplatePass;
      /** @type {?} */

      const tCleanup = firstTemplatePass && (tView.cleanup || (tView.cleanup = []));
      ngDevMode && assertNodeOfPossibleTypes(tNode, 3
      /* Element */
      , 0
      /* Container */
      , 4
      /* ElementContainer */
      );
      /** @type {?} */

      let processOutputs = true; // add native event listener - applicable to elements only

      if (tNode.type === 3
      /* Element */
      ) {
          /** @type {?} */
          const native =
          /** @type {?} */
          getNativeByTNode(tNode, lView);
          /** @type {?} */

          const resolved = eventTargetResolver ? eventTargetResolver(native) :
          /** @type {?} */
          EMPTY_OBJ;
          /** @type {?} */

          const target = resolved.target || native;
          /** @type {?} */

          const renderer = loadRendererFn ? loadRendererFn(tNode, lView) : lView[RENDERER];
          /** @type {?} */

          const lCleanup = getCleanup(lView);
          /** @type {?} */

          const lCleanupIndex = lCleanup.length;
          /** @type {?} */

          const idxOrTargetGetter = eventTargetResolver ?
          /**
          * @param {?} _lView
          * @return {?}
          */
          _lView => eventTargetResolver(unwrapRNode(_lView[tNode.index])).target : tNode.index; // In order to match current behavior, native DOM event listeners must be added for all
          // events (including outputs).

          if (isProceduralRenderer(renderer)) {
            // There might be cases where multiple directives on the same element try to register an event
            // handler function for the same event. In this situation we want to avoid registration of
            // several native listeners as each registration would be intercepted by NgZone and
            // trigger change detection. This would mean that a single user action would result in several
            // change detections being invoked. To avoid this situation we want to have only one call to
            // native handler registration (for the same element and same type of event).
            //
            // In order to have just one native event handler in presence of multiple handler functions,
            // we just register a first handler function as a native event listener and then chain
            // (coalesce) other handler functions on top of the first native handler function.

            /** @type {?} */
            let existingListener = null; // Please note that the coalescing described here doesn't happen for events specifying an
            // alternative target (ex. (document:click)) - this is to keep backward compatibility with the
            // view engine.
            // Also, we don't have to search for existing listeners is there are no directives
            // matching on a given node as we can't register multiple event handlers for the same event in
            // a template (this would mean having duplicate attributes).

            if (!eventTargetResolver && hasDirectives(tNode)) {
              existingListener = findExistingListener(lView, eventName, tNode.index);
            }

            if (existingListener !== null) {
              // Attach a new listener at the head of the coalesced listeners list.

              /** @type {?} */
              listenerFn.__ngNextListenerFn__ =
              /** @type {?} */
              existingListener.__ngNextListenerFn__;

              /** @type {?} */
              existingListener.__ngNextListenerFn__ = listenerFn;
              processOutputs = false;
            } else {
              // The first argument of `listen` function in Procedural Renderer is:
              // - either a target name (as a string) in case of global target (window, document, body)
              // - or element reference (in all other cases)
              listenerFn = wrapListener(tNode, lView, listenerFn, false
              /** preventDefault */
              );
              /** @type {?} */

              const cleanupFn = renderer.listen(resolved.name || target, eventName, listenerFn);
              ngDevMode && ngDevMode.rendererAddEventListener++;
              lCleanup.push(listenerFn, cleanupFn);
              tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, lCleanupIndex + 1);
            }
          } else {
            listenerFn = wrapListener(tNode, lView, listenerFn, true
            /** preventDefault */
            );
            target.addEventListener(eventName, listenerFn, useCapture);
            ngDevMode && ngDevMode.rendererAddEventListener++;
            lCleanup.push(listenerFn);
            tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, useCapture);
          }
        } // subscribe to directive outputs


      if (tNode.outputs === undefined) {
        // if we create TNode here, inputs must be undefined so we know they still need to be
        // checked
        tNode.outputs = generatePropertyAliases(tNode, 1
        /* Output */
        );
      }
      /** @type {?} */


      const outputs = tNode.outputs;
      /** @type {?} */

      let props;

      if (processOutputs && outputs && (props = outputs[eventName])) {
        /** @type {?} */
        const propsLength = props.length;

        if (propsLength) {
          /** @type {?} */
          const lCleanup = getCleanup(lView);

          for (let i = 0; i < propsLength; i += 3) {
            /** @type {?} */
            const index =
            /** @type {?} */
            props[i];
            ngDevMode && assertDataInRange(lView, index);
            /** @type {?} */

            const minifiedName = props[i + 2];
            /** @type {?} */

            const directiveInstance = lView[index];
            /** @type {?} */

            const output = directiveInstance[minifiedName];

            if (ngDevMode && !isObservable(output)) {
              throw new Error("@Output ".concat(minifiedName, " not initialized in '").concat(directiveInstance.constructor.name, "'."));
            }
            /** @type {?} */


            const subscription = output.subscribe(listenerFn);
            /** @type {?} */

            const idx = lCleanup.length;
            lCleanup.push(listenerFn, subscription);
            tCleanup && tCleanup.push(eventName, tNode.index, idx, -(idx + 1));
          }
        }
      }
    }
    /**
     * @param {?} lView
     * @param {?} listenerFn
     * @param {?} e
     * @return {?}
     */


    function executeListenerWithErrorHandling(lView, listenerFn, e) {
      try {
        // Only explicitly returning false from a listener should preventDefault
        return listenerFn(e) !== false;
      } catch (error) {
        handleError(lView, error);
        return false;
      }
    }
    /**
     * Wraps an event listener with a function that marks ancestors dirty and prevents default behavior,
     * if applicable.
     *
     * @param {?} tNode The TNode associated with this listener
     * @param {?} lView The LView that contains this listener
     * @param {?} listenerFn The listener function to call
     * @param {?} wrapWithPreventDefault Whether or not to prevent default behavior
     * (the procedural renderer does this already, so in those cases, we should skip)
     * @return {?}
     */


    function wrapListener(tNode, lView, listenerFn, wrapWithPreventDefault) {
      // Note: we are performing most of the work in the listener function itself
      // to optimize listener registration.
      return (
        /**
        * @param {?} e
        * @return {?}
        */
        function wrapListenerIn_markDirtyAndPreventDefault(e) {
          // In order to be backwards compatible with View Engine, events on component host nodes
          // must also mark the component view itself dirty (i.e. the view that it owns).

          /** @type {?} */
          const startView = tNode.flags & 1
          /* isComponent */
          ? getComponentViewByIndex(tNode.index, lView) : lView; // See interfaces/view.ts for more on LViewFlags.ManualOnPush

          if ((lView[FLAGS] & 32
          /* ManualOnPush */
          ) === 0) {
            markViewDirty(startView);
          }
          /** @type {?} */


          let result = executeListenerWithErrorHandling(lView, listenerFn, e); // A just-invoked listener function might have coalesced listeners so we need to check for
          // their presence and invoke as needed.

          /** @type {?} */

          let nextListenerFn =
          /** @type {?} */
          wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;

          while (nextListenerFn) {
            // We should prevent default if any of the listeners explicitly return false
            result = executeListenerWithErrorHandling(lView, nextListenerFn, e) && result;
            nextListenerFn =
            /** @type {?} */
            nextListenerFn.__ngNextListenerFn__;
          }

          if (wrapWithPreventDefault && result === false) {
            e.preventDefault(); // Necessary for legacy browsers that don't support preventDefault (e.g. IE)

            e.returnValue = false;
          }

          return result;
        }
      );
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Retrieves a context at the level specified and saves it as the global, contextViewData.
     * Will get the next level up if level is not specified.
     *
     * This is used to save contexts of parent views so they can be bound in embedded views, or
     * in conjunction with reference() to bind a ref from a parent view.
     *
     * \@codeGenApi
     * @template T
     * @param {?=} level The relative level of the view from which to grab context compared to contextVewData
     * @return {?} context
     *
     */


    function ɵɵnextContext(level = 1) {
      return nextContextImpl(level);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Checks a given node against matching projection slots and returns the
     * determined slot index. Returns "null" if no slot matched the given node.
     *
     * This function takes into account the parsed ngProjectAs selector from the
     * node's attributes. If present, it will check whether the ngProjectAs selector
     * matches any of the projection slot selectors.
     * @param {?} tNode
     * @param {?} projectionSlots
     * @return {?}
     */


    function matchingProjectionSlotIndex(tNode, projectionSlots) {
      /** @type {?} */
      let wildcardNgContentIndex = null;
      /** @type {?} */

      const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);

      for (let i = 0; i < projectionSlots.length; i++) {
        /** @type {?} */
        const slotValue = projectionSlots[i]; // The last wildcard projection slot should match all nodes which aren't matching
        // any selector. This is necessary to be backwards compatible with view engine.

        if (slotValue === '*') {
          wildcardNgContentIndex = i;
          continue;
        } // If we ran into an `ngProjectAs` attribute, we should match its parsed selector
        // to the list of selectors, otherwise we fall back to matching against the node.


        if (ngProjectAsAttrVal === null ? isNodeMatchingSelectorList(tNode, slotValue,
        /* isProjectionMode */
        true) : isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) {
          return i; // first matching selector "captures" a given node
        }
      }

      return wildcardNgContentIndex;
    }
    /**
     * Instruction to distribute projectable nodes among <ng-content> occurrences in a given template.
     * It takes all the selectors from the entire component's template and decides where
     * each projected node belongs (it re-distributes nodes among "buckets" where each "bucket" is
     * backed by a selector).
     *
     * This function requires CSS selectors to be provided in 2 forms: parsed (by a compiler) and text,
     * un-parsed form.
     *
     * The parsed form is needed for efficient matching of a node against a given CSS selector.
     * The un-parsed, textual form is needed for support of the ngProjectAs attribute.
     *
     * Having a CSS selector in 2 different formats is not ideal, but alternatives have even more
     * drawbacks:
     * - having only a textual form would require runtime parsing of CSS selectors;
     * - we can't have only a parsed as we can't re-construct textual form from it (as entered by a
     * template author).
     *
     * \@codeGenApi
     * @param {?=} projectionSlots
     * @return {?}
     */


    function ɵɵprojectionDef(projectionSlots) {
      /** @type {?} */
      const componentNode =
      /** @type {?} */
      findComponentView(getLView())[T_HOST];

      if (!componentNode.projection) {
        // If no explicit projection slots are defined, fall back to a single
        // projection slot with the wildcard selector.

        /** @type {?} */
        const numProjectionSlots = projectionSlots ? projectionSlots.length : 1;
        /** @type {?} */

        const projectionHeads = componentNode.projection = new Array(numProjectionSlots).fill(null);
        /** @type {?} */

        const tails = projectionHeads.slice();
        /** @type {?} */

        let componentChild = componentNode.child;

        while (componentChild !== null) {
          /** @type {?} */
          const slotIndex = projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;

          if (slotIndex !== null) {
            if (tails[slotIndex]) {
              /** @type {?} */
              tails[slotIndex].projectionNext = componentChild;
            } else {
              projectionHeads[slotIndex] = componentChild;
            }

            tails[slotIndex] = componentChild;
          }

          componentChild = componentChild.next;
        }
      }
    }
    /** @type {?} */


    let delayProjection = false;
    /**
     * @param {?} value
     * @return {?}
     */

    function setDelayProjection(value) {
      delayProjection = value;
    }
    /**
     * Inserts previously re-distributed projected nodes. This instruction must be preceded by a call
     * to the projectionDef instruction.
     *
     * \@codeGenApi
     * @param {?} nodeIndex
     * @param {?=} selectorIndex
     * @param {?=} attrs
     * @return {?}
     */


    function ɵɵprojection(nodeIndex, selectorIndex = 0, attrs) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const tProjectionNode = getOrCreateTNode(lView[TVIEW], lView[T_HOST], nodeIndex, 1
      /* Projection */
      , null, attrs || null); // We can't use viewData[HOST_NODE] because projection nodes can be nested in embedded views.

      if (tProjectionNode.projection === null) tProjectionNode.projection = selectorIndex; // `<ng-content>` has no content

      setIsNotParent(); // We might need to delay the projection of nodes if they are in the middle of an i18n block

      if (!delayProjection) {
        // re-distribution of projectable nodes is stored on a component's view level
        appendProjectedNodes(lView, tProjectionNode, selectorIndex, findComponentView(lView));
      }
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     *
     * Update an interpolated property on an element with a lone bound value
     *
     * Used when the value passed to a property has 1 interpolated value in it, an no additional text
     * surrounds that interpolated value:
     *
     * ```html
     * <div title="{{v0}}"></div>
     * ```
     *
     * Its compiled representation is::
     *
     * ```ts
     * ɵɵpropertyInterpolate('title', v0);
     * ```
     *
     * If the property name also exists as an input property on one of the element's directives,
     * the component property will be set instead of the element property. This check must
     * be conducted at runtime so child components that add new `\@Inputs` don't have to be re-compiled.
     *
     * \@codeGenApi
     * @param {?} propName The name of the property to update
     * @param {?} v0 Value checked for change.
     * @param {?=} sanitizer An optional sanitizer function
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵpropertyInterpolate(propName, v0, sanitizer) {
      ɵɵpropertyInterpolate1(propName, '', v0, '', sanitizer);
      return ɵɵpropertyInterpolate;
    }
    /**
     *
     * Update an interpolated property on an element with single bound value surrounded by text.
     *
     * Used when the value passed to a property has 1 interpolated value in it:
     *
     * ```html
     * <div title="prefix{{v0}}suffix"></div>
     * ```
     *
     * Its compiled representation is::
     *
     * ```ts
     * ɵɵpropertyInterpolate1('title', 'prefix', v0, 'suffix');
     * ```
     *
     * If the property name also exists as an input property on one of the element's directives,
     * the component property will be set instead of the element property. This check must
     * be conducted at runtime so child components that add new `\@Inputs` don't have to be re-compiled.
     *
     * \@codeGenApi
     * @param {?} propName The name of the property to update
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @param {?=} sanitizer An optional sanitizer function
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵpropertyInterpolate1(propName, prefix, v0, suffix, sanitizer) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const interpolatedValue = interpolation1(getLView(), prefix, v0, suffix);

      if (interpolatedValue !== NO_CHANGE) {
        elementPropertyInternal(index, propName, interpolatedValue, sanitizer);
      }

      return ɵɵpropertyInterpolate1;
    }
    /**
     *
     * Update an interpolated property on an element with 2 bound values surrounded by text.
     *
     * Used when the value passed to a property has 2 interpolated values in it:
     *
     * ```html
     * <div title="prefix{{v0}}-{{v1}}suffix"></div>
     * ```
     *
     * Its compiled representation is::
     *
     * ```ts
     * ɵɵpropertyInterpolate2('title', 'prefix', v0, '-', v1, 'suffix');
     * ```
     *
     * If the property name also exists as an input property on one of the element's directives,
     * the component property will be set instead of the element property. This check must
     * be conducted at runtime so child components that add new `\@Inputs` don't have to be re-compiled.
     *
     * \@codeGenApi
     * @param {?} propName The name of the property to update
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @param {?=} sanitizer An optional sanitizer function
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵpropertyInterpolate2(propName, prefix, v0, i0, v1, suffix, sanitizer) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const interpolatedValue = interpolation2(getLView(), prefix, v0, i0, v1, suffix);

      if (interpolatedValue !== NO_CHANGE) {
        elementPropertyInternal(index, propName, interpolatedValue, sanitizer);
      }

      return ɵɵpropertyInterpolate2;
    }
    /**
     *
     * Update an interpolated property on an element with 3 bound values surrounded by text.
     *
     * Used when the value passed to a property has 3 interpolated values in it:
     *
     * ```html
     * <div title="prefix{{v0}}-{{v1}}-{{v2}}suffix"></div>
     * ```
     *
     * Its compiled representation is::
     *
     * ```ts
     * ɵɵpropertyInterpolate3(
     * 'title', 'prefix', v0, '-', v1, '-', v2, 'suffix');
     * ```
     *
     * If the property name also exists as an input property on one of the element's directives,
     * the component property will be set instead of the element property. This check must
     * be conducted at runtime so child components that add new `\@Inputs` don't have to be re-compiled.
     *
     * \@codeGenApi
     * @param {?} propName The name of the property to update
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} i1 Static value used for concatenation only.
     * @param {?} v2 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @param {?=} sanitizer An optional sanitizer function
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵpropertyInterpolate3(propName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const interpolatedValue = interpolation3(getLView(), prefix, v0, i0, v1, i1, v2, suffix);

      if (interpolatedValue !== NO_CHANGE) {
        elementPropertyInternal(index, propName, interpolatedValue, sanitizer);
      }

      return ɵɵpropertyInterpolate3;
    }
    /**
     *
     * Update an interpolated property on an element with 4 bound values surrounded by text.
     *
     * Used when the value passed to a property has 4 interpolated values in it:
     *
     * ```html
     * <div title="prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix"></div>
     * ```
     *
     * Its compiled representation is::
     *
     * ```ts
     * ɵɵpropertyInterpolate4(
     * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');
     * ```
     *
     * If the property name also exists as an input property on one of the element's directives,
     * the component property will be set instead of the element property. This check must
     * be conducted at runtime so child components that add new `\@Inputs` don't have to be re-compiled.
     *
     * \@codeGenApi
     * @param {?} propName The name of the property to update
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} i1 Static value used for concatenation only.
     * @param {?} v2 Value checked for change.
     * @param {?} i2 Static value used for concatenation only.
     * @param {?} v3 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @param {?=} sanitizer An optional sanitizer function
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵpropertyInterpolate4(propName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const interpolatedValue = interpolation4(getLView(), prefix, v0, i0, v1, i1, v2, i2, v3, suffix);

      if (interpolatedValue !== NO_CHANGE) {
        elementPropertyInternal(index, propName, interpolatedValue, sanitizer);
      }

      return ɵɵpropertyInterpolate4;
    }
    /**
     *
     * Update an interpolated property on an element with 5 bound values surrounded by text.
     *
     * Used when the value passed to a property has 5 interpolated values in it:
     *
     * ```html
     * <div title="prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix"></div>
     * ```
     *
     * Its compiled representation is::
     *
     * ```ts
     * ɵɵpropertyInterpolate5(
     * 'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');
     * ```
     *
     * If the property name also exists as an input property on one of the element's directives,
     * the component property will be set instead of the element property. This check must
     * be conducted at runtime so child components that add new `\@Inputs` don't have to be re-compiled.
     *
     * \@codeGenApi
     * @param {?} propName The name of the property to update
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} i1 Static value used for concatenation only.
     * @param {?} v2 Value checked for change.
     * @param {?} i2 Static value used for concatenation only.
     * @param {?} v3 Value checked for change.
     * @param {?} i3 Static value used for concatenation only.
     * @param {?} v4 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @param {?=} sanitizer An optional sanitizer function
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵpropertyInterpolate5(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const interpolatedValue = interpolation5(getLView(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);

      if (interpolatedValue !== NO_CHANGE) {
        elementPropertyInternal(index, propName, interpolatedValue, sanitizer);
      }

      return ɵɵpropertyInterpolate5;
    }
    /**
     *
     * Update an interpolated property on an element with 6 bound values surrounded by text.
     *
     * Used when the value passed to a property has 6 interpolated values in it:
     *
     * ```html
     * <div title="prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix"></div>
     * ```
     *
     * Its compiled representation is::
     *
     * ```ts
     * ɵɵpropertyInterpolate6(
     *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');
     * ```
     *
     * If the property name also exists as an input property on one of the element's directives,
     * the component property will be set instead of the element property. This check must
     * be conducted at runtime so child components that add new `\@Inputs` don't have to be re-compiled.
     *
     * \@codeGenApi
     * @param {?} propName The name of the property to update
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} i1 Static value used for concatenation only.
     * @param {?} v2 Value checked for change.
     * @param {?} i2 Static value used for concatenation only.
     * @param {?} v3 Value checked for change.
     * @param {?} i3 Static value used for concatenation only.
     * @param {?} v4 Value checked for change.
     * @param {?} i4 Static value used for concatenation only.
     * @param {?} v5 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @param {?=} sanitizer An optional sanitizer function
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵpropertyInterpolate6(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const interpolatedValue = interpolation6(getLView(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);

      if (interpolatedValue !== NO_CHANGE) {
        elementPropertyInternal(index, propName, interpolatedValue, sanitizer);
      }

      return ɵɵpropertyInterpolate6;
    }
    /**
     *
     * Update an interpolated property on an element with 7 bound values surrounded by text.
     *
     * Used when the value passed to a property has 7 interpolated values in it:
     *
     * ```html
     * <div title="prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix"></div>
     * ```
     *
     * Its compiled representation is::
     *
     * ```ts
     * ɵɵpropertyInterpolate7(
     *    'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');
     * ```
     *
     * If the property name also exists as an input property on one of the element's directives,
     * the component property will be set instead of the element property. This check must
     * be conducted at runtime so child components that add new `\@Inputs` don't have to be re-compiled.
     *
     * \@codeGenApi
     * @param {?} propName The name of the property to update
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} i1 Static value used for concatenation only.
     * @param {?} v2 Value checked for change.
     * @param {?} i2 Static value used for concatenation only.
     * @param {?} v3 Value checked for change.
     * @param {?} i3 Static value used for concatenation only.
     * @param {?} v4 Value checked for change.
     * @param {?} i4 Static value used for concatenation only.
     * @param {?} v5 Value checked for change.
     * @param {?} i5 Static value used for concatenation only.
     * @param {?} v6 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @param {?=} sanitizer An optional sanitizer function
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵpropertyInterpolate7(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const interpolatedValue = interpolation7(getLView(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);

      if (interpolatedValue !== NO_CHANGE) {
        elementPropertyInternal(index, propName, interpolatedValue, sanitizer);
      }

      return ɵɵpropertyInterpolate7;
    }
    /**
     *
     * Update an interpolated property on an element with 8 bound values surrounded by text.
     *
     * Used when the value passed to a property has 8 interpolated values in it:
     *
     * ```html
     * <div title="prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix"></div>
     * ```
     *
     * Its compiled representation is::
     *
     * ```ts
     * ɵɵpropertyInterpolate8(
     *  'title', 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');
     * ```
     *
     * If the property name also exists as an input property on one of the element's directives,
     * the component property will be set instead of the element property. This check must
     * be conducted at runtime so child components that add new `\@Inputs` don't have to be re-compiled.
     *
     * \@codeGenApi
     * @param {?} propName The name of the property to update
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} i1 Static value used for concatenation only.
     * @param {?} v2 Value checked for change.
     * @param {?} i2 Static value used for concatenation only.
     * @param {?} v3 Value checked for change.
     * @param {?} i3 Static value used for concatenation only.
     * @param {?} v4 Value checked for change.
     * @param {?} i4 Static value used for concatenation only.
     * @param {?} v5 Value checked for change.
     * @param {?} i5 Static value used for concatenation only.
     * @param {?} v6 Value checked for change.
     * @param {?} i6 Static value used for concatenation only.
     * @param {?} v7 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @param {?=} sanitizer An optional sanitizer function
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵpropertyInterpolate8(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const interpolatedValue = interpolation8(getLView(), prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);

      if (interpolatedValue !== NO_CHANGE) {
        elementPropertyInternal(index, propName, interpolatedValue, sanitizer);
      }

      return ɵɵpropertyInterpolate8;
    }
    /**
     * Update an interpolated property on an element with 8 or more bound values surrounded by text.
     *
     * Used when the number of interpolated values exceeds 7.
     *
     * ```html
     * <div
     *  title="prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix"></div>
     * ```
     *
     * Its compiled representation is::
     *
     * ```ts
     * ɵɵpropertyInterpolateV(
     *  'title', ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,
     *  'suffix']);
     * ```
     *
     * If the property name also exists as an input property on one of the element's directives,
     * the component property will be set instead of the element property. This check must
     * be conducted at runtime so child components that add new `\@Inputs` don't have to be re-compiled.
     *
     * \@codeGenApi
     * @param {?} propName The name of the property to update.
     * @param {?} values The a collection of values and the strings inbetween those values, beginning with a
     * string prefix and ending with a string suffix.
     * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)
     * @param {?=} sanitizer An optional sanitizer function
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵpropertyInterpolateV(propName, values, sanitizer) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const interpolatedValue = interpolationV(getLView(), values);

      if (interpolatedValue !== NO_CHANGE) {
        elementPropertyInternal(index, propName, interpolatedValue, sanitizer);
      }

      return ɵɵpropertyInterpolateV;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Create static text node
     *
     * \@codeGenApi
     * @param {?} index Index of the node in the data array
     * @param {?=} value Value to write. This value will be stringified.
     *
     * @return {?}
     */


    function ɵɵtext(index, value) {
      /** @type {?} */
      const lView = getLView();
      ngDevMode && assertEqual(lView[BINDING_INDEX], lView[TVIEW].bindingStartIndex, 'text nodes should be created before any bindings');
      ngDevMode && ngDevMode.rendererCreateTextNode++;
      ngDevMode && assertDataInRange(lView, index + HEADER_OFFSET);
      /** @type {?} */

      const textNative = lView[index + HEADER_OFFSET] = createTextNode(value, lView[RENDERER]);
      ngDevMode && ngDevMode.rendererSetText++;
      /** @type {?} */

      const tNode = getOrCreateTNode(lView[TVIEW], lView[T_HOST], index, 3
      /* Element */
      , null, null); // Text nodes are self closing.

      setIsNotParent();
      appendChild(textNative, tNode, lView);
    }
    /**
     * Create text node with binding
     * Bindings should be handled externally with the proper interpolation(1-8) method
     *
     * \@codeGenApi
     * @template T
     * @param {?} value Stringified value to write.
     *
     * @return {?}
     */


    function ɵɵtextBinding(value) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const index = getSelectedIndex();
      /** @type {?} */

      const bound = bind(lView, value);

      if (bound !== NO_CHANGE) {
        textBindingInternal(lView, index, renderStringify(bound));
      }
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     *
     * Update text content with a lone bound value
     *
     * Used when a text node has 1 interpolated value in it, an no additional text
     * surrounds that interpolated value:
     *
     * ```html
     * <div>{{v0}}</div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵtextInterpolate(v0);
     * ```
     * @see textInterpolateV
     * \@codeGenApi
     * @param {?} v0
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵtextInterpolate(v0) {
      ɵɵtextInterpolate1('', v0, '');
      return ɵɵtextInterpolate;
    }
    /**
     *
     * Update text content with single bound value surrounded by other text.
     *
     * Used when a text node has 1 interpolated value in it:
     *
     * ```html
     * <div>prefix{{v0}}suffix</div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵtextInterpolate1('prefix', v0, 'suffix');
     * ```
     * @see textInterpolateV
     * \@codeGenApi
     * @param {?} prefix
     * @param {?} v0
     * @param {?} suffix
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵtextInterpolate1(prefix, v0, suffix) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const interpolated = interpolation1(lView, prefix, v0, suffix);

      if (interpolated !== NO_CHANGE) {
        textBindingInternal(lView, index,
        /** @type {?} */
        interpolated);
      }

      return ɵɵtextInterpolate1;
    }
    /**
     *
     * Update text content with 2 bound values surrounded by other text.
     *
     * Used when a text node has 2 interpolated values in it:
     *
     * ```html
     * <div>prefix{{v0}}-{{v1}}suffix</div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵtextInterpolate2('prefix', v0, '-', v1, 'suffix');
     * ```
     * @see textInterpolateV
     * \@codeGenApi
     * @param {?} prefix
     * @param {?} v0
     * @param {?} i0
     * @param {?} v1
     * @param {?} suffix
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵtextInterpolate2(prefix, v0, i0, v1, suffix) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const interpolated = interpolation2(lView, prefix, v0, i0, v1, suffix);

      if (interpolated !== NO_CHANGE) {
        textBindingInternal(lView, index,
        /** @type {?} */
        interpolated);
      }

      return ɵɵtextInterpolate2;
    }
    /**
     *
     * Update text content with 3 bound values surrounded by other text.
     *
     * Used when a text node has 3 interpolated values in it:
     *
     * ```html
     * <div>prefix{{v0}}-{{v1}}-{{v2}}suffix</div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵtextInterpolate3(
     * 'prefix', v0, '-', v1, '-', v2, 'suffix');
     * ```
     * @see textInterpolateV
     * \@codeGenApi
     * @param {?} prefix
     * @param {?} v0
     * @param {?} i0
     * @param {?} v1
     * @param {?} i1
     * @param {?} v2
     * @param {?} suffix
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵtextInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const interpolated = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);

      if (interpolated !== NO_CHANGE) {
        textBindingInternal(lView, index,
        /** @type {?} */
        interpolated);
      }

      return ɵɵtextInterpolate3;
    }
    /**
     *
     * Update text content with 4 bound values surrounded by other text.
     *
     * Used when a text node has 4 interpolated values in it:
     *
     * ```html
     * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix</div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵtextInterpolate4(
     * 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');
     * ```
     * @see ɵɵtextInterpolateV
     * \@codeGenApi
     * @param {?} prefix
     * @param {?} v0
     * @param {?} i0
     * @param {?} v1
     * @param {?} i1
     * @param {?} v2
     * @param {?} i2
     * @param {?} v3
     * @param {?} suffix
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵtextInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const interpolated = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);

      if (interpolated !== NO_CHANGE) {
        textBindingInternal(lView, index,
        /** @type {?} */
        interpolated);
      }

      return ɵɵtextInterpolate4;
    }
    /**
     *
     * Update text content with 5 bound values surrounded by other text.
     *
     * Used when a text node has 5 interpolated values in it:
     *
     * ```html
     * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix</div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵtextInterpolate5(
     * 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');
     * ```
     * @see textInterpolateV
     * \@codeGenApi
     * @param {?} prefix
     * @param {?} v0
     * @param {?} i0
     * @param {?} v1
     * @param {?} i1
     * @param {?} v2
     * @param {?} i2
     * @param {?} v3
     * @param {?} i3
     * @param {?} v4
     * @param {?} suffix
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵtextInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const interpolated = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);

      if (interpolated !== NO_CHANGE) {
        textBindingInternal(lView, index,
        /** @type {?} */
        interpolated);
      }

      return ɵɵtextInterpolate5;
    }
    /**
     *
     * Update text content with 6 bound values surrounded by other text.
     *
     * Used when a text node has 6 interpolated values in it:
     *
     * ```html
     * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix</div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵtextInterpolate6(
     *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');
     * ```
     *
     * @see textInterpolateV
     * \@codeGenApi
     * @param {?} prefix
     * @param {?} v0
     * @param {?} i0
     * @param {?} v1
     * @param {?} i1
     * @param {?} v2
     * @param {?} i2
     * @param {?} v3
     * @param {?} i3
     * @param {?} v4
     * @param {?} i4 Static value used for concatenation only.
     * @param {?} v5 Value checked for change. \@returns itself, so that it may be chained.
     * @param {?} suffix
     * @return {?}
     */


    function ɵɵtextInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const interpolated = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);

      if (interpolated !== NO_CHANGE) {
        textBindingInternal(lView, index,
        /** @type {?} */
        interpolated);
      }

      return ɵɵtextInterpolate6;
    }
    /**
     *
     * Update text content with 7 bound values surrounded by other text.
     *
     * Used when a text node has 7 interpolated values in it:
     *
     * ```html
     * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix</div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵtextInterpolate7(
     *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');
     * ```
     * @see textInterpolateV
     * \@codeGenApi
     * @param {?} prefix
     * @param {?} v0
     * @param {?} i0
     * @param {?} v1
     * @param {?} i1
     * @param {?} v2
     * @param {?} i2
     * @param {?} v3
     * @param {?} i3
     * @param {?} v4
     * @param {?} i4
     * @param {?} v5
     * @param {?} i5
     * @param {?} v6
     * @param {?} suffix
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵtextInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const interpolated = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);

      if (interpolated !== NO_CHANGE) {
        textBindingInternal(lView, index,
        /** @type {?} */
        interpolated);
      }

      return ɵɵtextInterpolate7;
    }
    /**
     *
     * Update text content with 8 bound values surrounded by other text.
     *
     * Used when a text node has 8 interpolated values in it:
     *
     * ```html
     * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix</div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵtextInterpolate8(
     *  'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');
     * ```
     * @see textInterpolateV
     * \@codeGenApi
     * @param {?} prefix
     * @param {?} v0
     * @param {?} i0
     * @param {?} v1
     * @param {?} i1
     * @param {?} v2
     * @param {?} i2
     * @param {?} v3
     * @param {?} i3
     * @param {?} v4
     * @param {?} i4
     * @param {?} v5
     * @param {?} i5
     * @param {?} v6
     * @param {?} i6
     * @param {?} v7
     * @param {?} suffix
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵtextInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const interpolated = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);

      if (interpolated !== NO_CHANGE) {
        textBindingInternal(lView, index,
        /** @type {?} */
        interpolated);
      }

      return ɵɵtextInterpolate8;
    }
    /**
     * Update text content with 9 or more bound values other surrounded by text.
     *
     * Used when the number of interpolated values exceeds 8.
     *
     * ```html
     * <div>prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix</div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵtextInterpolateV(
     *  ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,
     *  'suffix']);
     * ```
     * .
     * \@codeGenApi
     * @param {?} values The a collection of values and the strings in between those values, beginning with
     * a string prefix and ending with a string suffix.
     * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)
     *
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵtextInterpolateV(values) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const interpolated = interpolationV(lView, values);

      if (interpolated !== NO_CHANGE) {
        textBindingInternal(lView, index,
        /** @type {?} */
        interpolated);
      }

      return ɵɵtextInterpolateV;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     *
     * Update an interpolated class on an element with single bound value surrounded by text.
     *
     * Used when the value passed to a property has 1 interpolated value in it:
     *
     * ```html
     * <div class="prefix{{v0}}suffix"></div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵclassMapInterpolate1('prefix', v0, 'suffix');
     * ```
     *
     * \@codeGenApi
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @return {?}
     */


    function ɵɵclassMapInterpolate1(prefix, v0, suffix) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
      classMapInternal(getSelectedIndex(), interpolatedValue);
    }
    /**
     *
     * Update an interpolated class on an element with 2 bound values surrounded by text.
     *
     * Used when the value passed to a property has 2 interpolated values in it:
     *
     * ```html
     * <div class="prefix{{v0}}-{{v1}}suffix"></div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵclassMapInterpolate2('prefix', v0, '-', v1, 'suffix');
     * ```
     *
     * \@codeGenApi
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @return {?}
     */


    function ɵɵclassMapInterpolate2(prefix, v0, i0, v1, suffix) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
      classMapInternal(getSelectedIndex(), interpolatedValue);
    }
    /**
     *
     * Update an interpolated class on an element with 3 bound values surrounded by text.
     *
     * Used when the value passed to a property has 3 interpolated values in it:
     *
     * ```html
     * <div class="prefix{{v0}}-{{v1}}-{{v2}}suffix"></div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵclassMapInterpolate3(
     * 'prefix', v0, '-', v1, '-', v2, 'suffix');
     * ```
     *
     * \@codeGenApi
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} i1 Static value used for concatenation only.
     * @param {?} v2 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @return {?}
     */


    function ɵɵclassMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
      classMapInternal(getSelectedIndex(), interpolatedValue);
    }
    /**
     *
     * Update an interpolated class on an element with 4 bound values surrounded by text.
     *
     * Used when the value passed to a property has 4 interpolated values in it:
     *
     * ```html
     * <div class="prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix"></div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵclassMapInterpolate4(
     * 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');
     * ```
     *
     * \@codeGenApi
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} i1 Static value used for concatenation only.
     * @param {?} v2 Value checked for change.
     * @param {?} i2 Static value used for concatenation only.
     * @param {?} v3 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @return {?}
     */


    function ɵɵclassMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
      classMapInternal(getSelectedIndex(), interpolatedValue);
    }
    /**
     *
     * Update an interpolated class on an element with 5 bound values surrounded by text.
     *
     * Used when the value passed to a property has 5 interpolated values in it:
     *
     * ```html
     * <div class="prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix"></div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵclassMapInterpolate5(
     * 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');
     * ```
     *
     * \@codeGenApi
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} i1 Static value used for concatenation only.
     * @param {?} v2 Value checked for change.
     * @param {?} i2 Static value used for concatenation only.
     * @param {?} v3 Value checked for change.
     * @param {?} i3 Static value used for concatenation only.
     * @param {?} v4 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @return {?}
     */


    function ɵɵclassMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
      classMapInternal(getSelectedIndex(), interpolatedValue);
    }
    /**
     *
     * Update an interpolated class on an element with 6 bound values surrounded by text.
     *
     * Used when the value passed to a property has 6 interpolated values in it:
     *
     * ```html
     * <div class="prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix"></div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵclassMapInterpolate6(
     *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');
     * ```
     *
     * \@codeGenApi
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} i1 Static value used for concatenation only.
     * @param {?} v2 Value checked for change.
     * @param {?} i2 Static value used for concatenation only.
     * @param {?} v3 Value checked for change.
     * @param {?} i3 Static value used for concatenation only.
     * @param {?} v4 Value checked for change.
     * @param {?} i4 Static value used for concatenation only.
     * @param {?} v5 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @return {?}
     */


    function ɵɵclassMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
      classMapInternal(getSelectedIndex(), interpolatedValue);
    }
    /**
     *
     * Update an interpolated class on an element with 7 bound values surrounded by text.
     *
     * Used when the value passed to a property has 7 interpolated values in it:
     *
     * ```html
     * <div class="prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix"></div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵclassMapInterpolate7(
     *    'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');
     * ```
     *
     * \@codeGenApi
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} i1 Static value used for concatenation only.
     * @param {?} v2 Value checked for change.
     * @param {?} i2 Static value used for concatenation only.
     * @param {?} v3 Value checked for change.
     * @param {?} i3 Static value used for concatenation only.
     * @param {?} v4 Value checked for change.
     * @param {?} i4 Static value used for concatenation only.
     * @param {?} v5 Value checked for change.
     * @param {?} i5 Static value used for concatenation only.
     * @param {?} v6 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @return {?}
     */


    function ɵɵclassMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
      classMapInternal(getSelectedIndex(), interpolatedValue);
    }
    /**
     *
     * Update an interpolated class on an element with 8 bound values surrounded by text.
     *
     * Used when the value passed to a property has 8 interpolated values in it:
     *
     * ```html
     * <div class="prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix"></div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵclassMapInterpolate8(
     *  'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, 'suffix');
     * ```
     *
     * \@codeGenApi
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} i1 Static value used for concatenation only.
     * @param {?} v2 Value checked for change.
     * @param {?} i2 Static value used for concatenation only.
     * @param {?} v3 Value checked for change.
     * @param {?} i3 Static value used for concatenation only.
     * @param {?} v4 Value checked for change.
     * @param {?} i4 Static value used for concatenation only.
     * @param {?} v5 Value checked for change.
     * @param {?} i5 Static value used for concatenation only.
     * @param {?} v6 Value checked for change.
     * @param {?} i6 Static value used for concatenation only.
     * @param {?} v7 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @return {?}
     */


    function ɵɵclassMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
      classMapInternal(getSelectedIndex(), interpolatedValue);
    }
    /**
     * Update an interpolated class on an element with 8 or more bound values surrounded by text.
     *
     * Used when the number of interpolated values exceeds 7.
     *
     * ```html
     * <div
     *  class="prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix"></div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵclassMapInterpolateV(
     *  ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,
     *  'suffix']);
     * ```
     * .
     * \@codeGenApi
     * @param {?} values The a collection of values and the strings in-between those values, beginning with
     * a string prefix and ending with a string suffix.
     * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)
     * @return {?}
     */


    function ɵɵclassMapInterpolateV(values) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const interpolatedValue = interpolationV(lView, values);
      classMapInternal(getSelectedIndex(), interpolatedValue);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     *
     * Update an interpolated style property on an element with single bound value surrounded by text.
     *
     * Used when the value passed to a property has 1 interpolated value in it:
     *
     * ```html
     * <div style.color="prefix{{v0}}suffix"></div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵstylePropInterpolate1(0, 'prefix', v0, 'suffix');
     * ```
     *
     * \@codeGenApi
     * @param {?} prop
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @param {?=} valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵstylePropInterpolate1(prop, prefix, v0, suffix, valueSuffix) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const interpolatedValue = interpolation1(lView, prefix, v0, suffix);
      stylePropInternal(getSelectedIndex(), prop,
      /** @type {?} */
      interpolatedValue, valueSuffix);
      return ɵɵstylePropInterpolate1;
    }
    /**
     *
     * Update an interpolated style property on an element with 2 bound values surrounded by text.
     *
     * Used when the value passed to a property has 2 interpolated values in it:
     *
     * ```html
     * <div style.color="prefix{{v0}}-{{v1}}suffix"></div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵstylePropInterpolate2(0, 'prefix', v0, '-', v1, 'suffix');
     * ```
     *
     * \@codeGenApi
     * @param {?} prop
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @param {?=} valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵstylePropInterpolate2(prop, prefix, v0, i0, v1, suffix, valueSuffix) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);
      stylePropInternal(getSelectedIndex(), prop,
      /** @type {?} */
      interpolatedValue, valueSuffix);
      return ɵɵstylePropInterpolate2;
    }
    /**
     *
     * Update an interpolated style property on an element with 3 bound values surrounded by text.
     *
     * Used when the value passed to a property has 3 interpolated values in it:
     *
     * ```html
     * <div style.color="prefix{{v0}}-{{v1}}-{{v2}}suffix"></div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵstylePropInterpolate3(0, 'prefix', v0, '-', v1, '-', v2, 'suffix');
     * ```
     *
     * \@codeGenApi
     * @param {?} prop
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} i1 Static value used for concatenation only.
     * @param {?} v2 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @param {?=} valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵstylePropInterpolate3(prop, prefix, v0, i0, v1, i1, v2, suffix, valueSuffix) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);
      stylePropInternal(getSelectedIndex(), prop,
      /** @type {?} */
      interpolatedValue, valueSuffix);
      return ɵɵstylePropInterpolate3;
    }
    /**
     *
     * Update an interpolated style property on an element with 4 bound values surrounded by text.
     *
     * Used when the value passed to a property has 4 interpolated values in it:
     *
     * ```html
     * <div style.color="prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}suffix"></div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵstylePropInterpolate4(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, 'suffix');
     * ```
     *
     * \@codeGenApi
     * @param {?} prop
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} i1 Static value used for concatenation only.
     * @param {?} v2 Value checked for change.
     * @param {?} i2 Static value used for concatenation only.
     * @param {?} v3 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @param {?=} valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵstylePropInterpolate4(prop, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, valueSuffix) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);
      stylePropInternal(getSelectedIndex(), prop,
      /** @type {?} */
      interpolatedValue, valueSuffix);
      return ɵɵstylePropInterpolate4;
    }
    /**
     *
     * Update an interpolated style property on an element with 5 bound values surrounded by text.
     *
     * Used when the value passed to a property has 5 interpolated values in it:
     *
     * ```html
     * <div style.color="prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}suffix"></div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵstylePropInterpolate5(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, 'suffix');
     * ```
     *
     * \@codeGenApi
     * @param {?} prop
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} i1 Static value used for concatenation only.
     * @param {?} v2 Value checked for change.
     * @param {?} i2 Static value used for concatenation only.
     * @param {?} v3 Value checked for change.
     * @param {?} i3 Static value used for concatenation only.
     * @param {?} v4 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @param {?=} valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵstylePropInterpolate5(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, valueSuffix) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);
      stylePropInternal(getSelectedIndex(), prop,
      /** @type {?} */
      interpolatedValue, valueSuffix);
      return ɵɵstylePropInterpolate5;
    }
    /**
     *
     * Update an interpolated style property on an element with 6 bound values surrounded by text.
     *
     * Used when the value passed to a property has 6 interpolated values in it:
     *
     * ```html
     * <div style.color="prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}suffix"></div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵstylePropInterpolate6(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, 'suffix');
     * ```
     *
     * \@codeGenApi
     * @param {?} prop
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} i1 Static value used for concatenation only.
     * @param {?} v2 Value checked for change.
     * @param {?} i2 Static value used for concatenation only.
     * @param {?} v3 Value checked for change.
     * @param {?} i3 Static value used for concatenation only.
     * @param {?} v4 Value checked for change.
     * @param {?} i4 Static value used for concatenation only.
     * @param {?} v5 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @param {?=} valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵstylePropInterpolate6(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, valueSuffix) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);
      stylePropInternal(getSelectedIndex(), prop,
      /** @type {?} */
      interpolatedValue, valueSuffix);
      return ɵɵstylePropInterpolate6;
    }
    /**
     *
     * Update an interpolated style property on an element with 7 bound values surrounded by text.
     *
     * Used when the value passed to a property has 7 interpolated values in it:
     *
     * ```html
     * <div style.color="prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}suffix"></div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵstylePropInterpolate7(
     *    0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, 'suffix');
     * ```
     *
     * \@codeGenApi
     * @param {?} prop
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} i1 Static value used for concatenation only.
     * @param {?} v2 Value checked for change.
     * @param {?} i2 Static value used for concatenation only.
     * @param {?} v3 Value checked for change.
     * @param {?} i3 Static value used for concatenation only.
     * @param {?} v4 Value checked for change.
     * @param {?} i4 Static value used for concatenation only.
     * @param {?} v5 Value checked for change.
     * @param {?} i5 Static value used for concatenation only.
     * @param {?} v6 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @param {?=} valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵstylePropInterpolate7(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, valueSuffix) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);
      stylePropInternal(getSelectedIndex(), prop,
      /** @type {?} */
      interpolatedValue, valueSuffix);
      return ɵɵstylePropInterpolate7;
    }
    /**
     *
     * Update an interpolated style property on an element with 8 bound values surrounded by text.
     *
     * Used when the value passed to a property has 8 interpolated values in it:
     *
     * ```html
     * <div style.color="prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}suffix"></div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵstylePropInterpolate8(0, 'prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6,
     * '-', v7, 'suffix');
     * ```
     *
     * \@codeGenApi
     * @param {?} prop
     * @param {?} prefix Static value used for concatenation only.
     * @param {?} v0 Value checked for change.
     * @param {?} i0 Static value used for concatenation only.
     * @param {?} v1 Value checked for change.
     * @param {?} i1 Static value used for concatenation only.
     * @param {?} v2 Value checked for change.
     * @param {?} i2 Static value used for concatenation only.
     * @param {?} v3 Value checked for change.
     * @param {?} i3 Static value used for concatenation only.
     * @param {?} v4 Value checked for change.
     * @param {?} i4 Static value used for concatenation only.
     * @param {?} v5 Value checked for change.
     * @param {?} i5 Static value used for concatenation only.
     * @param {?} v6 Value checked for change.
     * @param {?} i6 Static value used for concatenation only.
     * @param {?} v7 Value checked for change.
     * @param {?} suffix Static value used for concatenation only.
     * @param {?=} valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵstylePropInterpolate8(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, valueSuffix) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);
      stylePropInternal(getSelectedIndex(), prop,
      /** @type {?} */
      interpolatedValue, valueSuffix);
      return ɵɵstylePropInterpolate8;
    }
    /**
     * Update an interpolated style property on an element with 8 or more bound values surrounded by
     * text.
     *
     * Used when the number of interpolated values exceeds 7.
     *
     * ```html
     * <div
     *  style.color="prefix{{v0}}-{{v1}}-{{v2}}-{{v3}}-{{v4}}-{{v5}}-{{v6}}-{{v7}}-{{v8}}-{{v9}}suffix">
     * </div>
     * ```
     *
     * Its compiled representation is:
     *
     * ```ts
     * ɵɵstylePropInterpolateV(
     *  0, ['prefix', v0, '-', v1, '-', v2, '-', v3, '-', v4, '-', v5, '-', v6, '-', v7, '-', v9,
     *  'suffix']);
     * ```
     *
     * \@codeGenApi
     * @param {?} prop
     * @param {?} values The a collection of values and the strings in-between those values, beginning with
     * a string prefix and ending with a string suffix.
     * (e.g. `['prefix', value0, '-', value1, '-', value2, ..., value99, 'suffix']`)
     * @param {?=} valueSuffix Optional suffix. Used with scalar values to add unit such as `px`.
     * @return {?} itself, so that it may be chained.
     */


    function ɵɵstylePropInterpolateV(prop, values, valueSuffix) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const interpolatedValue = interpolationV(lView, values);
      stylePropInternal(getSelectedIndex(), prop,
      /** @type {?} */
      interpolatedValue, valueSuffix);
      return ɵɵstylePropInterpolateV;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Update a property on a host element. Only applies to native node properties, not inputs.
     *
     * Operates on the element selected by index via the {\@link select} instruction.
     *
     * \@codeGenApi
     * @template T
     * @param {?} propName Name of property. Because it is going to DOM, this is not subject to
     *        renaming as part of minification.
     * @param {?} value New value to write.
     * @param {?=} sanitizer An optional function used to sanitize the value.
     * @return {?} This function returns itself so that it may be chained
     * (e.g. `property('name', ctx.name)('title', ctx.title)`)
     *
     */


    function ɵɵhostProperty(propName, value, sanitizer) {
      /** @type {?} */
      const index = getSelectedIndex();
      ngDevMode && assertNotEqual(index, -1, 'selected index cannot be -1');
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const bindReconciledValue = bind(lView, value);

      if (bindReconciledValue !== NO_CHANGE) {
        elementPropertyInternal(index, propName, bindReconciledValue, sanitizer, true);
      }

      return ɵɵhostProperty;
    }
    /**
     * Updates a synthetic host binding (e.g. `[\@foo]`) on a component.
     *
     * This instruction is for compatibility purposes and is designed to ensure that a
     * synthetic host binding (e.g. `\@HostBinding('\@foo')`) properly gets rendered in
     * the component's renderer. Normally all host bindings are evaluated with the parent
     * component's renderer, but, in the case of animation \@triggers, they need to be
     * evaluated with the sub component's renderer (because that's where the animation
     * triggers are defined).
     *
     * Do not use this instruction as a replacement for `elementProperty`. This instruction
     * only exists to ensure compatibility with the ViewEngine's host binding behavior.
     *
     * \@codeGenApi
     * @template T
     * @param {?} propName Name of property. Because it is going to DOM, this is not subject to
     *        renaming as part of minification.
     * @param {?} value New value to write.
     * @param {?=} sanitizer An optional function used to sanitize the value.
     *
     * @return {?}
     */


    function ɵɵupdateSyntheticHostBinding(propName, value, sanitizer) {
      /** @type {?} */
      const index = getSelectedIndex();
      /** @type {?} */

      const lView = getLView(); // TODO(benlesh): remove bind call here.

      /** @type {?} */

      const bound = bind(lView, value);

      if (bound !== NO_CHANGE) {
        elementPropertyInternal(index, propName, bound, sanitizer, true, loadComponentRenderer);
      }

      return ɵɵupdateSyntheticHostBinding;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Returns the component instance associated with a given DOM host element.
     * Elements which don't represent components return `null`.
     *
     * \@publicApi
     * @template T
     * @param {?} element Host DOM element from which the component should be retrieved.
     *
     * ```
     * <my-app>
     *   #VIEW
     *     <div>
     *       <child-comp></child-comp>
     *     </div>
     * </mp-app>
     *
     * expect(getComponent(<child-comp>) instanceof ChildComponent).toBeTruthy();
     * expect(getComponent(<my-app>) instanceof MyApp).toBeTruthy();
     * ```
     *
     * @return {?}
     */


    function getComponent(element) {
      /** @type {?} */
      const context = loadLContextFromNode(element);

      if (context.component === undefined) {
        context.component = getComponentAtNodeIndex(context.nodeIndex, context.lView);
      }

      return (
        /** @type {?} */
        context.component
      );
    }
    /**
     * Returns the component instance associated with a given DOM host element.
     * Elements which don't represent components return `null`.
     *
     * \@publicApi
     * @template T
     * @param {?} element Host DOM element from which the component should be retrieved.
     *
     * ```
     * <my-app>
     *   #VIEW
     *     <div>
     *       <child-comp></child-comp>
     *     </div>
     * </mp-app>
     *
     * expect(getComponent(<child-comp>) instanceof ChildComponent).toBeTruthy();
     * expect(getComponent(<my-app>) instanceof MyApp).toBeTruthy();
     * ```
     *
     * @return {?}
     */


    function getContext$1(element) {
      /** @type {?} */
      const context =
      /** @type {?} */
      loadLContextFromNode(element);
      return (
        /** @type {?} */
        context.lView[CONTEXT]
      );
    }
    /**
     * Returns the component instance associated with view which owns the DOM element (`null`
     * otherwise).
     *
     * \@publicApi
     * @template T
     * @param {?} element DOM element which is owned by an existing component's view.
     *
     * ```
     * <my-app>
     *   #VIEW
     *     <div>
     *       <child-comp></child-comp>
     *     </div>
     * </mp-app>
     *
     * expect(getViewComponent(<child-comp>) instanceof MyApp).toBeTruthy();
     * expect(getViewComponent(<my-app>)).toEqual(null);
     * ```
     *
     * @return {?}
     */


    function getViewComponent(element) {
      /** @type {?} */
      const context =
      /** @type {?} */
      loadLContext(element);
      /** @type {?} */

      let lView = context.lView;
      /** @type {?} */

      let parent;
      ngDevMode && assertLView(lView);

      while (lView[HOST] === null && (parent =
      /** @type {?} */
      getLViewParent(lView))) {
        // As long as lView[HOST] is null we know we are part of sub-template such as `*ngIf`
        lView = parent;
      }

      return lView[FLAGS] & 512
      /* IsRoot */
      ? null :
      /** @type {?} */
      lView[CONTEXT];
    }
    /**
     * Retrieve all root components.
     *
     * Root components are those which have been bootstrapped by Angular.
     *
     * \@publicApi
     * @param {?} target A DOM element, component or directive instance.
     *
     * @return {?}
     */


    function getRootComponents(target) {
      return [...getRootContext(target).components];
    }
    /**
     * Retrieves an `Injector` associated with the element, component or directive.
     *
     * \@publicApi
     * @param {?} target A DOM element, component or directive instance.
     *
     * @return {?}
     */


    function getInjector(target) {
      /** @type {?} */
      const context = loadLContext(target);
      /** @type {?} */

      const tNode =
      /** @type {?} */
      context.lView[TVIEW].data[context.nodeIndex];
      return new NodeInjector(tNode, context.lView);
    }
    /**
     * Retrieve a set of injection tokens at a given DOM node.
     *
     * \@publicApi
     * @param {?} element Element for which the injection tokens should be retrieved.
     * @return {?}
     */


    function getInjectionTokens(element) {
      /** @type {?} */
      const context = loadLContext(element, false);
      if (!context) return [];
      /** @type {?} */

      const lView = context.lView;
      /** @type {?} */

      const tView = lView[TVIEW];
      /** @type {?} */

      const tNode =
      /** @type {?} */
      tView.data[context.nodeIndex];
      /** @type {?} */

      const providerTokens = [];
      /** @type {?} */

      const startIndex = tNode.providerIndexes & 65535
      /* ProvidersStartIndexMask */
      ;
      /** @type {?} */

      const endIndex = tNode.directiveEnd;

      for (let i = startIndex; i < endIndex; i++) {
        /** @type {?} */
        let value = tView.data[i];

        if (isDirectiveDefHack(value)) {
          // The fact that we sometimes store Type and sometimes DirectiveDef in this location is a
          // design flaw.  We should always store same type so that we can be monomorphic. The issue
          // is that for Components/Directives we store the def instead the type. The correct behavior
          // is that we should always be storing injectable type in this location.
          value = value.type;
        }

        providerTokens.push(value);
      }

      return providerTokens;
    }
    /**
     * Retrieves directives associated with a given DOM host element.
     *
     * \@publicApi
     * @param {?} target A DOM element, component or directive instance.
     *
     * @return {?}
     */


    function getDirectives(target) {
      /** @type {?} */
      const context =
      /** @type {?} */
      loadLContext(target);

      if (context.directives === undefined) {
        context.directives = getDirectivesAtNodeIndex(context.nodeIndex, context.lView, false);
      }

      return context.directives || [];
    }
    /**
     * @param {?} target
     * @param {?=} throwOnNotFound
     * @return {?}
     */


    function loadLContext(target, throwOnNotFound = true) {
      /** @type {?} */
      const context = getLContext(target);

      if (!context && throwOnNotFound) {
        throw new Error(ngDevMode ? "Unable to find context associated with ".concat(stringifyForError(target)) : 'Invalid ng target');
      }

      return context;
    }
    /**
     * Retrieve map of local references.
     *
     * The references are retrieved as a map of local reference name to element or directive instance.
     *
     * \@publicApi
     * @param {?} target A DOM element, component or directive instance.
     *
     * @return {?}
     */


    function getLocalRefs(target) {
      /** @type {?} */
      const context =
      /** @type {?} */
      loadLContext(target);

      if (context.localRefs === undefined) {
        context.localRefs = discoverLocalRefs(context.lView, context.nodeIndex);
      }

      return context.localRefs || {};
    }
    /**
     * Retrieve the host element of the component.
     *
     * Use this function to retrieve the host element of the component. The host
     * element is the element which the component is associated with.
     *
     * \@publicApi
     * @template T
     * @param {?} directive Component or Directive for which the host element should be retrieved.
     *
     * @return {?}
     */


    function getHostElement(directive) {
      return (
        /** @type {?} */

        /** @type {?} */

        /** @type {?} */
        getLContext(directive).native
      );
    }
    /**
     * Retrieves the rendered text for a given component.
     *
     * This function retrieves the host element of a component and
     * and then returns the `textContent` for that element. This implies
     * that the text returned will include re-projected content of
     * the component as well.
     *
     * @param {?} component The component to return the content text for.
     * @return {?}
     */


    function getRenderedText(component) {
      /** @type {?} */
      const hostElement = getHostElement(component);
      return hostElement.textContent || '';
    }
    /**
     * @param {?} node
     * @return {?}
     */


    function loadLContextFromNode(node) {
      if (!(node instanceof Node)) throw new Error('Expecting instance of DOM Node');
      return (
        /** @type {?} */
        loadLContext(node)
      );
    }
    /**
     * @record
     */


    function Listener() {}

    if (false) {}
    /**
     * @param {?} listener
     * @return {?}
     */


    function isBrowserEvents(listener) {
      // Browser events are those which don't have `useCapture` as boolean.
      return typeof listener.useCapture === 'boolean';
    }
    /**
     * Retrieves a list of DOM listeners.
     *
     * ```
     * <my-app>
     *   #VIEW
     *     <div (click)="doSomething()">
     *     </div>
     * </mp-app>
     *
     * expect(getListeners(<div>)).toEqual({
     *   name: 'click',
     *   element: <div>,
     *   callback: () => doSomething(),
     *   useCapture: false
     * });
     * ```
     *
     * \@publicApi
     * @param {?} element Element for which the DOM listeners should be retrieved.
     * @return {?}
     */


    function getListeners(element) {
      /** @type {?} */
      const lContext = loadLContextFromNode(element);
      /** @type {?} */

      const lView = lContext.lView;
      /** @type {?} */

      const tView = lView[TVIEW];
      /** @type {?} */

      const lCleanup = lView[CLEANUP];
      /** @type {?} */

      const tCleanup = tView.cleanup;
      /** @type {?} */

      const listeners = [];

      if (tCleanup && lCleanup) {
        for (let i = 0; i < tCleanup.length;) {
          /** @type {?} */
          const firstParam = tCleanup[i++];
          /** @type {?} */

          const secondParam = tCleanup[i++];

          if (typeof firstParam === 'string') {
            /** @type {?} */
            const name = firstParam;
            /** @type {?} */

            const listenerElement =
            /** @type {?} */

            /** @type {?} */
            unwrapRNode(lView[secondParam]);
            /** @type {?} */

            const callback = lCleanup[tCleanup[i++]];
            /** @type {?} */

            const useCaptureOrIndx = tCleanup[i++]; // if useCaptureOrIndx is boolean then report it as is.
            // if useCaptureOrIndx is positive number then it in unsubscribe method
            // if useCaptureOrIndx is negative number then it is a Subscription

            /** @type {?} */

            const useCapture = typeof useCaptureOrIndx === 'boolean' ? useCaptureOrIndx : useCaptureOrIndx >= 0 ? false : null;

            if (element == listenerElement) {
              listeners.push({
                element,
                name,
                callback,
                useCapture
              });
            }
          }
        }
      }

      listeners.sort(sortListeners);
      return listeners;
    }
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */


    function sortListeners(a, b) {
      if (a.name == b.name) return 0;
      return a.name < b.name ? -1 : 1;
    }
    /**
     * This function should not exist because it is megamorphic and only mostly correct.
     *
     * See call site for more info.
     * @param {?} obj
     * @return {?}
     */


    function isDirectiveDefHack(obj) {
      return obj.type !== undefined && obj.template !== undefined && obj.declaredInputs !== undefined;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * This value reflects the property on the window where the dev
     * tools are patched (window.ng).
     *
     * @type {?}
     */


    const GLOBAL_PUBLISH_EXPANDO_KEY = 'ng';
    /** @type {?} */

    let _published = false;
    /**
     * Publishes a collection of default debug tools onto`window.ng`.
     *
     * These functions are available globally when Angular is in development
     * mode and are automatically stripped away from prod mode is on.
     * @return {?}
     */

    function publishDefaultGlobalUtils() {
      if (!_published) {
        _published = true;
        publishGlobalUtil('getComponent', getComponent);
        publishGlobalUtil('getContext', getContext$1);
        publishGlobalUtil('getListeners', getListeners);
        publishGlobalUtil('getViewComponent', getViewComponent);
        publishGlobalUtil('getHostElement', getHostElement);
        publishGlobalUtil('getInjector', getInjector);
        publishGlobalUtil('getRootComponents', getRootComponents);
        publishGlobalUtil('getDirectives', getDirectives);
        publishGlobalUtil('markDirty', markDirty);
      }
    }
    /**
     * Publishes the given function to `window.ng` so that it can be
     * used from the browser console when an application is not in production.
     * @param {?} name
     * @param {?} fn
     * @return {?}
     */


    function publishGlobalUtil(name, fn) {
      /** @type {?} */
      const w =
      /** @type {?} */

      /** @type {?} */
      _global;
      ngDevMode && assertDefined(fn, 'function not defined');

      if (w) {
        /** @type {?} */
        let container = w[GLOBAL_PUBLISH_EXPANDO_KEY];

        if (!container) {
          container = w[GLOBAL_PUBLISH_EXPANDO_KEY] = {};
        }

        container[name] = fn;
      }
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Options that control how the component should be bootstrapped.
     * @record
     */


    function CreateComponentOptions() {}

    if (false) {} // TODO: A hack to not pull in the NullInjector from @angular/core.


    const ɵ0$c =
    /**
    * @param {?} token
    * @param {?=} notFoundValue
    * @return {?}
    */
    (token, notFoundValue) => {
      throw new Error('NullInjector: Not found: ' + stringifyForError(token));
    };
    /** @type {?} */


    const NULL_INJECTOR$1 = {
      get: ɵ0$c
    };
    /**
     * Bootstraps a Component into an existing host element and returns an instance
     * of the component.
     *
     * Use this function to bootstrap a component into the DOM tree. Each invocation
     * of this function will create a separate tree of components, injectors and
     * change detection cycles and lifetimes. To dynamically insert a new component
     * into an existing tree such that it shares the same injection, change detection
     * and object lifetime, use {\@link ViewContainer#createComponent}.
     *
     * @template T
     * @param {?} componentType Component to bootstrap
     * @param {?=} opts
     * @return {?}
     */

    function renderComponent(componentType
    /* Type as workaround for: Microsoft/TypeScript/issues/4881 */
    , opts = {}) {
      ngDevMode && publishDefaultGlobalUtils();
      ngDevMode && assertComponentType(componentType); // this is preemptively set to avoid having test and debug code accidentally
      // read data from a previous application state...

      setActiveHostElement(null);
      /** @type {?} */

      const rendererFactory = opts.rendererFactory || domRendererFactory3;
      /** @type {?} */

      const sanitizer = opts.sanitizer || null;
      /** @type {?} */

      const componentDef =
      /** @type {?} */
      getComponentDef(componentType);
      if (componentDef.type != componentType) componentDef.type = componentType; // The first index of the first selector is the tag name.

      /** @type {?} */

      const componentTag =
      /** @type {?} */

      /** @type {?} */

      /** @type {?} */
      componentDef.selectors[0][0];
      /** @type {?} */

      const hostRNode = locateHostElement(rendererFactory, opts.host || componentTag);
      /** @type {?} */

      const rootFlags = componentDef.onPush ? 64
      /* Dirty */
      | 512
      /* IsRoot */
      : 16
      /* CheckAlways */
      | 512
      /* IsRoot */
      ;
      /** @type {?} */

      const rootContext = createRootContext(opts.scheduler, opts.playerHandler);
      /** @type {?} */

      const renderer = rendererFactory.createRenderer(hostRNode, componentDef);
      /** @type {?} */

      const rootView = createLView(null, createTView(-1, null, 1, 0, null, null, null, null), rootContext, rootFlags, null, null, rendererFactory, renderer, undefined, opts.injector || null);
      /** @type {?} */

      const oldView = enterView(rootView, null);
      /** @type {?} */

      let component; // Will become true if the `try` block executes with no errors.

      /** @type {?} */

      let safeToRunHooks = false;

      try {
        if (rendererFactory.begin) rendererFactory.begin();
        /** @type {?} */

        const componentView = createRootComponentView(hostRNode, componentDef, rootView, rendererFactory, renderer, sanitizer);
        component = createRootComponent(componentView, componentDef, rootView, rootContext, opts.hostFeatures || null);
        addToViewTree(rootView, componentView);
        refreshDescendantViews(rootView); // creation mode pass

        rootView[FLAGS] &= ~4
        /* CreationMode */
        ;
        resetPreOrderHookFlags(rootView);
        refreshDescendantViews(rootView); // update mode pass

        safeToRunHooks = true;
      } finally {
        leaveView(oldView, safeToRunHooks);
        if (rendererFactory.end) rendererFactory.end();
      }

      return component;
    }
    /**
     * Creates the root component view and the root component node.
     *
     * @param {?} rNode Render host element.
     * @param {?} def ComponentDef
     * @param {?} rootView The parent view where the host node is stored
     * @param {?} rendererFactory
     * @param {?} renderer The current renderer
     * @param {?=} sanitizer The sanitizer, if provided
     *
     * @return {?} Component view created
     */


    function createRootComponentView(rNode, def, rootView, rendererFactory, renderer, sanitizer) {
      resetComponentState();
      /** @type {?} */

      const tView = rootView[TVIEW];
      ngDevMode && assertDataInRange(rootView, 0 + HEADER_OFFSET);
      rootView[0 + HEADER_OFFSET] = rNode;
      /** @type {?} */

      const tNode = getOrCreateTNode(tView, null, 0, 3
      /* Element */
      , null, null);
      /** @type {?} */

      const componentView = createLView(rootView, getOrCreateTView(def), null, def.onPush ? 64
      /* Dirty */
      : 16
      /* CheckAlways */
      , rootView[HEADER_OFFSET], tNode, rendererFactory, renderer, sanitizer);

      if (tView.firstTemplatePass) {
        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, rootView), tView, def.type);
        tNode.flags = 1
        /* isComponent */
        ;
        initNodeFlags(tNode, rootView.length, 1);
        queueComponentIndexForCheck(tNode);
      } // Store component view at node index, with node as the HOST


      return rootView[HEADER_OFFSET] = componentView;
    }
    /**
     * Creates a root component and sets it up with features and host bindings. Shared by
     * renderComponent() and ViewContainerRef.createComponent().
     * @template T
     * @param {?} componentView
     * @param {?} componentDef
     * @param {?} rootView
     * @param {?} rootContext
     * @param {?} hostFeatures
     * @return {?}
     */


    function createRootComponent(componentView, componentDef, rootView, rootContext, hostFeatures) {
      /** @type {?} */
      const tView = rootView[TVIEW]; // Create directive instance with factory() and store at next index in viewData

      /** @type {?} */

      const component = instantiateRootComponent(tView, rootView, componentDef);
      rootContext.components.push(component);
      componentView[CONTEXT] = component;
      hostFeatures && hostFeatures.forEach(
      /**
      * @param {?} feature
      * @return {?}
      */
      feature => feature(component, componentDef)); // We want to generate an empty QueryList for root content queries for backwards
      // compatibility with ViewEngine.

      if (componentDef.contentQueries) {
        componentDef.contentQueries(1
        /* Create */
        , component, rootView.length - 1);
      }
      /** @type {?} */


      const rootTNode = getPreviousOrParentTNode();

      if (tView.firstTemplatePass && componentDef.hostBindings) {
        /** @type {?} */
        const elementIndex = rootTNode.index - HEADER_OFFSET;
        setActiveHostElement(elementIndex);
        /** @type {?} */

        const expando =
        /** @type {?} */
        tView.expandoInstructions;
        invokeHostBindingsInCreationMode(componentDef, expando, component, rootTNode, tView.firstTemplatePass);
        setActiveHostElement(null);
      }

      return component;
    }
    /**
     * @param {?=} scheduler
     * @param {?=} playerHandler
     * @return {?}
     */


    function createRootContext(scheduler, playerHandler) {
      return {
        components: [],
        scheduler: scheduler || defaultScheduler,
        clean: CLEAN_PROMISE,
        playerHandler: playerHandler || null,
        flags: 0
        /* Empty */

      };
    }
    /**
     * Used to enable lifecycle hooks on the root component.
     *
     * Include this feature when calling `renderComponent` if the root component
     * you are rendering has lifecycle hooks defined. Otherwise, the hooks won't
     * be called properly.
     *
     * Example:
     *
     * ```
     * renderComponent(AppComponent, {features: [RootLifecycleHooks]});
     * ```
     * @param {?} component
     * @param {?} def
     * @return {?}
     */


    function LifecycleHooksFeature(component, def) {
      /** @type {?} */
      const rootTView =
      /** @type {?} */
      readPatchedLView(component)[TVIEW];
      /** @type {?} */

      const dirIndex = rootTView.data.length - 1;
      registerPreOrderHooks(dirIndex, def, rootTView, -1, -1, -1); // TODO(misko): replace `as TNode` with createTNode call. (needs refactoring to lose dep on
      // LNode).

      registerPostOrderHooks(rootTView,
      /** @type {?} */
      {
        directiveStart: dirIndex,
        directiveEnd: dirIndex + 1
      });
    }
    /**
     * Wait on component until it is rendered.
     *
     * This function returns a `Promise` which is resolved when the component's
     * change detection is executed. This is determined by finding the scheduler
     * associated with the `component`'s render tree and waiting until the scheduler
     * flushes. If nothing is scheduled, the function returns a resolved promise.
     *
     * Example:
     * ```
     * await whenRendered(myComponent);
     * ```
     *
     * @param {?} component Component to wait upon
     * @return {?} Promise which resolves when the component is rendered.
     */


    function whenRendered(component) {
      return getRootContext(component).clean;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Represents a basic change from a previous to a new value for a single
     * property on a directive instance. Passed as a value in a
     * {@link SimpleChanges} object to the `ngOnChanges` hook.
     *
     * @see `OnChanges`
     *
     * @publicApi
     */


    class SimpleChange {
      constructor(previousValue, currentValue, firstChange) {
        this.previousValue = previousValue;
        this.currentValue = currentValue;
        this.firstChange = firstChange;
      }
      /**
       * Check whether the new value is the first value assigned.
       */


      isFirstChange() {
        return this.firstChange;
      }

    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    const PRIVATE_PREFIX = '__ngOnChanges_';
    /**
     * The NgOnChangesFeature decorates a component with support for the ngOnChanges
     * lifecycle hook, so it should be included in any component that implements
     * that hook.
     *
     * If the component or directive uses inheritance, the NgOnChangesFeature MUST
     * be included as a feature AFTER {\@link InheritDefinitionFeature}, otherwise
     * inherited properties will not be propagated to the ngOnChanges lifecycle
     * hook.
     *
     * Example usage:
     *
     * ```
     * static ngComponentDef = defineComponent({
     *   ...
     *   inputs: {name: 'publicName'},
     *   features: [NgOnChangesFeature()]
     * });
     * ```
     *
     * \@codeGenApi
     * @template T
     * @return {?}
     */

    function ɵɵNgOnChangesFeature() {
      // This option ensures that the ngOnChanges lifecycle hook will be inherited
      // from superclasses (in InheritDefinitionFeature).

      /** @type {?} */
      NgOnChangesFeatureImpl.ngInherit = true;
      return NgOnChangesFeatureImpl;
    }
    /**
     * @template T
     * @param {?} definition
     * @return {?}
     */


    function NgOnChangesFeatureImpl(definition) {
      if (definition.type.prototype.ngOnChanges) {
        definition.setInput = ngOnChangesSetInput;
        definition.onChanges = wrapOnChanges();
      }
    }
    /**
     * @return {?}
     */


    function wrapOnChanges() {
      return (
        /**
        * @this {?}
        * @return {?}
        */
        function wrapOnChangesHook_inPreviousChangesStorage() {
          /** @type {?} */
          const simpleChangesStore = getSimpleChangesStore(this);
          /** @type {?} */

          const current = simpleChangesStore && simpleChangesStore.current;

          if (current) {
            /** @type {?} */
            const previous =
            /** @type {?} */
            simpleChangesStore.previous;

            if (previous === EMPTY_OBJ) {
              /** @type {?} */
              simpleChangesStore.previous = current;
            } else {
              // New changes are copied to the previous store, so that we don't lose history for inputs
              // which were not changed this time
              for (let key in current) {
                previous[key] = current[key];
              }
            }

            /** @type {?} */
            simpleChangesStore.current = null;
            this.ngOnChanges(current);
          }
        }
      );
    }
    /**
     * @template T
     * @this {?}
     * @param {?} instance
     * @param {?} value
     * @param {?} publicName
     * @param {?} privateName
     * @return {?}
     */


    function ngOnChangesSetInput(instance, value, publicName, privateName) {
      /** @type {?} */
      const simpleChangesStore = getSimpleChangesStore(instance) || setSimpleChangesStore(instance, {
        previous: EMPTY_OBJ,
        current: null
      });
      /** @type {?} */

      const current = simpleChangesStore.current || (simpleChangesStore.current = {});
      /** @type {?} */

      const previous = simpleChangesStore.previous;
      /** @type {?} */

      const declaredName =
      /** @type {?} */
      this.declaredInputs[publicName];
      /** @type {?} */

      const previousChange = previous[declaredName];
      current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ);

      /** @type {?} */
      instance[privateName] = value;
    }
    /** @type {?} */


    const SIMPLE_CHANGES_STORE = '__ngSimpleChanges__';
    /**
     * @param {?} instance
     * @return {?}
     */

    function getSimpleChangesStore(instance) {
      return instance[SIMPLE_CHANGES_STORE] || null;
    }
    /**
     * @param {?} instance
     * @param {?} store
     * @return {?}
     */


    function setSimpleChangesStore(instance, store) {
      return instance[SIMPLE_CHANGES_STORE] = store;
    }
    /**
     * @record
     */


    function NgSimpleChangesStore() {}

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} type
     * @return {?}
     */


    function getSuperType(type) {
      return Object.getPrototypeOf(type.prototype).constructor;
    }
    /**
     * Merges the definition from a super class to a sub class.
     * \@codeGenApi
     * @param {?} definition The definition that is a SubClass of another directive of component
     *
     * @return {?}
     */


    function ɵɵInheritDefinitionFeature(definition) {
      /** @type {?} */
      let superType = getSuperType(definition.type);

      while (superType) {
        /** @type {?} */
        let superDef = undefined;

        if (isComponentDef(definition)) {
          // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.
          superDef = superType.ngComponentDef || superType.ngDirectiveDef;
        } else {
          if (superType.ngComponentDef) {
            throw new Error('Directives cannot inherit Components');
          } // Don't use getComponentDef/getDirectiveDef. This logic relies on inheritance.


          superDef = superType.ngDirectiveDef;
        }
        /** @nocollapse @type {?} */


        const baseDef =
        /** @type {?} */
        superType.ngBaseDef; // Some fields in the definition may be empty, if there were no values to put in them that
        // would've justified object creation. Unwrap them if necessary.

        if (baseDef || superDef) {
          /** @type {?} */
          const writeableDef =
          /** @type {?} */
          definition;
          writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);
          writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);
          writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);
        }

        if (baseDef) {
          /** @type {?} */
          const baseViewQuery = baseDef.viewQuery;
          /** @type {?} */

          const baseContentQueries = baseDef.contentQueries;
          /** @type {?} */

          const baseHostBindings = baseDef.hostBindings;
          baseHostBindings && inheritHostBindings(definition, baseHostBindings);
          baseViewQuery && inheritViewQuery(definition, baseViewQuery);
          baseContentQueries && inheritContentQueries(definition, baseContentQueries);
          fillProperties(definition.inputs, baseDef.inputs);
          fillProperties(definition.declaredInputs, baseDef.declaredInputs);
          fillProperties(definition.outputs, baseDef.outputs);
        }

        if (superDef) {
          // Merge hostBindings

          /** @type {?} */
          const superHostBindings = superDef.hostBindings;
          superHostBindings && inheritHostBindings(definition, superHostBindings); // Merge queries

          /** @type {?} */

          const superViewQuery = superDef.viewQuery;
          /** @type {?} */

          const superContentQueries = superDef.contentQueries;
          superViewQuery && inheritViewQuery(definition, superViewQuery);
          superContentQueries && inheritContentQueries(definition, superContentQueries); // Merge inputs and outputs

          fillProperties(definition.inputs, superDef.inputs);
          fillProperties(definition.declaredInputs, superDef.declaredInputs);
          fillProperties(definition.outputs, superDef.outputs); // Inherit hooks
          // Assume super class inheritance feature has already run.

          definition.afterContentChecked = definition.afterContentChecked || superDef.afterContentChecked;
          definition.afterContentInit = definition.afterContentInit || superDef.afterContentInit;
          definition.afterViewChecked = definition.afterViewChecked || superDef.afterViewChecked;
          definition.afterViewInit = definition.afterViewInit || superDef.afterViewInit;
          definition.doCheck = definition.doCheck || superDef.doCheck;
          definition.onDestroy = definition.onDestroy || superDef.onDestroy;
          definition.onInit = definition.onInit || superDef.onInit; // Run parent features

          /** @type {?} */

          const features = superDef.features;

          if (features) {
            for (const feature of features) {
              if (feature && feature.ngInherit) {
                /** @type {?} */
                feature(definition);
              }
            }
          }
        } else {
          // Even if we don't have a definition, check the type for the hooks and use those if need be

          /** @type {?} */
          const superPrototype = superType.prototype;

          if (superPrototype) {
            definition.afterContentChecked = definition.afterContentChecked || superPrototype.ngAfterContentChecked;
            definition.afterContentInit = definition.afterContentInit || superPrototype.ngAfterContentInit;
            definition.afterViewChecked = definition.afterViewChecked || superPrototype.ngAfterViewChecked;
            definition.afterViewInit = definition.afterViewInit || superPrototype.ngAfterViewInit;
            definition.doCheck = definition.doCheck || superPrototype.ngDoCheck;
            definition.onDestroy = definition.onDestroy || superPrototype.ngOnDestroy;
            definition.onInit = definition.onInit || superPrototype.ngOnInit;

            if (superPrototype.ngOnChanges) {
              ɵɵNgOnChangesFeature()(definition);
            }
          }
        }

        superType = Object.getPrototypeOf(superType);
      }
    }
    /**
     * @param {?} value
     * @return {?}
     */


    function maybeUnwrapEmpty(value) {
      if (value === EMPTY_OBJ) {
        return {};
      } else if (value === EMPTY_ARRAY) {
        return [];
      } else {
        return value;
      }
    }
    /**
     * @param {?} definition
     * @param {?} superViewQuery
     * @return {?}
     */


    function inheritViewQuery(definition, superViewQuery) {
      /** @type {?} */
      const prevViewQuery = definition.viewQuery;

      if (prevViewQuery) {
        definition.viewQuery =
        /**
        * @param {?} rf
        * @param {?} ctx
        * @return {?}
        */
        (rf, ctx) => {
          superViewQuery(rf, ctx);
          prevViewQuery(rf, ctx);
        };
      } else {
        definition.viewQuery = superViewQuery;
      }
    }
    /**
     * @param {?} definition
     * @param {?} superContentQueries
     * @return {?}
     */


    function inheritContentQueries(definition, superContentQueries) {
      /** @type {?} */
      const prevContentQueries = definition.contentQueries;

      if (prevContentQueries) {
        definition.contentQueries =
        /**
        * @param {?} rf
        * @param {?} ctx
        * @param {?} directiveIndex
        * @return {?}
        */
        (rf, ctx, directiveIndex) => {
          superContentQueries(rf, ctx, directiveIndex);
          prevContentQueries(rf, ctx, directiveIndex);
        };
      } else {
        definition.contentQueries = superContentQueries;
      }
    }
    /**
     * @param {?} definition
     * @param {?} superHostBindings
     * @return {?}
     */


    function inheritHostBindings(definition, superHostBindings) {
      /** @type {?} */
      const prevHostBindings = definition.hostBindings; // If the subclass does not have a host bindings function, we set the subclass host binding
      // function to be the superclass's (in this feature). We should check if they're the same here
      // to ensure we don't inherit it twice.

      if (superHostBindings !== prevHostBindings) {
        if (prevHostBindings) {
          // because inheritance is unknown during compile time, the runtime code
          // needs to be informed of the super-class depth so that instruction code
          // can distinguish one host bindings function from another. The reason why
          // relying on the directive uniqueId exclusively is not enough is because the
          // uniqueId value and the directive instance stay the same between hostBindings
          // calls throughout the directive inheritance chain. This means that without
          // a super-class depth value, there is no way to know whether a parent or
          // sub-class host bindings function is currently being executed.
          definition.hostBindings =
          /**
          * @param {?} rf
          * @param {?} ctx
          * @param {?} elementIndex
          * @return {?}
          */
          (rf, ctx, elementIndex) => {
            // The reason why we increment first and then decrement is so that parent
            // hostBindings calls have a higher id value compared to sub-class hostBindings
            // calls (this way the leaf directive is always at a super-class depth of 0).
            adjustActiveDirectiveSuperClassDepthPosition(1);

            try {
              superHostBindings(rf, ctx, elementIndex);
            } finally {
              adjustActiveDirectiveSuperClassDepthPosition(-1);
            }

            prevHostBindings(rf, ctx, elementIndex);
          };
        } else {
          definition.hostBindings = superHostBindings;
        }
      }
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Resolves the providers which are defined in the DirectiveDef.
     *
     * When inserting the tokens and the factories in their respective arrays, we can assume that
     * this method is called first for the component (if any), and then for other directives on the same
     * node.
     * As a consequence,the providers are always processed in that order:
     * 1) The view providers of the component
     * 2) The providers of the component
     * 3) The providers of the other directives
     * This matches the structure of the injectables arrays of a view (for each node).
     * So the tokens and the factories can be pushed at the end of the arrays, except
     * in one case for multi providers.
     *
     * @template T
     * @param {?} def the directive definition
     * @param {?} providers
     * @param {?} viewProviders
     * @return {?}
     */


    function providersResolver(def, providers, viewProviders) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const tView = lView[TVIEW];

      if (tView.firstTemplatePass) {
        /** @type {?} */
        const isComponent = isComponentDef(def); // The list of view providers is processed first, and the flags are updated

        resolveProvider$1(viewProviders, tView.data, tView.blueprint, isComponent, true); // Then, the list of providers is processed, and the flags are updated

        resolveProvider$1(providers, tView.data, tView.blueprint, isComponent, false);
      }
    }
    /**
     * Resolves a provider and publishes it to the DI system.
     * @param {?} provider
     * @param {?} tInjectables
     * @param {?} lInjectablesBlueprint
     * @param {?} isComponent
     * @param {?} isViewProvider
     * @return {?}
     */


    function resolveProvider$1(provider, tInjectables, lInjectablesBlueprint, isComponent, isViewProvider) {
      provider = resolveForwardRef(provider);

      if (Array.isArray(provider)) {
        // Recursively call `resolveProvider`
        // Recursion is OK in this case because this code will not be in hot-path once we implement
        // cloning of the initial state.
        for (let i = 0; i < provider.length; i++) {
          resolveProvider$1(provider[i], tInjectables, lInjectablesBlueprint, isComponent, isViewProvider);
        }
      } else {
        /** @type {?} */
        const lView = getLView();
        /** @type {?} */

        const tView = lView[TVIEW];
        /** @type {?} */

        let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);
        /** @type {?} */

        let providerFactory = providerToFactory(provider);
        /** @type {?} */

        const tNode = getPreviousOrParentTNode();
        /** @type {?} */

        const beginIndex = tNode.providerIndexes & 65535
        /* ProvidersStartIndexMask */
        ;
        /** @type {?} */

        const endIndex = tNode.directiveStart;
        /** @type {?} */

        const cptViewProvidersCount = tNode.providerIndexes >> 16
        /* CptViewProvidersCountShift */
        ;

        if (isClassProvider(provider) || isTypeProvider(provider)) {
          /** @type {?} */
          const prototype = (
          /** @type {?} */
          provider.useClass || provider).prototype;
          /** @type {?} */

          const ngOnDestroy = prototype.ngOnDestroy;

          if (ngOnDestroy) {
            (tView.destroyHooks || (tView.destroyHooks = [])).push(tInjectables.length, ngOnDestroy);
          }
        }

        if (isTypeProvider(provider) || !provider.multi) {
          // Single provider case: the factory is created and pushed immediately

          /** @type {?} */
          const factory = new NodeInjectorFactory(providerFactory, isViewProvider, ɵɵdirectiveInject);
          /** @type {?} */

          const existingFactoryIndex = indexOf(token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount, endIndex);

          if (existingFactoryIndex == -1) {
            diPublicInInjector(getOrCreateNodeInjectorForNode(
            /** @type {?} */
            tNode, lView), tView, token);
            tInjectables.push(token);
            tNode.directiveStart++;
            tNode.directiveEnd++;

            if (isViewProvider) {
              tNode.providerIndexes += 65536
              /* CptViewProvidersCountShifter */
              ;
            }

            lInjectablesBlueprint.push(factory);
            lView.push(factory);
          } else {
            lInjectablesBlueprint[existingFactoryIndex] = factory;
            lView[existingFactoryIndex] = factory;
          }
        } else {
          // Multi provider case:
          // We create a multi factory which is going to aggregate all the values.
          // Since the output of such a factory depends on content or view injection,
          // we create two of them, which are linked together.
          //
          // The first one (for view providers) is always in the first block of the injectables array,
          // and the second one (for providers) is always in the second block.
          // This is important because view providers have higher priority. When a multi token
          // is being looked up, the view providers should be found first.
          // Note that it is not possible to have a multi factory in the third block (directive block).
          //
          // The algorithm to process multi providers is as follows:
          // 1) If the multi provider comes from the `viewProviders` of the component:
          //   a) If the special view providers factory doesn't exist, it is created and pushed.
          //   b) Else, the multi provider is added to the existing multi factory.
          // 2) If the multi provider comes from the `providers` of the component or of another
          // directive:
          //   a) If the multi factory doesn't exist, it is created and provider pushed into it.
          //      It is also linked to the multi factory for view providers, if it exists.
          //   b) Else, the multi provider is added to the existing multi factory.

          /** @type {?} */
          const existingProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex);
          /** @type {?} */

          const existingViewProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount);
          /** @type {?} */

          const doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingProvidersFactoryIndex];
          /** @type {?} */

          const doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingViewProvidersFactoryIndex];

          if (isViewProvider && !doesViewProvidersFactoryExist || !isViewProvider && !doesProvidersFactoryExist) {
            // Cases 1.a and 2.a
            diPublicInInjector(getOrCreateNodeInjectorForNode(
            /** @type {?} */
            tNode, lView), tView, token);
            /** @type {?} */

            const factory = multiFactory(isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver, lInjectablesBlueprint.length, isViewProvider, isComponent, providerFactory);

            if (!isViewProvider && doesViewProvidersFactoryExist) {
              lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory;
            }

            tInjectables.push(token);
            tNode.directiveStart++;
            tNode.directiveEnd++;

            if (isViewProvider) {
              tNode.providerIndexes += 65536
              /* CptViewProvidersCountShifter */
              ;
            }

            lInjectablesBlueprint.push(factory);
            lView.push(factory);
          } else {
            // Cases 1.b and 2.b
            multiFactoryAdd(
            /** @type {?} */
            lInjectablesBlueprint[isViewProvider ? existingViewProvidersFactoryIndex : existingProvidersFactoryIndex], providerFactory, !isViewProvider && isComponent);
          }

          if (!isViewProvider && isComponent && doesViewProvidersFactoryExist) {
            /** @type {?} */lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++;
          }
        }
      }
    }
    /**
     * Add a factory in a multi factory.
     * @param {?} multiFactory
     * @param {?} factory
     * @param {?} isComponentProvider
     * @return {?}
     */


    function multiFactoryAdd(multiFactory, factory, isComponentProvider) {
      /** @type {?} */
      multiFactory.multi.push(factory);

      if (isComponentProvider) {
        /** @type {?} */multiFactory.componentProviders++;
      }
    }
    /**
     * Returns the index of item in the array, but only in the begin to end range.
     * @param {?} item
     * @param {?} arr
     * @param {?} begin
     * @param {?} end
     * @return {?}
     */


    function indexOf(item, arr, begin, end) {
      for (let i = begin; i < end; i++) {
        if (arr[i] === item) return i;
      }

      return -1;
    }
    /**
     * Use this with `multi` `providers`.
     * @this {?}
     * @param {?} _
     * @param {?} tData
     * @param {?} lData
     * @param {?} tNode
     * @return {?}
     */


    function multiProvidersFactoryResolver(_, tData, lData, tNode) {
      return multiResolve(
      /** @type {?} */
      this.multi, []);
    }
    /**
     * Use this with `multi` `viewProviders`.
     *
     * This factory knows how to concatenate itself with the existing `multi` `providers`.
     * @this {?}
     * @param {?} _
     * @param {?} tData
     * @param {?} lData
     * @param {?} tNode
     * @return {?}
     */


    function multiViewProvidersFactoryResolver(_, tData, lData, tNode) {
      /** @type {?} */
      const factories =
      /** @type {?} */
      this.multi;
      /** @type {?} */

      let result;

      if (this.providerFactory) {
        /** @type {?} */
        const componentCount =
        /** @type {?} */
        this.providerFactory.componentProviders;
        /** @type {?} */

        const multiProviders = getNodeInjectable(tData, lData,
        /** @type {?} */

        /** @type {?} */
        this.providerFactory.index, tNode); // Copy the section of the array which contains `multi` `providers` from the component

        result = multiProviders.slice(0, componentCount); // Insert the `viewProvider` instances.

        multiResolve(factories, result); // Copy the section of the array which contains `multi` `providers` from other directives

        for (let i = componentCount; i < multiProviders.length; i++) {
          result.push(multiProviders[i]);
        }
      } else {
        result = []; // Insert the `viewProvider` instances.

        multiResolve(factories, result);
      }

      return result;
    }
    /**
     * Maps an array of factories into an array of values.
     * @param {?} factories
     * @param {?} result
     * @return {?}
     */


    function multiResolve(factories, result) {
      for (let i = 0; i < factories.length; i++) {
        /** @type {?} */
        const factory =
        /** @type {?} */

        /** @type {?} */
        factories[i];
        result.push(factory());
      }

      return result;
    }
    /**
     * Creates a multi factory.
     * @param {?} factoryFn
     * @param {?} index
     * @param {?} isViewProvider
     * @param {?} isComponent
     * @param {?} f
     * @return {?}
     */


    function multiFactory(factoryFn, index, isViewProvider, isComponent, f) {
      /** @type {?} */
      const factory = new NodeInjectorFactory(factoryFn, isViewProvider, ɵɵdirectiveInject);
      factory.multi = [];
      factory.index = index;
      factory.componentProviders = 0;
      multiFactoryAdd(factory, f, isComponent && !isViewProvider);
      return factory;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * This feature resolves the providers of a directive (or component),
     * and publish them into the DI system, making it visible to others for injection.
     *
     * For example:
     * ```ts
     * class ComponentWithProviders {
     *   constructor(private greeter: GreeterDE) {}
     *
     *   static ngComponentDef = defineComponent({
     *     type: ComponentWithProviders,
     *     selectors: [['component-with-providers']],
     *    factory: () => new ComponentWithProviders(directiveInject(GreeterDE as any)),
     *    consts: 1,
     *    vars: 1,
     *    template: function(fs: RenderFlags, ctx: ComponentWithProviders) {
     *      if (fs & RenderFlags.Create) {
     *        ɵɵtext(0);
     *      }
     *      if (fs & RenderFlags.Update) {
     *        ɵɵselect(0);
     *        ɵɵtextBinding(ctx.greeter.greet());
     *      }
     *    },
     *    features: [ProvidersFeature([GreeterDE])]
     *  });
     * }
     * ```
     *
     * \@codeGenApi
     * @template T
     * @param {?} providers
     * @param {?=} viewProviders
     * @return {?}
     */


    function ɵɵProvidersFeature(providers, viewProviders = []) {
      return (
        /**
        * @param {?} definition
        * @return {?}
        */
        definition => {
          definition.providersResolver =
          /**
          * @param {?} def
          * @param {?=} processProvidersFn
          * @return {?}
          */
          (def, processProvidersFn) => {
            return providersResolver(def, //
            processProvidersFn ? processProvidersFn(providers) : providers, //
            viewProviders);
          };
        }
      );
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Represents a component created by a `ComponentFactory`.
     * Provides access to the component instance and related objects,
     * and provides the means of destroying the instance.
     *
     * \@publicApi
     * @abstract
     * @template C
     */


    class ComponentRef {}

    if (false) {}
    /**
     * Base class for a factory that can create a component dynamically.
     * Instantiate a factory for a given type of component with `resolveComponentFactory()`.
     * Use the resulting `ComponentFactory.create()` method to create a component of that type.
     *
     * @see [Dynamic Components](guide/dynamic-component-loader)
     *
     * \@publicApi
     * @abstract
     * @template C
     */


    class ComponentFactory {}

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} component
     * @return {?}
     */


    function noComponentFactoryError(component) {
      /** @type {?} */
      const error = Error("No component factory found for ".concat(stringify(component), ". Did you add it to @NgModule.entryComponents?"));

      /** @type {?} */
      error[ERROR_COMPONENT] = component;
      return error;
    }
    /** @type {?} */


    const ERROR_COMPONENT = 'ngComponent';
    /**
     * @param {?} error
     * @return {?}
     */

    function getComponent$1(error) {
      return (
        /** @type {?} */
        error[ERROR_COMPONENT]
      );
    }

    class _NullComponentFactoryResolver {
      /**
       * @template T
       * @param {?} component
       * @return {?}
       */
      resolveComponentFactory(component) {
        throw noComponentFactoryError(component);
      }

    }
    /**
     * A simple registry that maps `Components` to generated `ComponentFactory` classes
     * that can be used to create instances of components.
     * Use to obtain the factory for a given component type,
     * then use the factory's `create()` method to create a component of that type.
     *
     * @see [Dynamic Components](guide/dynamic-component-loader)
     * \@publicApi
     * @abstract
     */


    class ComponentFactoryResolver {}

    ComponentFactoryResolver.NULL = new _NullComponentFactoryResolver();

    if (false) {}

    class CodegenComponentFactoryResolver {
      /**
       * @param {?} factories
       * @param {?} _parent
       * @param {?} _ngModule
       */
      constructor(factories, _parent, _ngModule) {
        this._parent = _parent;
        this._ngModule = _ngModule;
        this._factories = new Map();

        for (let i = 0; i < factories.length; i++) {
          /** @type {?} */
          const factory = factories[i];

          this._factories.set(factory.componentType, factory);
        }
      }
      /**
       * @template T
       * @param {?} component
       * @return {?}
       */


      resolveComponentFactory(component) {
        /** @type {?} */
        let factory = this._factories.get(component);

        if (!factory && this._parent) {
          factory = this._parent.resolveComponentFactory(component);
        }

        if (!factory) {
          throw noComponentFactoryError(component);
        }

        return new ComponentFactoryBoundToModule(factory, this._ngModule);
      }

    }

    if (false) {}
    /**
     * @template C
     */


    class ComponentFactoryBoundToModule extends ComponentFactory {
      /**
       * @param {?} factory
       * @param {?} ngModule
       */
      constructor(factory, ngModule) {
        super();
        this.factory = factory;
        this.ngModule = ngModule;
        this.selector = factory.selector;
        this.componentType = factory.componentType;
        this.ngContentSelectors = factory.ngContentSelectors;
        this.inputs = factory.inputs;
        this.outputs = factory.outputs;
      }
      /**
       * @param {?} injector
       * @param {?=} projectableNodes
       * @param {?=} rootSelectorOrNode
       * @param {?=} ngModule
       * @return {?}
       */


      create(injector, projectableNodes, rootSelectorOrNode, ngModule) {
        return this.factory.create(injector, projectableNodes, rootSelectorOrNode, ngModule || this.ngModule);
      }

    }

    if (false) {}
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    function noop(...args) {} // Do nothing.

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * A wrapper around a native element inside of a View.
     *
     * An `ElementRef` is backed by a render-specific element. In the browser, this is usually a DOM
     * element.
     *
     * \@security Permitting direct access to the DOM can make your application more vulnerable to
     * XSS attacks. Carefully review any use of `ElementRef` in your code. For more detail, see the
     * [Security Guide](http://g.co/ng/security).
     *
     * \@publicApi
     * @template T
     */
    // Note: We don't expose things like `Injector`, `ViewContainer`, ... here,
    // i.e. users have to ask for what they need. With that, we can build better analysis tools
    // and could do better codegen in the future.


    class ElementRef {
      /**
       * @param {?} nativeElement
       */
      constructor(nativeElement) {
        this.nativeElement = nativeElement;
      }

    }
    /**
     * \@internal
     * @nocollapse
     */


    ElementRef.__NG_ELEMENT_ID__ =
    /**
    * @return {?}
    */
    () => SWITCH_ELEMENT_REF_FACTORY(ElementRef);

    if (false) {}
    /** @type {?} */


    const SWITCH_ELEMENT_REF_FACTORY__POST_R3__ = injectElementRef;
    /** @type {?} */

    const SWITCH_ELEMENT_REF_FACTORY__PRE_R3__ = noop;
    /** @type {?} */

    const SWITCH_ELEMENT_REF_FACTORY = SWITCH_ELEMENT_REF_FACTORY__PRE_R3__;
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @deprecated Use `RendererType2` (and `Renderer2`) instead.
     * \@publicApi
     */

    class RenderComponentType {
      /**
       * @param {?} id
       * @param {?} templateUrl
       * @param {?} slotCount
       * @param {?} encapsulation
       * @param {?} styles
       * @param {?} animations
       */
      constructor(id, templateUrl, slotCount, encapsulation, styles, animations) {
        this.id = id;
        this.templateUrl = templateUrl;
        this.slotCount = slotCount;
        this.encapsulation = encapsulation;
        this.styles = styles;
        this.animations = animations;
      }

    }

    if (false) {}
    /**
     * @deprecated Debug info is handled internally in the view engine now.
     * @abstract
     */


    class RenderDebugInfo {}

    if (false) {}
    /**
     * @deprecated Use the `Renderer2` instead.
     * @record
     */


    function DirectRenderer() {}

    if (false) {}
    /**
     * @deprecated Use the `Renderer2` instead.
     * \@publicApi
     * @abstract
     */


    class Renderer {}

    if (false) {}
    /** @type {?} */


    const Renderer2Interceptor = new InjectionToken('Renderer2Interceptor');
    /**
     * Injectable service that provides a low-level interface for modifying the UI.
     *
     * Use this service to bypass Angular's templating and make custom UI changes that can't be
     * expressed declaratively. For example if you need to set a property or an attribute whose name is
     * not statically known, use {\@link Renderer#setElementProperty setElementProperty} or
     * {\@link Renderer#setElementAttribute setElementAttribute} respectively.
     *
     * If you are implementing a custom renderer, you must implement this interface.
     *
     * The default Renderer implementation is `DomRenderer`. Also available is `WebWorkerRenderer`.
     *
     * @deprecated Use `RendererFactory2` instead.
     * \@publicApi
     * @abstract
     */

    class RootRenderer {}

    if (false) {}
    /**
     * Used by `RendererFactory2` to associate custom rendering data and styles
     * with a rendering implementation.
     * \@publicApi
     * @record
     */


    function RendererType2() {}

    if (false) {}
    /**
     * Creates and initializes a custom renderer that implements the `Renderer2` base class.
     *
     * \@publicApi
     * @abstract
     */


    class RendererFactory2 {}

    if (false) {}
    /** @enum {number} */


    const RendererStyleFlags2 = {
      /**
       * Marks a style as important.
       */
      Important: 1,

      /**
       * Marks a style as using dash case naming (this-is-dash-case).
       */
      DashCase: 2
    };
    RendererStyleFlags2[RendererStyleFlags2.Important] = 'Important';
    RendererStyleFlags2[RendererStyleFlags2.DashCase] = 'DashCase';
    /**
     * Extend this base class to implement custom rendering. By default, Angular
     * renders a template into DOM. You can use custom rendering to intercept
     * rendering calls, or to render to something other than DOM.
     *
     * Create your custom renderer using `RendererFactory2`.
     *
     * Use a custom renderer to bypass Angular's templating and
     * make custom UI changes that can't be expressed declaratively.
     * For example if you need to set a property or an attribute whose name is
     * not statically known, use the `setProperty()` or
     * `setAttribute()` method.
     *
     * \@publicApi
     * @abstract
     */

    class Renderer2 {}
    /**
     * \@internal
     * @nocollapse
     */


    Renderer2.__NG_ELEMENT_ID__ =
    /**
    * @return {?}
    */
    () => SWITCH_RENDERER2_FACTORY();

    if (false) {}
    /** @type {?} */


    const SWITCH_RENDERER2_FACTORY__POST_R3__ = injectRenderer2;
    /** @type {?} */

    const SWITCH_RENDERER2_FACTORY__PRE_R3__ = noop;
    /** @type {?} */

    const SWITCH_RENDERER2_FACTORY = SWITCH_RENDERER2_FACTORY__PRE_R3__;
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * \@description Represents the version of Angular
     *
     * \@publicApi
     */

    class Version {
      /**
       * @param {?} full
       */
      constructor(full) {
        this.full = full;
        this.major = full.split('.')[0];
        this.minor = full.split('.')[1];
        this.patch = full.split('.').slice(2).join('.');
      }

    }

    if (false) {}
    /**
     * \@publicApi
     * @type {?}
     */


    const VERSION = new Version('8.2.14');
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    class DefaultIterableDifferFactory {
      constructor() {}
      /**
       * @param {?} obj
       * @return {?}
       */


      supports(obj) {
        return isListLikeIterable$1(obj);
      }
      /**
       * @template V
       * @param {?=} trackByFn
       * @return {?}
       */


      create(trackByFn) {
        return new DefaultIterableDiffer(trackByFn);
      }

    }
    /** @type {?} */


    const trackByIdentity =
    /**
    * @param {?} index
    * @param {?} item
    * @return {?}
    */
    (index, item) => item;

    const ɵ0$d = trackByIdentity;
    /**
     * @deprecated v4.0.0 - Should not be part of public API.
     * \@publicApi
     * @template V
     */

    class DefaultIterableDiffer {
      /**
       * @param {?=} trackByFn
       */
      constructor(trackByFn) {
        this.length = 0; // Keeps track of the used records at any point in time (during & across `_check()` calls)

        this._linkedRecords = null; // Keeps track of the removed records at any point in time during `_check()` calls.

        this._unlinkedRecords = null;
        this._previousItHead = null;
        this._itHead = null;
        this._itTail = null;
        this._additionsHead = null;
        this._additionsTail = null;
        this._movesHead = null;
        this._movesTail = null;
        this._removalsHead = null;
        this._removalsTail = null; // Keeps track of records where custom track by is the same, but item identity has changed

        this._identityChangesHead = null;
        this._identityChangesTail = null;
        this._trackByFn = trackByFn || trackByIdentity;
      }
      /**
       * @param {?} fn
       * @return {?}
       */


      forEachItem(fn) {
        /** @type {?} */
        let record;

        for (record = this._itHead; record !== null; record = record._next) {
          fn(record);
        }
      }
      /**
       * @param {?} fn
       * @return {?}
       */


      forEachOperation(fn) {
        /** @type {?} */
        let nextIt = this._itHead;
        /** @type {?} */

        let nextRemove = this._removalsHead;
        /** @type {?} */

        let addRemoveOffset = 0;
        /** @type {?} */

        let moveOffsets = null;

        while (nextIt || nextRemove) {
          // Figure out which is the next record to process
          // Order: remove, add, move

          /** @type {?} */
          const record = !nextRemove || nextIt &&
          /** @type {?} */
          nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ?
          /** @type {?} */
          nextIt : nextRemove;
          /** @type {?} */

          const adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);
          /** @type {?} */

          const currentIndex = record.currentIndex; // consume the item, and adjust the addRemoveOffset and update moveDistance if necessary

          if (record === nextRemove) {
            addRemoveOffset--;
            nextRemove = nextRemove._nextRemoved;
          } else {
            nextIt =
            /** @type {?} */
            nextIt._next;

            if (record.previousIndex == null) {
              addRemoveOffset++;
            } else {
              // INVARIANT:  currentIndex < previousIndex
              if (!moveOffsets) moveOffsets = [];
              /** @type {?} */

              const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;
              /** @type {?} */

              const localCurrentIndex =
              /** @type {?} */
              currentIndex - addRemoveOffset;

              if (localMovePreviousIndex != localCurrentIndex) {
                for (let i = 0; i < localMovePreviousIndex; i++) {
                  /** @type {?} */
                  const offset = i < moveOffsets.length ? moveOffsets[i] : moveOffsets[i] = 0;
                  /** @type {?} */

                  const index = offset + i;

                  if (localCurrentIndex <= index && index < localMovePreviousIndex) {
                    moveOffsets[i] = offset + 1;
                  }
                }
                /** @type {?} */


                const previousIndex = record.previousIndex;
                moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;
              }
            }
          }

          if (adjPreviousIndex !== currentIndex) {
            fn(record, adjPreviousIndex, currentIndex);
          }
        }
      }
      /**
       * @param {?} fn
       * @return {?}
       */


      forEachPreviousItem(fn) {
        /** @type {?} */
        let record;

        for (record = this._previousItHead; record !== null; record = record._nextPrevious) {
          fn(record);
        }
      }
      /**
       * @param {?} fn
       * @return {?}
       */


      forEachAddedItem(fn) {
        /** @type {?} */
        let record;

        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
          fn(record);
        }
      }
      /**
       * @param {?} fn
       * @return {?}
       */


      forEachMovedItem(fn) {
        /** @type {?} */
        let record;

        for (record = this._movesHead; record !== null; record = record._nextMoved) {
          fn(record);
        }
      }
      /**
       * @param {?} fn
       * @return {?}
       */


      forEachRemovedItem(fn) {
        /** @type {?} */
        let record;

        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
          fn(record);
        }
      }
      /**
       * @param {?} fn
       * @return {?}
       */


      forEachIdentityChange(fn) {
        /** @type {?} */
        let record;

        for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {
          fn(record);
        }
      }
      /**
       * @param {?} collection
       * @return {?}
       */


      diff(collection) {
        if (collection == null) collection = [];

        if (!isListLikeIterable$1(collection)) {
          throw new Error("Error trying to diff '".concat(stringify(collection), "'. Only arrays and iterables are allowed"));
        }

        if (this.check(collection)) {
          return this;
        } else {
          return null;
        }
      }
      /**
       * @return {?}
       */


      onDestroy() {}
      /**
       * @param {?} collection
       * @return {?}
       */


      check(collection) {
        this._reset();
        /** @type {?} */


        let record = this._itHead;
        /** @type {?} */

        let mayBeDirty = false;
        /** @type {?} */

        let index;
        /** @type {?} */

        let item;
        /** @type {?} */

        let itemTrackBy;

        if (Array.isArray(collection)) {
          /** @type {?} */
          this.length = collection.length;

          for (let index = 0; index < this.length; index++) {
            item = collection[index];
            itemTrackBy = this._trackByFn(index, item);

            if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {
              record = this._mismatch(record, item, itemTrackBy, index);
              mayBeDirty = true;
            } else {
              if (mayBeDirty) {
                // TODO(misko): can we limit this to duplicates only?
                record = this._verifyReinsertion(record, item, itemTrackBy, index);
              }

              if (!looseIdentical(record.item, item)) this._addIdentityChange(record, item);
            }

            record = record._next;
          }
        } else {
          index = 0;
          iterateListLike$1(collection,
          /**
          * @param {?} item
          * @return {?}
          */
          item => {
            itemTrackBy = this._trackByFn(index, item);

            if (record === null || !looseIdentical(record.trackById, itemTrackBy)) {
              record = this._mismatch(record, item, itemTrackBy, index);
              mayBeDirty = true;
            } else {
              if (mayBeDirty) {
                // TODO(misko): can we limit this to duplicates only?
                record = this._verifyReinsertion(record, item, itemTrackBy, index);
              }

              if (!looseIdentical(record.item, item)) this._addIdentityChange(record, item);
            }

            record = record._next;
            index++;
          });

          /** @type {?} */
          this.length = index;
        }

        this._truncate(record);

        /** @type {?} */
        this.collection = collection;
        return this.isDirty;
      }
      /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity
         * changes.
         */

      /**
       * @return {?}
       */


      get isDirty() {
        return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null || this._identityChangesHead !== null;
      }
      /**
       * Reset the state of the change objects to show no changes. This means set previousKey to
       * currentKey, and clear all of the queues (additions, moves, removals).
       * Set the previousIndexes of moved and added items to their currentIndexes
       * Reset the list of additions, moves and removals
       *
       * \@internal
       * @return {?}
       */


      _reset() {
        if (this.isDirty) {
          /** @type {?} */
          let record;
          /** @type {?} */

          let nextRecord;

          for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {
            record._nextPrevious = record._next;
          }

          for (record = this._additionsHead; record !== null; record = record._nextAdded) {
            record.previousIndex = record.currentIndex;
          }

          this._additionsHead = this._additionsTail = null;

          for (record = this._movesHead; record !== null; record = nextRecord) {
            record.previousIndex = record.currentIndex;
            nextRecord = record._nextMoved;
          }

          this._movesHead = this._movesTail = null;
          this._removalsHead = this._removalsTail = null;
          this._identityChangesHead = this._identityChangesTail = null; // TODO(vicb): when assert gets supported
          // assert(!this.isDirty);
        }
      }
      /**
       * This is the core function which handles differences between collections.
       *
       * - `record` is the record which we saw at this position last time. If null then it is a new
       *   item.
       * - `item` is the current item in the collection
       * - `index` is the position of the item in the collection
       *
       * \@internal
       * @param {?} record
       * @param {?} item
       * @param {?} itemTrackBy
       * @param {?} index
       * @return {?}
       */


      _mismatch(record, item, itemTrackBy, index) {
        // The previous record after which we will append the current one.

        /** @type {?} */
        let previousRecord;

        if (record === null) {
          previousRecord = this._itTail;
        } else {
          previousRecord = record._prev; // Remove the record from the collection since we know it does not match the item.

          this._remove(record);
        } // Attempt to see if we have seen the item before.


        record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);

        if (record !== null) {
          // We have seen this before, we need to move it forward in the collection.
          // But first we need to check if identity changed, so we can update in view if necessary
          if (!looseIdentical(record.item, item)) this._addIdentityChange(record, item);

          this._moveAfter(record, previousRecord, index);
        } else {
          // Never seen it, check evicted list.
          record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);

          if (record !== null) {
            // It is an item which we have evicted earlier: reinsert it back into the list.
            // But first we need to check if identity changed, so we can update in view if necessary
            if (!looseIdentical(record.item, item)) this._addIdentityChange(record, item);

            this._reinsertAfter(record, previousRecord, index);
          } else {
            // It is a new item: add it.
            record = this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index);
          }
        }

        return record;
      }
      /**
       * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)
       *
       * Use case: `[a, a]` => `[b, a, a]`
       *
       * If we did not have this check then the insertion of `b` would:
       *   1) evict first `a`
       *   2) insert `b` at `0` index.
       *   3) leave `a` at index `1` as is. <-- this is wrong!
       *   3) reinsert `a` at index 2. <-- this is wrong!
       *
       * The correct behavior is:
       *   1) evict first `a`
       *   2) insert `b` at `0` index.
       *   3) reinsert `a` at index 1.
       *   3) move `a` at from `1` to `2`.
       *
       *
       * Double check that we have not evicted a duplicate item. We need to check if the item type may
       * have already been removed:
       * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted
       * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a
       * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'
       * at the end.
       *
       * \@internal
       * @param {?} record
       * @param {?} item
       * @param {?} itemTrackBy
       * @param {?} index
       * @return {?}
       */


      _verifyReinsertion(record, item, itemTrackBy, index) {
        /** @type {?} */
        let reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);

        if (reinsertRecord !== null) {
          record = this._reinsertAfter(reinsertRecord,
          /** @type {?} */
          record._prev, index);
        } else if (record.currentIndex != index) {
          record.currentIndex = index;

          this._addToMoves(record, index);
        }

        return record;
      }
      /**
       * Get rid of any excess {\@link IterableChangeRecord_}s from the previous collection
       *
       * - `record` The first excess {\@link IterableChangeRecord_}.
       *
       * \@internal
       * @param {?} record
       * @return {?}
       */


      _truncate(record) {
        // Anything after that needs to be removed;
        while (record !== null) {
          /** @type {?} */
          const nextRecord = record._next;

          this._addToRemovals(this._unlink(record));

          record = nextRecord;
        }

        if (this._unlinkedRecords !== null) {
          this._unlinkedRecords.clear();
        }

        if (this._additionsTail !== null) {
          this._additionsTail._nextAdded = null;
        }

        if (this._movesTail !== null) {
          this._movesTail._nextMoved = null;
        }

        if (this._itTail !== null) {
          this._itTail._next = null;
        }

        if (this._removalsTail !== null) {
          this._removalsTail._nextRemoved = null;
        }

        if (this._identityChangesTail !== null) {
          this._identityChangesTail._nextIdentityChange = null;
        }
      }
      /**
       * \@internal
       * @param {?} record
       * @param {?} prevRecord
       * @param {?} index
       * @return {?}
       */


      _reinsertAfter(record, prevRecord, index) {
        if (this._unlinkedRecords !== null) {
          this._unlinkedRecords.remove(record);
        }
        /** @type {?} */


        const prev = record._prevRemoved;
        /** @type {?} */

        const next = record._nextRemoved;

        if (prev === null) {
          this._removalsHead = next;
        } else {
          prev._nextRemoved = next;
        }

        if (next === null) {
          this._removalsTail = prev;
        } else {
          next._prevRemoved = prev;
        }

        this._insertAfter(record, prevRecord, index);

        this._addToMoves(record, index);

        return record;
      }
      /**
       * \@internal
       * @param {?} record
       * @param {?} prevRecord
       * @param {?} index
       * @return {?}
       */


      _moveAfter(record, prevRecord, index) {
        this._unlink(record);

        this._insertAfter(record, prevRecord, index);

        this._addToMoves(record, index);

        return record;
      }
      /**
       * \@internal
       * @param {?} record
       * @param {?} prevRecord
       * @param {?} index
       * @return {?}
       */


      _addAfter(record, prevRecord, index) {
        this._insertAfter(record, prevRecord, index);

        if (this._additionsTail === null) {
          // TODO(vicb):
          // assert(this._additionsHead === null);
          this._additionsTail = this._additionsHead = record;
        } else {
          // TODO(vicb):
          // assert(_additionsTail._nextAdded === null);
          // assert(record._nextAdded === null);
          this._additionsTail = this._additionsTail._nextAdded = record;
        }

        return record;
      }
      /**
       * \@internal
       * @param {?} record
       * @param {?} prevRecord
       * @param {?} index
       * @return {?}
       */


      _insertAfter(record, prevRecord, index) {
        // TODO(vicb):
        // assert(record != prevRecord);
        // assert(record._next === null);
        // assert(record._prev === null);
        // TODO(vicb):
        // assert(record != prevRecord);
        // assert(record._next === null);
        // assert(record._prev === null);

        /** @type {?} */
        const next = prevRecord === null ? this._itHead : prevRecord._next; // TODO(vicb):
        // assert(next != record);
        // assert(prevRecord != record);

        record._next = next;
        record._prev = prevRecord;

        if (next === null) {
          this._itTail = record;
        } else {
          next._prev = record;
        }

        if (prevRecord === null) {
          this._itHead = record;
        } else {
          prevRecord._next = record;
        }

        if (this._linkedRecords === null) {
          this._linkedRecords = new _DuplicateMap();
        }

        this._linkedRecords.put(record);

        record.currentIndex = index;
        return record;
      }
      /**
       * \@internal
       * @param {?} record
       * @return {?}
       */


      _remove(record) {
        return this._addToRemovals(this._unlink(record));
      }
      /**
       * \@internal
       * @param {?} record
       * @return {?}
       */


      _unlink(record) {
        if (this._linkedRecords !== null) {
          this._linkedRecords.remove(record);
        }
        /** @type {?} */


        const prev = record._prev;
        /** @type {?} */

        const next = record._next; // TODO(vicb):
        // assert((record._prev = null) === null);
        // assert((record._next = null) === null);

        if (prev === null) {
          this._itHead = next;
        } else {
          prev._next = next;
        }

        if (next === null) {
          this._itTail = prev;
        } else {
          next._prev = prev;
        }

        return record;
      }
      /**
       * \@internal
       * @param {?} record
       * @param {?} toIndex
       * @return {?}
       */


      _addToMoves(record, toIndex) {
        // TODO(vicb):
        // assert(record._nextMoved === null);
        if (record.previousIndex === toIndex) {
          return record;
        }

        if (this._movesTail === null) {
          // TODO(vicb):
          // assert(_movesHead === null);
          this._movesTail = this._movesHead = record;
        } else {
          // TODO(vicb):
          // assert(_movesTail._nextMoved === null);
          this._movesTail = this._movesTail._nextMoved = record;
        }

        return record;
      }
      /**
       * @private
       * @param {?} record
       * @return {?}
       */


      _addToRemovals(record) {
        if (this._unlinkedRecords === null) {
          this._unlinkedRecords = new _DuplicateMap();
        }

        this._unlinkedRecords.put(record);

        record.currentIndex = null;
        record._nextRemoved = null;

        if (this._removalsTail === null) {
          // TODO(vicb):
          // assert(_removalsHead === null);
          this._removalsTail = this._removalsHead = record;
          record._prevRemoved = null;
        } else {
          // TODO(vicb):
          // assert(_removalsTail._nextRemoved === null);
          // assert(record._nextRemoved === null);
          record._prevRemoved = this._removalsTail;
          this._removalsTail = this._removalsTail._nextRemoved = record;
        }

        return record;
      }
      /**
       * \@internal
       * @param {?} record
       * @param {?} item
       * @return {?}
       */


      _addIdentityChange(record, item) {
        record.item = item;

        if (this._identityChangesTail === null) {
          this._identityChangesTail = this._identityChangesHead = record;
        } else {
          this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;
        }

        return record;
      }

    }

    if (false) {}
    /**
     * @template V
     */


    class IterableChangeRecord_ {
      /**
       * @param {?} item
       * @param {?} trackById
       */
      constructor(item, trackById) {
        this.item = item;
        this.trackById = trackById;
        this.currentIndex = null;
        this.previousIndex = null;
        /**
         * \@internal
         */

        this._nextPrevious = null;
        /**
         * \@internal
         */

        this._prev = null;
        /**
         * \@internal
         */

        this._next = null;
        /**
         * \@internal
         */

        this._prevDup = null;
        /**
         * \@internal
         */

        this._nextDup = null;
        /**
         * \@internal
         */

        this._prevRemoved = null;
        /**
         * \@internal
         */

        this._nextRemoved = null;
        /**
         * \@internal
         */

        this._nextAdded = null;
        /**
         * \@internal
         */

        this._nextMoved = null;
        /**
         * \@internal
         */

        this._nextIdentityChange = null;
      }

    }

    if (false) {} // A linked list of CollectionChangeRecords with the same IterableChangeRecord_.item

    /**
     * @template V
     */


    class _DuplicateItemRecordList {
      constructor() {
        /**
         * \@internal
         */
        this._head = null;
        /**
         * \@internal
         */

        this._tail = null;
      }
      /**
       * Append the record to the list of duplicates.
       *
       * Note: by design all records in the list of duplicates hold the same value in record.item.
       * @param {?} record
       * @return {?}
       */


      add(record) {
        if (this._head === null) {
          this._head = this._tail = record;
          record._nextDup = null;
          record._prevDup = null;
        } else {
          // TODO(vicb):
          // assert(record.item ==  _head.item ||
          //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);

          /** @type {?} */
          this._tail._nextDup = record;
          record._prevDup = this._tail;
          record._nextDup = null;
          this._tail = record;
        }
      } // Returns a IterableChangeRecord_ having IterableChangeRecord_.trackById == trackById and
      // IterableChangeRecord_.currentIndex >= atOrAfterIndex

      /**
       * @param {?} trackById
       * @param {?} atOrAfterIndex
       * @return {?}
       */


      get(trackById, atOrAfterIndex) {
        /** @type {?} */
        let record;

        for (record = this._head; record !== null; record = record._nextDup) {
          if ((atOrAfterIndex === null || atOrAfterIndex <=
          /** @type {?} */
          record.currentIndex) && looseIdentical(record.trackById, trackById)) {
            return record;
          }
        }

        return null;
      }
      /**
       * Remove one {\@link IterableChangeRecord_} from the list of duplicates.
       *
       * Returns whether the list of duplicates is empty.
       * @param {?} record
       * @return {?}
       */


      remove(record) {
        // TODO(vicb):
        // assert(() {
        //  // verify that the record being removed is in the list.
        //  for (IterableChangeRecord_ cursor = _head; cursor != null; cursor = cursor._nextDup) {
        //    if (identical(cursor, record)) return true;
        //  }
        //  return false;
        //});
        // TODO(vicb):
        // assert(() {
        //  // verify that the record being removed is in the list.
        //  for (IterableChangeRecord_ cursor = _head; cursor != null; cursor = cursor._nextDup) {
        //    if (identical(cursor, record)) return true;
        //  }
        //  return false;
        //});

        /** @type {?} */
        const prev = record._prevDup;
        /** @type {?} */

        const next = record._nextDup;

        if (prev === null) {
          this._head = next;
        } else {
          prev._nextDup = next;
        }

        if (next === null) {
          this._tail = prev;
        } else {
          next._prevDup = prev;
        }

        return this._head === null;
      }

    }

    if (false) {}
    /**
     * @template V
     */


    class _DuplicateMap {
      constructor() {
        this.map = new Map();
      }
      /**
       * @param {?} record
       * @return {?}
       */


      put(record) {
        /** @type {?} */
        const key = record.trackById;
        /** @type {?} */

        let duplicates = this.map.get(key);

        if (!duplicates) {
          duplicates = new _DuplicateItemRecordList();
          this.map.set(key, duplicates);
        }

        duplicates.add(record);
      }
      /**
       * Retrieve the `value` using key. Because the IterableChangeRecord_ value may be one which we
       * have already iterated over, we use the `atOrAfterIndex` to pretend it is not there.
       *
       * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we
       * have any more `a`s needs to return the second `a`.
       * @param {?} trackById
       * @param {?} atOrAfterIndex
       * @return {?}
       */


      get(trackById, atOrAfterIndex) {
        /** @type {?} */
        const key = trackById;
        /** @type {?} */

        const recordList = this.map.get(key);
        return recordList ? recordList.get(trackById, atOrAfterIndex) : null;
      }
      /**
       * Removes a {\@link IterableChangeRecord_} from the list of duplicates.
       *
       * The list of duplicates also is removed from the map if it gets empty.
       * @param {?} record
       * @return {?}
       */


      remove(record) {
        /** @type {?} */
        const key = record.trackById;
        /** @type {?} */

        const recordList =
        /** @type {?} */
        this.map.get(key); // Remove the list of duplicates when it gets empty

        if (recordList.remove(record)) {
          this.map.delete(key);
        }

        return record;
      }
      /**
       * @return {?}
       */


      get isEmpty() {
        return this.map.size === 0;
      }
      /**
       * @return {?}
       */


      clear() {
        this.map.clear();
      }

    }

    if (false) {}
    /**
     * @param {?} item
     * @param {?} addRemoveOffset
     * @param {?} moveOffsets
     * @return {?}
     */


    function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
      /** @type {?} */
      const previousIndex = item.previousIndex;
      if (previousIndex === null) return previousIndex;
      /** @type {?} */

      let moveOffset = 0;

      if (moveOffsets && previousIndex < moveOffsets.length) {
        moveOffset = moveOffsets[previousIndex];
      }

      return previousIndex + addRemoveOffset + moveOffset;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @template K, V
     */


    class DefaultKeyValueDifferFactory {
      constructor() {}
      /**
       * @param {?} obj
       * @return {?}
       */


      supports(obj) {
        return obj instanceof Map || isJsObject$1(obj);
      }
      /**
       * @template K, V
       * @return {?}
       */


      create() {
        return new DefaultKeyValueDiffer();
      }

    }
    /**
     * @template K, V
     */


    class DefaultKeyValueDiffer {
      constructor() {
        this._records = new Map();
        this._mapHead = null; // _appendAfter is used in the check loop

        this._appendAfter = null;
        this._previousMapHead = null;
        this._changesHead = null;
        this._changesTail = null;
        this._additionsHead = null;
        this._additionsTail = null;
        this._removalsHead = null;
        this._removalsTail = null;
      }
      /**
       * @return {?}
       */


      get isDirty() {
        return this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null;
      }
      /**
       * @param {?} fn
       * @return {?}
       */


      forEachItem(fn) {
        /** @type {?} */
        let record;

        for (record = this._mapHead; record !== null; record = record._next) {
          fn(record);
        }
      }
      /**
       * @param {?} fn
       * @return {?}
       */


      forEachPreviousItem(fn) {
        /** @type {?} */
        let record;

        for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {
          fn(record);
        }
      }
      /**
       * @param {?} fn
       * @return {?}
       */


      forEachChangedItem(fn) {
        /** @type {?} */
        let record;

        for (record = this._changesHead; record !== null; record = record._nextChanged) {
          fn(record);
        }
      }
      /**
       * @param {?} fn
       * @return {?}
       */


      forEachAddedItem(fn) {
        /** @type {?} */
        let record;

        for (record = this._additionsHead; record !== null; record = record._nextAdded) {
          fn(record);
        }
      }
      /**
       * @param {?} fn
       * @return {?}
       */


      forEachRemovedItem(fn) {
        /** @type {?} */
        let record;

        for (record = this._removalsHead; record !== null; record = record._nextRemoved) {
          fn(record);
        }
      }
      /**
       * @param {?=} map
       * @return {?}
       */


      diff(map) {
        if (!map) {
          map = new Map();
        } else if (!(map instanceof Map || isJsObject$1(map))) {
          throw new Error("Error trying to diff '".concat(stringify(map), "'. Only maps and objects are allowed"));
        }

        return this.check(map) ? this : null;
      }
      /**
       * @return {?}
       */


      onDestroy() {}
      /**
       * Check the current state of the map vs the previous.
       * The algorithm is optimised for when the keys do no change.
       * @param {?} map
       * @return {?}
       */


      check(map) {
        this._reset();
        /** @type {?} */


        let insertBefore = this._mapHead;
        this._appendAfter = null;

        this._forEach(map,
        /**
        * @param {?} value
        * @param {?} key
        * @return {?}
        */
        (value, key) => {
          if (insertBefore && insertBefore.key === key) {
            this._maybeAddToChanges(insertBefore, value);

            this._appendAfter = insertBefore;
            insertBefore = insertBefore._next;
          } else {
            /** @type {?} */
            const record = this._getOrCreateRecordForKey(key, value);

            insertBefore = this._insertBeforeOrAppend(insertBefore, record);
          }
        }); // Items remaining at the end of the list have been deleted


        if (insertBefore) {
          if (insertBefore._prev) {
            insertBefore._prev._next = null;
          }

          this._removalsHead = insertBefore;

          for (let record = insertBefore; record !== null; record = record._nextRemoved) {
            if (record === this._mapHead) {
              this._mapHead = null;
            }

            this._records.delete(record.key);

            record._nextRemoved = record._next;
            record.previousValue = record.currentValue;
            record.currentValue = null;
            record._prev = null;
            record._next = null;
          }
        } // Make sure tails have no next records from previous runs


        if (this._changesTail) this._changesTail._nextChanged = null;
        if (this._additionsTail) this._additionsTail._nextAdded = null;
        return this.isDirty;
      }
      /**
       * Inserts a record before `before` or append at the end of the list when `before` is null.
       *
       * Notes:
       * - This method appends at `this._appendAfter`,
       * - This method updates `this._appendAfter`,
       * - The return value is the new value for the insertion pointer.
       * @private
       * @param {?} before
       * @param {?} record
       * @return {?}
       */


      _insertBeforeOrAppend(before, record) {
        if (before) {
          /** @type {?} */
          const prev = before._prev;
          record._next = before;
          record._prev = prev;
          before._prev = record;

          if (prev) {
            prev._next = record;
          }

          if (before === this._mapHead) {
            this._mapHead = record;
          }

          this._appendAfter = before;
          return before;
        }

        if (this._appendAfter) {
          this._appendAfter._next = record;
          record._prev = this._appendAfter;
        } else {
          this._mapHead = record;
        }

        this._appendAfter = record;
        return null;
      }
      /**
       * @private
       * @param {?} key
       * @param {?} value
       * @return {?}
       */


      _getOrCreateRecordForKey(key, value) {
        if (this._records.has(key)) {
          /** @type {?} */
          const record =
          /** @type {?} */
          this._records.get(key);

          this._maybeAddToChanges(record, value);
          /** @type {?} */


          const prev = record._prev;
          /** @type {?} */

          const next = record._next;

          if (prev) {
            prev._next = next;
          }

          if (next) {
            next._prev = prev;
          }

          record._next = null;
          record._prev = null;
          return record;
        }
        /** @type {?} */


        const record = new KeyValueChangeRecord_(key);

        this._records.set(key, record);

        record.currentValue = value;

        this._addToAdditions(record);

        return record;
      }
      /**
       * \@internal
       * @return {?}
       */


      _reset() {
        if (this.isDirty) {
          /** @type {?} */
          let record; // let `_previousMapHead` contain the state of the map before the changes

          this._previousMapHead = this._mapHead;

          for (record = this._previousMapHead; record !== null; record = record._next) {
            record._nextPrevious = record._next;
          } // Update `record.previousValue` with the value of the item before the changes
          // We need to update all changed items (that's those which have been added and changed)


          for (record = this._changesHead; record !== null; record = record._nextChanged) {
            record.previousValue = record.currentValue;
          }

          for (record = this._additionsHead; record != null; record = record._nextAdded) {
            record.previousValue = record.currentValue;
          }

          this._changesHead = this._changesTail = null;
          this._additionsHead = this._additionsTail = null;
          this._removalsHead = null;
        }
      } // Add the record or a given key to the list of changes only when the value has actually changed

      /**
       * @private
       * @param {?} record
       * @param {?} newValue
       * @return {?}
       */


      _maybeAddToChanges(record, newValue) {
        if (!looseIdentical(newValue, record.currentValue)) {
          record.previousValue = record.currentValue;
          record.currentValue = newValue;

          this._addToChanges(record);
        }
      }
      /**
       * @private
       * @param {?} record
       * @return {?}
       */


      _addToAdditions(record) {
        if (this._additionsHead === null) {
          this._additionsHead = this._additionsTail = record;
        } else {
          /** @type {?} */
          this._additionsTail._nextAdded = record;
          this._additionsTail = record;
        }
      }
      /**
       * @private
       * @param {?} record
       * @return {?}
       */


      _addToChanges(record) {
        if (this._changesHead === null) {
          this._changesHead = this._changesTail = record;
        } else {
          /** @type {?} */
          this._changesTail._nextChanged = record;
          this._changesTail = record;
        }
      }
      /**
       * \@internal
       * @private
       * @template K, V
       * @param {?} obj
       * @param {?} fn
       * @return {?}
       */


      _forEach(obj, fn) {
        if (obj instanceof Map) {
          obj.forEach(fn);
        } else {
          Object.keys(obj).forEach(
          /**
          * @param {?} k
          * @return {?}
          */
          k => fn(obj[k], k));
        }
      }

    }

    if (false) {}
    /**
     * @template K, V
     */


    class KeyValueChangeRecord_ {
      /**
       * @param {?} key
       */
      constructor(key) {
        this.key = key;
        this.previousValue = null;
        this.currentValue = null;
        /**
         * \@internal
         */

        this._nextPrevious = null;
        /**
         * \@internal
         */

        this._next = null;
        /**
         * \@internal
         */

        this._prev = null;
        /**
         * \@internal
         */

        this._nextAdded = null;
        /**
         * \@internal
         */

        this._nextRemoved = null;
        /**
         * \@internal
         */

        this._nextChanged = null;
      }

    }

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * A strategy for tracking changes over time to an iterable. Used by {\@link NgForOf} to
     * respond to changes in an iterable by effecting equivalent changes in the DOM.
     *
     * \@publicApi
     * @record
     * @template V
     */


    function IterableDiffer() {}

    if (false) {}
    /**
     * An object describing the changes in the `Iterable` collection since last time
     * `IterableDiffer#diff()` was invoked.
     *
     * \@publicApi
     * @record
     * @template V
     */


    function IterableChanges() {}

    if (false) {}
    /**
     * Record representing the item change information.
     *
     * \@publicApi
     * @record
     * @template V
     */


    function IterableChangeRecord() {}

    if (false) {}
    /**
     * @deprecated v4.0.0 - Use IterableChangeRecord instead.
     * \@publicApi
     * @record
     * @template V
     */


    function CollectionChangeRecord() {}
    /**
     * An optional function passed into the `NgForOf` directive that defines how to track
     * changes for items in an iterable.
     * The function takes the iteration index and item ID.
     * When supplied, Angular tracks changes by the return value of the function.
     *
     * \@publicApi
     * @record
     * @template T
     */


    function TrackByFunction() {}
    /**
     * Provides a factory for {\@link IterableDiffer}.
     *
     * \@publicApi
     * @record
     */


    function IterableDifferFactory() {}

    if (false) {}
    /**
     * A repository of different iterable diffing strategies used by NgFor, NgClass, and others.
     *
     * \@publicApi
     */


    class IterableDiffers {
      /**
       * @param {?} factories
       */
      constructor(factories) {
        this.factories = factories;
      }
      /**
       * @param {?} factories
       * @param {?=} parent
       * @return {?}
       */


      static create(factories, parent) {
        if (parent != null) {
          /** @type {?} */
          const copied = parent.factories.slice();
          factories = factories.concat(copied);
        }

        return new IterableDiffers(factories);
      }
      /**
       * Takes an array of {\@link IterableDifferFactory} and returns a provider used to extend the
       * inherited {\@link IterableDiffers} instance with the provided factories and return a new
       * {\@link IterableDiffers} instance.
       *
       * \@usageNotes
       * ### Example
       *
       * The following example shows how to extend an existing list of factories,
       * which will only be applied to the injector for this component and its children.
       * This step is all that's required to make a new {\@link IterableDiffer} available.
       *
       * ```
       * \@Component({
       *   viewProviders: [
       *     IterableDiffers.extend([new ImmutableListDiffer()])
       *   ]
       * })
       * ```
       * @param {?} factories
       * @return {?}
       */


      static extend(factories) {
        return {
          provide: IterableDiffers,
          useFactory:
          /**
          * @param {?} parent
          * @return {?}
          */
          parent => {
            if (!parent) {
              // Typically would occur when calling IterableDiffers.extend inside of dependencies passed
              // to
              // bootstrap(), which would override default pipes instead of extending them.
              throw new Error('Cannot extend IterableDiffers without a parent injector');
            }

            return IterableDiffers.create(factories, parent);
          },
          // Dependency technically isn't optional, but we can provide a better error message this way.
          deps: [[IterableDiffers, new SkipSelf(), new Optional()]]
        };
      }
      /**
       * @param {?} iterable
       * @return {?}
       */


      find(iterable) {
        /** @type {?} */
        const factory = this.factories.find(
        /**
        * @param {?} f
        * @return {?}
        */
        f => f.supports(iterable));

        if (factory != null) {
          return factory;
        } else {
          throw new Error("Cannot find a differ supporting object '".concat(iterable, "' of type '").concat(getTypeNameForDebugging(iterable), "'"));
        }
      }

    }
    /** @nocollapse */

    /** @nocollapse */


    IterableDiffers.ngInjectableDef = ɵɵdefineInjectable({
      token: IterableDiffers,
      providedIn: 'root',
      factory:
      /**
      * @nocollapse @return {?}
      */
      () => new IterableDiffers([new DefaultIterableDifferFactory()])
    });

    if (false) {}
    /**
     * @param {?} type
     * @return {?}
     */


    function getTypeNameForDebugging(type) {
      return type['name'] || typeof type;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * A differ that tracks changes made to an object over time.
     *
     * \@publicApi
     * @record
     * @template K, V
     */


    function KeyValueDiffer() {}

    if (false) {}
    /**
     * An object describing the changes in the `Map` or `{[k:string]: string}` since last time
     * `KeyValueDiffer#diff()` was invoked.
     *
     * \@publicApi
     * @record
     * @template K, V
     */


    function KeyValueChanges() {}

    if (false) {}
    /**
     * Record representing the item change information.
     *
     * \@publicApi
     * @record
     * @template K, V
     */


    function KeyValueChangeRecord() {}

    if (false) {}
    /**
     * Provides a factory for {\@link KeyValueDiffer}.
     *
     * \@publicApi
     * @record
     */


    function KeyValueDifferFactory() {}

    if (false) {}
    /**
     * A repository of different Map diffing strategies used by NgClass, NgStyle, and others.
     *
     * \@publicApi
     */


    class KeyValueDiffers {
      /**
       * @param {?} factories
       */
      constructor(factories) {
        this.factories = factories;
      }
      /**
       * @template S
       * @param {?} factories
       * @param {?=} parent
       * @return {?}
       */


      static create(factories, parent) {
        if (parent) {
          /** @type {?} */
          const copied = parent.factories.slice();
          factories = factories.concat(copied);
        }

        return new KeyValueDiffers(factories);
      }
      /**
       * Takes an array of {\@link KeyValueDifferFactory} and returns a provider used to extend the
       * inherited {\@link KeyValueDiffers} instance with the provided factories and return a new
       * {\@link KeyValueDiffers} instance.
       *
       * \@usageNotes
       * ### Example
       *
       * The following example shows how to extend an existing list of factories,
       * which will only be applied to the injector for this component and its children.
       * This step is all that's required to make a new {\@link KeyValueDiffer} available.
       *
       * ```
       * \@Component({
       *   viewProviders: [
       *     KeyValueDiffers.extend([new ImmutableMapDiffer()])
       *   ]
       * })
       * ```
       * @template S
       * @param {?} factories
       * @return {?}
       */


      static extend(factories) {
        return {
          provide: KeyValueDiffers,
          useFactory:
          /**
          * @param {?} parent
          * @return {?}
          */
          parent => {
            if (!parent) {
              // Typically would occur when calling KeyValueDiffers.extend inside of dependencies passed
              // to bootstrap(), which would override default pipes instead of extending them.
              throw new Error('Cannot extend KeyValueDiffers without a parent injector');
            }

            return KeyValueDiffers.create(factories, parent);
          },
          // Dependency technically isn't optional, but we can provide a better error message this way.
          deps: [[KeyValueDiffers, new SkipSelf(), new Optional()]]
        };
      }
      /**
       * @param {?} kv
       * @return {?}
       */


      find(kv) {
        /** @type {?} */
        const factory = this.factories.find(
        /**
        * @param {?} f
        * @return {?}
        */
        f => f.supports(kv));

        if (factory) {
          return factory;
        }

        throw new Error("Cannot find a differ supporting object '".concat(kv, "'"));
      }

    }
    /** @nocollapse */

    /** @nocollapse */


    KeyValueDiffers.ngInjectableDef = ɵɵdefineInjectable({
      token: KeyValueDiffers,
      providedIn: 'root',
      factory:
      /**
      * @nocollapse @return {?}
      */
      () => new KeyValueDiffers([new DefaultKeyValueDifferFactory()])
    });

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Structural diffing for `Object`s and `Map`s.
     * @type {?}
     */


    const keyValDiff = [new DefaultKeyValueDifferFactory()];
    /**
     * Structural diffing for `Iterable` types such as `Array`s.
     * @type {?}
     */

    const iterableDiff = [new DefaultIterableDifferFactory()];
    /** @type {?} */

    const defaultIterableDiffers = new IterableDiffers(iterableDiff);
    /** @type {?} */

    const defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Represents an embedded template that can be used to instantiate embedded views.
     * To instantiate embedded views based on a template, use the `ViewContainerRef`
     * method `createEmbeddedView()`.
     *
     * Access a `TemplateRef` instance by placing a directive on an `<ng-template>`
     * element (or directive prefixed with `*`). The `TemplateRef` for the embedded view
     * is injected into the constructor of the directive,
     * using the `TemplateRef` token.
     *
     * You can also use a `Query` to find a `TemplateRef` associated with
     * a component or a directive.
     *
     * @see `ViewContainerRef`
     * @see [Navigate the Component Tree with DI](guide/dependency-injection-navtree)
     *
     * \@publicApi
     * @abstract
     * @template C
     */

    class TemplateRef {}
    /**
     * \@internal
     * @nocollapse
     */


    TemplateRef.__NG_ELEMENT_ID__ =
    /**
    * @return {?}
    */
    () => SWITCH_TEMPLATE_REF_FACTORY(TemplateRef, ElementRef);

    if (false) {}
    /** @type {?} */


    const SWITCH_TEMPLATE_REF_FACTORY__POST_R3__ = injectTemplateRef;
    /** @type {?} */

    const SWITCH_TEMPLATE_REF_FACTORY__PRE_R3__ = noop;
    /** @type {?} */

    const SWITCH_TEMPLATE_REF_FACTORY = SWITCH_TEMPLATE_REF_FACTORY__PRE_R3__;
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Represents a container where one or more views can be attached to a component.
     *
     * Can contain *host views* (created by instantiating a
     * component with the `createComponent()` method), and *embedded views*
     * (created by instantiating a `TemplateRef` with the `createEmbeddedView()` method).
     *
     * A view container instance can contain other view containers,
     * creating a [view hierarchy](guide/glossary#view-tree).
     *
     * @see `ComponentRef`
     * @see `EmbeddedViewRef`
     *
     * \@publicApi
     * @abstract
     */

    class ViewContainerRef {}
    /**
     * \@internal
     * @nocollapse
     */


    ViewContainerRef.__NG_ELEMENT_ID__ =
    /**
    * @return {?}
    */
    () => SWITCH_VIEW_CONTAINER_REF_FACTORY(ViewContainerRef, ElementRef);

    if (false) {}
    /** @type {?} */


    const SWITCH_VIEW_CONTAINER_REF_FACTORY__POST_R3__ = injectViewContainerRef;
    /** @type {?} */

    const SWITCH_VIEW_CONTAINER_REF_FACTORY__PRE_R3__ = noop;
    /** @type {?} */

    const SWITCH_VIEW_CONTAINER_REF_FACTORY = SWITCH_VIEW_CONTAINER_REF_FACTORY__PRE_R3__;
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} context
     * @param {?} oldValue
     * @param {?} currValue
     * @param {?} isFirstCheck
     * @return {?}
     */

    function expressionChangedAfterItHasBeenCheckedError(context, oldValue, currValue, isFirstCheck) {
      /** @type {?} */
      let msg = "ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value: '".concat(oldValue, "'. Current value: '").concat(currValue, "'.");

      if (isFirstCheck) {
        msg += " It seems like the view has been created after its parent and its children have been dirty checked." + " Has it been created in a change detection hook ?";
      }

      return viewDebugError(msg, context);
    }
    /**
     * @param {?} err
     * @param {?} context
     * @return {?}
     */


    function viewWrappedDebugError(err, context) {
      if (!(err instanceof Error)) {
        // errors that are not Error instances don't have a stack,
        // so it is ok to wrap them into a new Error object...
        err = new Error(err.toString());
      }

      _addDebugContext(err, context);

      return err;
    }
    /**
     * @param {?} msg
     * @param {?} context
     * @return {?}
     */


    function viewDebugError(msg, context) {
      /** @type {?} */
      const err = new Error(msg);

      _addDebugContext(err, context);

      return err;
    }
    /**
     * @param {?} err
     * @param {?} context
     * @return {?}
     */


    function _addDebugContext(err, context) {
      /** @type {?} */
      err[ERROR_DEBUG_CONTEXT] = context;

      /** @type {?} */
      err[ERROR_LOGGER] = context.logError.bind(context);
    }
    /**
     * @param {?} err
     * @return {?}
     */


    function isViewDebugError(err) {
      return !!getDebugContext(err);
    }
    /**
     * @param {?} action
     * @return {?}
     */


    function viewDestroyedError(action) {
      return new Error("ViewDestroyedError: Attempt to use a destroyed view: ".concat(action));
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Factory for ViewDefinitions/NgModuleDefinitions.
     * We use a function so we can reexeute it in case an error happens and use the given logger
     * function to log the error from the definition of the node, which is shown in all browser
     * logs.
     * @record
     * @template D
     */


    function DefinitionFactory() {}
    /**
     * Function to call console.error at the right source location. This is an indirection
     * via another function as browser will log the location that actually called
     * `console.error`.
     * @record
     */


    function NodeLogger() {}
    /**
     * @record
     * @template DF
     */


    function Definition() {}

    if (false) {}
    /**
     * @record
     */


    function NgModuleDefinition() {}

    if (false) {}
    /**
     * @record
     */


    function NgModuleDefinitionFactory() {}
    /**
     * @record
     */


    function ViewDefinition() {}

    if (false) {}
    /**
     * @record
     */


    function ViewDefinitionFactory() {}
    /**
     * @record
     */


    function ViewUpdateFn() {}
    /**
     * @record
     */


    function NodeCheckFn() {}
    /** @enum {number} */


    const ArgumentType = {
      Inline: 0,
      Dynamic: 1
    };
    /**
     * @record
     */

    function ViewHandleEventFn() {}
    /** @enum {number} */


    const ViewFlags = {
      None: 0,
      OnPush: 2
    };
    /**
     * A node definition in the view.
     *
     * Note: We use one type for all nodes so that loops that loop over all nodes
     * of a ViewDefinition stay monomorphic!
     * @record
     */

    function NodeDef() {}

    if (false) {}
    /** @enum {number} */


    const NodeFlags = {
      None: 0,
      TypeElement: 1,
      TypeText: 2,
      ProjectedTemplate: 4,
      CatRenderNode: 3,
      TypeNgContent: 8,
      TypePipe: 16,
      TypePureArray: 32,
      TypePureObject: 64,
      TypePurePipe: 128,
      CatPureExpression: 224,
      TypeValueProvider: 256,
      TypeClassProvider: 512,
      TypeFactoryProvider: 1024,
      TypeUseExistingProvider: 2048,
      LazyProvider: 4096,
      PrivateProvider: 8192,
      TypeDirective: 16384,
      Component: 32768,
      CatProviderNoDirective: 3840,
      CatProvider: 20224,
      OnInit: 65536,
      OnDestroy: 131072,
      DoCheck: 262144,
      OnChanges: 524288,
      AfterContentInit: 1048576,
      AfterContentChecked: 2097152,
      AfterViewInit: 4194304,
      AfterViewChecked: 8388608,
      EmbeddedViews: 16777216,
      ComponentView: 33554432,
      TypeContentQuery: 67108864,
      TypeViewQuery: 134217728,
      StaticQuery: 268435456,
      DynamicQuery: 536870912,
      TypeNgModule: 1073741824,
      CatQuery: 201326592,
      // mutually exclusive values...
      Types: 201347067
    };
    /**
     * @record
     */

    function BindingDef() {}

    if (false) {}
    /** @enum {number} */


    const BindingFlags = {
      TypeElementAttribute: 1,
      TypeElementClass: 2,
      TypeElementStyle: 4,
      TypeProperty: 8,
      SyntheticProperty: 16,
      SyntheticHostProperty: 32,
      CatSyntheticProperty: 48,
      // mutually exclusive values...
      Types: 15
    };
    /**
     * @record
     */

    function OutputDef() {}

    if (false) {}
    /** @enum {number} */


    const OutputType = {
      ElementOutput: 0,
      DirectiveOutput: 1
    };
    /** @enum {number} */

    const QueryValueType = {
      ElementRef: 0,
      RenderElement: 1,
      TemplateRef: 2,
      ViewContainerRef: 3,
      Provider: 4
    };
    /**
     * @record
     */

    function ElementDef() {}

    if (false) {}
    /**
     * @record
     */


    function ElementHandleEventFn() {}
    /**
     * @record
     */


    function ProviderDef() {}

    if (false) {}
    /**
     * @record
     */


    function NgModuleProviderDef() {}

    if (false) {}
    /**
     * @record
     */


    function DepDef() {}

    if (false) {}
    /** @enum {number} */


    const DepFlags = {
      None: 0,
      SkipSelf: 1,
      Optional: 2,
      Self: 4,
      Value: 8
    };
    /**
     * @record
     */

    function TextDef() {}

    if (false) {}
    /**
     * @record
     */


    function QueryDef() {}

    if (false) {}
    /**
     * @record
     */


    function QueryBindingDef() {}

    if (false) {}
    /** @enum {number} */


    const QueryBindingType = {
      First: 0,
      All: 1
    };
    /**
     * @record
     */

    function NgContentDef() {}

    if (false) {}
    /**
     * @record
     */


    function NgModuleData() {}

    if (false) {}
    /**
     * View instance data.
     * Attention: Adding fields to this is performance sensitive!
     * @record
     */


    function ViewData() {}

    if (false) {}
    /** @enum {number} */


    const ViewState = {
      BeforeFirstCheck: 1,
      FirstCheck: 2,
      Attached: 4,
      ChecksEnabled: 8,
      IsProjectedView: 16,
      CheckProjectedView: 32,
      CheckProjectedViews: 64,
      Destroyed: 128,
      // InitState Uses 3 bits
      InitState_Mask: 1792,
      InitState_BeforeInit: 0,
      InitState_CallingOnInit: 256,
      InitState_CallingAfterContentInit: 512,
      InitState_CallingAfterViewInit: 768,
      InitState_AfterInit: 1024,
      CatDetectChanges: 12,
      CatInit: 13
    }; // Called before each cycle of a view's check to detect whether this is in the
    // initState for which we need to call ngOnInit, ngAfterContentInit or ngAfterViewInit
    // lifecycle methods. Returns true if this check cycle should call lifecycle
    // methods.

    /**
     * @param {?} view
     * @param {?} priorInitState
     * @param {?} newInitState
     * @return {?}
     */

    function shiftInitState(view, priorInitState, newInitState) {
      // Only update the InitState if we are currently in the prior state.
      // For example, only move into CallingInit if we are in BeforeInit. Only
      // move into CallingContentInit if we are in CallingInit. Normally this will
      // always be true because of how checkCycle is called in checkAndUpdateView.
      // However, if checkAndUpdateView is called recursively or if an exception is
      // thrown while checkAndUpdateView is running, checkAndUpdateView starts over
      // from the beginning. This ensures the state is monotonically increasing,
      // terminating in the AfterInit state, which ensures the Init methods are called
      // at least once and only once.

      /** @type {?} */
      const state = view.state;
      /** @type {?} */

      const initState = state & 1792
      /* InitState_Mask */
      ;

      if (initState === priorInitState) {
        view.state = state & ~1792
        /* InitState_Mask */
        | newInitState;
        view.initIndex = -1;
        return true;
      }

      return initState === newInitState;
    } // Returns true if the lifecycle init method should be called for the node with
    // the given init index.

    /**
     * @param {?} view
     * @param {?} initState
     * @param {?} index
     * @return {?}
     */


    function shouldCallLifecycleInitHook(view, initState, index) {
      if ((view.state & 1792
      /* InitState_Mask */
      ) === initState && view.initIndex <= index) {
        view.initIndex = index + 1;
        return true;
      }

      return false;
    }
    /**
     * @record
     */


    function DisposableFn() {}
    /**
     * Node instance data.
     *
     * We have a separate type per NodeType to save memory
     * (TextData | ElementData | ProviderData | PureExpressionData | QueryList<any>)
     *
     * To keep our code monomorphic,
     * we prohibit using `NodeData` directly but enforce the use of accessors (`asElementData`, ...).
     * This way, no usage site can get a `NodeData` from view.nodes and then use it for different
     * purposes.
     */


    class NodeData {}

    if (false) {}
    /**
     * Data for an instantiated NodeType.Text.
     *
     * Attention: Adding fields to this is performance sensitive!
     * @record
     */


    function TextData() {}

    if (false) {}
    /**
     * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
     * @param {?} view
     * @param {?} index
     * @return {?}
     */


    function asTextData(view, index) {
      return (
        /** @type {?} */
        view.nodes[index]
      );
    }
    /**
     * Data for an instantiated NodeType.Element.
     *
     * Attention: Adding fields to this is performance sensitive!
     * @record
     */


    function ElementData() {}

    if (false) {}
    /**
     * @record
     */


    function ViewContainerData() {}

    if (false) {}
    /**
     * @record
     */


    function TemplateData() {}

    if (false) {}
    /**
     * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
     * @param {?} view
     * @param {?} index
     * @return {?}
     */


    function asElementData(view, index) {
      return (
        /** @type {?} */
        view.nodes[index]
      );
    }
    /**
     * Data for an instantiated NodeType.Provider.
     *
     * Attention: Adding fields to this is performance sensitive!
     * @record
     */


    function ProviderData() {}

    if (false) {}
    /**
     * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
     * @param {?} view
     * @param {?} index
     * @return {?}
     */


    function asProviderData(view, index) {
      return (
        /** @type {?} */
        view.nodes[index]
      );
    }
    /**
     * Data for an instantiated NodeType.PureExpression.
     *
     * Attention: Adding fields to this is performance sensitive!
     * @record
     */


    function PureExpressionData() {}

    if (false) {}
    /**
     * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
     * @param {?} view
     * @param {?} index
     * @return {?}
     */


    function asPureExpressionData(view, index) {
      return (
        /** @type {?} */
        view.nodes[index]
      );
    }
    /**
     * Accessor for view.nodes, enforcing that every usage site stays monomorphic.
     * @param {?} view
     * @param {?} index
     * @return {?}
     */


    function asQueryList(view, index) {
      return (
        /** @type {?} */
        view.nodes[index]
      );
    }
    /**
     * @record
     */


    function RootData() {}

    if (false) {}
    /**
     * @abstract
     */


    class DebugContext {}

    if (false) {}
    /** @enum {number} */


    const CheckType = {
      CheckAndUpdate: 0,
      CheckNoChanges: 1
    };
    /**
     * @record
     */

    function ProviderOverride() {}

    if (false) {} // WARNING: interface has both a type and a value, skipping emit

    /**
     * This object is used to prevent cycles in the source files and to have a place where
     * debug mode can hook it. It is lazily filled when `isDevMode` is known.
     * @type {?}
     */


    const Services = {
      setCurrentNode:
      /** @type {?} */
      undefined,
      createRootView:
      /** @type {?} */
      undefined,
      createEmbeddedView:
      /** @type {?} */
      undefined,
      createComponentView:
      /** @type {?} */
      undefined,
      createNgModuleRef:
      /** @type {?} */
      undefined,
      overrideProvider:
      /** @type {?} */
      undefined,
      overrideComponentView:
      /** @type {?} */
      undefined,
      clearOverrides:
      /** @type {?} */
      undefined,
      checkAndUpdateView:
      /** @type {?} */
      undefined,
      checkNoChangesView:
      /** @type {?} */
      undefined,
      destroyView:
      /** @type {?} */
      undefined,
      resolveDep:
      /** @type {?} */
      undefined,
      createDebugContext:
      /** @type {?} */
      undefined,
      handleEvent:
      /** @type {?} */
      undefined,
      updateDirectives:
      /** @type {?} */
      undefined,
      updateRenderer:
      /** @type {?} */
      undefined,
      dirtyParentQueries:
      /** @type {?} */
      undefined
    };
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    const NOOP =
    /**
    * @return {?}
    */
    () => {};
    /** @type {?} */


    const _tokenKeyCache = new Map();
    /**
     * @param {?} token
     * @return {?}
     */


    function tokenKey(token) {
      /** @type {?} */
      let key = _tokenKeyCache.get(token);

      if (!key) {
        key = stringify(token) + '_' + _tokenKeyCache.size;

        _tokenKeyCache.set(token, key);
      }

      return key;
    }
    /**
     * @param {?} view
     * @param {?} nodeIdx
     * @param {?} bindingIdx
     * @param {?} value
     * @return {?}
     */


    function unwrapValue(view, nodeIdx, bindingIdx, value) {
      if (WrappedValue.isWrapped(value)) {
        value = WrappedValue.unwrap(value);
        /** @type {?} */

        const globalBindingIdx = view.def.nodes[nodeIdx].bindingIndex + bindingIdx;
        /** @type {?} */

        const oldValue = WrappedValue.unwrap(view.oldValues[globalBindingIdx]);
        view.oldValues[globalBindingIdx] = new WrappedValue(oldValue);
      }

      return value;
    }
    /** @type {?} */


    const UNDEFINED_RENDERER_TYPE_ID = '$$undefined';
    /** @type {?} */

    const EMPTY_RENDERER_TYPE_ID = '$$empty'; // Attention: this function is called as top level function.
    // Putting any logic in here will destroy closure tree shaking!

    /**
     * @param {?} values
     * @return {?}
     */

    function createRendererType2(values) {
      return {
        id: UNDEFINED_RENDERER_TYPE_ID,
        styles: values.styles,
        encapsulation: values.encapsulation,
        data: values.data
      };
    }
    /** @type {?} */


    let _renderCompCount$1 = 0;
    /**
     * @param {?=} type
     * @return {?}
     */

    function resolveRendererType2(type) {
      if (type && type.id === UNDEFINED_RENDERER_TYPE_ID) {
        // first time we see this RendererType2. Initialize it...

        /** @type {?} */
        const isFilled = type.encapsulation != null && type.encapsulation !== ViewEncapsulation.None || type.styles.length || Object.keys(type.data).length;

        if (isFilled) {
          type.id = "c".concat(_renderCompCount$1++);
        } else {
          type.id = EMPTY_RENDERER_TYPE_ID;
        }
      }

      if (type && type.id === EMPTY_RENDERER_TYPE_ID) {
        type = null;
      }

      return type || null;
    }
    /**
     * @param {?} view
     * @param {?} def
     * @param {?} bindingIdx
     * @param {?} value
     * @return {?}
     */


    function checkBinding(view, def, bindingIdx, value) {
      /** @type {?} */
      const oldValues = view.oldValues;

      if (view.state & 2
      /* FirstCheck */
      || !looseIdentical(oldValues[def.bindingIndex + bindingIdx], value)) {
        return true;
      }

      return false;
    }
    /**
     * @param {?} view
     * @param {?} def
     * @param {?} bindingIdx
     * @param {?} value
     * @return {?}
     */


    function checkAndUpdateBinding(view, def, bindingIdx, value) {
      if (checkBinding(view, def, bindingIdx, value)) {
        view.oldValues[def.bindingIndex + bindingIdx] = value;
        return true;
      }

      return false;
    }
    /**
     * @param {?} view
     * @param {?} def
     * @param {?} bindingIdx
     * @param {?} value
     * @return {?}
     */


    function checkBindingNoChanges(view, def, bindingIdx, value) {
      /** @type {?} */
      const oldValue = view.oldValues[def.bindingIndex + bindingIdx];

      if (view.state & 1
      /* BeforeFirstCheck */
      || !devModeEqual$1(oldValue, value)) {
        /** @type {?} */
        const bindingName = def.bindings[bindingIdx].name;
        throw expressionChangedAfterItHasBeenCheckedError(Services.createDebugContext(view, def.nodeIndex), "".concat(bindingName, ": ").concat(oldValue), "".concat(bindingName, ": ").concat(value), (view.state & 1
        /* BeforeFirstCheck */
        ) !== 0);
      }
    }
    /**
     * @param {?} view
     * @return {?}
     */


    function markParentViewsForCheck(view) {
      /** @type {?} */
      let currView = view;

      while (currView) {
        if (currView.def.flags & 2
        /* OnPush */
        ) {
            currView.state |= 8
            /* ChecksEnabled */
            ;
          }

        currView = currView.viewContainerParent || currView.parent;
      }
    }
    /**
     * @param {?} view
     * @param {?} endView
     * @return {?}
     */


    function markParentViewsForCheckProjectedViews(view, endView) {
      /** @type {?} */
      let currView = view;

      while (currView && currView !== endView) {
        currView.state |= 64
        /* CheckProjectedViews */
        ;
        currView = currView.viewContainerParent || currView.parent;
      }
    }
    /**
     * @param {?} view
     * @param {?} nodeIndex
     * @param {?} eventName
     * @param {?} event
     * @return {?}
     */


    function dispatchEvent(view, nodeIndex, eventName, event) {
      try {
        /** @type {?} */
        const nodeDef = view.def.nodes[nodeIndex];
        /** @type {?} */

        const startView = nodeDef.flags & 33554432
        /* ComponentView */
        ? asElementData(view, nodeIndex).componentView : view;
        markParentViewsForCheck(startView);
        return Services.handleEvent(view, nodeIndex, eventName, event);
      } catch (e) {
        // Attention: Don't rethrow, as it would cancel Observable subscriptions!
        view.root.errorHandler.handleError(e);
      }
    }
    /**
     * @param {?} view
     * @return {?}
     */


    function declaredViewContainer(view) {
      if (view.parent) {
        /** @type {?} */
        const parentView = view.parent;
        return asElementData(parentView,
        /** @type {?} */
        view.parentNodeDef.nodeIndex);
      }

      return null;
    }
    /**
     * for component views, this is the host element.
     * for embedded views, this is the index of the parent node
     * that contains the view container.
     * @param {?} view
     * @return {?}
     */


    function viewParentEl(view) {
      /** @type {?} */
      const parentView = view.parent;

      if (parentView) {
        return (
          /** @type {?} */
          view.parentNodeDef.parent
        );
      } else {
        return null;
      }
    }
    /**
     * @param {?} view
     * @param {?} def
     * @return {?}
     */


    function renderNode(view, def) {
      switch (def.flags & 201347067
      /* Types */
      ) {
        case 1
        /* TypeElement */
        :
          return asElementData(view, def.nodeIndex).renderElement;

        case 2
        /* TypeText */
        :
          return asTextData(view, def.nodeIndex).renderText;
      }
    }
    /**
     * @param {?} target
     * @param {?} name
     * @return {?}
     */


    function elementEventFullName(target, name) {
      return target ? "".concat(target, ":").concat(name) : name;
    }
    /**
     * @param {?} view
     * @return {?}
     */


    function isComponentView(view) {
      return !!view.parent && !!(
      /** @type {?} */
      view.parentNodeDef.flags & 32768
      /* Component */
      );
    }
    /**
     * @param {?} view
     * @return {?}
     */


    function isEmbeddedView(view) {
      return !!view.parent && !(
      /** @type {?} */
      view.parentNodeDef.flags & 32768
      /* Component */
      );
    }
    /**
     * @param {?} queryId
     * @return {?}
     */


    function filterQueryId(queryId) {
      return 1 << queryId % 32;
    }
    /**
     * @param {?} matchedQueriesDsl
     * @return {?}
     */


    function splitMatchedQueriesDsl(matchedQueriesDsl) {
      /** @type {?} */
      const matchedQueries = {};
      /** @type {?} */

      let matchedQueryIds = 0;
      /** @type {?} */

      const references = {};

      if (matchedQueriesDsl) {
        matchedQueriesDsl.forEach(
        /**
        * @param {?} __0
        * @return {?}
        */
        ([queryId, valueType]) => {
          if (typeof queryId === 'number') {
            matchedQueries[queryId] = valueType;
            matchedQueryIds |= filterQueryId(queryId);
          } else {
            references[queryId] = valueType;
          }
        });
      }

      return {
        matchedQueries,
        references,
        matchedQueryIds
      };
    }
    /**
     * @param {?} deps
     * @param {?=} sourceName
     * @return {?}
     */


    function splitDepsDsl(deps, sourceName) {
      return deps.map(
      /**
      * @param {?} value
      * @return {?}
      */
      value => {
        /** @type {?} */
        let token;
        /** @type {?} */

        let flags;

        if (Array.isArray(value)) {
          [flags, token] = value;
        } else {
          flags = 0
          /* None */
          ;
          token = value;
        }

        if (token && (typeof token === 'function' || typeof token === 'object') && sourceName) {
          Object.defineProperty(token, SOURCE, {
            value: sourceName,
            configurable: true
          });
        }

        return {
          flags,
          token,
          tokenKey: tokenKey(token)
        };
      });
    }
    /**
     * @param {?} view
     * @param {?} renderHost
     * @param {?} def
     * @return {?}
     */


    function getParentRenderElement(view, renderHost, def) {
      /** @type {?} */
      let renderParent = def.renderParent;

      if (renderParent) {
        if ((renderParent.flags & 1
        /* TypeElement */
        ) === 0 || (renderParent.flags & 33554432
        /* ComponentView */
        ) === 0 ||
        /** @type {?} */
        renderParent.element.componentRendererType &&
        /** @type {?} */

        /** @type {?} */
        renderParent.element.componentRendererType.encapsulation === ViewEncapsulation.Native) {
          // only children of non components, or children of components with native encapsulation should
          // be attached.
          return asElementData(view,
          /** @type {?} */
          def.renderParent.nodeIndex).renderElement;
        }
      } else {
        return renderHost;
      }
    }
    /** @type {?} */


    const DEFINITION_CACHE = new WeakMap();
    /**
     * @template D
     * @param {?} factory
     * @return {?}
     */

    function resolveDefinition(factory) {
      /** @type {?} */
      let value =
      /** @type {?} */

      /** @type {?} */
      DEFINITION_CACHE.get(factory);

      if (!value) {
        value = factory(
        /**
        * @return {?}
        */
        () => NOOP);
        value.factory = factory;
        DEFINITION_CACHE.set(factory, value);
      }

      return value;
    }
    /**
     * @param {?} view
     * @return {?}
     */


    function rootRenderNodes(view) {
      /** @type {?} */
      const renderNodes = [];
      visitRootRenderNodes(view, 0
      /* Collect */
      , undefined, undefined, renderNodes);
      return renderNodes;
    }
    /** @enum {number} */


    const RenderNodeAction = {
      Collect: 0,
      AppendChild: 1,
      InsertBefore: 2,
      RemoveChild: 3
    };
    /**
     * @param {?} view
     * @param {?} action
     * @param {?} parentNode
     * @param {?} nextSibling
     * @param {?=} target
     * @return {?}
     */

    function visitRootRenderNodes(view, action, parentNode, nextSibling, target) {
      // We need to re-compute the parent node in case the nodes have been moved around manually
      if (action === 3
      /* RemoveChild */
      ) {
          parentNode = view.renderer.parentNode(renderNode(view,
          /** @type {?} */
          view.def.lastRenderRootNode));
        }

      visitSiblingRenderNodes(view, action, 0, view.def.nodes.length - 1, parentNode, nextSibling, target);
    }
    /**
     * @param {?} view
     * @param {?} action
     * @param {?} startIndex
     * @param {?} endIndex
     * @param {?} parentNode
     * @param {?} nextSibling
     * @param {?=} target
     * @return {?}
     */


    function visitSiblingRenderNodes(view, action, startIndex, endIndex, parentNode, nextSibling, target) {
      for (let i = startIndex; i <= endIndex; i++) {
        /** @type {?} */
        const nodeDef = view.def.nodes[i];

        if (nodeDef.flags & (1
        /* TypeElement */
        | 2
        /* TypeText */
        | 8
        /* TypeNgContent */
        )) {
          visitRenderNode(view, nodeDef, action, parentNode, nextSibling, target);
        } // jump to next sibling


        i += nodeDef.childCount;
      }
    }
    /**
     * @param {?} view
     * @param {?} ngContentIndex
     * @param {?} action
     * @param {?} parentNode
     * @param {?} nextSibling
     * @param {?=} target
     * @return {?}
     */


    function visitProjectedRenderNodes(view, ngContentIndex, action, parentNode, nextSibling, target) {
      /** @type {?} */
      let compView = view;

      while (compView && !isComponentView(compView)) {
        compView = compView.parent;
      }
      /** @type {?} */


      const hostView =
      /** @type {?} */
      compView.parent;
      /** @type {?} */

      const hostElDef = viewParentEl(
      /** @type {?} */
      compView);
      /** @type {?} */

      const startIndex =
      /** @type {?} */
      hostElDef.nodeIndex + 1;
      /** @type {?} */

      const endIndex =
      /** @type {?} */
      hostElDef.nodeIndex +
      /** @type {?} */
      hostElDef.childCount;

      for (let i = startIndex; i <= endIndex; i++) {
        /** @type {?} */
        const nodeDef =
        /** @type {?} */
        hostView.def.nodes[i];

        if (nodeDef.ngContentIndex === ngContentIndex) {
          visitRenderNode(
          /** @type {?} */
          hostView, nodeDef, action, parentNode, nextSibling, target);
        } // jump to next sibling


        i += nodeDef.childCount;
      }

      if (!
      /** @type {?} */
      hostView.parent) {
        // a root view

        /** @type {?} */
        const projectedNodes = view.root.projectableNodes[ngContentIndex];

        if (projectedNodes) {
          for (let i = 0; i < projectedNodes.length; i++) {
            execRenderNodeAction(view, projectedNodes[i], action, parentNode, nextSibling, target);
          }
        }
      }
    }
    /**
     * @param {?} view
     * @param {?} nodeDef
     * @param {?} action
     * @param {?} parentNode
     * @param {?} nextSibling
     * @param {?=} target
     * @return {?}
     */


    function visitRenderNode(view, nodeDef, action, parentNode, nextSibling, target) {
      if (nodeDef.flags & 8
      /* TypeNgContent */
      ) {
          visitProjectedRenderNodes(view,
          /** @type {?} */
          nodeDef.ngContent.index, action, parentNode, nextSibling, target);
        } else {
        /** @type {?} */
        const rn = renderNode(view, nodeDef);

        if (action === 3
        /* RemoveChild */
        && nodeDef.flags & 33554432
        /* ComponentView */
        && nodeDef.bindingFlags & 48
        /* CatSyntheticProperty */
        ) {
          // Note: we might need to do both actions.
          if (nodeDef.bindingFlags & 16
          /* SyntheticProperty */
          ) {
            execRenderNodeAction(view, rn, action, parentNode, nextSibling, target);
          }

          if (nodeDef.bindingFlags & 32
          /* SyntheticHostProperty */
          ) {
            /** @type {?} */
            const compView = asElementData(view, nodeDef.nodeIndex).componentView;
            execRenderNodeAction(compView, rn, action, parentNode, nextSibling, target);
          }
        } else {
          execRenderNodeAction(view, rn, action, parentNode, nextSibling, target);
        }

        if (nodeDef.flags & 16777216
        /* EmbeddedViews */
        ) {
            /** @type {?} */
            const embeddedViews =
            /** @type {?} */
            asElementData(view, nodeDef.nodeIndex).viewContainer._embeddedViews;

            for (let k = 0; k < embeddedViews.length; k++) {
              visitRootRenderNodes(embeddedViews[k], action, parentNode, nextSibling, target);
            }
          }

        if (nodeDef.flags & 1
        /* TypeElement */
        && !
        /** @type {?} */
        nodeDef.element.name) {
          visitSiblingRenderNodes(view, action, nodeDef.nodeIndex + 1, nodeDef.nodeIndex + nodeDef.childCount, parentNode, nextSibling, target);
        }
      }
    }
    /**
     * @param {?} view
     * @param {?} renderNode
     * @param {?} action
     * @param {?} parentNode
     * @param {?} nextSibling
     * @param {?=} target
     * @return {?}
     */


    function execRenderNodeAction(view, renderNode, action, parentNode, nextSibling, target) {
      /** @type {?} */
      const renderer = view.renderer;

      switch (action) {
        case 1
        /* AppendChild */
        :
          renderer.appendChild(parentNode, renderNode);
          break;

        case 2
        /* InsertBefore */
        :
          renderer.insertBefore(parentNode, renderNode, nextSibling);
          break;

        case 3
        /* RemoveChild */
        :
          renderer.removeChild(parentNode, renderNode);
          break;

        case 0
        /* Collect */
        :
          /** @type {?} */
          target.push(renderNode);
          break;
      }
    }
    /** @type {?} */


    const NS_PREFIX_RE = /^:([^:]+):(.+)$/;
    /**
     * @param {?} name
     * @return {?}
     */

    function splitNamespace(name) {
      if (name[0] === ':') {
        /** @type {?} */
        const match =
        /** @type {?} */
        name.match(NS_PREFIX_RE);
        return [match[1], match[2]];
      }

      return ['', name];
    }
    /**
     * @param {?} bindings
     * @return {?}
     */


    function calcBindingFlags(bindings) {
      /** @type {?} */
      let flags = 0;

      for (let i = 0; i < bindings.length; i++) {
        flags |= bindings[i].flags;
      }

      return flags;
    }
    /**
     * @param {?} valueCount
     * @param {?} constAndInterp
     * @return {?}
     */


    function interpolate(valueCount, constAndInterp) {
      /** @type {?} */
      let result = '';

      for (let i = 0; i < valueCount * 2; i = i + 2) {
        result = result + constAndInterp[i] + _toStringWithNull(constAndInterp[i + 1]);
      }

      return result + constAndInterp[valueCount * 2];
    }
    /**
     * @param {?} valueCount
     * @param {?} c0
     * @param {?} a1
     * @param {?} c1
     * @param {?=} a2
     * @param {?=} c2
     * @param {?=} a3
     * @param {?=} c3
     * @param {?=} a4
     * @param {?=} c4
     * @param {?=} a5
     * @param {?=} c5
     * @param {?=} a6
     * @param {?=} c6
     * @param {?=} a7
     * @param {?=} c7
     * @param {?=} a8
     * @param {?=} c8
     * @param {?=} a9
     * @param {?=} c9
     * @return {?}
     */


    function inlineInterpolate(valueCount, c0, a1, c1, a2, c2, a3, c3, a4, c4, a5, c5, a6, c6, a7, c7, a8, c8, a9, c9) {
      switch (valueCount) {
        case 1:
          return c0 + _toStringWithNull(a1) + c1;

        case 2:
          return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2;

        case 3:
          return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3;

        case 4:
          return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4;

        case 5:
          return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5;

        case 6:
          return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6;

        case 7:
          return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6 + _toStringWithNull(a7) + c7;

        case 8:
          return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8;

        case 9:
          return c0 + _toStringWithNull(a1) + c1 + _toStringWithNull(a2) + c2 + _toStringWithNull(a3) + c3 + _toStringWithNull(a4) + c4 + _toStringWithNull(a5) + c5 + _toStringWithNull(a6) + c6 + _toStringWithNull(a7) + c7 + _toStringWithNull(a8) + c8 + _toStringWithNull(a9) + c9;

        default:
          throw new Error("Does not support more than 9 expressions");
      }
    }
    /**
     * @param {?} v
     * @return {?}
     */


    function _toStringWithNull(v) {
      return v != null ? v.toString() : '';
    }
    /** @type {?} */


    const EMPTY_ARRAY$3 = [];
    /** @type {?} */

    const EMPTY_MAP = {};
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    const UNDEFINED_VALUE = new Object();
    /** @type {?} */

    const InjectorRefTokenKey = tokenKey(Injector);
    /** @type {?} */

    const INJECTORRefTokenKey = tokenKey(INJECTOR);
    /** @type {?} */

    const NgModuleRefTokenKey = tokenKey(NgModuleRef);
    /**
     * @param {?} flags
     * @param {?} token
     * @param {?} value
     * @param {?} deps
     * @return {?}
     */

    function moduleProvideDef(flags, token, value, deps) {
      // Need to resolve forwardRefs as e.g. for `useValue` we
      // lowered the expression and then stopped evaluating it,
      // i.e. also didn't unwrap it.
      value = resolveForwardRef(value);
      /** @type {?} */

      const depDefs = splitDepsDsl(deps, stringify(token));
      return {
        // will bet set by the module definition
        index: -1,
        deps: depDefs,
        flags,
        token,
        value
      };
    }
    /**
     * @param {?} providers
     * @return {?}
     */


    function moduleDef(providers) {
      /** @type {?} */
      const providersByKey = {};
      /** @type {?} */

      const modules = [];
      /** @type {?} */

      let isRoot = false;

      for (let i = 0; i < providers.length; i++) {
        /** @type {?} */
        const provider = providers[i];

        if (provider.token === APP_ROOT && provider.value === true) {
          isRoot = true;
        }

        if (provider.flags & 1073741824
        /* TypeNgModule */
        ) {
            modules.push(provider.token);
          }

        provider.index = i;
        providersByKey[tokenKey(provider.token)] = provider;
      }

      return {
        // Will be filled later...
        factory: null,
        providersByKey,
        providers,
        modules,
        isRoot
      };
    }
    /**
     * @param {?} data
     * @return {?}
     */


    function initNgModule(data) {
      /** @type {?} */
      const def = data._def;
      /** @type {?} */

      const providers = data._providers = new Array(def.providers.length);

      for (let i = 0; i < def.providers.length; i++) {
        /** @type {?} */
        const provDef = def.providers[i];

        if (!(provDef.flags & 4096
        /* LazyProvider */
        )) {
          // Make sure the provider has not been already initialized outside this loop.
          if (providers[i] === undefined) {
            providers[i] = _createProviderInstance(data, provDef);
          }
        }
      }
    }
    /**
     * @param {?} data
     * @param {?} depDef
     * @param {?=} notFoundValue
     * @return {?}
     */


    function resolveNgModuleDep(data, depDef, notFoundValue = Injector.THROW_IF_NOT_FOUND) {
      /** @type {?} */
      const former = setCurrentInjector(data);

      try {
        if (depDef.flags & 8
        /* Value */
        ) {
            return depDef.token;
          }

        if (depDef.flags & 2
        /* Optional */
        ) {
            notFoundValue = null;
          }

        if (depDef.flags & 1
        /* SkipSelf */
        ) {
            return data._parent.get(depDef.token, notFoundValue);
          }
        /** @type {?} */


        const tokenKey = depDef.tokenKey;

        switch (tokenKey) {
          case InjectorRefTokenKey:
          case INJECTORRefTokenKey:
          case NgModuleRefTokenKey:
            return data;
        }
        /** @type {?} */


        const providerDef = data._def.providersByKey[tokenKey];
        /** @type {?} */

        let injectableDef;

        if (providerDef) {
          /** @type {?} */
          let providerInstance = data._providers[providerDef.index];

          if (providerInstance === undefined) {
            providerInstance = data._providers[providerDef.index] = _createProviderInstance(data, providerDef);
          }

          return providerInstance === UNDEFINED_VALUE ? undefined : providerInstance;
        } else if ((injectableDef = getInjectableDef(depDef.token)) && targetsModule(data, injectableDef)) {
          /** @type {?} */
          const index = data._providers.length;
          data._def.providers[index] = data._def.providersByKey[depDef.tokenKey] = {
            flags: 1024
            /* TypeFactoryProvider */
            | 4096
            /* LazyProvider */
            ,
            value: injectableDef.factory,
            deps: [],
            index,
            token: depDef.token
          };
          data._providers[index] = UNDEFINED_VALUE;
          return data._providers[index] = _createProviderInstance(data, data._def.providersByKey[depDef.tokenKey]);
        } else if (depDef.flags & 4
        /* Self */
        ) {
            return notFoundValue;
          }

        return data._parent.get(depDef.token, notFoundValue);
      } finally {
        setCurrentInjector(former);
      }
    }
    /**
     * @param {?} ngModule
     * @param {?} scope
     * @return {?}
     */


    function moduleTransitivelyPresent(ngModule, scope) {
      return ngModule._def.modules.indexOf(scope) > -1;
    }
    /**
     * @param {?} ngModule
     * @param {?} def
     * @return {?}
     */


    function targetsModule(ngModule, def) {
      return def.providedIn != null && (moduleTransitivelyPresent(ngModule, def.providedIn) || def.providedIn === 'root' && ngModule._def.isRoot);
    }
    /**
     * @param {?} ngModule
     * @param {?} providerDef
     * @return {?}
     */


    function _createProviderInstance(ngModule, providerDef) {
      /** @type {?} */
      let injectable;

      switch (providerDef.flags & 201347067
      /* Types */
      ) {
        case 512
        /* TypeClassProvider */
        :
          injectable = _createClass(ngModule, providerDef.value, providerDef.deps);
          break;

        case 1024
        /* TypeFactoryProvider */
        :
          injectable = _callFactory(ngModule, providerDef.value, providerDef.deps);
          break;

        case 2048
        /* TypeUseExistingProvider */
        :
          injectable = resolveNgModuleDep(ngModule, providerDef.deps[0]);
          break;

        case 256
        /* TypeValueProvider */
        :
          injectable = providerDef.value;
          break;
      } // The read of `ngOnDestroy` here is slightly expensive as it's megamorphic, so it should be
      // avoided if possible. The sequence of checks here determines whether ngOnDestroy needs to be
      // checked. It might not if the `injectable` isn't an object or if NodeFlags.OnDestroy is already
      // set (ngOnDestroy was detected statically).


      if (injectable !== UNDEFINED_VALUE && injectable !== null && typeof injectable === 'object' && !(providerDef.flags & 131072
      /* OnDestroy */
      ) && typeof injectable.ngOnDestroy === 'function') {
        providerDef.flags |= 131072
        /* OnDestroy */
        ;
      }

      return injectable === undefined ? UNDEFINED_VALUE : injectable;
    }
    /**
     * @param {?} ngModule
     * @param {?} ctor
     * @param {?} deps
     * @return {?}
     */


    function _createClass(ngModule, ctor, deps) {
      /** @type {?} */
      const len = deps.length;

      switch (len) {
        case 0:
          return new ctor();

        case 1:
          return new ctor(resolveNgModuleDep(ngModule, deps[0]));

        case 2:
          return new ctor(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]));

        case 3:
          return new ctor(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]), resolveNgModuleDep(ngModule, deps[2]));

        default:
          /** @type {?} */
          const depValues = new Array(len);

          for (let i = 0; i < len; i++) {
            depValues[i] = resolveNgModuleDep(ngModule, deps[i]);
          }

          return new ctor(...depValues);
      }
    }
    /**
     * @param {?} ngModule
     * @param {?} factory
     * @param {?} deps
     * @return {?}
     */


    function _callFactory(ngModule, factory, deps) {
      /** @type {?} */
      const len = deps.length;

      switch (len) {
        case 0:
          return factory();

        case 1:
          return factory(resolveNgModuleDep(ngModule, deps[0]));

        case 2:
          return factory(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]));

        case 3:
          return factory(resolveNgModuleDep(ngModule, deps[0]), resolveNgModuleDep(ngModule, deps[1]), resolveNgModuleDep(ngModule, deps[2]));

        default:
          /** @type {?} */
          const depValues = Array(len);

          for (let i = 0; i < len; i++) {
            depValues[i] = resolveNgModuleDep(ngModule, deps[i]);
          }

          return factory(...depValues);
      }
    }
    /**
     * @param {?} ngModule
     * @param {?} lifecycles
     * @return {?}
     */


    function callNgModuleLifecycle(ngModule, lifecycles) {
      /** @type {?} */
      const def = ngModule._def;
      /** @type {?} */

      const destroyed = new Set();

      for (let i = 0; i < def.providers.length; i++) {
        /** @type {?} */
        const provDef = def.providers[i];

        if (provDef.flags & 131072
        /* OnDestroy */
        ) {
            /** @type {?} */
            const instance = ngModule._providers[i];

            if (instance && instance !== UNDEFINED_VALUE) {
              /** @type {?} */
              const onDestroy = instance.ngOnDestroy;

              if (typeof onDestroy === 'function' && !destroyed.has(instance)) {
                onDestroy.apply(instance);
                destroyed.add(instance);
              }
            }
          }
      }
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} parentView
     * @param {?} elementData
     * @param {?} viewIndex
     * @param {?} view
     * @return {?}
     */


    function attachEmbeddedView(parentView, elementData, viewIndex, view) {
      /** @type {?} */
      let embeddedViews =
      /** @type {?} */
      elementData.viewContainer._embeddedViews;

      if (viewIndex === null || viewIndex === undefined) {
        viewIndex = embeddedViews.length;
      }

      view.viewContainerParent = parentView;
      addToArray(embeddedViews,
      /** @type {?} */
      viewIndex, view);
      attachProjectedView(elementData, view);
      Services.dirtyParentQueries(view);
      /** @type {?} */

      const prevView =
      /** @type {?} */
      viewIndex > 0 ? embeddedViews[
      /** @type {?} */
      viewIndex - 1] : null;
      renderAttachEmbeddedView(elementData, prevView, view);
    }
    /**
     * @param {?} vcElementData
     * @param {?} view
     * @return {?}
     */


    function attachProjectedView(vcElementData, view) {
      /** @type {?} */
      const dvcElementData = declaredViewContainer(view);

      if (!dvcElementData || dvcElementData === vcElementData || view.state & 16
      /* IsProjectedView */
      ) {
          return;
        } // Note: For performance reasons, we
      // - add a view to template._projectedViews only 1x throughout its lifetime,
      //   and remove it not until the view is destroyed.
      //   (hard, as when a parent view is attached/detached we would need to attach/detach all
      //    nested projected views as well, even across component boundaries).
      // - don't track the insertion order of views in the projected views array
      //   (hard, as when the views of the same template are inserted different view containers)


      view.state |= 16
      /* IsProjectedView */
      ;
      /** @type {?} */

      let projectedViews = dvcElementData.template._projectedViews;

      if (!projectedViews) {
        projectedViews = dvcElementData.template._projectedViews = [];
      }

      projectedViews.push(view); // Note: we are changing the NodeDef here as we cannot calculate
      // the fact whether a template is used for projection during compilation.

      markNodeAsProjectedTemplate(
      /** @type {?} */
      view.parent.def,
      /** @type {?} */
      view.parentNodeDef);
    }
    /**
     * @param {?} viewDef
     * @param {?} nodeDef
     * @return {?}
     */


    function markNodeAsProjectedTemplate(viewDef, nodeDef) {
      if (nodeDef.flags & 4
      /* ProjectedTemplate */
      ) {
          return;
        }

      viewDef.nodeFlags |= 4
      /* ProjectedTemplate */
      ;
      nodeDef.flags |= 4
      /* ProjectedTemplate */
      ;
      /** @type {?} */

      let parentNodeDef = nodeDef.parent;

      while (parentNodeDef) {
        parentNodeDef.childFlags |= 4
        /* ProjectedTemplate */
        ;
        parentNodeDef = parentNodeDef.parent;
      }
    }
    /**
     * @param {?} elementData
     * @param {?=} viewIndex
     * @return {?}
     */


    function detachEmbeddedView(elementData, viewIndex) {
      /** @type {?} */
      const embeddedViews =
      /** @type {?} */
      elementData.viewContainer._embeddedViews;

      if (viewIndex == null || viewIndex >= embeddedViews.length) {
        viewIndex = embeddedViews.length - 1;
      }

      if (viewIndex < 0) {
        return null;
      }
      /** @type {?} */


      const view = embeddedViews[viewIndex];
      view.viewContainerParent = null;
      removeFromArray(embeddedViews, viewIndex); // See attachProjectedView for why we don't update projectedViews here.

      Services.dirtyParentQueries(view);
      renderDetachView$1(view);
      return view;
    }
    /**
     * @param {?} view
     * @return {?}
     */


    function detachProjectedView(view) {
      if (!(view.state & 16
      /* IsProjectedView */
      )) {
        return;
      }
      /** @type {?} */


      const dvcElementData = declaredViewContainer(view);

      if (dvcElementData) {
        /** @type {?} */
        const projectedViews = dvcElementData.template._projectedViews;

        if (projectedViews) {
          removeFromArray(projectedViews, projectedViews.indexOf(view));
          Services.dirtyParentQueries(view);
        }
      }
    }
    /**
     * @param {?} elementData
     * @param {?} oldViewIndex
     * @param {?} newViewIndex
     * @return {?}
     */


    function moveEmbeddedView(elementData, oldViewIndex, newViewIndex) {
      /** @type {?} */
      const embeddedViews =
      /** @type {?} */
      elementData.viewContainer._embeddedViews;
      /** @type {?} */

      const view = embeddedViews[oldViewIndex];
      removeFromArray(embeddedViews, oldViewIndex);

      if (newViewIndex == null) {
        newViewIndex = embeddedViews.length;
      }

      addToArray(embeddedViews, newViewIndex, view); // Note: Don't need to change projectedViews as the order in there
      // as always invalid...

      Services.dirtyParentQueries(view);
      renderDetachView$1(view);
      /** @type {?} */

      const prevView = newViewIndex > 0 ? embeddedViews[newViewIndex - 1] : null;
      renderAttachEmbeddedView(elementData, prevView, view);
      return view;
    }
    /**
     * @param {?} elementData
     * @param {?} prevView
     * @param {?} view
     * @return {?}
     */


    function renderAttachEmbeddedView(elementData, prevView, view) {
      /** @type {?} */
      const prevRenderNode = prevView ? renderNode(prevView,
      /** @type {?} */
      prevView.def.lastRenderRootNode) : elementData.renderElement;
      /** @type {?} */

      const parentNode = view.renderer.parentNode(prevRenderNode);
      /** @type {?} */

      const nextSibling = view.renderer.nextSibling(prevRenderNode); // Note: We can't check if `nextSibling` is present, as on WebWorkers it will always be!
      // However, browsers automatically do `appendChild` when there is no `nextSibling`.

      visitRootRenderNodes(view, 2
      /* InsertBefore */
      , parentNode, nextSibling, undefined);
    }
    /**
     * @param {?} view
     * @return {?}
     */


    function renderDetachView$1(view) {
      visitRootRenderNodes(view, 3
      /* RemoveChild */
      , null, null, undefined);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    const EMPTY_CONTEXT = new Object(); // Attention: this function is called as top level function.
    // Putting any logic in here will destroy closure tree shaking!

    /**
     * @param {?} selector
     * @param {?} componentType
     * @param {?} viewDefFactory
     * @param {?} inputs
     * @param {?} outputs
     * @param {?} ngContentSelectors
     * @return {?}
     */

    function createComponentFactory(selector, componentType, viewDefFactory, inputs, outputs, ngContentSelectors) {
      return new ComponentFactory_(selector, componentType, viewDefFactory, inputs, outputs, ngContentSelectors);
    }
    /**
     * @param {?} componentFactory
     * @return {?}
     */


    function getComponentViewDefinitionFactory(componentFactory) {
      return (
        /** @type {?} */
        componentFactory.viewDefFactory
      );
    }

    class ComponentFactory_ extends ComponentFactory {
      /**
       * @param {?} selector
       * @param {?} componentType
       * @param {?} viewDefFactory
       * @param {?} _inputs
       * @param {?} _outputs
       * @param {?} ngContentSelectors
       */
      constructor(selector, componentType, viewDefFactory, _inputs, _outputs, ngContentSelectors) {
        // Attention: this ctor is called as top level function.
        // Putting any logic in here will destroy closure tree shaking!
        super();
        this.selector = selector;
        this.componentType = componentType;
        this._inputs = _inputs;
        this._outputs = _outputs;
        this.ngContentSelectors = ngContentSelectors;
        this.viewDefFactory = viewDefFactory;
      }
      /**
       * @return {?}
       */


      get inputs() {
        /** @type {?} */
        const inputsArr = [];
        /** @type {?} */

        const inputs =
        /** @type {?} */
        this._inputs;

        for (let propName in inputs) {
          /** @type {?} */
          const templateName = inputs[propName];
          inputsArr.push({
            propName,
            templateName
          });
        }

        return inputsArr;
      }
      /**
       * @return {?}
       */


      get outputs() {
        /** @type {?} */
        const outputsArr = [];

        for (let propName in this._outputs) {
          /** @type {?} */
          const templateName = this._outputs[propName];
          outputsArr.push({
            propName,
            templateName
          });
        }

        return outputsArr;
      }
      /**
       * Creates a new component.
       * @param {?} injector
       * @param {?=} projectableNodes
       * @param {?=} rootSelectorOrNode
       * @param {?=} ngModule
       * @return {?}
       */


      create(injector, projectableNodes, rootSelectorOrNode, ngModule) {
        if (!ngModule) {
          throw new Error('ngModule should be provided');
        }
        /** @type {?} */


        const viewDef = resolveDefinition(this.viewDefFactory);
        /** @type {?} */

        const componentNodeIndex =
        /** @type {?} */

        /** @type {?} */
        viewDef.nodes[0].element.componentProvider.nodeIndex;
        /** @type {?} */

        const view = Services.createRootView(injector, projectableNodes || [], rootSelectorOrNode, viewDef, ngModule, EMPTY_CONTEXT);
        /** @type {?} */

        const component = asProviderData(view, componentNodeIndex).instance;

        if (rootSelectorOrNode) {
          view.renderer.setAttribute(asElementData(view, 0).renderElement, 'ng-version', VERSION.full);
        }

        return new ComponentRef_(view, new ViewRef_(view), component);
      }

    }

    if (false) {}

    class ComponentRef_ extends ComponentRef {
      /**
       * @param {?} _view
       * @param {?} _viewRef
       * @param {?} _component
       */
      constructor(_view, _viewRef, _component) {
        super();
        this._view = _view;
        this._viewRef = _viewRef;
        this._component = _component;
        this._elDef = this._view.def.nodes[0];
        this.hostView = _viewRef;
        this.changeDetectorRef = _viewRef;
        this.instance = _component;
      }
      /**
       * @return {?}
       */


      get location() {
        return new ElementRef(asElementData(this._view, this._elDef.nodeIndex).renderElement);
      }
      /**
       * @return {?}
       */


      get injector() {
        return new Injector_(this._view, this._elDef);
      }
      /**
       * @return {?}
       */


      get componentType() {
        return (
          /** @type {?} */
          this._component.constructor
        );
      }
      /**
       * @return {?}
       */


      destroy() {
        this._viewRef.destroy();
      }
      /**
       * @param {?} callback
       * @return {?}
       */


      onDestroy(callback) {
        this._viewRef.onDestroy(callback);
      }

    }

    if (false) {}
    /**
     * @param {?} view
     * @param {?} elDef
     * @param {?} elData
     * @return {?}
     */


    function createViewContainerData(view, elDef, elData) {
      return new ViewContainerRef_(view, elDef, elData);
    }

    class ViewContainerRef_ {
      /**
       * @param {?} _view
       * @param {?} _elDef
       * @param {?} _data
       */
      constructor(_view, _elDef, _data) {
        this._view = _view;
        this._elDef = _elDef;
        this._data = _data;
        /**
         * \@internal
         */

        this._embeddedViews = [];
      }
      /**
       * @return {?}
       */


      get element() {
        return new ElementRef(this._data.renderElement);
      }
      /**
       * @return {?}
       */


      get injector() {
        return new Injector_(this._view, this._elDef);
      }
      /**
       * @deprecated No replacement
       * @return {?}
       */


      get parentInjector() {
        /** @type {?} */
        let view = this._view;
        /** @type {?} */

        let elDef = this._elDef.parent;

        while (!elDef && view) {
          elDef = viewParentEl(view);
          view =
          /** @type {?} */
          view.parent;
        }

        return view ? new Injector_(view, elDef) : new Injector_(this._view, null);
      }
      /**
       * @return {?}
       */


      clear() {
        /** @type {?} */
        const len = this._embeddedViews.length;

        for (let i = len - 1; i >= 0; i--) {
          /** @type {?} */
          const view =
          /** @type {?} */
          detachEmbeddedView(this._data, i);
          Services.destroyView(view);
        }
      }
      /**
       * @param {?} index
       * @return {?}
       */


      get(index) {
        /** @type {?} */
        const view = this._embeddedViews[index];

        if (view) {
          /** @type {?} */
          const ref = new ViewRef_(view);
          ref.attachToViewContainerRef(this);
          return ref;
        }

        return null;
      }
      /**
       * @return {?}
       */


      get length() {
        return this._embeddedViews.length;
      }
      /**
       * @template C
       * @param {?} templateRef
       * @param {?=} context
       * @param {?=} index
       * @return {?}
       */


      createEmbeddedView(templateRef, context, index) {
        /** @type {?} */
        const viewRef = templateRef.createEmbeddedView(context ||
        /** @type {?} */
        {});
        this.insert(viewRef, index);
        return viewRef;
      }
      /**
       * @template C
       * @param {?} componentFactory
       * @param {?=} index
       * @param {?=} injector
       * @param {?=} projectableNodes
       * @param {?=} ngModuleRef
       * @return {?}
       */


      createComponent(componentFactory, index, injector, projectableNodes, ngModuleRef) {
        /** @type {?} */
        const contextInjector = injector || this.parentInjector;

        if (!ngModuleRef && !(componentFactory instanceof ComponentFactoryBoundToModule)) {
          ngModuleRef = contextInjector.get(NgModuleRef);
        }
        /** @type {?} */


        const componentRef = componentFactory.create(contextInjector, projectableNodes, undefined, ngModuleRef);
        this.insert(componentRef.hostView, index);
        return componentRef;
      }
      /**
       * @param {?} viewRef
       * @param {?=} index
       * @return {?}
       */


      insert(viewRef, index) {
        if (viewRef.destroyed) {
          throw new Error('Cannot insert a destroyed View in a ViewContainer!');
        }
        /** @type {?} */


        const viewRef_ =
        /** @type {?} */
        viewRef;
        /** @type {?} */

        const viewData = viewRef_._view;
        attachEmbeddedView(this._view, this._data, index, viewData);
        viewRef_.attachToViewContainerRef(this);
        return viewRef;
      }
      /**
       * @param {?} viewRef
       * @param {?} currentIndex
       * @return {?}
       */


      move(viewRef, currentIndex) {
        if (viewRef.destroyed) {
          throw new Error('Cannot move a destroyed View in a ViewContainer!');
        }
        /** @type {?} */


        const previousIndex = this._embeddedViews.indexOf(viewRef._view);

        moveEmbeddedView(this._data, previousIndex, currentIndex);
        return viewRef;
      }
      /**
       * @param {?} viewRef
       * @return {?}
       */


      indexOf(viewRef) {
        return this._embeddedViews.indexOf(
        /** @type {?} */
        viewRef._view);
      }
      /**
       * @param {?=} index
       * @return {?}
       */


      remove(index) {
        /** @type {?} */
        const viewData = detachEmbeddedView(this._data, index);

        if (viewData) {
          Services.destroyView(viewData);
        }
      }
      /**
       * @param {?=} index
       * @return {?}
       */


      detach(index) {
        /** @type {?} */
        const view = detachEmbeddedView(this._data, index);
        return view ? new ViewRef_(view) : null;
      }

    }

    if (false) {}
    /**
     * @param {?} view
     * @return {?}
     */


    function createChangeDetectorRef(view) {
      return new ViewRef_(view);
    }

    class ViewRef_ {
      /**
       * @param {?} _view
       */
      constructor(_view) {
        this._view = _view;
        this._viewContainerRef = null;
        this._appRef = null;
      }
      /**
       * @return {?}
       */


      get rootNodes() {
        return rootRenderNodes(this._view);
      }
      /**
       * @return {?}
       */


      get context() {
        return this._view.context;
      }
      /**
       * @return {?}
       */


      get destroyed() {
        return (this._view.state & 128
        /* Destroyed */
        ) !== 0;
      }
      /**
       * @return {?}
       */


      markForCheck() {
        markParentViewsForCheck(this._view);
      }
      /**
       * @return {?}
       */


      detach() {
        this._view.state &= ~4
        /* Attached */
        ;
      }
      /**
       * @return {?}
       */


      detectChanges() {
        /** @type {?} */
        const fs = this._view.root.rendererFactory;

        if (fs.begin) {
          fs.begin();
        }

        try {
          Services.checkAndUpdateView(this._view);
        } finally {
          if (fs.end) {
            fs.end();
          }
        }
      }
      /**
       * @return {?}
       */


      checkNoChanges() {
        Services.checkNoChangesView(this._view);
      }
      /**
       * @return {?}
       */


      reattach() {
        this._view.state |= 4
        /* Attached */
        ;
      }
      /**
       * @param {?} callback
       * @return {?}
       */


      onDestroy(callback) {
        if (!this._view.disposables) {
          this._view.disposables = [];
        }

        this._view.disposables.push(
        /** @type {?} */
        callback);
      }
      /**
       * @return {?}
       */


      destroy() {
        if (this._appRef) {
          this._appRef.detachView(this);
        } else if (this._viewContainerRef) {
          this._viewContainerRef.detach(this._viewContainerRef.indexOf(this));
        }

        Services.destroyView(this._view);
      }
      /**
       * @return {?}
       */


      detachFromAppRef() {
        this._appRef = null;
        renderDetachView$1(this._view);
        Services.dirtyParentQueries(this._view);
      }
      /**
       * @param {?} appRef
       * @return {?}
       */


      attachToAppRef(appRef) {
        if (this._viewContainerRef) {
          throw new Error('This view is already attached to a ViewContainer!');
        }

        this._appRef = appRef;
      }
      /**
       * @param {?} vcRef
       * @return {?}
       */


      attachToViewContainerRef(vcRef) {
        if (this._appRef) {
          throw new Error('This view is already attached directly to the ApplicationRef!');
        }

        this._viewContainerRef = vcRef;
      }

    }

    if (false) {}
    /**
     * @param {?} view
     * @param {?} def
     * @return {?}
     */


    function createTemplateData(view, def) {
      return new TemplateRef_(view, def);
    }

    class TemplateRef_ extends TemplateRef {
      /**
       * @param {?} _parentView
       * @param {?} _def
       */
      constructor(_parentView, _def) {
        super();
        this._parentView = _parentView;
        this._def = _def;
      }
      /**
       * @param {?} context
       * @return {?}
       */


      createEmbeddedView(context) {
        return new ViewRef_(Services.createEmbeddedView(this._parentView, this._def,
        /** @type {?} */

        /** @type {?} */
        this._def.element.template, context));
      }
      /**
       * @return {?}
       */


      get elementRef() {
        return new ElementRef(asElementData(this._parentView, this._def.nodeIndex).renderElement);
      }

    }

    if (false) {}
    /**
     * @param {?} view
     * @param {?} elDef
     * @return {?}
     */


    function createInjector$1(view, elDef) {
      return new Injector_(view, elDef);
    }

    class Injector_ {
      /**
       * @param {?} view
       * @param {?} elDef
       */
      constructor(view, elDef) {
        this.view = view;
        this.elDef = elDef;
      }
      /**
       * @param {?} token
       * @param {?=} notFoundValue
       * @return {?}
       */


      get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND) {
        /** @type {?} */
        const allowPrivateServices = this.elDef ? (this.elDef.flags & 33554432
        /* ComponentView */
        ) !== 0 : false;
        return Services.resolveDep(this.view, this.elDef, allowPrivateServices, {
          flags: 0
          /* None */
          ,
          token,
          tokenKey: tokenKey(token)
        }, notFoundValue);
      }

    }

    if (false) {}
    /**
     * @param {?} view
     * @param {?} index
     * @return {?}
     */


    function nodeValue(view, index) {
      /** @type {?} */
      const def = view.def.nodes[index];

      if (def.flags & 1
      /* TypeElement */
      ) {
          /** @type {?} */
          const elData = asElementData(view, def.nodeIndex);
          return (
            /** @type {?} */
            def.element.template ? elData.template : elData.renderElement
          );
        } else if (def.flags & 2
      /* TypeText */
      ) {
          return asTextData(view, def.nodeIndex).renderText;
        } else if (def.flags & (20224
      /* CatProvider */
      | 16
      /* TypePipe */
      )) {
        return asProviderData(view, def.nodeIndex).instance;
      }

      throw new Error("Illegal state: read nodeValue for node index ".concat(index));
    }
    /**
     * @param {?} view
     * @return {?}
     */


    function createRendererV1(view) {
      return new RendererAdapter(view.renderer);
    }

    class RendererAdapter {
      /**
       * @param {?} delegate
       */
      constructor(delegate) {
        this.delegate = delegate;
      }
      /**
       * @param {?} selectorOrNode
       * @return {?}
       */


      selectRootElement(selectorOrNode) {
        return this.delegate.selectRootElement(selectorOrNode);
      }
      /**
       * @param {?} parent
       * @param {?} namespaceAndName
       * @return {?}
       */


      createElement(parent, namespaceAndName) {
        const [ns, name] = splitNamespace(namespaceAndName);
        /** @type {?} */

        const el = this.delegate.createElement(name, ns);

        if (parent) {
          this.delegate.appendChild(parent, el);
        }

        return el;
      }
      /**
       * @param {?} hostElement
       * @return {?}
       */


      createViewRoot(hostElement) {
        return hostElement;
      }
      /**
       * @param {?} parentElement
       * @return {?}
       */


      createTemplateAnchor(parentElement) {
        /** @type {?} */
        const comment = this.delegate.createComment('');

        if (parentElement) {
          this.delegate.appendChild(parentElement, comment);
        }

        return comment;
      }
      /**
       * @param {?} parentElement
       * @param {?} value
       * @return {?}
       */


      createText(parentElement, value) {
        /** @type {?} */
        const node = this.delegate.createText(value);

        if (parentElement) {
          this.delegate.appendChild(parentElement, node);
        }

        return node;
      }
      /**
       * @param {?} parentElement
       * @param {?} nodes
       * @return {?}
       */


      projectNodes(parentElement, nodes) {
        for (let i = 0; i < nodes.length; i++) {
          this.delegate.appendChild(parentElement, nodes[i]);
        }
      }
      /**
       * @param {?} node
       * @param {?} viewRootNodes
       * @return {?}
       */


      attachViewAfter(node, viewRootNodes) {
        /** @type {?} */
        const parentElement = this.delegate.parentNode(node);
        /** @type {?} */

        const nextSibling = this.delegate.nextSibling(node);

        for (let i = 0; i < viewRootNodes.length; i++) {
          this.delegate.insertBefore(parentElement, viewRootNodes[i], nextSibling);
        }
      }
      /**
       * @param {?} viewRootNodes
       * @return {?}
       */


      detachView(viewRootNodes) {
        for (let i = 0; i < viewRootNodes.length; i++) {
          /** @type {?} */
          const node = viewRootNodes[i];
          /** @type {?} */

          const parentElement = this.delegate.parentNode(node);
          this.delegate.removeChild(parentElement, node);
        }
      }
      /**
       * @param {?} hostElement
       * @param {?} viewAllNodes
       * @return {?}
       */


      destroyView(hostElement, viewAllNodes) {
        for (let i = 0; i < viewAllNodes.length; i++) {
          /** @type {?} */
          this.delegate.destroyNode(viewAllNodes[i]);
        }
      }
      /**
       * @param {?} renderElement
       * @param {?} name
       * @param {?} callback
       * @return {?}
       */


      listen(renderElement, name, callback) {
        return this.delegate.listen(renderElement, name,
        /** @type {?} */
        callback);
      }
      /**
       * @param {?} target
       * @param {?} name
       * @param {?} callback
       * @return {?}
       */


      listenGlobal(target, name, callback) {
        return this.delegate.listen(target, name,
        /** @type {?} */
        callback);
      }
      /**
       * @param {?} renderElement
       * @param {?} propertyName
       * @param {?} propertyValue
       * @return {?}
       */


      setElementProperty(renderElement, propertyName, propertyValue) {
        this.delegate.setProperty(renderElement, propertyName, propertyValue);
      }
      /**
       * @param {?} renderElement
       * @param {?} namespaceAndName
       * @param {?=} attributeValue
       * @return {?}
       */


      setElementAttribute(renderElement, namespaceAndName, attributeValue) {
        const [ns, name] = splitNamespace(namespaceAndName);

        if (attributeValue != null) {
          this.delegate.setAttribute(renderElement, name, attributeValue, ns);
        } else {
          this.delegate.removeAttribute(renderElement, name, ns);
        }
      }
      /**
       * @param {?} renderElement
       * @param {?} propertyName
       * @param {?} propertyValue
       * @return {?}
       */


      setBindingDebugInfo(renderElement, propertyName, propertyValue) {}
      /**
       * @param {?} renderElement
       * @param {?} className
       * @param {?} isAdd
       * @return {?}
       */


      setElementClass(renderElement, className, isAdd) {
        if (isAdd) {
          this.delegate.addClass(renderElement, className);
        } else {
          this.delegate.removeClass(renderElement, className);
        }
      }
      /**
       * @param {?} renderElement
       * @param {?} styleName
       * @param {?=} styleValue
       * @return {?}
       */


      setElementStyle(renderElement, styleName, styleValue) {
        if (styleValue != null) {
          this.delegate.setStyle(renderElement, styleName, styleValue);
        } else {
          this.delegate.removeStyle(renderElement, styleName);
        }
      }
      /**
       * @param {?} renderElement
       * @param {?} methodName
       * @param {?} args
       * @return {?}
       */


      invokeElementMethod(renderElement, methodName, args) {
        /** @type {?} */
        renderElement[methodName].apply(renderElement, args);
      }
      /**
       * @param {?} renderNode
       * @param {?} text
       * @return {?}
       */


      setText(renderNode, text) {
        this.delegate.setValue(renderNode, text);
      }
      /**
       * @return {?}
       */


      animate() {
        throw new Error('Renderer.animate is no longer supported!');
      }

    }

    if (false) {}
    /**
     * @param {?} moduleType
     * @param {?} parent
     * @param {?} bootstrapComponents
     * @param {?} def
     * @return {?}
     */


    function createNgModuleRef(moduleType, parent, bootstrapComponents, def) {
      return new NgModuleRef_(moduleType, parent, bootstrapComponents, def);
    }

    class NgModuleRef_ {
      /**
       * @param {?} _moduleType
       * @param {?} _parent
       * @param {?} _bootstrapComponents
       * @param {?} _def
       */
      constructor(_moduleType, _parent, _bootstrapComponents, _def) {
        this._moduleType = _moduleType;
        this._parent = _parent;
        this._bootstrapComponents = _bootstrapComponents;
        this._def = _def;
        this._destroyListeners = [];
        this._destroyed = false;
        this.injector = this;
        initNgModule(this);
      }
      /**
       * @param {?} token
       * @param {?=} notFoundValue
       * @param {?=} injectFlags
       * @return {?}
       */


      get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, injectFlags = InjectFlags.Default) {
        /** @type {?} */
        let flags = 0
        /* None */
        ;

        if (injectFlags & InjectFlags.SkipSelf) {
          flags |= 1
          /* SkipSelf */
          ;
        } else if (injectFlags & InjectFlags.Self) {
          flags |= 4
          /* Self */
          ;
        }

        return resolveNgModuleDep(this, {
          token: token,
          tokenKey: tokenKey(token),
          flags: flags
        }, notFoundValue);
      }
      /**
       * @return {?}
       */


      get instance() {
        return this.get(this._moduleType);
      }
      /**
       * @return {?}
       */


      get componentFactoryResolver() {
        return this.get(ComponentFactoryResolver);
      }
      /**
       * @return {?}
       */


      destroy() {
        if (this._destroyed) {
          throw new Error("The ng module ".concat(stringify(this.instance.constructor), " has already been destroyed."));
        }

        this._destroyed = true;
        callNgModuleLifecycle(this, 131072
        /* OnDestroy */
        );

        this._destroyListeners.forEach(
        /**
        * @param {?} listener
        * @return {?}
        */
        listener => listener());
      }
      /**
       * @param {?} callback
       * @return {?}
       */


      onDestroy(callback) {
        this._destroyListeners.push(callback);
      }

    }

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    const RendererV1TokenKey = tokenKey(Renderer);
    /** @type {?} */

    const Renderer2TokenKey = tokenKey(Renderer2);
    /** @type {?} */

    const ElementRefTokenKey = tokenKey(ElementRef);
    /** @type {?} */

    const ViewContainerRefTokenKey = tokenKey(ViewContainerRef);
    /** @type {?} */

    const TemplateRefTokenKey = tokenKey(TemplateRef);
    /** @type {?} */

    const ChangeDetectorRefTokenKey = tokenKey(ChangeDetectorRef);
    /** @type {?} */

    const InjectorRefTokenKey$1 = tokenKey(Injector);
    /** @type {?} */

    const INJECTORRefTokenKey$1 = tokenKey(INJECTOR);
    /**
     * @param {?} checkIndex
     * @param {?} flags
     * @param {?} matchedQueries
     * @param {?} childCount
     * @param {?} ctor
     * @param {?} deps
     * @param {?=} props
     * @param {?=} outputs
     * @return {?}
     */

    function directiveDef(checkIndex, flags, matchedQueries, childCount, ctor, deps, props, outputs) {
      /** @type {?} */
      const bindings = [];

      if (props) {
        for (let prop in props) {
          const [bindingIndex, nonMinifiedName] = props[prop];
          bindings[bindingIndex] = {
            flags: 8
            /* TypeProperty */
            ,
            name: prop,
            nonMinifiedName,
            ns: null,
            securityContext: null,
            suffix: null
          };
        }
      }
      /** @type {?} */


      const outputDefs = [];

      if (outputs) {
        for (let propName in outputs) {
          outputDefs.push({
            type: 1
            /* DirectiveOutput */
            ,
            propName,
            target: null,
            eventName: outputs[propName]
          });
        }
      }

      flags |= 16384
      /* TypeDirective */
      ;
      return _def(checkIndex, flags, matchedQueries, childCount, ctor, ctor, deps, bindings, outputDefs);
    }
    /**
     * @param {?} flags
     * @param {?} ctor
     * @param {?} deps
     * @return {?}
     */


    function pipeDef(flags, ctor, deps) {
      flags |= 16
      /* TypePipe */
      ;
      return _def(-1, flags, null, 0, ctor, ctor, deps);
    }
    /**
     * @param {?} flags
     * @param {?} matchedQueries
     * @param {?} token
     * @param {?} value
     * @param {?} deps
     * @return {?}
     */


    function providerDef(flags, matchedQueries, token, value, deps) {
      return _def(-1, flags, matchedQueries, 0, token, value, deps);
    }
    /**
     * @param {?} checkIndex
     * @param {?} flags
     * @param {?} matchedQueriesDsl
     * @param {?} childCount
     * @param {?} token
     * @param {?} value
     * @param {?} deps
     * @param {?=} bindings
     * @param {?=} outputs
     * @return {?}
     */


    function _def(checkIndex, flags, matchedQueriesDsl, childCount, token, value, deps, bindings, outputs) {
      const {
        matchedQueries,
        references,
        matchedQueryIds
      } = splitMatchedQueriesDsl(matchedQueriesDsl);

      if (!outputs) {
        outputs = [];
      }

      if (!bindings) {
        bindings = [];
      } // Need to resolve forwardRefs as e.g. for `useValue` we
      // lowered the expression and then stopped evaluating it,
      // i.e. also didn't unwrap it.


      value = resolveForwardRef(value);
      /** @type {?} */

      const depDefs = splitDepsDsl(deps, stringify(token));
      return {
        // will bet set by the view definition
        nodeIndex: -1,
        parent: null,
        renderParent: null,
        bindingIndex: -1,
        outputIndex: -1,
        // regular values
        checkIndex,
        flags,
        childFlags: 0,
        directChildFlags: 0,
        childMatchedQueries: 0,
        matchedQueries,
        matchedQueryIds,
        references,
        ngContentIndex: -1,
        childCount,
        bindings,
        bindingFlags: calcBindingFlags(bindings),
        outputs,
        element: null,
        provider: {
          token,
          value,
          deps: depDefs
        },
        text: null,
        query: null,
        ngContent: null
      };
    }
    /**
     * @param {?} view
     * @param {?} def
     * @return {?}
     */


    function createProviderInstance(view, def) {
      return _createProviderInstance$1(view, def);
    }
    /**
     * @param {?} view
     * @param {?} def
     * @return {?}
     */


    function createPipeInstance(view, def) {
      // deps are looked up from component.

      /** @type {?} */
      let compView = view;

      while (compView.parent && !isComponentView(compView)) {
        compView = compView.parent;
      } // pipes can see the private services of the component

      /** @type {?} */


      const allowPrivateServices = true; // pipes are always eager and classes!

      return createClass(
      /** @type {?} */
      compView.parent,
      /** @type {?} */
      viewParentEl(compView), allowPrivateServices,
      /** @type {?} */
      def.provider.value,
      /** @type {?} */
      def.provider.deps);
    }
    /**
     * @param {?} view
     * @param {?} def
     * @return {?}
     */


    function createDirectiveInstance(view, def) {
      // components can see other private services, other directives can't.

      /** @type {?} */
      const allowPrivateServices = (def.flags & 32768
      /* Component */
      ) > 0; // directives are always eager and classes!

      /** @type {?} */

      const instance = createClass(view,
      /** @type {?} */
      def.parent, allowPrivateServices,
      /** @type {?} */
      def.provider.value,
      /** @type {?} */
      def.provider.deps);

      if (def.outputs.length) {
        for (let i = 0; i < def.outputs.length; i++) {
          /** @type {?} */
          const output = def.outputs[i];
          /** @type {?} */

          const outputObservable = instance[
          /** @type {?} */
          output.propName];

          if (isObservable(outputObservable)) {
            /** @type {?} */
            const subscription = outputObservable.subscribe(eventHandlerClosure(view,
            /** @type {?} */
            def.parent.nodeIndex, output.eventName));

            /** @type {?} */
            view.disposables[def.outputIndex + i] = subscription.unsubscribe.bind(subscription);
          } else {
            throw new Error("@Output ".concat(output.propName, " not initialized in '").concat(instance.constructor.name, "'."));
          }
        }
      }

      return instance;
    }
    /**
     * @param {?} view
     * @param {?} index
     * @param {?} eventName
     * @return {?}
     */


    function eventHandlerClosure(view, index, eventName) {
      return (
        /**
        * @param {?} event
        * @return {?}
        */
        event => dispatchEvent(view, index, eventName, event)
      );
    }
    /**
     * @param {?} view
     * @param {?} def
     * @param {?} v0
     * @param {?} v1
     * @param {?} v2
     * @param {?} v3
     * @param {?} v4
     * @param {?} v5
     * @param {?} v6
     * @param {?} v7
     * @param {?} v8
     * @param {?} v9
     * @return {?}
     */


    function checkAndUpdateDirectiveInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
      /** @type {?} */
      const providerData = asProviderData(view, def.nodeIndex);
      /** @type {?} */

      const directive = providerData.instance;
      /** @type {?} */

      let changed = false;
      /** @type {?} */

      let changes =
      /** @type {?} */
      undefined;
      /** @type {?} */

      const bindLen = def.bindings.length;

      if (bindLen > 0 && checkBinding(view, def, 0, v0)) {
        changed = true;
        changes = updateProp(view, providerData, def, 0, v0, changes);
      }

      if (bindLen > 1 && checkBinding(view, def, 1, v1)) {
        changed = true;
        changes = updateProp(view, providerData, def, 1, v1, changes);
      }

      if (bindLen > 2 && checkBinding(view, def, 2, v2)) {
        changed = true;
        changes = updateProp(view, providerData, def, 2, v2, changes);
      }

      if (bindLen > 3 && checkBinding(view, def, 3, v3)) {
        changed = true;
        changes = updateProp(view, providerData, def, 3, v3, changes);
      }

      if (bindLen > 4 && checkBinding(view, def, 4, v4)) {
        changed = true;
        changes = updateProp(view, providerData, def, 4, v4, changes);
      }

      if (bindLen > 5 && checkBinding(view, def, 5, v5)) {
        changed = true;
        changes = updateProp(view, providerData, def, 5, v5, changes);
      }

      if (bindLen > 6 && checkBinding(view, def, 6, v6)) {
        changed = true;
        changes = updateProp(view, providerData, def, 6, v6, changes);
      }

      if (bindLen > 7 && checkBinding(view, def, 7, v7)) {
        changed = true;
        changes = updateProp(view, providerData, def, 7, v7, changes);
      }

      if (bindLen > 8 && checkBinding(view, def, 8, v8)) {
        changed = true;
        changes = updateProp(view, providerData, def, 8, v8, changes);
      }

      if (bindLen > 9 && checkBinding(view, def, 9, v9)) {
        changed = true;
        changes = updateProp(view, providerData, def, 9, v9, changes);
      }

      if (changes) {
        directive.ngOnChanges(changes);
      }

      if (def.flags & 65536
      /* OnInit */
      && shouldCallLifecycleInitHook(view, 256
      /* InitState_CallingOnInit */
      , def.nodeIndex)) {
        directive.ngOnInit();
      }

      if (def.flags & 262144
      /* DoCheck */
      ) {
          directive.ngDoCheck();
        }

      return changed;
    }
    /**
     * @param {?} view
     * @param {?} def
     * @param {?} values
     * @return {?}
     */


    function checkAndUpdateDirectiveDynamic(view, def, values) {
      /** @type {?} */
      const providerData = asProviderData(view, def.nodeIndex);
      /** @type {?} */

      const directive = providerData.instance;
      /** @type {?} */

      let changed = false;
      /** @type {?} */

      let changes =
      /** @type {?} */
      undefined;

      for (let i = 0; i < values.length; i++) {
        if (checkBinding(view, def, i, values[i])) {
          changed = true;
          changes = updateProp(view, providerData, def, i, values[i], changes);
        }
      }

      if (changes) {
        directive.ngOnChanges(changes);
      }

      if (def.flags & 65536
      /* OnInit */
      && shouldCallLifecycleInitHook(view, 256
      /* InitState_CallingOnInit */
      , def.nodeIndex)) {
        directive.ngOnInit();
      }

      if (def.flags & 262144
      /* DoCheck */
      ) {
          directive.ngDoCheck();
        }

      return changed;
    }
    /**
     * @param {?} view
     * @param {?} def
     * @return {?}
     */


    function _createProviderInstance$1(view, def) {
      // private services can see other private services

      /** @type {?} */
      const allowPrivateServices = (def.flags & 8192
      /* PrivateProvider */
      ) > 0;
      /** @type {?} */

      const providerDef = def.provider;

      switch (def.flags & 201347067
      /* Types */
      ) {
        case 512
        /* TypeClassProvider */
        :
          return createClass(view,
          /** @type {?} */
          def.parent, allowPrivateServices,
          /** @type {?} */
          providerDef.value,
          /** @type {?} */
          providerDef.deps);

        case 1024
        /* TypeFactoryProvider */
        :
          return callFactory(view,
          /** @type {?} */
          def.parent, allowPrivateServices,
          /** @type {?} */
          providerDef.value,
          /** @type {?} */
          providerDef.deps);

        case 2048
        /* TypeUseExistingProvider */
        :
          return resolveDep(view,
          /** @type {?} */
          def.parent, allowPrivateServices,
          /** @type {?} */
          providerDef.deps[0]);

        case 256
        /* TypeValueProvider */
        :
          return (
            /** @type {?} */
            providerDef.value
          );
      }
    }
    /**
     * @param {?} view
     * @param {?} elDef
     * @param {?} allowPrivateServices
     * @param {?} ctor
     * @param {?} deps
     * @return {?}
     */


    function createClass(view, elDef, allowPrivateServices, ctor, deps) {
      /** @type {?} */
      const len = deps.length;

      switch (len) {
        case 0:
          return new ctor();

        case 1:
          return new ctor(resolveDep(view, elDef, allowPrivateServices, deps[0]));

        case 2:
          return new ctor(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]));

        case 3:
          return new ctor(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]), resolveDep(view, elDef, allowPrivateServices, deps[2]));

        default:
          /** @type {?} */
          const depValues = new Array(len);

          for (let i = 0; i < len; i++) {
            depValues[i] = resolveDep(view, elDef, allowPrivateServices, deps[i]);
          }

          return new ctor(...depValues);
      }
    }
    /**
     * @param {?} view
     * @param {?} elDef
     * @param {?} allowPrivateServices
     * @param {?} factory
     * @param {?} deps
     * @return {?}
     */


    function callFactory(view, elDef, allowPrivateServices, factory, deps) {
      /** @type {?} */
      const len = deps.length;

      switch (len) {
        case 0:
          return factory();

        case 1:
          return factory(resolveDep(view, elDef, allowPrivateServices, deps[0]));

        case 2:
          return factory(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]));

        case 3:
          return factory(resolveDep(view, elDef, allowPrivateServices, deps[0]), resolveDep(view, elDef, allowPrivateServices, deps[1]), resolveDep(view, elDef, allowPrivateServices, deps[2]));

        default:
          /** @type {?} */
          const depValues = Array(len);

          for (let i = 0; i < len; i++) {
            depValues[i] = resolveDep(view, elDef, allowPrivateServices, deps[i]);
          }

          return factory(...depValues);
      }
    } // This default value is when checking the hierarchy for a token.
    //
    // It means both:
    // - the token is not provided by the current injector,
    // - only the element injectors should be checked (ie do not check module injectors
    //
    //          mod1
    //         /
    //       el1   mod2
    //         \  /
    //         el2
    //
    // When requesting el2.injector.get(token), we should check in the following order and return the
    // first found value:
    // - el2.injector.get(token, default)
    // - el1.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) -> do not check the module
    // - mod2.injector.get(token, default)

    /** @type {?} */


    const NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};
    /**
     * @param {?} view
     * @param {?} elDef
     * @param {?} allowPrivateServices
     * @param {?} depDef
     * @param {?=} notFoundValue
     * @return {?}
     */

    function resolveDep(view, elDef, allowPrivateServices, depDef, notFoundValue = Injector.THROW_IF_NOT_FOUND) {
      if (depDef.flags & 8
      /* Value */
      ) {
          return depDef.token;
        }
      /** @type {?} */


      const startView = view;

      if (depDef.flags & 2
      /* Optional */
      ) {
          notFoundValue = null;
        }
      /** @type {?} */


      const tokenKey = depDef.tokenKey;

      if (tokenKey === ChangeDetectorRefTokenKey) {
        // directives on the same element as a component should be able to control the change detector
        // of that component as well.
        allowPrivateServices = !!(elDef &&
        /** @type {?} */
        elDef.element.componentView);
      }

      if (elDef && depDef.flags & 1
      /* SkipSelf */
      ) {
        allowPrivateServices = false;
        elDef =
        /** @type {?} */
        elDef.parent;
      }
      /** @type {?} */


      let searchView = view;

      while (searchView) {
        if (elDef) {
          switch (tokenKey) {
            case RendererV1TokenKey:
              {
                /** @type {?} */
                const compView = findCompView(searchView, elDef, allowPrivateServices);
                return createRendererV1(compView);
              }

            case Renderer2TokenKey:
              {
                /** @type {?} */
                const compView = findCompView(searchView, elDef, allowPrivateServices);
                return compView.renderer;
              }

            case ElementRefTokenKey:
              return new ElementRef(asElementData(searchView, elDef.nodeIndex).renderElement);

            case ViewContainerRefTokenKey:
              return asElementData(searchView, elDef.nodeIndex).viewContainer;

            case TemplateRefTokenKey:
              {
                if (
                /** @type {?} */
                elDef.element.template) {
                  return asElementData(searchView, elDef.nodeIndex).template;
                }

                break;
              }

            case ChangeDetectorRefTokenKey:
              {
                /** @type {?} */
                let cdView = findCompView(searchView, elDef, allowPrivateServices);
                return createChangeDetectorRef(cdView);
              }

            case InjectorRefTokenKey$1:
            case INJECTORRefTokenKey$1:
              return createInjector$1(searchView, elDef);

            default:
              /** @type {?} */
              const providerDef = (
              /** @type {?} */
              allowPrivateServices ?
              /** @type {?} */
              elDef.element.allProviders :
              /** @type {?} */
              elDef.element.publicProviders)[tokenKey];

              if (providerDef) {
                /** @type {?} */
                let providerData = asProviderData(searchView, providerDef.nodeIndex);

                if (!providerData) {
                  providerData = {
                    instance: _createProviderInstance$1(searchView, providerDef)
                  };
                  searchView.nodes[providerDef.nodeIndex] =
                  /** @type {?} */
                  providerData;
                }

                return providerData.instance;
              }

          }
        }

        allowPrivateServices = isComponentView(searchView);
        elDef =
        /** @type {?} */
        viewParentEl(searchView);
        searchView =
        /** @type {?} */
        searchView.parent;

        if (depDef.flags & 4
        /* Self */
        ) {
            searchView = null;
          }
      }
      /** @type {?} */


      const value = startView.root.injector.get(depDef.token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR);

      if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR || notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {
        // Return the value from the root element injector when
        // - it provides it
        //   (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)
        // - the module injector should not be checked
        //   (notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)
        return value;
      }

      return startView.root.ngModule.injector.get(depDef.token, notFoundValue);
    }
    /**
     * @param {?} view
     * @param {?} elDef
     * @param {?} allowPrivateServices
     * @return {?}
     */


    function findCompView(view, elDef, allowPrivateServices) {
      /** @type {?} */
      let compView;

      if (allowPrivateServices) {
        compView = asElementData(view, elDef.nodeIndex).componentView;
      } else {
        compView = view;

        while (compView.parent && !isComponentView(compView)) {
          compView = compView.parent;
        }
      }

      return compView;
    }
    /**
     * @param {?} view
     * @param {?} providerData
     * @param {?} def
     * @param {?} bindingIdx
     * @param {?} value
     * @param {?} changes
     * @return {?}
     */


    function updateProp(view, providerData, def, bindingIdx, value, changes) {
      if (def.flags & 32768
      /* Component */
      ) {
          /** @type {?} */
          const compView = asElementData(view,
          /** @type {?} */
          def.parent.nodeIndex).componentView;

          if (compView.def.flags & 2
          /* OnPush */
          ) {
              compView.state |= 8
              /* ChecksEnabled */
              ;
            }
        }
      /** @type {?} */


      const binding = def.bindings[bindingIdx];
      /** @type {?} */

      const propName =
      /** @type {?} */
      binding.name; // Note: This is still safe with Closure Compiler as
      // the user passed in the property name as an object has to `providerDef`,
      // so Closure Compiler will have renamed the property correctly already.

      providerData.instance[propName] = value;

      if (def.flags & 524288
      /* OnChanges */
      ) {
          changes = changes || {};
          /** @type {?} */

          const oldValue = WrappedValue.unwrap(view.oldValues[def.bindingIndex + bindingIdx]);
          /** @type {?} */

          const binding = def.bindings[bindingIdx];
          changes[
          /** @type {?} */
          binding.nonMinifiedName] = new SimpleChange(oldValue, value, (view.state & 2
          /* FirstCheck */
          ) !== 0);
        }

      view.oldValues[def.bindingIndex + bindingIdx] = value;
      return changes;
    } // This function calls the ngAfterContentCheck, ngAfterContentInit,
    // ngAfterViewCheck, and ngAfterViewInit lifecycle hooks (depending on the node
    // flags in lifecycle). Unlike ngDoCheck, ngOnChanges and ngOnInit, which are
    // called during a pre-order traversal of the view tree (that is calling the
    // parent hooks before the child hooks) these events are sent in using a
    // post-order traversal of the tree (children before parents). This changes the
    // meaning of initIndex in the view state. For ngOnInit, initIndex tracks the
    // expected nodeIndex which a ngOnInit should be called. When sending
    // ngAfterContentInit and ngAfterViewInit it is the expected count of
    // ngAfterContentInit or ngAfterViewInit methods that have been called. This
    // ensure that despite being called recursively or after picking up after an
    // exception, the ngAfterContentInit or ngAfterViewInit will be called on the
    // correct nodes. Consider for example, the following (where E is an element
    // and D is a directive)
    //  Tree:       pre-order index  post-order index
    //    E1        0                6
    //      E2      1                1
    //       D3     2                0
    //      E4      3                5
    //       E5     4                4
    //        E6    5                2
    //        E7    6                3
    // As can be seen, the post-order index has an unclear relationship to the
    // pre-order index (postOrderIndex === preOrderIndex - parentCount +
    // childCount). Since number of calls to ngAfterContentInit and ngAfterViewInit
    // are stable (will be the same for the same view regardless of exceptions or
    // recursion) we just need to count them which will roughly correspond to the
    // post-order index (it skips elements and directives that do not have
    // lifecycle hooks).
    //
    // For example, if an exception is raised in the E6.onAfterViewInit() the
    // initIndex is left at 3 (by shouldCallLifecycleInitHook() which set it to
    // initIndex + 1). When checkAndUpdateView() is called again D3, E2 and E6 will
    // not have their ngAfterViewInit() called but, starting with E7, the rest of
    // the view will begin getting ngAfterViewInit() called until a check and
    // pass is complete.
    //
    // This algorthim also handles recursion. Consider if E4's ngAfterViewInit()
    // indirectly calls E1's ChangeDetectorRef.detectChanges(). The expected
    // initIndex is set to 6, the recusive checkAndUpdateView() starts walk again.
    // D3, E2, E6, E7, E5 and E4 are skipped, ngAfterViewInit() is called on E1.
    // When the recursion returns the initIndex will be 7 so E1 is skipped as it
    // has already been called in the recursively called checkAnUpdateView().

    /**
     * @param {?} view
     * @param {?} lifecycles
     * @return {?}
     */


    function callLifecycleHooksChildrenFirst(view, lifecycles) {
      if (!(view.def.nodeFlags & lifecycles)) {
        return;
      }
      /** @type {?} */


      const nodes = view.def.nodes;
      /** @type {?} */

      let initIndex = 0;

      for (let i = 0; i < nodes.length; i++) {
        /** @type {?} */
        const nodeDef = nodes[i];
        /** @type {?} */

        let parent = nodeDef.parent;

        if (!parent && nodeDef.flags & lifecycles) {
          // matching root node (e.g. a pipe)
          callProviderLifecycles(view, i, nodeDef.flags & lifecycles, initIndex++);
        }

        if ((nodeDef.childFlags & lifecycles) === 0) {
          // no child matches one of the lifecycles
          i += nodeDef.childCount;
        }

        while (parent && parent.flags & 1
        /* TypeElement */
        && i === parent.nodeIndex + parent.childCount) {
          // last child of an element
          if (parent.directChildFlags & lifecycles) {
            initIndex = callElementProvidersLifecycles(view, parent, lifecycles, initIndex);
          }

          parent = parent.parent;
        }
      }
    }
    /**
     * @param {?} view
     * @param {?} elDef
     * @param {?} lifecycles
     * @param {?} initIndex
     * @return {?}
     */


    function callElementProvidersLifecycles(view, elDef, lifecycles, initIndex) {
      for (let i = elDef.nodeIndex + 1; i <= elDef.nodeIndex + elDef.childCount; i++) {
        /** @type {?} */
        const nodeDef = view.def.nodes[i];

        if (nodeDef.flags & lifecycles) {
          callProviderLifecycles(view, i, nodeDef.flags & lifecycles, initIndex++);
        } // only visit direct children


        i += nodeDef.childCount;
      }

      return initIndex;
    }
    /**
     * @param {?} view
     * @param {?} index
     * @param {?} lifecycles
     * @param {?} initIndex
     * @return {?}
     */


    function callProviderLifecycles(view, index, lifecycles, initIndex) {
      /** @type {?} */
      const providerData = asProviderData(view, index);

      if (!providerData) {
        return;
      }
      /** @type {?} */


      const provider = providerData.instance;

      if (!provider) {
        return;
      }

      Services.setCurrentNode(view, index);

      if (lifecycles & 1048576
      /* AfterContentInit */
      && shouldCallLifecycleInitHook(view, 512
      /* InitState_CallingAfterContentInit */
      , initIndex)) {
        provider.ngAfterContentInit();
      }

      if (lifecycles & 2097152
      /* AfterContentChecked */
      ) {
          provider.ngAfterContentChecked();
        }

      if (lifecycles & 4194304
      /* AfterViewInit */
      && shouldCallLifecycleInitHook(view, 768
      /* InitState_CallingAfterViewInit */
      , initIndex)) {
        provider.ngAfterViewInit();
      }

      if (lifecycles & 8388608
      /* AfterViewChecked */
      ) {
          provider.ngAfterViewChecked();
        }

      if (lifecycles & 131072
      /* OnDestroy */
      ) {
          provider.ngOnDestroy();
        }
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    class ComponentFactoryResolver$1 extends ComponentFactoryResolver {
      /**
       * @param {?=} ngModule The NgModuleRef to which all resolved factories are bound.
       */
      constructor(ngModule) {
        super();
        this.ngModule = ngModule;
      }
      /**
       * @template T
       * @param {?} component
       * @return {?}
       */


      resolveComponentFactory(component) {
        ngDevMode && assertComponentType(component);
        /** @type {?} */

        const componentDef =
        /** @type {?} */
        getComponentDef(component);
        return new ComponentFactory$1(componentDef, this.ngModule);
      }

    }

    if (false) {}
    /**
     * @param {?} map
     * @return {?}
     */


    function toRefArray(map) {
      /** @type {?} */
      const array = [];

      for (let nonMinified in map) {
        if (map.hasOwnProperty(nonMinified)) {
          /** @type {?} */
          const minified = map[nonMinified];
          array.push({
            propName: minified,
            templateName: nonMinified
          });
        }
      }

      return array;
    }
    /**
     * A change detection scheduler token for {\@link RootContext}. This token is the default value used
     * for the default `RootContext` found in the {\@link ROOT_CONTEXT} token.
     * @type {?}
     */


    const SCHEDULER = new InjectionToken('SCHEDULER_TOKEN', {
      providedIn: 'root',
      factory:
      /**
      * @return {?}
      */
      () => defaultScheduler
    });
    /**
     * @param {?} rootViewInjector
     * @param {?} moduleInjector
     * @return {?}
     */

    function createChainedInjector(rootViewInjector, moduleInjector) {
      return {
        get:
        /**
        * @template T
        * @param {?} token
        * @param {?=} notFoundValue
        * @param {?=} flags
        * @return {?}
        */
        (token, notFoundValue, flags) => {
          /** @type {?} */
          const value = rootViewInjector.get(token,
          /** @type {?} */
          NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, flags);

          if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR || notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {
            // Return the value from the root element injector when
            // - it provides it
            //   (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)
            // - the module injector should not be checked
            //   (notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR)
            return value;
          }

          return moduleInjector.get(token, notFoundValue, flags);
        }
      };
    }
    /**
     * Render3 implementation of {\@link viewEngine_ComponentFactory}.
     * @template T
     */


    class ComponentFactory$1 extends ComponentFactory {
      /**
       * @param {?} componentDef The component definition.
       * @param {?=} ngModule The NgModuleRef to which the factory is bound.
       */
      constructor(componentDef, ngModule) {
        super();
        this.componentDef = componentDef;
        this.ngModule = ngModule;
        this.componentType = componentDef.type; // default to 'div' in case this component has an attribute selector

        this.selector =
        /** @type {?} */
        componentDef.selectors[0][0] || 'div';
        this.ngContentSelectors = componentDef.ngContentSelectors ? componentDef.ngContentSelectors : [];
        this.isBoundToModule = !!ngModule;
      }
      /**
       * @return {?}
       */


      get inputs() {
        return toRefArray(this.componentDef.inputs);
      }
      /**
       * @return {?}
       */


      get outputs() {
        return toRefArray(this.componentDef.outputs);
      }
      /**
       * @param {?} injector
       * @param {?=} projectableNodes
       * @param {?=} rootSelectorOrNode
       * @param {?=} ngModule
       * @return {?}
       */


      create(injector, projectableNodes, rootSelectorOrNode, ngModule) {
        ngModule = ngModule || this.ngModule;
        /** @type {?} */

        const rootViewInjector = ngModule ? createChainedInjector(injector, ngModule.injector) : injector;
        /** @type {?} */

        const rendererFactory =
        /** @type {?} */
        rootViewInjector.get(RendererFactory2, domRendererFactory3);
        /** @type {?} */

        const sanitizer = rootViewInjector.get(Sanitizer, null); // Ensure that the namespace for the root node is correct,
        // otherwise the browser might not render out the element properly.

        namespaceHTMLInternal();
        /** @type {?} */

        const hostRNode = rootSelectorOrNode ? locateHostElement(rendererFactory, rootSelectorOrNode) : elementCreate(this.selector, rendererFactory.createRenderer(null, this.componentDef));
        /** @type {?} */

        const rootFlags = this.componentDef.onPush ? 64
        /* Dirty */
        | 512
        /* IsRoot */
        : 16
        /* CheckAlways */
        | 512
        /* IsRoot */
        ; // Check whether this Component needs to be isolated from other components, i.e. whether it
        // should be placed into its own (empty) root context or existing root context should be used.
        // Note: this is internal-only convention and might change in the future, so it should not be
        // relied upon externally.

        /** @type {?} */

        const isIsolated = typeof rootSelectorOrNode === 'string' && /^#root-ng-internal-isolated-\d+/.test(rootSelectorOrNode);
        /** @type {?} */

        const rootContext = createRootContext();
        /** @type {?} */

        const renderer = rendererFactory.createRenderer(hostRNode, this.componentDef);

        if (rootSelectorOrNode && hostRNode) {
          ngDevMode && ngDevMode.rendererSetAttribute++;
          isProceduralRenderer(renderer) ? renderer.setAttribute(hostRNode, 'ng-version', VERSION.full) : hostRNode.setAttribute('ng-version', VERSION.full);
        } // Create the root view. Uses empty TView and ContentTemplate.

        /** @type {?} */


        const rootLView = createLView(null, createTView(-1, null, 1, 0, null, null, null, null), rootContext, rootFlags, null, null, rendererFactory, renderer, sanitizer, rootViewInjector); // rootView is the parent when bootstrapping

        /** @type {?} */

        const oldLView = enterView(rootLView, null);
        /** @type {?} */

        let component;
        /** @type {?} */

        let tElementNode; // Will become true if the `try` block executes with no errors.

        /** @type {?} */

        let safeToRunHooks = false;

        try {
          /** @type {?} */
          const componentView = createRootComponentView(hostRNode, this.componentDef, rootLView, rendererFactory, renderer);
          tElementNode =
          /** @type {?} */
          getTNode(0, rootLView);

          if (projectableNodes) {
            // projectable nodes can be passed as array of arrays or an array of iterables (ngUpgrade
            // case). Here we do normalize passed data structure to be an array of arrays to avoid
            // complex checks down the line.
            tElementNode.projection = projectableNodes.map(
            /**
            * @param {?} nodesforSlot
            * @return {?}
            */
            nodesforSlot => {
              return Array.from(nodesforSlot);
            });
          } // TODO: should LifecycleHooksFeature and other host features be generated by the compiler and
          // executed here?
          // Angular 5 reference: https://stackblitz.com/edit/lifecycle-hooks-vcref


          component = createRootComponent(componentView, this.componentDef, rootLView, rootContext, [LifecycleHooksFeature]);
          addToViewTree(rootLView, componentView);
          refreshDescendantViews(rootLView);
          safeToRunHooks = true;
        } finally {
          leaveView(oldLView, safeToRunHooks);
        }
        /** @type {?} */


        const componentRef = new ComponentRef$1(this.componentType, component, createElementRef(ElementRef, tElementNode, rootLView), rootLView, tElementNode);

        if (!rootSelectorOrNode || isIsolated) {
          // The host element of the internal or isolated root view is attached to the component's host
          // view node.

          /** @type {?} */
          componentRef.hostView._tViewNode.child = tElementNode;
        }

        return componentRef;
      }

    }

    if (false) {}
    /** @type {?} */


    const componentFactoryResolver = new ComponentFactoryResolver$1();
    /**
     * Creates a ComponentFactoryResolver and stores it on the injector. Or, if the
     * ComponentFactoryResolver
     * already exists, retrieves the existing ComponentFactoryResolver.
     *
     * @return {?} The ComponentFactoryResolver instance to use
     */

    function injectComponentFactoryResolver() {
      return componentFactoryResolver;
    }
    /**
     * Represents an instance of a Component created via a {\@link ComponentFactory}.
     *
     * `ComponentRef` provides access to the Component Instance as well other objects related to this
     * Component Instance and allows you to destroy the Component Instance via the {\@link #destroy}
     * method.
     *
     * @template T
     */


    class ComponentRef$1 extends ComponentRef {
      /**
       * @param {?} componentType
       * @param {?} instance
       * @param {?} location
       * @param {?} _rootLView
       * @param {?} _tNode
       */
      constructor(componentType, instance, location, _rootLView, _tNode) {
        super();
        this.location = location;
        this._rootLView = _rootLView;
        this._tNode = _tNode;
        this.destroyCbs = [];
        this.instance = instance;
        this.hostView = this.changeDetectorRef = new RootViewRef(_rootLView);
        this.hostView._tViewNode = assignTViewNodeToLView(_rootLView[TVIEW], null, -1, _rootLView);
        this.componentType = componentType;
      }
      /**
       * @return {?}
       */


      get injector() {
        return new NodeInjector(this._tNode, this._rootLView);
      }
      /**
       * @return {?}
       */


      destroy() {
        if (this.destroyCbs) {
          this.destroyCbs.forEach(
          /**
          * @param {?} fn
          * @return {?}
          */
          fn => fn());
          this.destroyCbs = null;
          !this.hostView.destroyed && this.hostView.destroy();
        }
      }
      /**
       * @param {?} callback
       * @return {?}
       */


      onDestroy(callback) {
        if (this.destroyCbs) {
          this.destroyCbs.push(callback);
        }
      }

    }

    if (false) {}
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * NOTE: changes to the `ngI18nClosureMode` name must be synced with `compiler-cli/src/tooling.ts`.
     */


    if (typeof ngI18nClosureMode === 'undefined') {
      // These property accesses can be ignored because ngI18nClosureMode will be set to false
      // when optimizing code and the whole if statement will be dropped.
      // Make sure to refer to ngI18nClosureMode as ['ngI18nClosureMode'] for closure.
      // NOTE: we need to have it in IIFE so that the tree-shaker is happy.
      (function () {
        // tslint:disable-next-line:no-toplevel-property-access
        _global['ngI18nClosureMode'] = // TODO(FW-1250): validate that this actually, you know, works.
        // tslint:disable-next-line:no-toplevel-property-access
        typeof goog !== 'undefined' && typeof goog.getMsg === 'function';
      })();
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * This const is used to store the locale data registered with `registerLocaleData`
     * @type {?}
     */


    const LOCALE_DATA = {};
    /** @enum {number} */

    const LocaleDataIndex = {
      LocaleId: 0,
      DayPeriodsFormat: 1,
      DayPeriodsStandalone: 2,
      DaysFormat: 3,
      DaysStandalone: 4,
      MonthsFormat: 5,
      MonthsStandalone: 6,
      Eras: 7,
      FirstDayOfWeek: 8,
      WeekendRange: 9,
      DateFormat: 10,
      TimeFormat: 11,
      DateTimeFormat: 12,
      NumberSymbols: 13,
      NumberFormats: 14,
      CurrencySymbol: 15,
      CurrencyName: 16,
      Currencies: 17,
      PluralCase: 18,
      ExtraData: 19
    };
    LocaleDataIndex[LocaleDataIndex.LocaleId] = 'LocaleId';
    LocaleDataIndex[LocaleDataIndex.DayPeriodsFormat] = 'DayPeriodsFormat';
    LocaleDataIndex[LocaleDataIndex.DayPeriodsStandalone] = 'DayPeriodsStandalone';
    LocaleDataIndex[LocaleDataIndex.DaysFormat] = 'DaysFormat';
    LocaleDataIndex[LocaleDataIndex.DaysStandalone] = 'DaysStandalone';
    LocaleDataIndex[LocaleDataIndex.MonthsFormat] = 'MonthsFormat';
    LocaleDataIndex[LocaleDataIndex.MonthsStandalone] = 'MonthsStandalone';
    LocaleDataIndex[LocaleDataIndex.Eras] = 'Eras';
    LocaleDataIndex[LocaleDataIndex.FirstDayOfWeek] = 'FirstDayOfWeek';
    LocaleDataIndex[LocaleDataIndex.WeekendRange] = 'WeekendRange';
    LocaleDataIndex[LocaleDataIndex.DateFormat] = 'DateFormat';
    LocaleDataIndex[LocaleDataIndex.TimeFormat] = 'TimeFormat';
    LocaleDataIndex[LocaleDataIndex.DateTimeFormat] = 'DateTimeFormat';
    LocaleDataIndex[LocaleDataIndex.NumberSymbols] = 'NumberSymbols';
    LocaleDataIndex[LocaleDataIndex.NumberFormats] = 'NumberFormats';
    LocaleDataIndex[LocaleDataIndex.CurrencySymbol] = 'CurrencySymbol';
    LocaleDataIndex[LocaleDataIndex.CurrencyName] = 'CurrencyName';
    LocaleDataIndex[LocaleDataIndex.Currencies] = 'Currencies';
    LocaleDataIndex[LocaleDataIndex.PluralCase] = 'PluralCase';
    LocaleDataIndex[LocaleDataIndex.ExtraData] = 'ExtraData';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // THIS CODE IS GENERATED - DO NOT MODIFY
    // See angular/tools/gulp-tasks/cldr/extract.js

    /** @type {?} */

    const u = undefined;
    /**
     * @param {?} n
     * @return {?}
     */

    function plural(n) {
      /** @type {?} */
      let i = Math.floor(Math.abs(n));
      /** @type {?} */

      let v = n.toString().replace(/^[^.]*\.?/, '').length;
      if (i === 1 && v === 0) return 1;
      return 5;
    }

    var localeEn = ['en', [['a', 'p'], ['AM', 'PM'], u], [['AM', 'PM'], u, u], [['S', 'M', 'T', 'W', 'T', 'F', 'S'], ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'], ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa']], u, [['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'], ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']], u, [['B', 'A'], ['BC', 'AD'], ['Before Christ', 'Anno Domini']], 0, [6, 0], ['M/d/yy', 'MMM d, y', 'MMMM d, y', 'EEEE, MMMM d, y'], ['h:mm a', 'h:mm:ss a', 'h:mm:ss a z', 'h:mm:ss a zzzz'], ['{1}, {0}', u, '{1} \'at\' {0}', u], ['.', ',', ';', '%', '+', '-', 'E', '×', '‰', '∞', 'NaN', ':'], ['#,##0.###', '#,##0%', '¤#,##0.00', '#E0'], '$', 'US Dollar', {}, plural];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Retrieves the plural function used by ICU expressions to determine the plural case to use
     * for a given locale.
     * @see `NgPlural` / [Internationalization (i18n) Guide](https://angular.io/guide/i18n)
     * @param {?} locale A locale code for the locale format rules to use.
     * @return {?} The plural function for the locale.
     */

    function getLocalePluralCase(locale) {
      /** @type {?} */
      const data = findLocaleData(locale);
      return data[LocaleDataIndex.PluralCase];
    }
    /**
     * Finds the locale data for a given locale.
     *
     * @see [Internationalization (i18n) Guide](https://angular.io/guide/i18n)
     * @param {?} locale The locale code.
     * @return {?} The locale data.
     */


    function findLocaleData(locale) {
      /** @type {?} */
      const normalizedLocale = locale.toLowerCase().replace(/_/g, '-');
      /** @type {?} */

      let match = LOCALE_DATA[normalizedLocale];

      if (match) {
        return match;
      } // let's try to find a parent locale

      /** @type {?} */


      const parentLocale = normalizedLocale.split('-')[0];
      match = LOCALE_DATA[parentLocale];

      if (match) {
        return match;
      }

      if (parentLocale === 'en') {
        return localeEn;
      }

      throw new Error("Missing locale data for the locale \"".concat(locale, "\"."));
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Returns the plural case based on the locale
     * @param {?} value
     * @param {?} locale
     * @return {?}
     */


    function getPluralCase(value, locale) {
      /** @type {?} */
      const plural = getLocalePluralCase(locale)(value);

      switch (plural) {
        case 0:
          return 'zero';

        case 1:
          return 'one';

        case 2:
          return 'two';

        case 3:
          return 'few';

        case 4:
          return 'many';

        default:
          return 'other';
      }
    }
    /**
     * The locale id that the application is using by default (for translations and ICU expressions).
     * @type {?}
     */


    const DEFAULT_LOCALE_ID = 'en-US';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    const MARKER = "\uFFFD";
    /** @type {?} */

    const ICU_BLOCK_REGEXP = /^\s*(�\d+:?\d*�)\s*,\s*(select|plural)\s*,/;
    /** @type {?} */

    const SUBTEMPLATE_REGEXP = /�\/?\*(\d+:\d+)�/gi;
    /** @type {?} */

    const PH_REGEXP = /�(\/?[#*!]\d+):?\d*�/gi;
    /** @type {?} */

    const BINDING_REGEXP = /�(\d+):?\d*�/gi;
    /** @type {?} */

    const ICU_REGEXP = /({\s*�\d+:?\d*�\s*,\s*\S{6}\s*,[\s\S]*})/gi;
    /** @enum {string} */

    const TagType = {
      ELEMENT: '#',
      TEMPLATE: '*',
      PROJECTION: '!'
    }; // i18nPostprocess consts

    /** @type {?} */

    const ROOT_TEMPLATE_ID = 0;
    /** @type {?} */

    const PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\[(�.+?�?)\]/;
    /** @type {?} */

    const PP_PLACEHOLDERS_REGEXP = /\[(�.+?�?)\]|(�\/?\*\d+:\d+�)/g;
    /** @type {?} */

    const PP_ICU_VARS_REGEXP = /({\s*)(VAR_(PLURAL|SELECT)(_\d+)?)(\s*,)/g;
    /** @type {?} */

    const PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;
    /** @type {?} */

    const PP_ICUS_REGEXP = /�I18N_EXP_(ICU(_\d+)?)�/g;
    /** @type {?} */

    const PP_CLOSE_TEMPLATE_REGEXP = /\/\*/;
    /** @type {?} */

    const PP_TEMPLATE_ID_REGEXP = /\d+\:(\d+)/;
    /**
     * @record
     */

    function IcuExpression() {}

    if (false) {}
    /**
     * @record
     */


    function IcuCase() {}

    if (false) {}
    /**
     * Breaks pattern into strings and top level {...} blocks.
     * Can be used to break a message into text and ICU expressions, or to break an ICU expression into
     * keys and cases.
     * Original code from closure library, modified for Angular.
     *
     * @param {?} pattern (sub)Pattern to be broken.
     *
     * @return {?}
     */


    function extractParts(pattern) {
      if (!pattern) {
        return [];
      }
      /** @type {?} */


      let prevPos = 0;
      /** @type {?} */

      const braceStack = [];
      /** @type {?} */

      const results = [];
      /** @type {?} */

      const braces = /[{}]/g; // lastIndex doesn't get set to 0 so we have to.

      braces.lastIndex = 0;
      /** @type {?} */

      let match;

      while (match = braces.exec(pattern)) {
        /** @type {?} */
        const pos = match.index;

        if (match[0] == '}') {
          braceStack.pop();

          if (braceStack.length == 0) {
            // End of the block.

            /** @type {?} */
            const block = pattern.substring(prevPos, pos);

            if (ICU_BLOCK_REGEXP.test(block)) {
              results.push(parseICUBlock(block));
            } else {
              results.push(block);
            }

            prevPos = pos + 1;
          }
        } else {
          if (braceStack.length == 0) {
            /** @type {?} */
            const substring = pattern.substring(prevPos, pos);
            results.push(substring);
            prevPos = pos + 1;
          }

          braceStack.push('{');
        }
      }
      /** @type {?} */


      const substring = pattern.substring(prevPos);
      results.push(substring);
      return results;
    }
    /**
     * Parses text containing an ICU expression and produces a JSON object for it.
     * Original code from closure library, modified for Angular.
     *
     * @param {?} pattern Text containing an ICU expression that needs to be parsed.
     *
     * @return {?}
     */


    function parseICUBlock(pattern) {
      /** @type {?} */
      const cases = [];
      /** @type {?} */

      const values = [];
      /** @type {?} */

      let icuType = 1
      /* plural */
      ;
      /** @type {?} */

      let mainBinding = 0;
      pattern = pattern.replace(ICU_BLOCK_REGEXP,
      /**
      * @param {?} str
      * @param {?} binding
      * @param {?} type
      * @return {?}
      */
      function (str, binding, type) {
        if (type === 'select') {
          icuType = 0
          /* select */
          ;
        } else {
          icuType = 1
          /* plural */
          ;
        }

        mainBinding = parseInt(binding.substr(1), 10);
        return '';
      });
      /** @type {?} */

      const parts =
      /** @type {?} */
      extractParts(pattern); // Looking for (key block)+ sequence. One of the keys has to be "other".

      for (let pos = 0; pos < parts.length;) {
        /** @type {?} */
        let key = parts[pos++].trim();

        if (icuType === 1
        /* plural */
        ) {
            // Key can be "=x", we just want "x"
            key = key.replace(/\s*(?:=)?(\w+)\s*/, '$1');
          }

        if (key.length) {
          cases.push(key);
        }
        /** @type {?} */


        const blocks =
        /** @type {?} */
        extractParts(parts[pos++]);

        if (cases.length > values.length) {
          values.push(blocks);
        }
      }

      assertGreaterThan(cases.indexOf('other'), -1, 'Missing key "other" in ICU statement.'); // TODO(ocombe): support ICU expressions in attributes, see #21615

      return {
        type: icuType,
        mainBinding: mainBinding,
        cases,
        values
      };
    }
    /**
     * Removes everything inside the sub-templates of a message.
     * @param {?} message
     * @return {?}
     */


    function removeInnerTemplateTranslation(message) {
      /** @type {?} */
      let match;
      /** @type {?} */

      let res = '';
      /** @type {?} */

      let index = 0;
      /** @type {?} */

      let inTemplate = false;
      /** @type {?} */

      let tagMatched;

      while ((match = SUBTEMPLATE_REGEXP.exec(message)) !== null) {
        if (!inTemplate) {
          res += message.substring(index, match.index + match[0].length);
          tagMatched = match[1];
          inTemplate = true;
        } else {
          if (match[0] === "".concat(MARKER, "/*").concat(tagMatched).concat(MARKER)) {
            index = match.index;
            inTemplate = false;
          }
        }
      }

      ngDevMode && assertEqual(inTemplate, false, "Tag mismatch: unable to find the end of the sub-template in the translation \"".concat(message, "\""));
      res += message.substr(index);
      return res;
    }
    /**
     * Extracts a part of a message and removes the rest.
     *
     * This method is used for extracting a part of the message associated with a template. A translated
     * message can span multiple templates.
     *
     * Example:
     * ```
     * <div i18n>Translate <span *ngIf>me</span>!</div>
     * ```
     *
     * @param {?} message The message to crop
     * @param {?=} subTemplateIndex Index of the sub-template to extract. If undefined it returns the
     * external template and removes all sub-templates.
     * @return {?}
     */


    function getTranslationForTemplate(message, subTemplateIndex) {
      if (typeof subTemplateIndex !== 'number') {
        // We want the root template message, ignore all sub-templates
        return removeInnerTemplateTranslation(message);
      } else {
        // We want a specific sub-template

        /** @type {?} */
        const start = message.indexOf(":".concat(subTemplateIndex).concat(MARKER)) + 2 + subTemplateIndex.toString().length;
        /** @type {?} */

        const end = message.search(new RegExp("".concat(MARKER, "\\/\\*\\d+:").concat(subTemplateIndex).concat(MARKER)));
        return removeInnerTemplateTranslation(message.substring(start, end));
      }
    }
    /**
     * Generate the OpCodes to update the bindings of a string.
     *
     * @param {?} str The string containing the bindings.
     * @param {?} destinationNode Index of the destination node which will receive the binding.
     * @param {?=} attrName Name of the attribute, if the string belongs to an attribute.
     * @param {?=} sanitizeFn Sanitization function used to sanitize the string after update, if necessary.
     * @return {?}
     */


    function generateBindingUpdateOpCodes(str, destinationNode, attrName, sanitizeFn = null) {
      /** @type {?} */
      const updateOpCodes = [null, null]; // Alloc space for mask and size

      /** @type {?} */

      const textParts = str.split(BINDING_REGEXP);
      /** @type {?} */

      let mask = 0;

      for (let j = 0; j < textParts.length; j++) {
        /** @type {?} */
        const textValue = textParts[j];

        if (j & 1) {
          // Odd indexes are bindings

          /** @type {?} */
          const bindingIndex = parseInt(textValue, 10);
          updateOpCodes.push(-1 - bindingIndex);
          mask = mask | toMaskBit(bindingIndex);
        } else if (textValue !== '') {
          // Even indexes are text
          updateOpCodes.push(textValue);
        }
      }

      updateOpCodes.push(destinationNode << 2
      /* SHIFT_REF */
      | (attrName ? 1
      /* Attr */
      : 0
      /* Text */
      ));

      if (attrName) {
        updateOpCodes.push(attrName, sanitizeFn);
      }

      updateOpCodes[0] = mask;
      updateOpCodes[1] = updateOpCodes.length - 2;
      return updateOpCodes;
    }
    /**
     * @param {?} icuExpression
     * @param {?=} mask
     * @return {?}
     */


    function getBindingMask(icuExpression, mask = 0) {
      mask = mask | toMaskBit(icuExpression.mainBinding);
      /** @type {?} */

      let match;

      for (let i = 0; i < icuExpression.values.length; i++) {
        /** @type {?} */
        const valueArr = icuExpression.values[i];

        for (let j = 0; j < valueArr.length; j++) {
          /** @type {?} */
          const value = valueArr[j];

          if (typeof value === 'string') {
            while (match = BINDING_REGEXP.exec(value)) {
              mask = mask | toMaskBit(parseInt(match[1], 10));
            }
          } else {
            mask = getBindingMask(
            /** @type {?} */
            value, mask);
          }
        }
      }

      return mask;
    }
    /** @type {?} */


    const i18nIndexStack = [];
    /** @type {?} */

    let i18nIndexStackPointer = -1;
    /**
     * Convert binding index to mask bit.
     *
     * Each index represents a single bit on the bit-mask. Because bit-mask only has 32 bits, we make
     * the 32nd bit share all masks for all bindings higher than 32. Since it is extremely rare to have
     * more than 32 bindings this will be hit very rarely. The downside of hitting this corner case is
     * that we will execute binding code more often than necessary. (penalty of performance)
     * @param {?} bindingIndex
     * @return {?}
     */

    function toMaskBit(bindingIndex) {
      return 1 << Math.min(bindingIndex, 31);
    }
    /** @type {?} */


    const parentIndexStack = [];
    /**
     * Marks a block of text as translatable.
     *
     * The instructions `i18nStart` and `i18nEnd` mark the translation block in the template.
     * The translation `message` is the value which is locale specific. The translation string may
     * contain placeholders which associate inner elements and sub-templates within the translation.
     *
     * The translation `message` placeholders are:
     * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be
     *   interpolated into. The placeholder `index` points to the expression binding index. An optional
     *   `block` that matches the sub-template in which it was declared.
     * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning
     *   and end of DOM element that were embedded in the original translation block. The placeholder
     *   `index` points to the element index in the template instructions set. An optional `block` that
     *   matches the sub-template in which it was declared.
     * - `�!{index}(:{block})�`/`�/!{index}(:{block})�`: *Projection Placeholder*:  Marks the
     *   beginning and end of <ng-content> that was embedded in the original translation block.
     *   The placeholder `index` points to the element index in the template instructions set.
     *   An optional `block` that matches the sub-template in which it was declared.
     * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be
     *   split up and translated separately in each angular template function. The `index` points to the
     *   `template` instruction index. A `block` that matches the sub-template in which it was declared.
     *
     * \@codeGenApi
     * @param {?} index A unique index of the translation in the static block.
     * @param {?} message The translation message.
     * @param {?=} subTemplateIndex Optional sub-template index in the `message`.
     *
     * @return {?}
     */

    function ɵɵi18nStart(index, message, subTemplateIndex) {
      /** @type {?} */
      const tView = getLView()[TVIEW];
      ngDevMode && assertDefined(tView, "tView should be defined");
      i18nIndexStack[++i18nIndexStackPointer] = index; // We need to delay projections until `i18nEnd`

      setDelayProjection(true);

      if (tView.firstTemplatePass && tView.data[index + HEADER_OFFSET] === null) {
        i18nStartFirstPass(tView, index, message, subTemplateIndex);
      }
    } // Count for the number of vars that will be allocated for each i18n block.
    // It is global because this is used in multiple functions that include loops and recursive calls.
    // This is reset to 0 when `i18nStartFirstPass` is called.

    /** @type {?} */


    let i18nVarsCount;
    /**
     * See `i18nStart` above.
     * @param {?} tView
     * @param {?} index
     * @param {?} message
     * @param {?=} subTemplateIndex
     * @return {?}
     */

    function i18nStartFirstPass(tView, index, message, subTemplateIndex) {
      /** @type {?} */
      const viewData = getLView();
      /** @type {?} */

      const startIndex = tView.blueprint.length - HEADER_OFFSET;
      i18nVarsCount = 0;
      /** @type {?} */

      const previousOrParentTNode = getPreviousOrParentTNode();
      /** @type {?} */

      const parentTNode = getIsParent() ? getPreviousOrParentTNode() : previousOrParentTNode && previousOrParentTNode.parent;
      /** @type {?} */

      let parentIndex = parentTNode && parentTNode !== viewData[T_HOST] ? parentTNode.index - HEADER_OFFSET : index;
      /** @type {?} */

      let parentIndexPointer = 0;
      parentIndexStack[parentIndexPointer] = parentIndex;
      /** @type {?} */

      const createOpCodes = []; // If the previous node wasn't the direct parent then we have a translation without top level
      // element and we need to keep a reference of the previous element if there is one

      if (index > 0 && previousOrParentTNode !== parentTNode) {
        // Create an OpCode to select the previous TNode
        createOpCodes.push(previousOrParentTNode.index << 3
        /* SHIFT_REF */
        | 0
        /* Select */
        );
      }
      /** @type {?} */


      const updateOpCodes = [];
      /** @type {?} */

      const icuExpressions = [];
      /** @type {?} */

      const templateTranslation = getTranslationForTemplate(message, subTemplateIndex);
      /** @type {?} */

      const msgParts = replaceNgsp(templateTranslation).split(PH_REGEXP);

      for (let i = 0; i < msgParts.length; i++) {
        /** @type {?} */
        let value = msgParts[i];

        if (i & 1) {
          // Odd indexes are placeholders (elements and sub-templates)
          if (value.charAt(0) === '/') {
            // It is a closing tag
            if (value.charAt(1) === "#"
            /* ELEMENT */
            ) {
                /** @type {?} */
                const phIndex = parseInt(value.substr(2), 10);
                parentIndex = parentIndexStack[--parentIndexPointer];
                createOpCodes.push(phIndex << 3
                /* SHIFT_REF */
                | 5
                /* ElementEnd */
                );
              }
          } else {
            /** @type {?} */
            const phIndex = parseInt(value.substr(1), 10); // The value represents a placeholder that we move to the designated index

            createOpCodes.push(phIndex << 3
            /* SHIFT_REF */
            | 0
            /* Select */
            , parentIndex << 17
            /* SHIFT_PARENT */
            | 1
            /* AppendChild */
            );

            if (value.charAt(0) === "#"
            /* ELEMENT */
            ) {
                parentIndexStack[++parentIndexPointer] = parentIndex = phIndex;
              }
          }
        } else {
          // Even indexes are text (including bindings & ICU expressions)

          /** @type {?} */
          const parts = extractParts(value);

          for (let j = 0; j < parts.length; j++) {
            if (j & 1) {
              // Odd indexes are ICU expressions
              // Create the comment node that will anchor the ICU expression

              /** @type {?} */
              const icuNodeIndex = startIndex + i18nVarsCount++;
              createOpCodes.push(COMMENT_MARKER, ngDevMode ? "ICU ".concat(icuNodeIndex) : '', icuNodeIndex, parentIndex << 17
              /* SHIFT_PARENT */
              | 1
              /* AppendChild */
              ); // Update codes for the ICU expression

              /** @type {?} */

              const icuExpression =
              /** @type {?} */
              parts[j];
              /** @type {?} */

              const mask = getBindingMask(icuExpression);
              icuStart(icuExpressions, icuExpression, icuNodeIndex, icuNodeIndex); // Since this is recursive, the last TIcu that was pushed is the one we want

              /** @type {?} */

              const tIcuIndex = icuExpressions.length - 1;
              updateOpCodes.push(toMaskBit(icuExpression.mainBinding), // mask of the main binding
              3, // skip 3 opCodes if not changed
              -1 - icuExpression.mainBinding, icuNodeIndex << 2
              /* SHIFT_REF */
              | 2
              /* IcuSwitch */
              , tIcuIndex, mask, // mask of all the bindings of this ICU expression
              2, // skip 2 opCodes if not changed
              icuNodeIndex << 2
              /* SHIFT_REF */
              | 3
              /* IcuUpdate */
              , tIcuIndex);
            } else if (parts[j] !== '') {
              /** @type {?} */
              const text =
              /** @type {?} */
              parts[j]; // Even indexes are text (including bindings)

              /** @type {?} */

              const hasBinding = text.match(BINDING_REGEXP); // Create text nodes

              /** @type {?} */

              const textNodeIndex = startIndex + i18nVarsCount++;
              createOpCodes.push( // If there is a binding, the value will be set during update
              hasBinding ? '' : text, textNodeIndex, parentIndex << 17
              /* SHIFT_PARENT */
              | 1
              /* AppendChild */
              );

              if (hasBinding) {
                addAllToArray(generateBindingUpdateOpCodes(text, textNodeIndex), updateOpCodes);
              }
            }
          }
        }
      }

      if (i18nVarsCount > 0) {
        allocExpando(viewData, i18nVarsCount);
      }

      ngDevMode && attachI18nOpCodesDebug(createOpCodes, updateOpCodes, icuExpressions.length ? icuExpressions : null, viewData); // NOTE: local var needed to properly assert the type of `TI18n`.

      /** @type {?} */

      const tI18n = {
        vars: i18nVarsCount,
        create: createOpCodes,
        update: updateOpCodes,
        icus: icuExpressions.length ? icuExpressions : null
      };
      tView.data[index + HEADER_OFFSET] = tI18n;
    }
    /**
     * @param {?} tNode
     * @param {?} parentTNode
     * @param {?} previousTNode
     * @param {?} viewData
     * @return {?}
     */


    function appendI18nNode(tNode, parentTNode, previousTNode, viewData) {
      ngDevMode && ngDevMode.rendererMoveNode++;
      /** @type {?} */

      const nextNode = tNode.next;

      if (!previousTNode) {
        previousTNode = parentTNode;
      } // Re-organize node tree to put this node in the correct position.


      if (previousTNode === parentTNode && tNode !== parentTNode.child) {
        tNode.next = parentTNode.child;
        parentTNode.child = tNode;
      } else if (previousTNode !== parentTNode && tNode !== previousTNode.next) {
        tNode.next = previousTNode.next;
        previousTNode.next = tNode;
      } else {
        tNode.next = null;
      }

      if (parentTNode !== viewData[T_HOST]) {
        tNode.parent =
        /** @type {?} */
        parentTNode;
      } // If tNode was moved around, we might need to fix a broken link.

      /** @type {?} */


      let cursor = tNode.next;

      while (cursor) {
        if (cursor.next === tNode) {
          cursor.next = nextNode;
        }

        cursor = cursor.next;
      } // If the placeholder to append is a projection, we need to move the projected nodes instead


      if (tNode.type === 1
      /* Projection */
      ) {
          /** @type {?} */
          const tProjectionNode =
          /** @type {?} */
          tNode;
          appendProjectedNodes(viewData, tProjectionNode, tProjectionNode.projection, findComponentView(viewData));
          return tNode;
        }

      appendChild(getNativeByTNode(tNode, viewData), tNode, viewData);
      /** @type {?} */

      const slotValue = viewData[tNode.index];

      if (tNode.type !== 0
      /* Container */
      && isLContainer(slotValue)) {
        // Nodes that inject ViewContainerRef also have a comment node that should be moved
        appendChild(slotValue[NATIVE], tNode, viewData);
      }

      return tNode;
    }
    /**
     * Handles message string post-processing for internationalization.
     *
     * Handles message string post-processing by transforming it from intermediate
     * format (that might contain some markers that we need to replace) to the final
     * form, consumable by i18nStart instruction. Post processing steps include:
     *
     * 1. Resolve all multi-value cases (like [�*1:1��#2:1�|�#4:1�|�5�])
     * 2. Replace all ICU vars (like "VAR_PLURAL")
     * 3. Replace all placeholders used inside ICUs in a form of {PLACEHOLDER}
     * 4. Replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�)
     *    in case multiple ICUs have the same placeholder name
     *
     * \@codeGenApi
     * @param {?} message Raw translation string for post processing
     * @param {?=} replacements Set of replacements that should be applied
     *
     * @return {?} Transformed string that can be consumed by i18nStart instruction
     *
     */


    function ɵɵi18nPostprocess(message, replacements = {}) {
      /**
       * Step 1: resolve all multi-value placeholders like [�#5�|�*1:1��#2:1�|�#4:1�]
       *
       * Note: due to the way we process nested templates (BFS), multi-value placeholders are typically
       * grouped by templates, for example: [�#5�|�#6�|�#1:1�|�#3:2�] where �#5� and �#6� belong to root
       * template, �#1:1� belong to nested template with index 1 and �#1:2� - nested template with index
       * 3. However in real templates the order might be different: i.e. �#1:1� and/or �#3:2� may go in
       * front of �#6�. The post processing step restores the right order by keeping track of the
       * template id stack and looks for placeholders that belong to the currently active template.
       * @type {?}
       */
      let result = message;

      if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {
        /** @type {?} */
        const matches = {};
        /** @type {?} */

        const templateIdsStack = [ROOT_TEMPLATE_ID];
        result = result.replace(PP_PLACEHOLDERS_REGEXP,
        /**
        * @param {?} m
        * @param {?} phs
        * @param {?} tmpl
        * @return {?}
        */
        (m, phs, tmpl) => {
          /** @type {?} */
          const content = phs || tmpl;
          /** @type {?} */

          const placeholders = matches[content] || [];

          if (!placeholders.length) {
            content.split('|').forEach(
            /**
            * @param {?} placeholder
            * @return {?}
            */
            placeholder => {
              /** @type {?} */
              const match = placeholder.match(PP_TEMPLATE_ID_REGEXP);
              /** @type {?} */

              const templateId = match ? parseInt(match[1], 10) : ROOT_TEMPLATE_ID;
              /** @type {?} */

              const isCloseTemplateTag = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder);
              placeholders.push([templateId, isCloseTemplateTag, placeholder]);
            });
            matches[content] = placeholders;
          }

          if (!placeholders.length) {
            throw new Error("i18n postprocess: unmatched placeholder - ".concat(content));
          }
          /** @type {?} */


          const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];
          /** @type {?} */

          let idx = 0; // find placeholder index that matches current template id

          for (let i = 0; i < placeholders.length; i++) {
            if (placeholders[i][0] === currentTemplateId) {
              idx = i;
              break;
            }
          } // update template id stack based on the current tag extracted


          const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];

          if (isCloseTemplateTag) {
            templateIdsStack.pop();
          } else if (currentTemplateId !== templateId) {
            templateIdsStack.push(templateId);
          } // remove processed tag from the list


          placeholders.splice(idx, 1);
          return placeholder;
        });
      } // return current result if no replacements specified


      if (!Object.keys(replacements).length) {
        return result;
      }
      /**
       * Step 2: replace all ICU vars (like "VAR_PLURAL")
       */


      result = result.replace(PP_ICU_VARS_REGEXP,
      /**
      * @param {?} match
      * @param {?} start
      * @param {?} key
      * @param {?} _type
      * @param {?} _idx
      * @param {?} end
      * @return {?}
      */
      (match, start, key, _type, _idx, end) => {
        return replacements.hasOwnProperty(key) ? "".concat(start).concat(replacements[key]).concat(end) : match;
      });
      /**
       * Step 3: replace all placeholders used inside ICUs in a form of {PLACEHOLDER}
       */

      result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP,
      /**
      * @param {?} match
      * @param {?} key
      * @return {?}
      */
      (match, key) => {
        return replacements.hasOwnProperty(key) ?
        /** @type {?} */
        replacements[key] : match;
      });
      /**
       * Step 4: replace all ICU references with corresponding values (like �ICU_EXP_ICU_1�) in case
       * multiple ICUs have the same placeholder name
       */

      result = result.replace(PP_ICUS_REGEXP,
      /**
      * @param {?} match
      * @param {?} key
      * @return {?}
      */
      (match, key) => {
        if (replacements.hasOwnProperty(key)) {
          /** @type {?} */
          const list =
          /** @type {?} */
          replacements[key];

          if (!list.length) {
            throw new Error("i18n postprocess: unmatched ICU - ".concat(match, " with key: ").concat(key));
          }

          return (
            /** @type {?} */
            list.shift()
          );
        }

        return match;
      });
      return result;
    }
    /**
     * Translates a translation block marked by `i18nStart` and `i18nEnd`. It inserts the text/ICU nodes
     * into the render tree, moves the placeholder nodes and removes the deleted nodes.
     *
     * \@codeGenApi
     * @return {?}
     */


    function ɵɵi18nEnd() {
      /** @type {?} */
      const tView = getLView()[TVIEW];
      ngDevMode && assertDefined(tView, "tView should be defined");
      i18nEndFirstPass(tView); // Stop delaying projections

      setDelayProjection(false);
    }
    /**
     * See `i18nEnd` above.
     * @param {?} tView
     * @return {?}
     */


    function i18nEndFirstPass(tView) {
      /** @type {?} */
      const viewData = getLView();
      ngDevMode && assertEqual(viewData[BINDING_INDEX], viewData[TVIEW].bindingStartIndex, 'i18nEnd should be called before any binding');
      /** @type {?} */

      const rootIndex = i18nIndexStack[i18nIndexStackPointer--];
      /** @type {?} */

      const tI18n =
      /** @type {?} */
      tView.data[rootIndex + HEADER_OFFSET];
      ngDevMode && assertDefined(tI18n, "You should call i18nStart before i18nEnd"); // Find the last node that was added before `i18nEnd`

      /** @type {?} */

      let lastCreatedNode = getPreviousOrParentTNode(); // Read the instructions to insert/move/remove DOM elements

      /** @type {?} */

      const visitedNodes = readCreateOpCodes(rootIndex, tI18n.create, tI18n.icus, viewData); // Remove deleted nodes

      for (let i = rootIndex + 1; i <= lastCreatedNode.index - HEADER_OFFSET; i++) {
        if (visitedNodes.indexOf(i) === -1) {
          removeNode(i, viewData);
        }
      }
    }
    /**
     * Creates and stores the dynamic TNode, and unhooks it from the tree for now.
     * @param {?} lView
     * @param {?} index
     * @param {?} type
     * @param {?} native
     * @param {?} name
     * @return {?}
     */


    function createDynamicNodeAtIndex(lView, index, type, native, name) {
      /** @type {?} */
      const previousOrParentTNode = getPreviousOrParentTNode();
      ngDevMode && assertDataInRange(lView, index + HEADER_OFFSET);
      lView[index + HEADER_OFFSET] = native;
      /** @type {?} */

      const tNode = getOrCreateTNode(lView[TVIEW], lView[T_HOST], index,
      /** @type {?} */
      type, name, null); // We are creating a dynamic node, the previous tNode might not be pointing at this node.
      // We will link ourselves into the tree later with `appendI18nNode`.

      if (previousOrParentTNode.next === tNode) {
        previousOrParentTNode.next = null;
      }

      return tNode;
    }
    /**
     * @param {?} index
     * @param {?} createOpCodes
     * @param {?} icus
     * @param {?} viewData
     * @return {?}
     */


    function readCreateOpCodes(index, createOpCodes, icus, viewData) {
      /** @type {?} */
      const renderer = getLView()[RENDERER];
      /** @type {?} */

      let currentTNode = null;
      /** @type {?} */

      let previousTNode = null;
      /** @type {?} */

      const visitedNodes = [];

      for (let i = 0; i < createOpCodes.length; i++) {
        /** @type {?} */
        const opCode = createOpCodes[i];

        if (typeof opCode == 'string') {
          /** @type {?} */
          const textRNode = createTextNode(opCode, renderer);
          /** @type {?} */

          const textNodeIndex =
          /** @type {?} */
          createOpCodes[++i];
          ngDevMode && ngDevMode.rendererCreateTextNode++;
          previousTNode = currentTNode;
          currentTNode = createDynamicNodeAtIndex(viewData, textNodeIndex, 3
          /* Element */
          , textRNode, null);
          visitedNodes.push(textNodeIndex);
          setIsNotParent();
        } else if (typeof opCode == 'number') {
          switch (opCode & 7
          /* MASK_OPCODE */
          ) {
            case 1
            /* AppendChild */
            :
              /** @type {?} */
              const destinationNodeIndex = opCode >>> 17
              /* SHIFT_PARENT */
              ;
              /** @type {?} */

              let destinationTNode;

              if (destinationNodeIndex === index) {
                // If the destination node is `i18nStart`, we don't have a
                // top-level node and we should use the host node instead
                destinationTNode =
                /** @type {?} */
                viewData[T_HOST];
              } else {
                destinationTNode = getTNode(destinationNodeIndex, viewData);
              }

              ngDevMode && assertDefined(
              /** @type {?} */
              currentTNode, "You need to create or select a node before you can insert it into the DOM");
              previousTNode = appendI18nNode(
              /** @type {?} */
              currentTNode, destinationTNode, previousTNode, viewData);
              break;

            case 0
            /* Select */
            :
              /** @type {?} */
              const nodeIndex = opCode >>> 3
              /* SHIFT_REF */
              ;
              visitedNodes.push(nodeIndex);
              previousTNode = currentTNode;
              currentTNode = getTNode(nodeIndex, viewData);

              if (currentTNode) {
                setPreviousOrParentTNode(currentTNode, currentTNode.type === 3
                /* Element */
                );
              }

              break;

            case 5
            /* ElementEnd */
            :
              /** @type {?} */
              const elementIndex = opCode >>> 3
              /* SHIFT_REF */
              ;
              previousTNode = currentTNode = getTNode(elementIndex, viewData);
              setPreviousOrParentTNode(currentTNode, false);
              break;

            case 4
            /* Attr */
            :
              /** @type {?} */
              const elementNodeIndex = opCode >>> 3
              /* SHIFT_REF */
              ;
              /** @type {?} */

              const attrName =
              /** @type {?} */
              createOpCodes[++i];
              /** @type {?} */

              const attrValue =
              /** @type {?} */
              createOpCodes[++i]; // This code is used for ICU expressions only, since we don't support
              // directives/components in ICUs, we don't need to worry about inputs here

              elementAttributeInternal(elementNodeIndex, attrName, attrValue, viewData);
              break;

            default:
              throw new Error("Unable to determine the type of mutate operation for \"".concat(opCode, "\""));
          }
        } else {
          switch (opCode) {
            case COMMENT_MARKER:
              /** @type {?} */
              const commentValue =
              /** @type {?} */
              createOpCodes[++i];
              /** @type {?} */

              const commentNodeIndex =
              /** @type {?} */
              createOpCodes[++i];
              ngDevMode && assertEqual(typeof commentValue, 'string', "Expected \"".concat(commentValue, "\" to be a comment node value"));
              /** @type {?} */

              const commentRNode = renderer.createComment(commentValue);
              ngDevMode && ngDevMode.rendererCreateComment++;
              previousTNode = currentTNode;
              currentTNode = createDynamicNodeAtIndex(viewData, commentNodeIndex, 5
              /* IcuContainer */
              , commentRNode, null);
              visitedNodes.push(commentNodeIndex);
              attachPatchData(commentRNode, viewData);

              /** @type {?} */
              currentTNode.activeCaseIndex = null; // We will add the case nodes later, during the update phase

              setIsNotParent();
              break;

            case ELEMENT_MARKER:
              /** @type {?} */
              const tagNameValue =
              /** @type {?} */
              createOpCodes[++i];
              /** @type {?} */

              const elementNodeIndex =
              /** @type {?} */
              createOpCodes[++i];
              ngDevMode && assertEqual(typeof tagNameValue, 'string', "Expected \"".concat(tagNameValue, "\" to be an element node tag name"));
              /** @type {?} */

              const elementRNode = renderer.createElement(tagNameValue);
              ngDevMode && ngDevMode.rendererCreateElement++;
              previousTNode = currentTNode;
              currentTNode = createDynamicNodeAtIndex(viewData, elementNodeIndex, 3
              /* Element */
              , elementRNode, tagNameValue);
              visitedNodes.push(elementNodeIndex);
              break;

            default:
              throw new Error("Unable to determine the type of mutate operation for \"".concat(opCode, "\""));
          }
        }
      }

      setIsNotParent();
      return visitedNodes;
    }
    /**
     * @param {?} updateOpCodes
     * @param {?} icus
     * @param {?} bindingsStartIndex
     * @param {?} changeMask
     * @param {?} viewData
     * @param {?=} bypassCheckBit
     * @return {?}
     */


    function readUpdateOpCodes(updateOpCodes, icus, bindingsStartIndex, changeMask, viewData, bypassCheckBit = false) {
      /** @type {?} */
      let caseCreated = false;

      for (let i = 0; i < updateOpCodes.length; i++) {
        // bit code to check if we should apply the next update

        /** @type {?} */
        const checkBit =
        /** @type {?} */
        updateOpCodes[i]; // Number of opCodes to skip until next set of update codes

        /** @type {?} */

        const skipCodes =
        /** @type {?} */
        updateOpCodes[++i];

        if (bypassCheckBit || checkBit & changeMask) {
          // The value has been updated since last checked

          /** @type {?} */
          let value = '';

          for (let j = i + 1; j <= i + skipCodes; j++) {
            /** @type {?} */
            const opCode = updateOpCodes[j];

            if (typeof opCode == 'string') {
              value += opCode;
            } else if (typeof opCode == 'number') {
              if (opCode < 0) {
                // It's a binding index whose value is negative
                value += renderStringify(viewData[bindingsStartIndex - opCode]);
              } else {
                /** @type {?} */
                const nodeIndex = opCode >>> 2
                /* SHIFT_REF */
                ;
                /** @type {?} */

                let tIcuIndex;
                /** @type {?} */

                let tIcu;
                /** @type {?} */

                let icuTNode;

                switch (opCode & 3
                /* MASK_OPCODE */
                ) {
                  case 1
                  /* Attr */
                  :
                    /** @type {?} */
                    const propName =
                    /** @type {?} */
                    updateOpCodes[++j];
                    /** @type {?} */

                    const sanitizeFn =
                    /** @type {?} */
                    updateOpCodes[++j];
                    elementPropertyInternal(nodeIndex, propName, value, sanitizeFn);
                    break;

                  case 0
                  /* Text */
                  :
                    textBindingInternal(viewData, nodeIndex, value);
                    break;

                  case 2
                  /* IcuSwitch */
                  :
                    tIcuIndex =
                    /** @type {?} */
                    updateOpCodes[++j];
                    tIcu =
                    /** @type {?} */
                    icus[tIcuIndex];
                    icuTNode =
                    /** @type {?} */
                    getTNode(nodeIndex, viewData); // If there is an active case, delete the old nodes

                    if (icuTNode.activeCaseIndex !== null) {
                      /** @type {?} */
                      const removeCodes = tIcu.remove[icuTNode.activeCaseIndex];

                      for (let k = 0; k < removeCodes.length; k++) {
                        /** @type {?} */
                        const removeOpCode =
                        /** @type {?} */
                        removeCodes[k];

                        switch (removeOpCode & 7
                        /* MASK_OPCODE */
                        ) {
                          case 3
                          /* Remove */
                          :
                            /** @type {?} */
                            const nodeIndex = removeOpCode >>> 3
                            /* SHIFT_REF */
                            ;
                            removeNode(nodeIndex, viewData);
                            break;

                          case 6
                          /* RemoveNestedIcu */
                          :
                            /** @type {?} */
                            const nestedIcuNodeIndex =
                            /** @type {?} */
                            removeCodes[k + 1] >>> 3
                            /* SHIFT_REF */
                            ;
                            /** @type {?} */

                            const nestedIcuTNode =
                            /** @type {?} */
                            getTNode(nestedIcuNodeIndex, viewData);
                            /** @type {?} */

                            const activeIndex = nestedIcuTNode.activeCaseIndex;

                            if (activeIndex !== null) {
                              /** @type {?} */
                              const nestedIcuTIndex = removeOpCode >>> 3
                              /* SHIFT_REF */
                              ;
                              /** @type {?} */

                              const nestedTIcu =
                              /** @type {?} */
                              icus[nestedIcuTIndex];
                              addAllToArray(nestedTIcu.remove[activeIndex], removeCodes);
                            }

                            break;
                        }
                      }
                    } // Update the active caseIndex

                    /** @type {?} */


                    const caseIndex = getCaseIndex(tIcu, value);
                    icuTNode.activeCaseIndex = caseIndex !== -1 ? caseIndex : null; // Add the nodes for the new case

                    readCreateOpCodes(-1, tIcu.create[caseIndex], icus, viewData);
                    caseCreated = true;
                    break;

                  case 3
                  /* IcuUpdate */
                  :
                    tIcuIndex =
                    /** @type {?} */
                    updateOpCodes[++j];
                    tIcu =
                    /** @type {?} */
                    icus[tIcuIndex];
                    icuTNode =
                    /** @type {?} */
                    getTNode(nodeIndex, viewData);
                    readUpdateOpCodes(tIcu.update[
                    /** @type {?} */
                    icuTNode.activeCaseIndex], icus, bindingsStartIndex, changeMask, viewData, caseCreated);
                    break;
                }
              }
            }
          }
        }

        i += skipCodes;
      }
    }
    /**
     * @param {?} index
     * @param {?} viewData
     * @return {?}
     */


    function removeNode(index, viewData) {
      /** @type {?} */
      const removedPhTNode = getTNode(index, viewData);
      /** @type {?} */

      const removedPhRNode = getNativeByIndex(index, viewData);

      if (removedPhRNode) {
        nativeRemoveNode(viewData[RENDERER], removedPhRNode);
      }
      /** @type {?} */


      const slotValue =
      /** @type {?} */
      ɵɵload(index);

      if (isLContainer(slotValue)) {
        /** @type {?} */
        const lContainer =
        /** @type {?} */
        slotValue;

        if (removedPhTNode.type !== 0
        /* Container */
        ) {
            nativeRemoveNode(viewData[RENDERER], lContainer[NATIVE]);
          }
      } // Define this node as detached so that we don't risk projecting it


      removedPhTNode.flags |= 32
      /* isDetached */
      ;
      ngDevMode && ngDevMode.rendererRemoveNode++;
    }
    /**
     *
     * Use this instruction to create a translation block that doesn't contain any placeholder.
     * It calls both {\@link i18nStart} and {\@link i18nEnd} in one instruction.
     *
     * The translation `message` is the value which is locale specific. The translation string may
     * contain placeholders which associate inner elements and sub-templates within the translation.
     *
     * The translation `message` placeholders are:
     * - `�{index}(:{block})�`: *Binding Placeholder*: Marks a location where an expression will be
     *   interpolated into. The placeholder `index` points to the expression binding index. An optional
     *   `block` that matches the sub-template in which it was declared.
     * - `�#{index}(:{block})�`/`�/#{index}(:{block})�`: *Element Placeholder*:  Marks the beginning
     *   and end of DOM element that were embedded in the original translation block. The placeholder
     *   `index` points to the element index in the template instructions set. An optional `block` that
     *   matches the sub-template in which it was declared.
     * - `�*{index}:{block}�`/`�/*{index}:{block}�`: *Sub-template Placeholder*: Sub-templates must be
     *   split up and translated separately in each angular template function. The `index` points to the
     *   `template` instruction index. A `block` that matches the sub-template in which it was declared.
     *
     * \@codeGenApi
     * @param {?} index A unique index of the translation in the static block.
     * @param {?} message The translation message.
     * @param {?=} subTemplateIndex Optional sub-template index in the `message`.
     *
     * @return {?}
     */


    function ɵɵi18n(index, message, subTemplateIndex) {
      ɵɵi18nStart(index, message, subTemplateIndex);
      ɵɵi18nEnd();
    }
    /**
     * Marks a list of attributes as translatable.
     *
     * \@codeGenApi
     * @param {?} index A unique index in the static block
     * @param {?} values
     *
     * @return {?}
     */


    function ɵɵi18nAttributes(index, values) {
      /** @type {?} */
      const tView = getLView()[TVIEW];
      ngDevMode && assertDefined(tView, "tView should be defined");
      i18nAttributesFirstPass(tView, index, values);
    }
    /**
     * See `i18nAttributes` above.
     * @param {?} tView
     * @param {?} index
     * @param {?} values
     * @return {?}
     */


    function i18nAttributesFirstPass(tView, index, values) {
      /** @type {?} */
      const previousElement = getPreviousOrParentTNode();
      /** @type {?} */

      const previousElementIndex = previousElement.index - HEADER_OFFSET;
      /** @type {?} */

      const updateOpCodes = [];

      for (let i = 0; i < values.length; i += 2) {
        /** @type {?} */
        const attrName = values[i];
        /** @type {?} */

        const message = values[i + 1];
        /** @type {?} */

        const parts = message.split(ICU_REGEXP);

        for (let j = 0; j < parts.length; j++) {
          /** @type {?} */
          const value = parts[j];

          if (j & 1) {
            // Odd indexes are ICU expressions
            // TODO(ocombe): support ICU expressions in attributes
            throw new Error('ICU expressions are not yet supported in attributes');
          } else if (value !== '') {
            // Even indexes are text (including bindings)

            /** @type {?} */
            const hasBinding = !!value.match(BINDING_REGEXP);

            if (hasBinding) {
              if (tView.firstTemplatePass && tView.data[index + HEADER_OFFSET] === null) {
                addAllToArray(generateBindingUpdateOpCodes(value, previousElementIndex, attrName), updateOpCodes);
              }
            } else {
              /** @type {?} */
              const lView = getLView();
              elementAttributeInternal(previousElementIndex, attrName, value, lView); // Check if that attribute is a directive input

              /** @type {?} */

              const tNode = getTNode(previousElementIndex, lView);
              /** @type {?} */

              const dataValue = tNode.inputs && tNode.inputs[attrName];

              if (dataValue) {
                setInputsForProperty(lView, dataValue, value);
              }
            }
          }
        }
      }

      if (tView.firstTemplatePass && tView.data[index + HEADER_OFFSET] === null) {
        tView.data[index + HEADER_OFFSET] = updateOpCodes;
      }
    }
    /** @type {?} */


    let changeMask = 0b0;
    /** @type {?} */

    let shiftsCounter = 0;
    /**
     * Stores the values of the bindings during each update cycle in order to determine if we need to
     * update the translated nodes.
     *
     * \@codeGenApi
     * @template T
     * @param {?} value The binding's value
     * @return {?} This function returns itself so that it may be chained
     * (e.g. `i18nExp(ctx.name)(ctx.title)`)
     *
     */

    function ɵɵi18nExp(value) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const expression = bind(lView, value);

      if (expression !== NO_CHANGE) {
        changeMask = changeMask | 1 << shiftsCounter;
      }

      shiftsCounter++;
      return ɵɵi18nExp;
    }
    /**
     * Updates a translation block or an i18n attribute when the bindings have changed.
     *
     * \@codeGenApi
     * @param {?} index Index of either {\@link i18nStart} (translation block) or {\@link i18nAttributes}
     * (i18n attribute) on which it should update the content.
     *
     * @return {?}
     */


    function ɵɵi18nApply(index) {
      if (shiftsCounter) {
        /** @type {?} */
        const lView = getLView();
        /** @type {?} */

        const tView = lView[TVIEW];
        ngDevMode && assertDefined(tView, "tView should be defined");
        /** @type {?} */

        const tI18n = tView.data[index + HEADER_OFFSET];
        /** @type {?} */

        let updateOpCodes;
        /** @type {?} */

        let icus = null;

        if (Array.isArray(tI18n)) {
          updateOpCodes =
          /** @type {?} */
          tI18n;
        } else {
          updateOpCodes =
          /** @type {?} */
          tI18n.update;
          icus =
          /** @type {?} */
          tI18n.icus;
        }
        /** @type {?} */


        const bindingsStartIndex = lView[BINDING_INDEX] - shiftsCounter - 1;
        readUpdateOpCodes(updateOpCodes, icus, bindingsStartIndex, changeMask, lView); // Reset changeMask & maskBit to default for the next update cycle

        changeMask = 0b0;
        shiftsCounter = 0;
      }
    }
    /**
     * Returns the index of the current case of an ICU expression depending on the main binding value
     *
     * @param {?} icuExpression
     * @param {?} bindingValue The value of the main binding used by this ICU expression
     * @return {?}
     */


    function getCaseIndex(icuExpression, bindingValue) {
      /** @type {?} */
      let index = icuExpression.cases.indexOf(bindingValue);

      if (index === -1) {
        switch (icuExpression.type) {
          case 1
          /* plural */
          :
            {
              /** @type {?} */
              const resolvedCase = getPluralCase(bindingValue, getLocaleId());
              index = icuExpression.cases.indexOf(resolvedCase);

              if (index === -1 && resolvedCase !== 'other') {
                index = icuExpression.cases.indexOf('other');
              }

              break;
            }

          case 0
          /* select */
          :
            {
              index = icuExpression.cases.indexOf('other');
              break;
            }
        }
      }

      return index;
    }
    /**
     * Generate the OpCodes for ICU expressions.
     *
     * @param {?} tIcus
     * @param {?} icuExpression
     * @param {?} startIndex
     * @param {?} expandoStartIndex
     * @return {?}
     */


    function icuStart(tIcus, icuExpression, startIndex, expandoStartIndex) {
      /** @type {?} */
      const createCodes = [];
      /** @type {?} */

      const removeCodes = [];
      /** @type {?} */

      const updateCodes = [];
      /** @type {?} */

      const vars = [];
      /** @type {?} */

      const childIcus = [];

      for (let i = 0; i < icuExpression.values.length; i++) {
        // Each value is an array of strings & other ICU expressions

        /** @type {?} */
        const valueArr = icuExpression.values[i];
        /** @type {?} */

        const nestedIcus = [];

        for (let j = 0; j < valueArr.length; j++) {
          /** @type {?} */
          const value = valueArr[j];

          if (typeof value !== 'string') {
            // It is an nested ICU expression

            /** @type {?} */
            const icuIndex = nestedIcus.push(
            /** @type {?} */
            value) - 1; // Replace nested ICU expression by a comment node

            valueArr[j] = "<!--\uFFFD".concat(icuIndex, "\uFFFD-->");
          }
        }
        /** @type {?} */


        const icuCase = parseIcuCase(valueArr.join(''), startIndex, nestedIcus, tIcus, expandoStartIndex);
        createCodes.push(icuCase.create);
        removeCodes.push(icuCase.remove);
        updateCodes.push(icuCase.update);
        vars.push(icuCase.vars);
        childIcus.push(icuCase.childIcus);
      }
      /** @type {?} */


      const tIcu = {
        type: icuExpression.type,
        vars,
        childIcus,
        cases: icuExpression.cases,
        create: createCodes,
        remove: removeCodes,
        update: updateCodes
      };
      tIcus.push(tIcu); // Adding the maximum possible of vars needed (based on the cases with the most vars)

      i18nVarsCount += Math.max(...vars);
    }
    /**
     * Transforms a string template into an HTML template and a list of instructions used to update
     * attributes or nodes that contain bindings.
     *
     * @param {?} unsafeHtml The string to parse
     * @param {?} parentIndex
     * @param {?} nestedIcus
     * @param {?} tIcus
     * @param {?} expandoStartIndex
     * @return {?}
     */


    function parseIcuCase(unsafeHtml, parentIndex, nestedIcus, tIcus, expandoStartIndex) {
      /** @type {?} */
      const inertBodyHelper = new InertBodyHelper(document);
      /** @type {?} */

      const inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);

      if (!inertBodyElement) {
        throw new Error('Unable to generate inert body element');
      }
      /** @type {?} */


      const wrapper =
      /** @type {?} */
      getTemplateContent(
      /** @type {?} */
      inertBodyElement) || inertBodyElement;
      /** @type {?} */

      const opCodes = {
        vars: 0,
        childIcus: [],
        create: [],
        remove: [],
        update: []
      };
      parseNodes(wrapper.firstChild, opCodes, parentIndex, nestedIcus, tIcus, expandoStartIndex);
      return opCodes;
    }
    /** @type {?} */


    const NESTED_ICU = /�(\d+)�/;
    /**
     * Parses a node, its children and its siblings, and generates the mutate & update OpCodes.
     *
     * @param {?} currentNode The first node to parse
     * @param {?} icuCase The data for the ICU expression case that contains those nodes
     * @param {?} parentIndex Index of the current node's parent
     * @param {?} nestedIcus Data for the nested ICU expressions that this case contains
     * @param {?} tIcus Data for all ICU expressions of the current message
     * @param {?} expandoStartIndex Expando start index for the current ICU expression
     * @return {?}
     */

    function parseNodes(currentNode, icuCase, parentIndex, nestedIcus, tIcus, expandoStartIndex) {
      if (currentNode) {
        /** @type {?} */
        const nestedIcusToCreate = [];

        while (currentNode) {
          /** @type {?} */
          const nextNode = currentNode.nextSibling;
          /** @type {?} */

          const newIndex = expandoStartIndex + ++icuCase.vars;

          switch (currentNode.nodeType) {
            case Node.ELEMENT_NODE:
              /** @type {?} */
              const element =
              /** @type {?} */
              currentNode;
              /** @type {?} */

              const tagName = element.tagName.toLowerCase();

              if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {
                // This isn't a valid element, we won't create an element for it
                icuCase.vars--;
              } else {
                icuCase.create.push(ELEMENT_MARKER, tagName, newIndex, parentIndex << 17
                /* SHIFT_PARENT */
                | 1
                /* AppendChild */
                );
                /** @type {?} */

                const elAttrs = element.attributes;

                for (let i = 0; i < elAttrs.length; i++) {
                  /** @type {?} */
                  const attr =
                  /** @type {?} */
                  elAttrs.item(i);
                  /** @type {?} */

                  const lowerAttrName = attr.name.toLowerCase();
                  /** @type {?} */

                  const hasBinding = !!attr.value.match(BINDING_REGEXP); // we assume the input string is safe, unless it's using a binding

                  if (hasBinding) {
                    if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {
                      if (URI_ATTRS[lowerAttrName]) {
                        addAllToArray(generateBindingUpdateOpCodes(attr.value, newIndex, attr.name, _sanitizeUrl), icuCase.update);
                      } else if (SRCSET_ATTRS[lowerAttrName]) {
                        addAllToArray(generateBindingUpdateOpCodes(attr.value, newIndex, attr.name, sanitizeSrcset), icuCase.update);
                      } else {
                        addAllToArray(generateBindingUpdateOpCodes(attr.value, newIndex, attr.name), icuCase.update);
                      }
                    } else {
                      ngDevMode && console.warn("WARNING: ignoring unsafe attribute value ".concat(lowerAttrName, " on element ").concat(tagName, " (see http://g.co/ng/security#xss)"));
                    }
                  } else {
                    icuCase.create.push(newIndex << 3
                    /* SHIFT_REF */
                    | 4
                    /* Attr */
                    , attr.name, attr.value);
                  }
                } // Parse the children of this node (if any)


                parseNodes(currentNode.firstChild, icuCase, newIndex, nestedIcus, tIcus, expandoStartIndex); // Remove the parent node after the children

                icuCase.remove.push(newIndex << 3
                /* SHIFT_REF */
                | 3
                /* Remove */
                );
              }

              break;

            case Node.TEXT_NODE:
              /** @type {?} */
              const value = currentNode.textContent || '';
              /** @type {?} */

              const hasBinding = value.match(BINDING_REGEXP);
              icuCase.create.push(hasBinding ? '' : value, newIndex, parentIndex << 17
              /* SHIFT_PARENT */
              | 1
              /* AppendChild */
              );
              icuCase.remove.push(newIndex << 3
              /* SHIFT_REF */
              | 3
              /* Remove */
              );

              if (hasBinding) {
                addAllToArray(generateBindingUpdateOpCodes(value, newIndex), icuCase.update);
              }

              break;

            case Node.COMMENT_NODE:
              // Check if the comment node is a placeholder for a nested ICU

              /** @type {?} */
              const match = NESTED_ICU.exec(currentNode.textContent || '');

              if (match) {
                /** @type {?} */
                const nestedIcuIndex = parseInt(match[1], 10);
                /** @type {?} */

                const newLocal = ngDevMode ? "nested ICU ".concat(nestedIcuIndex) : ''; // Create the comment node that will anchor the ICU expression

                icuCase.create.push(COMMENT_MARKER, newLocal, newIndex, parentIndex << 17
                /* SHIFT_PARENT */
                | 1
                /* AppendChild */
                );
                /** @type {?} */

                const nestedIcu = nestedIcus[nestedIcuIndex];
                nestedIcusToCreate.push([nestedIcu, newIndex]);
              } else {
                // We do not handle any other type of comment
                icuCase.vars--;
              }

              break;

            default:
              // We do not handle any other type of element
              icuCase.vars--;
          }

          currentNode =
          /** @type {?} */
          nextNode;
        }

        for (let i = 0; i < nestedIcusToCreate.length; i++) {
          /** @type {?} */
          const nestedIcu = nestedIcusToCreate[i][0];
          /** @type {?} */

          const nestedIcuNodeIndex = nestedIcusToCreate[i][1];
          icuStart(tIcus, nestedIcu, nestedIcuNodeIndex, expandoStartIndex + icuCase.vars); // Since this is recursive, the last TIcu that was pushed is the one we want

          /** @type {?} */

          const nestTIcuIndex = tIcus.length - 1;
          icuCase.vars += Math.max(...tIcus[nestTIcuIndex].vars);
          icuCase.childIcus.push(nestTIcuIndex);
          /** @type {?} */

          const mask = getBindingMask(nestedIcu);
          icuCase.update.push(toMaskBit(nestedIcu.mainBinding), // mask of the main binding
          3, // skip 3 opCodes if not changed
          -1 - nestedIcu.mainBinding, nestedIcuNodeIndex << 2
          /* SHIFT_REF */
          | 2
          /* IcuSwitch */
          , nestTIcuIndex, mask, // mask of all the bindings of this ICU expression
          2, // skip 2 opCodes if not changed
          nestedIcuNodeIndex << 2
          /* SHIFT_REF */
          | 3
          /* IcuUpdate */
          , nestTIcuIndex);
          icuCase.remove.push(nestTIcuIndex << 3
          /* SHIFT_REF */
          | 6
          /* RemoveNestedIcu */
          , nestedIcuNodeIndex << 3
          /* SHIFT_REF */
          | 3
          /* Remove */
          );
        }
      }
    }
    /**
     * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:
     * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32
     * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character
     * and later on replaced by a space. We are re-implementing the same idea here, since translations
     * might contain this special character.
     * @type {?}
     */


    const NGSP_UNICODE_REGEXP = /\uE500/g;
    /**
     * @param {?} value
     * @return {?}
     */

    function replaceNgsp(value) {
      return value.replace(NGSP_UNICODE_REGEXP, ' ');
    }
    /** @type {?} */


    let TRANSLATIONS = {};
    /**
     * @record
     */

    function I18nLocalizeOptions() {}

    if (false) {}
    /**
     * Set the configuration for `i18nLocalize`.
     *
     * @deprecated this method is temporary & should not be used as it will be removed soon
     * @param {?=} options
     * @return {?}
     */


    function i18nConfigureLocalize(options = {
      translations: {}
    }) {
      TRANSLATIONS = options.translations;
    }
    /** @type {?} */


    const LOCALIZE_PH_REGEXP = /\{\$(.*?)\}/g;
    /**
     * A goog.getMsg-like function for users that do not use Closure.
     *
     * This method is required as a *temporary* measure to prevent i18n tests from being blocked while
     * running outside of Closure Compiler. This method will not be needed once runtime translation
     * service support is introduced.
     *
     * \@codeGenApi
     * @deprecated this method is temporary & should not be used as it will be removed soon
     * @param {?} input
     * @param {?=} placeholders
     * @return {?}
     */

    function ɵɵi18nLocalize(input, placeholders) {
      if (typeof TRANSLATIONS[input] !== 'undefined') {
        // to account for empty string
        input = TRANSLATIONS[input];
      }

      if (placeholders !== undefined && Object.keys(placeholders).length) {
        return input.replace(LOCALIZE_PH_REGEXP,
        /**
        * @param {?} _
        * @param {?} key
        * @return {?}
        */
        (_, key) => placeholders[key] || '');
      }

      return input;
    }
    /**
     * The locale id that the application is currently using (for translations and ICU expressions).
     * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine
     * but is now defined as a global value.
     * @type {?}
     */


    let LOCALE_ID = DEFAULT_LOCALE_ID;
    /**
     * Sets the locale id that will be used for translations and ICU expressions.
     * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine
     * but is now defined as a global value.
     *
     * @param {?} localeId
     * @return {?}
     */

    function setLocaleId(localeId) {
      assertDefined(localeId, "Expected localeId to be defined");

      if (typeof localeId === 'string') {
        LOCALE_ID = localeId.toLowerCase().replace(/_/g, '-');
      }
    }
    /**
     * Gets the locale id that will be used for translations and ICU expressions.
     * This is the ivy version of `LOCALE_ID` that was defined as an injection token for the view engine
     * but is now defined as a global value.
     * @return {?}
     */


    function getLocaleId() {
      return LOCALE_ID;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Map of module-id to the corresponding NgModule.
     * - In pre Ivy we track NgModuleFactory,
     * - In post Ivy we track the NgModuleType
     * @type {?}
     */


    const modules = new Map();
    /**
     * Registers a loaded module. Should only be called from generated NgModuleFactory code.
     * \@publicApi
     * @param {?} id
     * @param {?} factory
     * @return {?}
     */

    function registerModuleFactory(id, factory) {
      /** @type {?} */
      const existing =
      /** @type {?} */
      modules.get(id);
      assertSameOrNotExisting(id, existing && existing.moduleType, factory.moduleType);
      modules.set(id, factory);
    }
    /**
     * @param {?} id
     * @param {?} type
     * @param {?} incoming
     * @return {?}
     */


    function assertSameOrNotExisting(id, type, incoming) {
      if (type && type !== incoming) {
        throw new Error("Duplicate module registered for ".concat(id, " - ").concat(stringify(type), " vs ").concat(stringify(type.name)));
      }
    }
    /**
     * @param {?} ngModuleType
     * @return {?}
     */


    function registerNgModuleType(ngModuleType) {
      if (ngModuleType.ngModuleDef.id !== null) {
        /** @type {?} */
        const id = ngModuleType.ngModuleDef.id;
        /** @type {?} */

        const existing =
        /** @type {?} */
        modules.get(id);
        assertSameOrNotExisting(id, existing, ngModuleType);
        modules.set(id, ngModuleType);
      }
      /** @type {?} */


      let imports = ngModuleType.ngModuleDef.imports;

      if (imports instanceof Function) {
        imports = imports();
      }

      if (imports) {
        imports.forEach(
        /**
        * @param {?} i
        * @return {?}
        */
        i => registerNgModuleType(
        /** @type {?} */
        i));
      }
    }
    /**
     * @return {?}
     */


    function clearModulesForTest() {
      modules.clear();
    }
    /**
     * @param {?} id
     * @return {?}
     */


    function getRegisteredNgModuleType(id) {
      return modules.get(id);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @record
     * @template T
     */


    function NgModuleType() {}

    if (false) {}
    /** @type {?} */


    const COMPONENT_FACTORY_RESOLVER = {
      provide: ComponentFactoryResolver,
      useClass: ComponentFactoryResolver$1,
      deps: [NgModuleRef]
    };
    /**
     * @template T
     */

    class NgModuleRef$1 extends NgModuleRef {
      /**
       * @param {?} ngModuleType
       * @param {?} _parent
       */
      constructor(ngModuleType, _parent) {
        super();
        this._parent = _parent; // tslint:disable-next-line:require-internal-with-underscore

        this._bootstrapComponents = [];
        this.injector = this;
        this.destroyCbs = [];
        /** @type {?} */

        /** @nocollapse */

        const ngModuleDef = getNgModuleDef(ngModuleType);
        ngDevMode && assertDefined(ngModuleDef, "NgModule '".concat(stringify(ngModuleType), "' is not a subtype of 'NgModuleType'."));
        /** @type {?} */

        const ngLocaleIdDef = getNgLocaleIdDef(ngModuleType);

        if (ngLocaleIdDef) {
          setLocaleId(ngLocaleIdDef);
        }

        this._bootstrapComponents = maybeUnwrapFn(
        /** @type {?} */
        ngModuleDef.bootstrap);
        /** @type {?} */

        const additionalProviders = [{
          provide: NgModuleRef,
          useValue: this
        }, COMPONENT_FACTORY_RESOLVER];
        this._r3Injector =
        /** @type {?} */
        createInjector(ngModuleType, _parent, additionalProviders, stringify(ngModuleType));
        this.instance = this.get(ngModuleType);
      }
      /**
       * @param {?} token
       * @param {?=} notFoundValue
       * @param {?=} injectFlags
       * @return {?}
       */


      get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, injectFlags = InjectFlags.Default) {
        if (token === Injector || token === NgModuleRef || token === INJECTOR) {
          return this;
        }

        return this._r3Injector.get(token, notFoundValue, injectFlags);
      }
      /**
       * @return {?}
       */


      get componentFactoryResolver() {
        return this.get(ComponentFactoryResolver);
      }
      /**
       * @return {?}
       */


      destroy() {
        ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');
        /** @type {?} */

        const injector = this._r3Injector;
        !injector.destroyed && injector.destroy();

        /** @type {?} */
        this.destroyCbs.forEach(
        /**
        * @param {?} fn
        * @return {?}
        */
        fn => fn());
        this.destroyCbs = null;
      }
      /**
       * @param {?} callback
       * @return {?}
       */


      onDestroy(callback) {
        ngDevMode && assertDefined(this.destroyCbs, 'NgModule already destroyed');

        /** @type {?} */
        this.destroyCbs.push(callback);
      }

    }

    if (false) {}
    /**
     * @template T
     */


    class NgModuleFactory$1 extends NgModuleFactory {
      /**
       * @param {?} moduleType
       */
      constructor(moduleType) {
        super();
        this.moduleType = moduleType;
        /** @type {?} */

        /** @nocollapse */

        const ngModuleDef = getNgModuleDef(moduleType);

        if (ngModuleDef !== null) {
          // Register the NgModule with Angular's module registry. The location (and hence timing) of
          // this call is critical to ensure this works correctly (modules get registered when expected)
          // without bloating bundles (modules are registered when otherwise not referenced).
          //
          // In View Engine, registration occurs in the .ngfactory.js file as a side effect. This has
          // several practical consequences:
          //
          // - If an .ngfactory file is not imported from, the module won't be registered (and can be
          //   tree shaken).
          // - If an .ngfactory file is imported from, the module will be registered even if an instance
          //   is not actually created (via `create` below).
          // - Since an .ngfactory file in View Engine references the .ngfactory files of the NgModule's
          //   imports,
          //
          // In Ivy, things are a bit different. .ngfactory files still exist for compatibility, but are
          // not a required API to use - there are other ways to obtain an NgModuleFactory for a given
          // NgModule. Thus, relying on a side effect in the .ngfactory file is not sufficient. Instead,
          // the side effect of registration is added here, in the constructor of NgModuleFactory,
          // ensuring no matter how a factory is created, the module is registered correctly.
          //
          // An alternative would be to include the registration side effect inline following the actual
          // NgModule definition. This also has the correct timing, but breaks tree-shaking - modules
          // will be registered and retained even if they're otherwise never referenced.
          registerNgModuleType(
          /** @type {?} */
          moduleType);
        }
      }
      /**
       * @param {?} parentInjector
       * @return {?}
       */


      create(parentInjector) {
        return new NgModuleRef$1(this.moduleType, parentInjector);
      }

    }

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @record
     */


    function TypeWithMetadata() {}

    if (false) {}
    /**
     * Adds decorator, constructor, and property metadata to a given type via static metadata fields
     * on the type.
     *
     * These metadata fields can later be read with Angular's `ReflectionCapabilities` API.
     *
     * Calls to `setClassMetadata` can be marked as pure, resulting in the metadata assignments being
     * tree-shaken away during production builds.
     * @param {?} type
     * @param {?} decorators
     * @param {?} ctorParameters
     * @param {?} propDecorators
     * @return {?}
     */


    function setClassMetadata(type, decorators, ctorParameters, propDecorators) {
      return (
        /** @type {?} */
        noSideEffects(
        /**
        * @return {?}
        */
        () => {
          /** @type {?} */
          const clazz =
          /** @type {?} */
          type; // We determine whether a class has its own metadata by taking the metadata from the parent
          // constructor and checking whether it's the same as the subclass metadata below. We can't use
          // `hasOwnProperty` here because it doesn't work correctly in IE10 for static fields that are
          // defined by TS. See https://github.com/angular/angular/pull/28439#issuecomment-459349218.

          /** @type {?} */

          const parentPrototype = clazz.prototype ? Object.getPrototypeOf(clazz.prototype) : null;
          /** @type {?} */

          const parentConstructor = parentPrototype && parentPrototype.constructor;

          if (decorators !== null) {
            if (clazz.decorators !== undefined && (!parentConstructor || parentConstructor.decorators !== clazz.decorators)) {
              clazz.decorators.push(...decorators);
            } else {
              clazz.decorators = decorators;
            }
          }

          if (ctorParameters !== null) {
            // Rather than merging, clobber the existing parameters. If other projects exist which use
            // tsickle-style annotations and reflect over them in the same way, this could cause issues,
            // but that is vanishingly unlikely.
            clazz.ctorParameters = ctorParameters;
          }

          if (propDecorators !== null) {
            // The property decorator objects are merged as it is possible different fields have different
            // decorator types. Decorators on individual fields are not merged, as it's also incredibly
            // unlikely that a field will be decorated both with an Angular decorator and a non-Angular
            // decorator that's also been downleveled.
            if (clazz.propDecorators !== undefined && (!parentConstructor || parentConstructor.propDecorators !== clazz.propDecorators)) {
              clazz.propDecorators = Object.assign({}, clazz.propDecorators, propDecorators);
            } else {
              clazz.propDecorators = propDecorators;
            }
          }
        })
      );
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Bindings for pure functions are stored after regular bindings.
     *
     * |------consts------|---------vars---------|                 |----- hostVars (dir1) ------|
     * ------------------------------------------------------------------------------------------
     * | nodes/refs/pipes | bindings | fn slots  | injector | dir1 | host bindings | host slots |
     * ------------------------------------------------------------------------------------------
     *                    ^                      ^
     *      TView.bindingStartIndex      TView.expandoStartIndex
     *
     * Pure function instructions are given an offset from the binding root. Adding the offset to the
     * binding root gives the first index where the bindings are stored. In component views, the binding
     * root is the bindingStartIndex. In host bindings, the binding root is the expandoStartIndex +
     * any directive instances + any hostVars in directives evaluated before it.
     *
     * See VIEW_DATA.md for more information about host binding resolution.
     */

    /**
     * If the value hasn't been saved, calls the pure function to store and return the
     * value. If it has been saved, returns the saved value.
     *
     * \@codeGenApi
     * @template T
     * @param {?} slotOffset the offset from binding root to the reserved slot
     * @param {?} pureFn Function that returns a value
     * @param {?=} thisArg Optional calling context of pureFn
     * @return {?} value
     *
     */


    function ɵɵpureFunction0(slotOffset, pureFn, thisArg) {
      // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings

      /** @type {?} */
      const bindingIndex = getBindingRoot() + slotOffset;
      /** @type {?} */

      const lView = getLView();
      return isCreationMode() ? updateBinding(lView, bindingIndex, thisArg ? pureFn.call(thisArg) : pureFn()) : getBinding(lView, bindingIndex);
    }
    /**
     * If the value of the provided exp has changed, calls the pure function to return
     * an updated value. Or if the value has not changed, returns cached value.
     *
     * \@codeGenApi
     * @param {?} slotOffset the offset from binding root to the reserved slot
     * @param {?} pureFn Function that returns an updated value
     * @param {?} exp Updated expression value
     * @param {?=} thisArg Optional calling context of pureFn
     * @return {?} Updated or cached value
     *
     */


    function ɵɵpureFunction1(slotOffset, pureFn, exp, thisArg) {
      // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings

      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const bindingIndex = getBindingRoot() + slotOffset;
      return bindingUpdated(lView, bindingIndex, exp) ? updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) : getBinding(lView, bindingIndex + 1);
    }
    /**
     * If the value of any provided exp has changed, calls the pure function to return
     * an updated value. Or if no values have changed, returns cached value.
     *
     * \@codeGenApi
     * @param {?} slotOffset the offset from binding root to the reserved slot
     * @param {?} pureFn
     * @param {?} exp1
     * @param {?} exp2
     * @param {?=} thisArg Optional calling context of pureFn
     * @return {?} Updated or cached value
     *
     */


    function ɵɵpureFunction2(slotOffset, pureFn, exp1, exp2, thisArg) {
      // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings

      /** @type {?} */
      const bindingIndex = getBindingRoot() + slotOffset;
      /** @type {?} */

      const lView = getLView();
      return bindingUpdated2(lView, bindingIndex, exp1, exp2) ? updateBinding(lView, bindingIndex + 2, thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) : getBinding(lView, bindingIndex + 2);
    }
    /**
     * If the value of any provided exp has changed, calls the pure function to return
     * an updated value. Or if no values have changed, returns cached value.
     *
     * \@codeGenApi
     * @param {?} slotOffset the offset from binding root to the reserved slot
     * @param {?} pureFn
     * @param {?} exp1
     * @param {?} exp2
     * @param {?} exp3
     * @param {?=} thisArg Optional calling context of pureFn
     * @return {?} Updated or cached value
     *
     */


    function ɵɵpureFunction3(slotOffset, pureFn, exp1, exp2, exp3, thisArg) {
      // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings

      /** @type {?} */
      const bindingIndex = getBindingRoot() + slotOffset;
      /** @type {?} */

      const lView = getLView();
      return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) ? updateBinding(lView, bindingIndex + 3, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3)) : getBinding(lView, bindingIndex + 3);
    }
    /**
     * If the value of any provided exp has changed, calls the pure function to return
     * an updated value. Or if no values have changed, returns cached value.
     *
     * \@codeGenApi
     * @param {?} slotOffset the offset from binding root to the reserved slot
     * @param {?} pureFn
     * @param {?} exp1
     * @param {?} exp2
     * @param {?} exp3
     * @param {?} exp4
     * @param {?=} thisArg Optional calling context of pureFn
     * @return {?} Updated or cached value
     *
     */


    function ɵɵpureFunction4(slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {
      // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings

      /** @type {?} */
      const bindingIndex = getBindingRoot() + slotOffset;
      /** @type {?} */

      const lView = getLView();
      return bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) ? updateBinding(lView, bindingIndex + 4, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) : pureFn(exp1, exp2, exp3, exp4)) : getBinding(lView, bindingIndex + 4);
    }
    /**
     * If the value of any provided exp has changed, calls the pure function to return
     * an updated value. Or if no values have changed, returns cached value.
     *
     * \@codeGenApi
     * @param {?} slotOffset the offset from binding root to the reserved slot
     * @param {?} pureFn
     * @param {?} exp1
     * @param {?} exp2
     * @param {?} exp3
     * @param {?} exp4
     * @param {?} exp5
     * @param {?=} thisArg Optional calling context of pureFn
     * @return {?} Updated or cached value
     *
     */


    function ɵɵpureFunction5(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, thisArg) {
      // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings

      /** @type {?} */
      const bindingIndex = getBindingRoot() + slotOffset;
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
      return bindingUpdated(lView, bindingIndex + 4, exp5) || different ? updateBinding(lView, bindingIndex + 5, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5) : pureFn(exp1, exp2, exp3, exp4, exp5)) : getBinding(lView, bindingIndex + 5);
    }
    /**
     * If the value of any provided exp has changed, calls the pure function to return
     * an updated value. Or if no values have changed, returns cached value.
     *
     * \@codeGenApi
     * @param {?} slotOffset the offset from binding root to the reserved slot
     * @param {?} pureFn
     * @param {?} exp1
     * @param {?} exp2
     * @param {?} exp3
     * @param {?} exp4
     * @param {?} exp5
     * @param {?} exp6
     * @param {?=} thisArg Optional calling context of pureFn
     * @return {?} Updated or cached value
     *
     */


    function ɵɵpureFunction6(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, thisArg) {
      // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings

      /** @type {?} */
      const bindingIndex = getBindingRoot() + slotOffset;
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
      return bindingUpdated2(lView, bindingIndex + 4, exp5, exp6) || different ? updateBinding(lView, bindingIndex + 6, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6)) : getBinding(lView, bindingIndex + 6);
    }
    /**
     * If the value of any provided exp has changed, calls the pure function to return
     * an updated value. Or if no values have changed, returns cached value.
     *
     * \@codeGenApi
     * @param {?} slotOffset the offset from binding root to the reserved slot
     * @param {?} pureFn
     * @param {?} exp1
     * @param {?} exp2
     * @param {?} exp3
     * @param {?} exp4
     * @param {?} exp5
     * @param {?} exp6
     * @param {?} exp7
     * @param {?=} thisArg Optional calling context of pureFn
     * @return {?} Updated or cached value
     *
     */


    function ɵɵpureFunction7(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, thisArg) {
      // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings

      /** @type {?} */
      const bindingIndex = getBindingRoot() + slotOffset;
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      let different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
      return bindingUpdated3(lView, bindingIndex + 4, exp5, exp6, exp7) || different ? updateBinding(lView, bindingIndex + 7, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7)) : getBinding(lView, bindingIndex + 7);
    }
    /**
     * If the value of any provided exp has changed, calls the pure function to return
     * an updated value. Or if no values have changed, returns cached value.
     *
     * \@codeGenApi
     * @param {?} slotOffset the offset from binding root to the reserved slot
     * @param {?} pureFn
     * @param {?} exp1
     * @param {?} exp2
     * @param {?} exp3
     * @param {?} exp4
     * @param {?} exp5
     * @param {?} exp6
     * @param {?} exp7
     * @param {?} exp8
     * @param {?=} thisArg Optional calling context of pureFn
     * @return {?} Updated or cached value
     *
     */


    function ɵɵpureFunction8(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, thisArg) {
      // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings

      /** @type {?} */
      const bindingIndex = getBindingRoot() + slotOffset;
      /** @type {?} */

      const lView = getLView();
      /** @type {?} */

      const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);
      return bindingUpdated4(lView, bindingIndex + 4, exp5, exp6, exp7, exp8) || different ? updateBinding(lView, bindingIndex + 8, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)) : getBinding(lView, bindingIndex + 8);
    }
    /**
     * pureFunction instruction that can support any number of bindings.
     *
     * If the value of any provided exp has changed, calls the pure function to return
     * an updated value. Or if no values have changed, returns cached value.
     *
     * \@codeGenApi
     * @param {?} slotOffset the offset from binding root to the reserved slot
     * @param {?} pureFn A pure function that takes binding values and builds an object or array
     * containing those values.
     * @param {?} exps An array of binding values
     * @param {?=} thisArg Optional calling context of pureFn
     * @return {?} Updated or cached value
     *
     */


    function ɵɵpureFunctionV(slotOffset, pureFn, exps, thisArg) {
      // TODO(kara): use bindingRoot instead of bindingStartIndex when implementing host bindings

      /** @type {?} */
      let bindingIndex = getBindingRoot() + slotOffset;
      /** @type {?} */

      let different = false;
      /** @type {?} */

      const lView = getLView();

      for (let i = 0; i < exps.length; i++) {
        bindingUpdated(lView, bindingIndex++, exps[i]) && (different = true);
      }

      return different ? updateBinding(lView, bindingIndex, pureFn.apply(thisArg, exps)) : getBinding(lView, bindingIndex);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Create a pipe.
     *
     * \@codeGenApi
     * @param {?} index Pipe index where the pipe will be stored.
     * @param {?} pipeName The name of the pipe
     * @return {?} T the instance of the pipe.
     *
     */


    function ɵɵpipe(index, pipeName) {
      /** @type {?} */
      const tView = getLView()[TVIEW];
      /** @type {?} */

      let pipeDef;
      /** @type {?} */

      const adjustedIndex = index + HEADER_OFFSET;

      if (tView.firstTemplatePass) {
        pipeDef = getPipeDef$1(pipeName, tView.pipeRegistry);
        tView.data[adjustedIndex] = pipeDef;

        if (pipeDef.onDestroy) {
          (tView.destroyHooks || (tView.destroyHooks = [])).push(adjustedIndex, pipeDef.onDestroy);
        }
      } else {
        pipeDef =
        /** @type {?} */
        tView.data[adjustedIndex];
      }
      /** @type {?} */


      const pipeInstance = pipeDef.factory();
      store(index, pipeInstance);
      return pipeInstance;
    }
    /**
     * Searches the pipe registry for a pipe with the given name. If one is found,
     * returns the pipe. Otherwise, an error is thrown because the pipe cannot be resolved.
     *
     * \@publicApi
     * @param {?} name Name of pipe to resolve
     * @param {?} registry Full list of available pipes
     * @return {?} Matching PipeDef
     *
     */


    function getPipeDef$1(name, registry) {
      if (registry) {
        for (let i = registry.length - 1; i >= 0; i--) {
          /** @type {?} */
          const pipeDef = registry[i];

          if (name === pipeDef.name) {
            return pipeDef;
          }
        }
      }

      throw new Error("The pipe '".concat(name, "' could not be found!"));
    }
    /**
     * Invokes a pipe with 1 arguments.
     *
     * This instruction acts as a guard to {\@link PipeTransform#transform} invoking
     * the pipe only when an input to the pipe changes.
     *
     * \@codeGenApi
     * @param {?} index Pipe index where the pipe was stored on creation.
     * @param {?} slotOffset the offset in the reserved slot space
     * @param {?} v1 1st argument to {\@link PipeTransform#transform}.
     *
     * @return {?}
     */


    function ɵɵpipeBind1(index, slotOffset, v1) {
      /** @type {?} */
      const pipeInstance = ɵɵload(index);
      return unwrapValue$1(isPure(index) ? ɵɵpureFunction1(slotOffset, pipeInstance.transform, v1, pipeInstance) : pipeInstance.transform(v1));
    }
    /**
     * Invokes a pipe with 2 arguments.
     *
     * This instruction acts as a guard to {\@link PipeTransform#transform} invoking
     * the pipe only when an input to the pipe changes.
     *
     * \@codeGenApi
     * @param {?} index Pipe index where the pipe was stored on creation.
     * @param {?} slotOffset the offset in the reserved slot space
     * @param {?} v1 1st argument to {\@link PipeTransform#transform}.
     * @param {?} v2 2nd argument to {\@link PipeTransform#transform}.
     *
     * @return {?}
     */


    function ɵɵpipeBind2(index, slotOffset, v1, v2) {
      /** @type {?} */
      const pipeInstance = ɵɵload(index);
      return unwrapValue$1(isPure(index) ? ɵɵpureFunction2(slotOffset, pipeInstance.transform, v1, v2, pipeInstance) : pipeInstance.transform(v1, v2));
    }
    /**
     * Invokes a pipe with 3 arguments.
     *
     * This instruction acts as a guard to {\@link PipeTransform#transform} invoking
     * the pipe only when an input to the pipe changes.
     *
     * \@codeGenApi
     * @param {?} index Pipe index where the pipe was stored on creation.
     * @param {?} slotOffset the offset in the reserved slot space
     * @param {?} v1 1st argument to {\@link PipeTransform#transform}.
     * @param {?} v2 2nd argument to {\@link PipeTransform#transform}.
     * @param {?} v3 4rd argument to {\@link PipeTransform#transform}.
     *
     * @return {?}
     */


    function ɵɵpipeBind3(index, slotOffset, v1, v2, v3) {
      /** @type {?} */
      const pipeInstance = ɵɵload(index);
      return unwrapValue$1(isPure(index) ? ɵɵpureFunction3(slotOffset, pipeInstance.transform, v1, v2, v3, pipeInstance) : pipeInstance.transform(v1, v2, v3));
    }
    /**
     * Invokes a pipe with 4 arguments.
     *
     * This instruction acts as a guard to {\@link PipeTransform#transform} invoking
     * the pipe only when an input to the pipe changes.
     *
     * \@codeGenApi
     * @param {?} index Pipe index where the pipe was stored on creation.
     * @param {?} slotOffset the offset in the reserved slot space
     * @param {?} v1 1st argument to {\@link PipeTransform#transform}.
     * @param {?} v2 2nd argument to {\@link PipeTransform#transform}.
     * @param {?} v3 3rd argument to {\@link PipeTransform#transform}.
     * @param {?} v4 4th argument to {\@link PipeTransform#transform}.
     *
     * @return {?}
     */


    function ɵɵpipeBind4(index, slotOffset, v1, v2, v3, v4) {
      /** @type {?} */
      const pipeInstance = ɵɵload(index);
      return unwrapValue$1(isPure(index) ? ɵɵpureFunction4(slotOffset, pipeInstance.transform, v1, v2, v3, v4, pipeInstance) : pipeInstance.transform(v1, v2, v3, v4));
    }
    /**
     * Invokes a pipe with variable number of arguments.
     *
     * This instruction acts as a guard to {\@link PipeTransform#transform} invoking
     * the pipe only when an input to the pipe changes.
     *
     * \@codeGenApi
     * @param {?} index Pipe index where the pipe was stored on creation.
     * @param {?} slotOffset the offset in the reserved slot space
     * @param {?} values Array of arguments to pass to {\@link PipeTransform#transform} method.
     *
     * @return {?}
     */


    function ɵɵpipeBindV(index, slotOffset, values) {
      /** @type {?} */
      const pipeInstance = ɵɵload(index);
      return unwrapValue$1(isPure(index) ? ɵɵpureFunctionV(slotOffset, pipeInstance.transform, values, pipeInstance) : pipeInstance.transform.apply(pipeInstance, values));
    }
    /**
     * @param {?} index
     * @return {?}
     */


    function isPure(index) {
      return (
        /** @type {?} */
        getLView()[TVIEW].data[index + HEADER_OFFSET].pure
      );
    }
    /**
     * Unwrap the output of a pipe transformation.
     * In order to trick change detection into considering that the new value is always different from
     * the old one, the old value is overwritten by NO_CHANGE.
     *
     * @param {?} newValue the pipe transformation output.
     * @return {?}
     */


    function unwrapValue$1(newValue) {
      if (WrappedValue.isWrapped(newValue)) {
        newValue = WrappedValue.unwrap(newValue);
        /** @type {?} */

        const lView = getLView(); // The NO_CHANGE value needs to be written at the index where the impacted binding value is
        // stored

        /** @type {?} */

        const bindingToInvalidateIdx = lView[BINDING_INDEX];
        lView[bindingToInvalidateIdx] = NO_CHANGE;
      }

      return newValue;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Use in components with the `\@Output` directive to emit custom events
     * synchronously or asynchronously, and register handlers for those events
     * by subscribing to an instance.
     *
     * \@usageNotes
     *
     * Extends
     * [RxJS `Subject`](https://rxjs.dev/api/index/class/Subject)
     * for Angular by adding the `emit()` method.
     *
     * In the following example, a component defines two output properties
     * that create event emitters. When the title is clicked, the emitter
     * emits an open or close event to toggle the current visibility state.
     *
     * ```html
     * \@Component({
     *   selector: 'zippy',
     *   template: `
     *   <div class="zippy">
     *     <div (click)="toggle()">Toggle</div>
     *     <div [hidden]="!visible">
     *       <ng-content></ng-content>
     *     </div>
     *  </div>`})
     * export class Zippy {
     *   visible: boolean = true;
     * \@Output() open: EventEmitter<any> = new EventEmitter();
     * \@Output() close: EventEmitter<any> = new EventEmitter();
     *
     *   toggle() {
     *     this.visible = !this.visible;
     *     if (this.visible) {
     *       this.open.emit(null);
     *     } else {
     *       this.close.emit(null);
     *     }
     *   }
     * }
     * ```
     *
     * Access the event object with the `$event` argument passed to the output event
     * handler:
     *
     * ```html
     * <zippy (open)="onOpen($event)" (close)="onClose($event)"></zippy>
     * ```
     *
     * @see [Observables in Angular](guide/observables-in-angular)
     * \@publicApi
     * @template T
     */


    class EventEmitter extends rxjs__WEBPACK_IMPORTED_MODULE_0__["Subject"] {
      // tslint:disable-line

      /**
       * Creates an instance of this class that can
       * deliver events synchronously or asynchronously.
       *
       * @param {?=} isAsync When true, deliver events asynchronously.
       *
       */
      constructor(isAsync = false) {
        super();
        this.__isAsync = isAsync;
      }
      /**
       * Emits an event containing a given value.
       * @param {?=} value The value to emit.
       * @return {?}
       */


      emit(value) {
        super.next(value);
      }
      /**
       * Registers handlers for events emitted by this instance.
       * @param {?=} generatorOrNext When supplied, a custom handler for emitted events.
       * @param {?=} error When supplied, a custom handler for an error notification
       * from this emitter.
       * @param {?=} complete When supplied, a custom handler for a completion
       * notification from this emitter.
       * @return {?}
       */


      subscribe(generatorOrNext, error, complete) {
        /** @type {?} */
        let schedulerFn;
        /** @type {?} */

        let errorFn =
        /**
        * @param {?} err
        * @return {?}
        */
        err => null;
        /** @type {?} */


        let completeFn =
        /**
        * @return {?}
        */
        () => null;

        if (generatorOrNext && typeof generatorOrNext === 'object') {
          schedulerFn = this.__isAsync ?
          /**
          * @param {?} value
          * @return {?}
          */
          value => {
            setTimeout(
            /**
            * @return {?}
            */
            () => generatorOrNext.next(value));
          } :
          /**
          * @param {?} value
          * @return {?}
          */
          value => {
            generatorOrNext.next(value);
          };

          if (generatorOrNext.error) {
            errorFn = this.__isAsync ?
            /**
            * @param {?} err
            * @return {?}
            */
            err => {
              setTimeout(
              /**
              * @return {?}
              */
              () => generatorOrNext.error(err));
            } :
            /**
            * @param {?} err
            * @return {?}
            */
            err => {
              generatorOrNext.error(err);
            };
          }

          if (generatorOrNext.complete) {
            completeFn = this.__isAsync ?
            /**
            * @return {?}
            */
            () => {
              setTimeout(
              /**
              * @return {?}
              */
              () => generatorOrNext.complete());
            } :
            /**
            * @return {?}
            */
            () => {
              generatorOrNext.complete();
            };
          }
        } else {
          schedulerFn = this.__isAsync ?
          /**
          * @param {?} value
          * @return {?}
          */
          value => {
            setTimeout(
            /**
            * @return {?}
            */
            () => generatorOrNext(value));
          } :
          /**
          * @param {?} value
          * @return {?}
          */
          value => {
            generatorOrNext(value);
          };

          if (error) {
            errorFn = this.__isAsync ?
            /**
            * @param {?} err
            * @return {?}
            */
            err => {
              setTimeout(
              /**
              * @return {?}
              */
              () => error(err));
            } :
            /**
            * @param {?} err
            * @return {?}
            */
            err => {
              error(err);
            };
          }

          if (complete) {
            completeFn = this.__isAsync ?
            /**
            * @return {?}
            */
            () => {
              setTimeout(
              /**
              * @return {?}
              */
              () => complete());
            } :
            /**
            * @return {?}
            */
            () => {
              complete();
            };
          }
        }
        /** @type {?} */


        const sink = super.subscribe(schedulerFn, errorFn, completeFn);

        if (generatorOrNext instanceof rxjs__WEBPACK_IMPORTED_MODULE_0__["Subscription"]) {
          generatorOrNext.add(sink);
        }

        return sink;
      }

    }

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @template T
     * @this {?}
     * @return {?}
     */


    function symbolIterator() {
      return (
        /** @type {?} */

        /** @type {?} */

        /** @type {?} */
        this._results[getSymbolIterator()]()
      );
    }
    /**
     * An unmodifiable list of items that Angular keeps up to date when the state
     * of the application changes.
     *
     * The type of object that {\@link ViewChildren}, {\@link ContentChildren}, and {\@link QueryList}
     * provide.
     *
     * Implements an iterable interface, therefore it can be used in both ES6
     * javascript `for (var i of items)` loops as well as in Angular templates with
     * `*ngFor="let i of myList"`.
     *
     * Changes can be observed by subscribing to the changes `Observable`.
     *
     * NOTE: In the future this class will implement an `Observable` interface.
     *
     * \@usageNotes
     * ### Example
     * ```typescript
     * \@Component({...})
     * class Container {
     * \@ViewChildren(Item) items:QueryList<Item>;
     * }
     * ```
     *
     * \@publicApi
     * @template T
     */


    class QueryList {
      constructor() {
        this.dirty = true;
        this._results = [];
        this.changes = new EventEmitter();
        this.length = 0; // This function should be declared on the prototype, but doing so there will cause the class
        // declaration to have side-effects and become not tree-shakable. For this reason we do it in
        // the constructor.
        // [getSymbolIterator()](): Iterator<T> { ... }

        /** @type {?} */

        const symbol = getSymbolIterator();
        /** @type {?} */

        const proto =
        /** @type {?} */
        QueryList.prototype;
        if (!proto[symbol]) proto[symbol] = symbolIterator;
      }
      /**
       * See
       * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
       * @template U
       * @param {?} fn
       * @return {?}
       */


      map(fn) {
        return this._results.map(fn);
      }
      /**
       * See
       * [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)
       * @param {?} fn
       * @return {?}
       */


      filter(fn) {
        return this._results.filter(fn);
      }
      /**
       * See
       * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)
       * @param {?} fn
       * @return {?}
       */


      find(fn) {
        return this._results.find(fn);
      }
      /**
       * See
       * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)
       * @template U
       * @param {?} fn
       * @param {?} init
       * @return {?}
       */


      reduce(fn, init) {
        return this._results.reduce(fn, init);
      }
      /**
       * See
       * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
       * @param {?} fn
       * @return {?}
       */


      forEach(fn) {
        this._results.forEach(fn);
      }
      /**
       * See
       * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)
       * @param {?} fn
       * @return {?}
       */


      some(fn) {
        return this._results.some(fn);
      }
      /**
       * Returns a copy of the internal results list as an Array.
       * @return {?}
       */


      toArray() {
        return this._results.slice();
      }
      /**
       * @return {?}
       */


      toString() {
        return this._results.toString();
      }
      /**
       * Updates the stored data of the query list, and resets the `dirty` flag to `false`, so that
       * on change detection, it will not notify of changes to the queries, unless a new change
       * occurs.
       *
       * @param {?} resultsTree The query results to store
       * @return {?}
       */


      reset(resultsTree) {
        this._results = flatten(resultsTree);

        /** @type {?} */
        this.dirty = false;

        /** @type {?} */
        this.length = this._results.length;

        /** @type {?} */
        this.last = this._results[this.length - 1];

        /** @type {?} */
        this.first = this._results[0];
      }
      /**
       * Triggers a change event by emitting on the `changes` {\@link EventEmitter}.
       * @return {?}
       */


      notifyOnChanges() {
        /** @type {?} */
        this.changes.emit(this);
      }
      /**
       * internal
       * @return {?}
       */


      setDirty() {
        /** @type {?} */
        this.dirty = true;
      }
      /**
       * internal
       * @return {?}
       */


      destroy() {
        /** @type {?} */
        this.changes.complete();

        /** @type {?} */
        this.changes.unsubscribe();
      }

    }

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /** @enum {number} */


    const RenderFlags = {
      /* Whether to run the creation block (e.g. create elements and directives) */
      Create: 1,

      /* Whether to run the update block (e.g. refresh bindings) */
      Update: 2
    };
    /**
     * A subclass of `Type` which has a static `ngComponentDef`:`ComponentDef` field making it
     * consumable for rendering.
     * @record
     * @template T
     */

    function ComponentType() {}

    if (false) {}
    /**
     * A subclass of `Type` which has a static `ngDirectiveDef`:`DirectiveDef` field making it
     * consumable for rendering.
     * @record
     * @template T
     */


    function DirectiveType() {}

    if (false) {}
    /** @enum {number} */


    const DirectiveDefFlags = {
      ContentQuery: 2
    };
    /**
     * A subclass of `Type` which has a static `ngPipeDef`:`PipeDef` field making it
     * consumable for rendering.
     * @record
     * @template T
     */

    function PipeType() {}

    if (false) {}
    /**
     * Runtime information for classes that are inherited by components or directives
     * that aren't defined as components or directives.
     *
     * This is an internal data structure used by the renderer to determine what inputs
     * and outputs should be inherited.
     *
     * See: {\@link defineBase}
     *
     * \@codeGenApi
     * @record
     * @template T
     */


    function ɵɵBaseDef() {}

    if (false) {}
    /**
     * Runtime link information for Directives.
     *
     * This is internal data structure used by the render to link
     * directives into templates.
     *
     * NOTE: Always use `defineDirective` function to create this object,
     * never create the object directly since the shape of this object
     * can change between versions.
     *
     * @param Selector type metadata specifying the selector of the directive or component
     *
     * See: {\@link defineDirective}
     * @record
     * @template T
     */


    function DirectiveDef() {}

    if (false) {}
    /**
     * Runtime link information for Components.
     *
     * This is internal data structure used by the render to link
     * components into templates.
     *
     * NOTE: Always use `defineComponent` function to create this object,
     * never create the object directly since the shape of this object
     * can change between versions.
     *
     * See: {\@link defineComponent}
     * @record
     * @template T
     */


    function ComponentDef() {}

    if (false) {}
    /**
     * Runtime link information for Pipes.
     *
     * This is internal data structure used by the renderer to link
     * pipes into templates.
     *
     * NOTE: Always use `definePipe` function to create this object,
     * never create the object directly since the shape of this object
     * can change between versions.
     *
     * See: {\@link definePipe}
     * @record
     * @template T
     */


    function PipeDef() {}

    if (false) {}
    /**
     * @record
     */


    function DirectiveDefFeature() {}

    if (false) {}
    /**
     * @record
     */


    function ComponentDefFeature() {}

    if (false) {} // Note: This hack is necessary so we don't erroneously get a circular dependency
    // failure based on types.

    /** @type {?} */


    const unusedValueExportToPlacateAjd$7 = 1;
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * An object representing query metadata extracted from query annotations.
     * @record
     */

    function TQueryMetadata() {}

    if (false) {}
    /**
     * TQuery objects represent all the query-related data that remain the same from one view instance
     * to another and can be determined on the very first template pass. Most notably TQuery holds all
     * the matches for a given view.
     * @record
     */


    function TQuery() {}

    if (false) {}
    /**
     * TQueries represent a collection of individual TQuery objects tracked in a given view. Most of the
     * methods on this interface are simple proxy methods to the corresponding functionality on TQuery.
     * @record
     */


    function TQueries() {}

    if (false) {}
    /**
     * An interface that represents query-related information specific to a view instance. Most notably
     * it contains:
     * - materialized query matches;
     * - a pointer to a QueryList where materialized query results should be reported.
     * @record
     * @template T
     */


    function LQuery() {}

    if (false) {}
    /**
     * lQueries represent a collection of individual LQuery objects tracked in a given view.
     * @record
     */


    function LQueries() {}

    if (false) {} // Note: This hack is necessary so we don't erroneously get a circular dependency
    // failure based on types.

    /** @type {?} */


    const unusedValueExportToPlacateAjd$8 = 1;
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    const unusedValueToPlacateAjd$2 = unusedValueExportToPlacateAjd$7 + unusedValueExportToPlacateAjd$2 + unusedValueExportToPlacateAjd$4 + unusedValueExportToPlacateAjd$8;
    /**
     * @template T
     */

    class LQuery_ {
      /**
       * @param {?} queryList
       */
      constructor(queryList) {
        this.queryList = queryList;
        this.matches = null;
      }
      /**
       * @return {?}
       */


      clone() {
        return new LQuery_(this.queryList);
      }
      /**
       * @return {?}
       */


      setDirty() {
        this.queryList.setDirty();
      }

    }

    if (false) {}

    class LQueries_ {
      /**
       * @param {?=} queries
       */
      constructor(queries = []) {
        this.queries = queries;
      }
      /**
       * @param {?} tView
       * @return {?}
       */


      createEmbeddedView(tView) {
        /** @type {?} */
        const tQueries = tView.queries;

        if (tQueries !== null) {
          /** @type {?} */
          const noOfInheritedQueries = tView.contentQueries !== null ? tView.contentQueries[0] : tQueries.length;
          /** @type {?} */

          const viewLQueries = new Array(noOfInheritedQueries); // An embedded view has queries propagated from a declaration view at the beginning of the
          // TQueries collection and up until a first content query declared in the embedded view. Only
          // propagated LQueries are created at this point (LQuery corresponding to declared content
          // queries will be instantiated from the content query instructions for each directive).

          for (let i = 0; i < noOfInheritedQueries; i++) {
            /** @type {?} */
            const tQuery = tQueries.getByIndex(i);
            /** @type {?} */

            const parentLQuery = this.queries[tQuery.indexInDeclarationView];
            viewLQueries[i] = parentLQuery.clone();
          }

          return new LQueries_(viewLQueries);
        }

        return null;
      }
      /**
       * @param {?} tView
       * @return {?}
       */


      insertView(tView) {
        this.dirtyQueriesWithMatches(tView);
      }
      /**
       * @param {?} tView
       * @return {?}
       */


      detachView(tView) {
        this.dirtyQueriesWithMatches(tView);
      }
      /**
       * @private
       * @param {?} tView
       * @return {?}
       */


      dirtyQueriesWithMatches(tView) {
        for (let i = 0; i < this.queries.length; i++) {
          if (getTQuery(tView, i).matches !== null) {
            this.queries[i].setDirty();
          }
        }
      }

    }

    if (false) {}

    class TQueryMetadata_ {
      /**
       * @param {?} predicate
       * @param {?} descendants
       * @param {?} isStatic
       * @param {?=} read
       */
      constructor(predicate, descendants, isStatic, read = null) {
        this.predicate = predicate;
        this.descendants = descendants;
        this.isStatic = isStatic;
        this.read = read;
      }

    }

    if (false) {}

    class TQueries_ {
      /**
       * @param {?=} queries
       */
      constructor(queries = []) {
        this.queries = queries;
      }
      /**
       * @param {?} tView
       * @param {?} tNode
       * @return {?}
       */


      elementStart(tView, tNode) {
        ngDevMode && assertFirstTemplatePass(tView, 'Queries should collect results on the first template pass only');

        for (let query of this.queries) {
          query.elementStart(tView, tNode);
        }
      }
      /**
       * @param {?} tNode
       * @return {?}
       */


      elementEnd(tNode) {
        for (let query of this.queries) {
          query.elementEnd(tNode);
        }
      }
      /**
       * @param {?} tNode
       * @return {?}
       */


      embeddedTView(tNode) {
        /** @type {?} */
        let queriesForTemplateRef = null;

        for (let i = 0; i < this.length; i++) {
          /** @type {?} */
          const childQueryIndex = queriesForTemplateRef !== null ? queriesForTemplateRef.length : 0;
          /** @type {?} */

          const tqueryClone = this.getByIndex(i).embeddedTView(tNode, childQueryIndex);

          if (tqueryClone) {
            tqueryClone.indexInDeclarationView = i;

            if (queriesForTemplateRef !== null) {
              queriesForTemplateRef.push(tqueryClone);
            } else {
              queriesForTemplateRef = [tqueryClone];
            }
          }
        }

        return queriesForTemplateRef !== null ? new TQueries_(queriesForTemplateRef) : null;
      }
      /**
       * @param {?} tView
       * @param {?} tNode
       * @return {?}
       */


      template(tView, tNode) {
        ngDevMode && assertFirstTemplatePass(tView, 'Queries should collect results on the first template pass only');

        for (let query of this.queries) {
          query.template(tView, tNode);
        }
      }
      /**
       * @param {?} index
       * @return {?}
       */


      getByIndex(index) {
        ngDevMode && assertDataInRange(this.queries, index);
        return this.queries[index];
      }
      /**
       * @return {?}
       */


      get length() {
        return this.queries.length;
      }
      /**
       * @param {?} tquery
       * @return {?}
       */


      track(tquery) {
        this.queries.push(tquery);
      }

    }

    if (false) {}

    class TQuery_ {
      /**
       * @param {?} metadata
       * @param {?=} nodeIndex
       */
      constructor(metadata, nodeIndex = -1) {
        this.metadata = metadata;
        this.matches = null;
        this.indexInDeclarationView = -1;
        this.crossesNgTemplate = false;
        /**
         * A flag indicating if a given query still applies to nodes it is crossing. We use this flag
         * (alongside with _declarationNodeIndex) to know when to stop applying content queries to
         * elements in a template.
         */

        this._appliesToNextNode = true;
        this._declarationNodeIndex = nodeIndex;
      }
      /**
       * @param {?} tView
       * @param {?} tNode
       * @return {?}
       */


      elementStart(tView, tNode) {
        if (this.isApplyingToNode(tNode)) {
          this.matchTNode(tView, tNode);
        }
      }
      /**
       * @param {?} tNode
       * @return {?}
       */


      elementEnd(tNode) {
        if (this._declarationNodeIndex === tNode.index) {
          this._appliesToNextNode = false;
        }
      }
      /**
       * @param {?} tView
       * @param {?} tNode
       * @return {?}
       */


      template(tView, tNode) {
        this.elementStart(tView, tNode);
      }
      /**
       * @param {?} tNode
       * @param {?} childQueryIndex
       * @return {?}
       */


      embeddedTView(tNode, childQueryIndex) {
        if (this.isApplyingToNode(tNode)) {
          this.crossesNgTemplate = true; // A marker indicating a `<ng-template>` element (a placeholder for query results from
          // embedded views created based on this `<ng-template>`).

          this.addMatch(-tNode.index, childQueryIndex);
          return new TQuery_(this.metadata);
        }

        return null;
      }
      /**
       * @private
       * @param {?} tNode
       * @return {?}
       */


      isApplyingToNode(tNode) {
        if (this._appliesToNextNode && this.metadata.descendants === false) {
          return this._declarationNodeIndex === (tNode.parent ? tNode.parent.index : -1);
        }

        return this._appliesToNextNode;
      }
      /**
       * @private
       * @param {?} tView
       * @param {?} tNode
       * @return {?}
       */


      matchTNode(tView, tNode) {
        if (Array.isArray(this.metadata.predicate)) {
          /** @type {?} */
          const localNames =
          /** @type {?} */
          this.metadata.predicate;

          for (let i = 0; i < localNames.length; i++) {
            this.matchTNodeWithReadOption(tView, tNode, getIdxOfMatchingSelector(tNode, localNames[i]));
          }
        } else {
          /** @type {?} */
          const typePredicate =
          /** @type {?} */
          this.metadata.predicate;

          if (typePredicate === TemplateRef) {
            if (tNode.type === 0
            /* Container */
            ) {
                this.matchTNodeWithReadOption(tView, tNode, -1);
              }
          } else {
            this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, typePredicate, false, false));
          }
        }
      }
      /**
       * @private
       * @param {?} tView
       * @param {?} tNode
       * @param {?} nodeMatchIdx
       * @return {?}
       */


      matchTNodeWithReadOption(tView, tNode, nodeMatchIdx) {
        if (nodeMatchIdx !== null) {
          /** @type {?} */
          const read = this.metadata.read;

          if (read !== null) {
            if (read === ElementRef || read === ViewContainerRef || read === TemplateRef && tNode.type === 0
            /* Container */
            ) {
                this.addMatch(tNode.index, -2);
              } else {
              /** @type {?} */
              const directiveOrProviderIdx = locateDirectiveOrProvider(tNode, tView, read, false, false);

              if (directiveOrProviderIdx !== null) {
                this.addMatch(tNode.index, directiveOrProviderIdx);
              }
            }
          } else {
            this.addMatch(tNode.index, nodeMatchIdx);
          }
        }
      }
      /**
       * @private
       * @param {?} tNodeIdx
       * @param {?} matchIdx
       * @return {?}
       */


      addMatch(tNodeIdx, matchIdx) {
        if (this.matches === null) {
          this.matches = [tNodeIdx, matchIdx];
        } else {
          this.matches.push(tNodeIdx, matchIdx);
        }
      }

    }

    if (false) {}
    /**
     * Iterates over local names for a given node and returns directive index
     * (or -1 if a local name points to an element).
     *
     * @param {?} tNode static data of a node to check
     * @param {?} selector selector to match
     * @return {?} directive index, -1 or null if a selector didn't match any of the local names
     */


    function getIdxOfMatchingSelector(tNode, selector) {
      /** @type {?} */
      const localNames = tNode.localNames;

      if (localNames !== null) {
        for (let i = 0; i < localNames.length; i += 2) {
          if (localNames[i] === selector) {
            return (
              /** @type {?} */
              localNames[i + 1]
            );
          }
        }
      }

      return null;
    }
    /**
     * @param {?} tNode
     * @param {?} currentView
     * @return {?}
     */


    function createResultByTNodeType(tNode, currentView) {
      if (tNode.type === 3
      /* Element */
      || tNode.type === 4
      /* ElementContainer */
      ) {
          return createElementRef(ElementRef, tNode, currentView);
        } else if (tNode.type === 0
      /* Container */
      ) {
          return createTemplateRef(TemplateRef, ElementRef, tNode, currentView);
        }

      return null;
    }
    /**
     * @param {?} lView
     * @param {?} tNode
     * @param {?} matchingIdx
     * @param {?} read
     * @return {?}
     */


    function createResultForNode(lView, tNode, matchingIdx, read) {
      if (matchingIdx === -1) {
        // if read token and / or strategy is not specified, detect it using appropriate tNode type
        return createResultByTNodeType(tNode, lView);
      } else if (matchingIdx === -2) {
        // read a special token from a node injector
        return createSpecialToken(lView, tNode, read);
      } else {
        // read a token
        return getNodeInjectable(lView[TVIEW].data, lView, matchingIdx,
        /** @type {?} */
        tNode);
      }
    }
    /**
     * @param {?} lView
     * @param {?} tNode
     * @param {?} read
     * @return {?}
     */


    function createSpecialToken(lView, tNode, read) {
      if (read === ElementRef) {
        return createElementRef(ElementRef, tNode, lView);
      } else if (read === TemplateRef) {
        return createTemplateRef(TemplateRef, ElementRef, tNode, lView);
      } else if (read === ViewContainerRef) {
        ngDevMode && assertNodeOfPossibleTypes(tNode, 3
        /* Element */
        , 0
        /* Container */
        , 4
        /* ElementContainer */
        );
        return createContainerRef(ViewContainerRef, ElementRef,
        /** @type {?} */
        tNode, lView);
      } else {
        ngDevMode && throwError("Special token to read should be one of ElementRef, TemplateRef or ViewContainerRef but got ".concat(stringify(read), "."));
      }
    }
    /**
     * A helper function that creates query results for a given view. This function is meant to do the
     * processing once and only once for a given view instance (a set of results for a given view
     * doesn't change).
     * @template T
     * @param {?} lView
     * @param {?} tQuery
     * @param {?} queryIndex
     * @return {?}
     */


    function materializeViewResults(lView, tQuery, queryIndex) {
      /** @type {?} */
      const lQuery =
      /** @type {?} */

      /** @type {?} */
      lView[QUERIES].queries[queryIndex];

      if (lQuery.matches === null) {
        /** @type {?} */
        const tViewData = lView[TVIEW].data;
        /** @type {?} */

        const tQueryMatches =
        /** @type {?} */
        tQuery.matches;
        /** @type {?} */

        const result = new Array(tQueryMatches.length / 2);

        for (let i = 0; i < tQueryMatches.length; i += 2) {
          /** @type {?} */
          const matchedNodeIdx = tQueryMatches[i];

          if (matchedNodeIdx < 0) {
            // we at the <ng-template> marker which might have results in views created based on this
            // <ng-template> - those results will be in separate views though, so here we just leave
            // null as a placeholder
            result[i / 2] = null;
          } else {
            ngDevMode && assertDataInRange(tViewData, matchedNodeIdx);
            /** @type {?} */

            const tNode =
            /** @type {?} */
            tViewData[matchedNodeIdx];
            result[i / 2] = createResultForNode(lView, tNode, tQueryMatches[i + 1], tQuery.metadata.read);
          }
        }

        lQuery.matches = result;
      }

      return lQuery.matches;
    }
    /**
     * A helper function that collects (already materialized) query results from a tree of views,
     * starting with a provided LView.
     * @template T
     * @param {?} lView
     * @param {?} queryIndex
     * @param {?} result
     * @return {?}
     */


    function collectQueryResults(lView, queryIndex, result) {
      /** @type {?} */
      const tQuery =
      /** @type {?} */
      lView[TVIEW].queries.getByIndex(queryIndex);
      /** @type {?} */

      const tQueryMatches = tQuery.matches;

      if (tQueryMatches !== null) {
        /** @type {?} */
        const lViewResults = materializeViewResults(lView, tQuery, queryIndex);

        for (let i = 0; i < tQueryMatches.length; i += 2) {
          /** @type {?} */
          const tNodeIdx = tQueryMatches[i];

          if (tNodeIdx > 0) {
            /** @type {?} */
            const viewResult = lViewResults[i / 2];
            ngDevMode && assertDefined(viewResult, 'materialized query result should be defined');
            result.push(
            /** @type {?} */
            viewResult);
          } else {
            /** @type {?} */
            const childQueryIndex = tQueryMatches[i + 1];
            /** @type {?} */

            const declarationLContainer =
            /** @type {?} */
            lView[-tNodeIdx];
            ngDevMode && assertLContainer(declarationLContainer); // collect matches for views inserted in this container

            for (let i = CONTAINER_HEADER_OFFSET; i < declarationLContainer.length; i++) {
              /** @type {?} */
              const embeddedLView = declarationLContainer[i];

              if (embeddedLView[DECLARATION_LCONTAINER] === embeddedLView[PARENT]) {
                collectQueryResults(embeddedLView, childQueryIndex, result);
              }
            } // collect matches for views created from this declaration container and inserted into
            // different containers


            if (declarationLContainer[MOVED_VIEWS] !== null) {
              for (let embeddedLView of
              /** @type {?} */
              declarationLContainer[MOVED_VIEWS]) {
                collectQueryResults(embeddedLView, childQueryIndex, result);
              }
            }
          }
        }
      }

      return result;
    }
    /**
     * Refreshes a query by combining matches from all active views and removing matches from deleted
     * views.
     *
     * \@codeGenApi
     * @param {?} queryList
     * @return {?} `true` if a query got dirty during change detection or if this is a static query
     * resolving in creation mode, `false` otherwise.
     *
     */


    function ɵɵqueryRefresh(queryList) {
      /** @type {?} */
      const lView = getLView();
      /** @type {?} */

      const queryIndex = getCurrentQueryIndex();
      setCurrentQueryIndex(queryIndex + 1);
      /** @type {?} */

      const tQuery = getTQuery(lView[TVIEW], queryIndex);

      if (queryList.dirty && isCreationMode() === tQuery.metadata.isStatic) {
        if (tQuery.matches === null) {
          queryList.reset([]);
        } else {
          /** @type {?} */
          const result = tQuery.crossesNgTemplate ? collectQueryResults(lView, queryIndex, []) : materializeViewResults(lView, tQuery, queryIndex);
          queryList.reset(result);
          queryList.notifyOnChanges();
        }

        return true;
      }

      return false;
    }
    /**
     * Creates new QueryList for a static view query.
     *
     * \@codeGenApi
     * @template T
     * @param {?} predicate The type for which the query will search
     * @param {?} descend Whether or not to descend into children
     * @param {?=} read What to save in the query
     *
     * @return {?}
     */


    function ɵɵstaticViewQuery(predicate, descend, read) {
      viewQueryInternal(getLView(), predicate, descend, read, true);
    }
    /**
     * Creates new QueryList, stores the reference in LView and returns QueryList.
     *
     * \@codeGenApi
     * @template T
     * @param {?} predicate The type for which the query will search
     * @param {?} descend Whether or not to descend into children
     * @param {?=} read What to save in the query
     *
     * @return {?}
     */


    function ɵɵviewQuery(predicate, descend, read) {
      viewQueryInternal(getLView(), predicate, descend, read, false);
    }
    /**
     * @template T
     * @param {?} lView
     * @param {?} predicate
     * @param {?} descend
     * @param {?} read
     * @param {?} isStatic
     * @return {?}
     */


    function viewQueryInternal(lView, predicate, descend, read, isStatic) {
      /** @type {?} */
      const tView = lView[TVIEW];

      if (tView.firstTemplatePass) {
        createTQuery(tView, new TQueryMetadata_(predicate, descend, isStatic, read), -1);

        if (isStatic) {
          tView.staticViewQueries = true;
        }
      }

      createLQuery(lView);
    }
    /**
     * Loads a QueryList corresponding to the current view query.
     *
     * \@codeGenApi
     * @template T
     * @return {?}
     */


    function ɵɵloadViewQuery() {
      return loadQueryInternal(getLView(), getCurrentQueryIndex());
    }
    /**
     * Registers a QueryList, associated with a content query, for later refresh (part of a view
     * refresh).
     *
     * \@codeGenApi
     * @template T
     * @param {?} directiveIndex Current directive index
     * @param {?} predicate The type for which the query will search
     * @param {?} descend Whether or not to descend into children
     * @param {?=} read What to save in the query
     * @return {?} QueryList<T>
     *
     */


    function ɵɵcontentQuery(directiveIndex, predicate, descend, read) {
      contentQueryInternal(getLView(), predicate, descend, read, false, getPreviousOrParentTNode(), directiveIndex);
    }
    /**
     * Registers a QueryList, associated with a static content query, for later refresh
     * (part of a view refresh).
     *
     * \@codeGenApi
     * @template T
     * @param {?} directiveIndex Current directive index
     * @param {?} predicate The type for which the query will search
     * @param {?} descend Whether or not to descend into children
     * @param {?=} read What to save in the query
     * @return {?} QueryList<T>
     *
     */


    function ɵɵstaticContentQuery(directiveIndex, predicate, descend, read) {
      contentQueryInternal(getLView(), predicate, descend, read, true, getPreviousOrParentTNode(), directiveIndex);
    }
    /**
     * @template T
     * @param {?} lView
     * @param {?} predicate
     * @param {?} descend
     * @param {?} read
     * @param {?} isStatic
     * @param {?} tNode
     * @param {?} directiveIndex
     * @return {?}
     */


    function contentQueryInternal(lView, predicate, descend, read, isStatic, tNode, directiveIndex) {
      /** @type {?} */
      const tView = lView[TVIEW];

      if (tView.firstTemplatePass) {
        createTQuery(tView, new TQueryMetadata_(predicate, descend, isStatic, read), tNode.index);
        saveContentQueryAndDirectiveIndex(tView, directiveIndex);

        if (isStatic) {
          tView.staticContentQueries = true;
        }
      }

      createLQuery(lView);
    }
    /**
     * Loads a QueryList corresponding to the current content query.
     *
     * \@codeGenApi
     * @template T
     * @return {?}
     */


    function ɵɵloadContentQuery() {
      return loadQueryInternal(getLView(), getCurrentQueryIndex());
    }
    /**
     * @template T
     * @param {?} lView
     * @param {?} queryIndex
     * @return {?}
     */


    function loadQueryInternal(lView, queryIndex) {
      ngDevMode && assertDefined(lView[QUERIES], 'LQueries should be defined when trying to load a query');
      ngDevMode && assertDataInRange(
      /** @type {?} */
      lView[QUERIES].queries, queryIndex);
      return (
        /** @type {?} */
        lView[QUERIES].queries[queryIndex].queryList
      );
    }
    /**
     * @template T
     * @param {?} lView
     * @return {?}
     */


    function createLQuery(lView) {
      /** @type {?} */
      const queryList = new QueryList();
      storeCleanupWithContext(lView, queryList, queryList.destroy);
      if (lView[QUERIES] === null) lView[QUERIES] = new LQueries_();

      /** @type {?} */
      lView[QUERIES].queries.push(new LQuery_(queryList));
    }
    /**
     * @param {?} tView
     * @param {?} metadata
     * @param {?} nodeIndex
     * @return {?}
     */


    function createTQuery(tView, metadata, nodeIndex) {
      if (tView.queries === null) tView.queries = new TQueries_();
      tView.queries.track(new TQuery_(metadata, nodeIndex));
    }
    /**
     * @param {?} tView
     * @param {?} directiveIndex
     * @return {?}
     */


    function saveContentQueryAndDirectiveIndex(tView, directiveIndex) {
      /** @type {?} */
      const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);
      /** @type {?} */

      const lastSavedDirectiveIndex = tView.contentQueries.length ? tViewContentQueries[tViewContentQueries.length - 1] : -1;

      if (directiveIndex !== lastSavedDirectiveIndex) {
        tViewContentQueries.push(
        /** @type {?} */
        tView.queries.length - 1, directiveIndex);
      }
    }
    /**
     * @param {?} tView
     * @param {?} index
     * @return {?}
     */


    function getTQuery(tView, index) {
      ngDevMode && assertDefined(tView.queries, 'TQueries must be defined to retrieve a TQuery');
      return (
        /** @type {?} */
        tView.queries.getByIndex(index)
      );
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Retrieves `TemplateRef` instance from `Injector` when a local reference is placed on the
     * `<ng-template>` element.
     *
     * \@codeGenApi
     * @param {?} tNode
     * @param {?} currentView
     * @return {?}
     */


    function ɵɵtemplateRefExtractor(tNode, currentView) {
      return createTemplateRef(TemplateRef, ElementRef, tNode, currentView);
    }
    /**
     * Returns the appropriate `ChangeDetectorRef` for a pipe.
     *
     * \@codeGenApi
     * @param {?=} flags
     * @return {?}
     */


    function ɵɵinjectPipeChangeDetectorRef(flags = InjectFlags.Default) {
      /** @type {?} */
      const value = injectChangeDetectorRef(true);

      if (value == null && !(flags & InjectFlags.Optional)) {
        throw new Error("No provider for ChangeDetectorRef!");
      } else {
        return value;
      }
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */


    const ɵ0$e =
    /**
    * @return {?}
    */
    () => ({
      'ɵɵattribute': ɵɵattribute,
      'ɵɵattributeInterpolate1': ɵɵattributeInterpolate1,
      'ɵɵattributeInterpolate2': ɵɵattributeInterpolate2,
      'ɵɵattributeInterpolate3': ɵɵattributeInterpolate3,
      'ɵɵattributeInterpolate4': ɵɵattributeInterpolate4,
      'ɵɵattributeInterpolate5': ɵɵattributeInterpolate5,
      'ɵɵattributeInterpolate6': ɵɵattributeInterpolate6,
      'ɵɵattributeInterpolate7': ɵɵattributeInterpolate7,
      'ɵɵattributeInterpolate8': ɵɵattributeInterpolate8,
      'ɵɵattributeInterpolateV': ɵɵattributeInterpolateV,
      'ɵɵdefineBase': ɵɵdefineBase,
      'ɵɵdefineComponent': ɵɵdefineComponent,
      'ɵɵdefineDirective': ɵɵdefineDirective,
      'ɵɵdefineInjectable': ɵɵdefineInjectable,
      'ɵɵdefineInjector': ɵɵdefineInjector,
      'ɵɵdefineNgModule': ɵɵdefineNgModule,
      'ɵɵdefinePipe': ɵɵdefinePipe,
      'ɵɵdirectiveInject': ɵɵdirectiveInject,
      'ɵɵgetFactoryOf': ɵɵgetFactoryOf,
      'ɵɵgetInheritedFactory': ɵɵgetInheritedFactory,
      'ɵɵinject': ɵɵinject,
      'ɵɵinjectAttribute': ɵɵinjectAttribute,
      'ɵɵinjectPipeChangeDetectorRef': ɵɵinjectPipeChangeDetectorRef,
      'ɵɵtemplateRefExtractor': ɵɵtemplateRefExtractor,
      'ɵɵNgOnChangesFeature': ɵɵNgOnChangesFeature,
      'ɵɵProvidersFeature': ɵɵProvidersFeature,
      'ɵɵInheritDefinitionFeature': ɵɵInheritDefinitionFeature,
      'ɵɵcontainer': ɵɵcontainer,
      'ɵɵnextContext': ɵɵnextContext,
      'ɵɵcontainerRefreshStart': ɵɵcontainerRefreshStart,
      'ɵɵcontainerRefreshEnd': ɵɵcontainerRefreshEnd,
      'ɵɵnamespaceHTML': ɵɵnamespaceHTML,
      'ɵɵnamespaceMathML': ɵɵnamespaceMathML,
      'ɵɵnamespaceSVG': ɵɵnamespaceSVG,
      'ɵɵenableBindings': ɵɵenableBindings,
      'ɵɵdisableBindings': ɵɵdisableBindings,
      'ɵɵallocHostVars': ɵɵallocHostVars,
      'ɵɵelementStart': ɵɵelementStart,
      'ɵɵelementEnd': ɵɵelementEnd,
      'ɵɵelement': ɵɵelement,
      'ɵɵelementContainerStart': ɵɵelementContainerStart,
      'ɵɵelementContainerEnd': ɵɵelementContainerEnd,
      'ɵɵelementContainer': ɵɵelementContainer,
      'ɵɵpureFunction0': ɵɵpureFunction0,
      'ɵɵpureFunction1': ɵɵpureFunction1,
      'ɵɵpureFunction2': ɵɵpureFunction2,
      'ɵɵpureFunction3': ɵɵpureFunction3,
      'ɵɵpureFunction4': ɵɵpureFunction4,
      'ɵɵpureFunction5': ɵɵpureFunction5,
      'ɵɵpureFunction6': ɵɵpureFunction6,
      'ɵɵpureFunction7': ɵɵpureFunction7,
      'ɵɵpureFunction8': ɵɵpureFunction8,
      'ɵɵpureFunctionV': ɵɵpureFunctionV,
      'ɵɵgetCurrentView': ɵɵgetCurrentView,
      'ɵɵrestoreView': ɵɵrestoreView,
      'ɵɵlistener': ɵɵlistener,
      'ɵɵload': ɵɵload,
      'ɵɵprojection': ɵɵprojection,
      'ɵɵupdateSyntheticHostBinding': ɵɵupdateSyntheticHostBinding,
      'ɵɵcomponentHostSyntheticListener': ɵɵcomponentHostSyntheticListener,
      'ɵɵpipeBind1': ɵɵpipeBind1,
      'ɵɵpipeBind2': ɵɵpipeBind2,
      'ɵɵpipeBind3': ɵɵpipeBind3,
      'ɵɵpipeBind4': ɵɵpipeBind4,
      'ɵɵpipeBindV': ɵɵpipeBindV,
      'ɵɵprojectionDef': ɵɵprojectionDef,
      'ɵɵhostProperty': ɵɵhostProperty,
      'ɵɵproperty': ɵɵproperty,
      'ɵɵpropertyInterpolate': ɵɵpropertyInterpolate,
      'ɵɵpropertyInterpolate1': ɵɵpropertyInterpolate1,
      'ɵɵpropertyInterpolate2': ɵɵpropertyInterpolate2,
      'ɵɵpropertyInterpolate3': ɵɵpropertyInterpolate3,
      'ɵɵpropertyInterpolate4': ɵɵpropertyInterpolate4,
      'ɵɵpropertyInterpolate5': ɵɵpropertyInterpolate5,
      'ɵɵpropertyInterpolate6': ɵɵpropertyInterpolate6,
      'ɵɵpropertyInterpolate7': ɵɵpropertyInterpolate7,
      'ɵɵpropertyInterpolate8': ɵɵpropertyInterpolate8,
      'ɵɵpropertyInterpolateV': ɵɵpropertyInterpolateV,
      'ɵɵpipe': ɵɵpipe,
      'ɵɵqueryRefresh': ɵɵqueryRefresh,
      'ɵɵviewQuery': ɵɵviewQuery,
      'ɵɵstaticViewQuery': ɵɵstaticViewQuery,
      'ɵɵstaticContentQuery': ɵɵstaticContentQuery,
      'ɵɵloadViewQuery': ɵɵloadViewQuery,
      'ɵɵcontentQuery': ɵɵcontentQuery,
      'ɵɵloadContentQuery': ɵɵloadContentQuery,
      'ɵɵreference': ɵɵreference,
      'ɵɵelementHostAttrs': ɵɵelementHostAttrs,
      'ɵɵclassMap': ɵɵclassMap,
      'ɵɵclassMapInterpolate1': ɵɵclassMapInterpolate1,
      'ɵɵclassMapInterpolate2': ɵɵclassMapInterpolate2,
      'ɵɵclassMapInterpolate3': ɵɵclassMapInterpolate3,
      'ɵɵclassMapInterpolate4': ɵɵclassMapInterpolate4,
      'ɵɵclassMapInterpolate5': ɵɵclassMapInterpolate5,
      'ɵɵclassMapInterpolate6': ɵɵclassMapInterpolate6,
      'ɵɵclassMapInterpolate7': ɵɵclassMapInterpolate7,
      'ɵɵclassMapInterpolate8': ɵɵclassMapInterpolate8,
      'ɵɵclassMapInterpolateV': ɵɵclassMapInterpolateV,
      'ɵɵstyling': ɵɵstyling,
      'ɵɵstyleMap': ɵɵstyleMap,
      'ɵɵstyleProp': ɵɵstyleProp,
      'ɵɵstylePropInterpolate1': ɵɵstylePropInterpolate1,
      'ɵɵstylePropInterpolate2': ɵɵstylePropInterpolate2,
      'ɵɵstylePropInterpolate3': ɵɵstylePropInterpolate3,
      'ɵɵstylePropInterpolate4': ɵɵstylePropInterpolate4,
      'ɵɵstylePropInterpolate5': ɵɵstylePropInterpolate5,
      'ɵɵstylePropInterpolate6': ɵɵstylePropInterpolate6,
      'ɵɵstylePropInterpolate7': ɵɵstylePropInterpolate7,
      'ɵɵstylePropInterpolate8': ɵɵstylePropInterpolate8,
      'ɵɵstylePropInterpolateV': ɵɵstylePropInterpolateV,
      'ɵɵstyleSanitizer': ɵɵstyleSanitizer,
      'ɵɵstylingApply': ɵɵstylingApply,
      'ɵɵclassProp': ɵɵclassProp,
      'ɵɵselect': ɵɵselect,
      'ɵɵtemplate': ɵɵtemplate,
      'ɵɵtext': ɵɵtext,
      'ɵɵtextBinding': ɵɵtextBinding,
      'ɵɵtextInterpolate': ɵɵtextInterpolate,
      'ɵɵtextInterpolate1': ɵɵtextInterpolate1,
      'ɵɵtextInterpolate2': ɵɵtextInterpolate2,
      'ɵɵtextInterpolate3': ɵɵtextInterpolate3,
      'ɵɵtextInterpolate4': ɵɵtextInterpolate4,
      'ɵɵtextInterpolate5': ɵɵtextInterpolate5,
      'ɵɵtextInterpolate6': ɵɵtextInterpolate6,
      'ɵɵtextInterpolate7': ɵɵtextInterpolate7,
      'ɵɵtextInterpolate8': ɵɵtextInterpolate8,
      'ɵɵtextInterpolateV': ɵɵtextInterpolateV,
      'ɵɵembeddedViewStart': ɵɵembeddedViewStart,
      'ɵɵembeddedViewEnd': ɵɵembeddedViewEnd,
      'ɵɵi18n': ɵɵi18n,
      'ɵɵi18nAttributes': ɵɵi18nAttributes,
      'ɵɵi18nExp': ɵɵi18nExp,
      'ɵɵi18nStart': ɵɵi18nStart,
      'ɵɵi18nEnd': ɵɵi18nEnd,
      'ɵɵi18nApply': ɵɵi18nApply,
      'ɵɵi18nPostprocess': ɵɵi18nPostprocess,
      'ɵɵi18nLocalize': ɵɵi18nLocalize,
      'ɵɵresolveWindow': ɵɵresolveWindow,
      'ɵɵresolveDocument': ɵɵresolveDocument,
      'ɵɵresolveBody': ɵɵresolveBody,
      'ɵɵsetComponentScope': ɵɵsetComponentScope,
      'ɵɵsetNgModuleScope': ɵɵsetNgModuleScope,
      'ɵɵsanitizeHtml': ɵɵsanitizeHtml,
      'ɵɵsanitizeStyle': ɵɵsanitizeStyle,
      'ɵɵdefaultStyleSanitizer': ɵɵdefaultStyleSanitizer,
      'ɵɵsanitizeResourceUrl': ɵɵsanitizeResourceUrl,
      'ɵɵsanitizeScript': ɵɵsanitizeScript,
      'ɵɵsanitizeUrl': ɵɵsanitizeUrl,
      'ɵɵsanitizeUrlOrResourceUrl': ɵɵsanitizeUrlOrResourceUrl
    });
    /**
     * A mapping of the \@angular/core API surface used in generated expressions to the actual symbols.
     *
     * This should be kept up to date with the public exports of \@angular/core.
     * @type {?}
     */


    const angularCoreEnv = ɵ0$e();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    const EMPTY_ARRAY$4 = [];
    /**
     * @record
     */

    function ModuleQueueItem() {}

    if (false) {}
    /** @type {?} */


    const moduleQueue = [];
    /**
     * Enqueues moduleDef to be checked later to see if scope can be set on its
     * component declarations.
     * @param {?} moduleType
     * @param {?} ngModule
     * @return {?}
     */

    function enqueueModuleForDelayedScoping(moduleType, ngModule) {
      moduleQueue.push({
        moduleType,
        ngModule
      });
    }
    /** @type {?} */


    let flushingModuleQueue = false;
    /**
     * Loops over queued module definitions, if a given module definition has all of its
     * declarations resolved, it dequeues that module definition and sets the scope on
     * its declarations.
     * @return {?}
     */

    function flushModuleScopingQueueAsMuchAsPossible() {
      if (!flushingModuleQueue) {
        flushingModuleQueue = true;

        try {
          for (let i = moduleQueue.length - 1; i >= 0; i--) {
            const {
              moduleType,
              ngModule
            } = moduleQueue[i];

            if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {
              // dequeue
              moduleQueue.splice(i, 1);
              setScopeOnDeclaredComponents(moduleType, ngModule);
            }
          }
        } finally {
          flushingModuleQueue = false;
        }
      }
    }
    /**
     * Returns truthy if a declaration has resolved. If the declaration happens to be
     * an array of declarations, it will recurse to check each declaration in that array
     * (which may also be arrays).
     * @param {?} declaration
     * @return {?}
     */


    function isResolvedDeclaration(declaration) {
      if (Array.isArray(declaration)) {
        return declaration.every(isResolvedDeclaration);
      }

      return !!resolveForwardRef(declaration);
    }
    /**
     * Compiles a module in JIT mode.
     *
     * This function automatically gets called when a class has a `\@NgModule` decorator.
     * @param {?} moduleType
     * @param {?=} ngModule
     * @return {?}
     */


    function compileNgModule(moduleType, ngModule = {}) {
      compileNgModuleDefs(
      /** @type {?} */
      moduleType, ngModule); // Because we don't know if all declarations have resolved yet at the moment the
      // NgModule decorator is executing, we're enqueueing the setting of module scope
      // on its declarations to be run at a later time when all declarations for the module,
      // including forward refs, have resolved.

      enqueueModuleForDelayedScoping(moduleType, ngModule);
    }
    /**
     * Compiles and adds the `ngModuleDef` and `ngInjectorDef` properties to the module class.
     *
     * It's possible to compile a module via this API which will allow duplicate declarations in its
     * root.
     * @param {?} moduleType
     * @param {?} ngModule
     * @param {?=} allowDuplicateDeclarationsInRoot
     * @return {?}
     */


    function compileNgModuleDefs(moduleType, ngModule, allowDuplicateDeclarationsInRoot = false) {
      ngDevMode && assertDefined(moduleType, 'Required value moduleType');
      ngDevMode && assertDefined(ngModule, 'Required value ngModule');
      /** @type {?} */

      const declarations = flatten(ngModule.declarations || EMPTY_ARRAY$4);
      /** @type {?} */

      /** @nocollapse */

      let ngModuleDef = null;
      Object.defineProperty(moduleType, NG_MODULE_DEF, {
        configurable: true,
        get:
        /**
        * @return {?}
        */
        () => {
          if (ngModuleDef === null) {
            if (ngDevMode && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) {
              // We need to assert this immediately, because allowing it to continue will cause it to
              // go into an infinite loop before we've reached the point where we throw all the errors.
              throw new Error("'".concat(stringifyForError(moduleType), "' module can't import itself"));
            }

            ngModuleDef = getCompilerFacade().compileNgModule(angularCoreEnv, "ng:///".concat(moduleType.name, "/ngModuleDef.js"), {
              type: moduleType,
              bootstrap: flatten(ngModule.bootstrap || EMPTY_ARRAY$4).map(resolveForwardRef),
              declarations: declarations.map(resolveForwardRef),
              imports: flatten(ngModule.imports || EMPTY_ARRAY$4).map(resolveForwardRef).map(expandModuleWithProviders),
              exports: flatten(ngModule.exports || EMPTY_ARRAY$4).map(resolveForwardRef).map(expandModuleWithProviders),
              emitInline: true,
              schemas: ngModule.schemas ? flatten(ngModule.schemas) : null,
              id: ngModule.id || null
            });
          }

          return ngModuleDef;
        }
      });
      /** @type {?} */

      /** @nocollapse */

      let ngInjectorDef = null;
      Object.defineProperty(moduleType, NG_INJECTOR_DEF, {
        get:
        /**
        * @return {?}
        */
        () => {
          if (ngInjectorDef === null) {
            ngDevMode && verifySemanticsOfNgModuleDef(
            /** @type {?} */

            /** @type {?} */
            moduleType, allowDuplicateDeclarationsInRoot);
            /** @type {?} */

            const meta = {
              name: moduleType.name,
              type: moduleType,
              deps: reflectDependencies(moduleType),
              providers: ngModule.providers || EMPTY_ARRAY$4,
              imports: [(ngModule.imports || EMPTY_ARRAY$4).map(resolveForwardRef), (ngModule.exports || EMPTY_ARRAY$4).map(resolveForwardRef)]
            };
            ngInjectorDef = getCompilerFacade().compileInjector(angularCoreEnv, "ng:///".concat(moduleType.name, "/ngInjectorDef.js"), meta);
          }

          return ngInjectorDef;
        },
        // Make the property configurable in dev mode to allow overriding in tests
        configurable: !!ngDevMode
      });
    }
    /**
     * @param {?} moduleType
     * @param {?} allowDuplicateDeclarationsInRoot
     * @param {?=} importingModule
     * @return {?}
     */


    function verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot, importingModule) {
      if (verifiedNgModule.get(moduleType)) return;
      verifiedNgModule.set(moduleType, true);
      moduleType = resolveForwardRef(moduleType);
      /** @type {?} */

      let ngModuleDef;

      if (importingModule) {
        ngModuleDef =
        /** @type {?} */
        getNgModuleDef(moduleType);

        if (!ngModuleDef) {
          throw new Error("Unexpected value '".concat(moduleType.name, "' imported by the module '").concat(importingModule.name, "'. Please add an @NgModule annotation."));
        }
      } else {
        ngModuleDef = getNgModuleDef(moduleType, true);
      }
      /** @type {?} */


      const errors = [];
      /** @type {?} */

      const declarations = maybeUnwrapFn(ngModuleDef.declarations);
      /** @type {?} */

      const imports = maybeUnwrapFn(ngModuleDef.imports);
      flatten(imports).map(unwrapModuleWithProvidersImports).forEach(
      /**
      * @param {?} mod
      * @return {?}
      */
      mod => {
        verifySemanticsOfNgModuleImport(mod, moduleType);
        verifySemanticsOfNgModuleDef(mod, false, moduleType);
      });
      /** @type {?} */

      const exports = maybeUnwrapFn(ngModuleDef.exports);
      declarations.forEach(verifyDeclarationsHaveDefinitions);
      /** @type {?} */

      const combinedDeclarations = [...declarations.map(resolveForwardRef), ...flatten(imports.map(computeCombinedExports)).map(resolveForwardRef)];
      exports.forEach(verifyExportsAreDeclaredOrReExported);
      declarations.forEach(
      /**
      * @param {?} decl
      * @return {?}
      */
      decl => verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));
      declarations.forEach(verifyComponentEntryComponentsIsPartOfNgModule);
      /** @type {?} */

      const ngModule = getAnnotation(moduleType, 'NgModule');

      if (ngModule) {
        ngModule.imports && flatten(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach(
        /**
        * @param {?} mod
        * @return {?}
        */
        mod => {
          verifySemanticsOfNgModuleImport(mod, moduleType);
          verifySemanticsOfNgModuleDef(mod, false, moduleType);
        });
        ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyCorrectBootstrapType);
        ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyComponentIsPartOfNgModule);
        ngModule.entryComponents && deepForEach(ngModule.entryComponents, verifyComponentIsPartOfNgModule);
      } // Throw Error if any errors were detected.


      if (errors.length) {
        throw new Error(errors.join('\n'));
      } ////////////////////////////////////////////////////////////////////////////////////////////////

      /**
       * @param {?} type
       * @return {?}
       */


      function verifyDeclarationsHaveDefinitions(type) {
        type = resolveForwardRef(type);
        /** @type {?} */

        const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef(type);

        if (!def) {
          errors.push("Unexpected value '".concat(stringifyForError(type), "' declared by the module '").concat(stringifyForError(moduleType), "'. Please add a @Pipe/@Directive/@Component annotation."));
        }
      }
      /**
       * @param {?} type
       * @return {?}
       */


      function verifyExportsAreDeclaredOrReExported(type) {
        type = resolveForwardRef(type);
        /** @type {?} */

        const kind = getComponentDef(type) && 'component' || getDirectiveDef(type) && 'directive' || getPipeDef(type) && 'pipe';

        if (kind) {
          // only checked if we are declared as Component, Directive, or Pipe
          // Modules don't need to be declared or imported.
          if (combinedDeclarations.lastIndexOf(type) === -1) {
            // We are exporting something which we don't explicitly declare or import.
            errors.push("Can't export ".concat(kind, " ").concat(stringifyForError(type), " from ").concat(stringifyForError(moduleType), " as it was neither declared nor imported!"));
          }
        }
      }
      /**
       * @param {?} type
       * @param {?} suppressErrors
       * @return {?}
       */


      function verifyDeclarationIsUnique(type, suppressErrors) {
        type = resolveForwardRef(type);
        /** @type {?} */

        const existingModule = ownerNgModule.get(type);

        if (existingModule && existingModule !== moduleType) {
          if (!suppressErrors) {
            /** @type {?} */
            const modules = [existingModule, moduleType].map(stringifyForError).sort();
            errors.push("Type ".concat(stringifyForError(type), " is part of the declarations of 2 modules: ").concat(modules[0], " and ").concat(modules[1], "! ") + "Please consider moving ".concat(stringifyForError(type), " to a higher module that imports ").concat(modules[0], " and ").concat(modules[1], ". ") + "You can also create a new NgModule that exports and includes ".concat(stringifyForError(type), " then import that NgModule in ").concat(modules[0], " and ").concat(modules[1], "."));
          }
        } else {
          // Mark type as having owner.
          ownerNgModule.set(type, moduleType);
        }
      }
      /**
       * @param {?} type
       * @return {?}
       */


      function verifyComponentIsPartOfNgModule(type) {
        type = resolveForwardRef(type);
        /** @type {?} */

        const existingModule = ownerNgModule.get(type);

        if (!existingModule) {
          errors.push("Component ".concat(stringifyForError(type), " is not part of any NgModule or the module has not been imported into your module."));
        }
      }
      /**
       * @param {?} type
       * @return {?}
       */


      function verifyCorrectBootstrapType(type) {
        type = resolveForwardRef(type);

        if (!getComponentDef(type)) {
          errors.push("".concat(stringifyForError(type), " cannot be used as an entry component."));
        }
      }
      /**
       * @param {?} type
       * @return {?}
       */


      function verifyComponentEntryComponentsIsPartOfNgModule(type) {
        type = resolveForwardRef(type);

        if (getComponentDef(type)) {
          // We know we are component

          /** @type {?} */
          const component = getAnnotation(type, 'Component');

          if (component && component.entryComponents) {
            deepForEach(component.entryComponents, verifyComponentIsPartOfNgModule);
          }
        }
      }
      /**
       * @param {?} type
       * @param {?} importingModule
       * @return {?}
       */


      function verifySemanticsOfNgModuleImport(type, importingModule) {
        type = resolveForwardRef(type);

        if (getComponentDef(type) || getDirectiveDef(type)) {
          throw new Error("Unexpected directive '".concat(type.name, "' imported by the module '").concat(importingModule.name, "'. Please add an @NgModule annotation."));
        }

        if (getPipeDef(type)) {
          throw new Error("Unexpected pipe '".concat(type.name, "' imported by the module '").concat(importingModule.name, "'. Please add an @NgModule annotation."));
        }
      }
    }
    /**
     * @param {?} typeOrWithProviders
     * @return {?}
     */


    function unwrapModuleWithProvidersImports(typeOrWithProviders) {
      typeOrWithProviders = resolveForwardRef(typeOrWithProviders);
      return (
        /** @type {?} */
        typeOrWithProviders.ngModule || typeOrWithProviders
      );
    }
    /**
     * @template T
     * @param {?} type
     * @param {?} name
     * @return {?}
     */


    function getAnnotation(type, name) {
      /** @type {?} */
      let annotation = null;
      collect(type.__annotations__);
      collect(type.decorators);
      return annotation;
      /**
       * @param {?} annotations
       * @return {?}
       */

      function collect(annotations) {
        if (annotations) {
          annotations.forEach(readAnnotation);
        }
      }
      /**
       * @param {?} decorator
       * @return {?}
       */


      function readAnnotation(decorator) {
        if (!annotation) {
          /** @type {?} */
          const proto = Object.getPrototypeOf(decorator);

          if (proto.ngMetadataName == name) {
            annotation =
            /** @type {?} */
            decorator;
          } else if (decorator.type) {
            /** @type {?} */
            const proto = Object.getPrototypeOf(decorator.type);

            if (proto.ngMetadataName == name) {
              annotation = decorator.args[0];
            }
          }
        }
      }
    }
    /**
     * Keep track of compiled components. This is needed because in tests we often want to compile the
     * same component with more than one NgModule. This would cause an error unless we reset which
     * NgModule the component belongs to. We keep the list of compiled components here so that the
     * TestBed can reset it later.
     * @type {?}
     */


    let ownerNgModule = new Map();
    /** @type {?} */

    let verifiedNgModule = new Map();
    /**
     * @return {?}
     */

    function resetCompiledComponents() {
      ownerNgModule = new Map();
      verifiedNgModule = new Map();
      moduleQueue.length = 0;
    }
    /**
     * Computes the combined declarations of explicit declarations, as well as declarations inherited by
     * traversing the exports of imported modules.
     * @param {?} type
     * @return {?}
     */


    function computeCombinedExports(type) {
      type = resolveForwardRef(type);
      /** @type {?} */

      /** @nocollapse */

      const ngModuleDef = getNgModuleDef(type, true);
      return [...flatten(maybeUnwrapFn(ngModuleDef.exports).map(
      /**
      * @param {?} type
      * @return {?}
      */
      type => {
        /** @type {?} */

        /** @nocollapse */
        const ngModuleDef = getNgModuleDef(type);

        if (ngModuleDef) {
          verifySemanticsOfNgModuleDef(
          /** @type {?} */

          /** @type {?} */
          type, false);
          return computeCombinedExports(type);
        } else {
          return type;
        }
      }))];
    }
    /**
     * Some declared components may be compiled asynchronously, and thus may not have their
     * ngComponentDef set yet. If this is the case, then a reference to the module is written into
     * the `ngSelectorScope` property of the declared type.
     * @param {?} moduleType
     * @param {?} ngModule
     * @return {?}
     */


    function setScopeOnDeclaredComponents(moduleType, ngModule) {
      /** @type {?} */
      const declarations = flatten(ngModule.declarations || EMPTY_ARRAY$4);
      /** @type {?} */

      const transitiveScopes = transitiveScopesFor(moduleType);
      declarations.forEach(
      /**
      * @param {?} declaration
      * @return {?}
      */
      declaration => {
        if (declaration.hasOwnProperty(NG_COMPONENT_DEF)) {
          // An `ngComponentDef` field exists - go ahead and patch the component directly.

          /** @type {?} */
          const component =
          /** @type {?} */
          declaration;
          /** @type {?} */

          const componentDef =
          /** @type {?} */
          getComponentDef(component);
          patchComponentDefWithScope(componentDef, transitiveScopes);
        } else if (!declaration.hasOwnProperty(NG_DIRECTIVE_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {
          // Set `ngSelectorScope` for future reference when the component compilation finishes.

          /** @type {?} */
          declaration.ngSelectorScope = moduleType;
        }
      });
    }
    /**
     * Patch the definition of a component with directives and pipes from the compilation scope of
     * a given module.
     * @template C
     * @param {?} componentDef
     * @param {?} transitiveScopes
     * @return {?}
     */


    function patchComponentDefWithScope(componentDef, transitiveScopes) {
      componentDef.directiveDefs =
      /**
      * @return {?}
      */
      () => Array.from(transitiveScopes.compilation.directives).map(
      /**
      * @param {?} dir
      * @return {?}
      */
      dir => dir.hasOwnProperty(NG_COMPONENT_DEF) ?
      /** @type {?} */
      getComponentDef(dir) :
      /** @type {?} */
      getDirectiveDef(dir)).filter(
      /**
      * @param {?} def
      * @return {?}
      */
      def => !!def);

      componentDef.pipeDefs =
      /**
      * @return {?}
      */
      () => Array.from(transitiveScopes.compilation.pipes).map(
      /**
      * @param {?} pipe
      * @return {?}
      */
      pipe =>
      /** @type {?} */
      getPipeDef(pipe));

      componentDef.schemas = transitiveScopes.schemas; // Since we avoid Components/Directives/Pipes recompiling in case there are no overrides, we
      // may face a problem where previously compiled defs available to a given Component/Directive
      // are cached in TView and may become stale (in case any of these defs gets recompiled). In
      // order to avoid this problem, we force fresh TView to be created.

      componentDef.tView = null;
    }
    /**
     * Compute the pair of transitive scopes (compilation scope and exported scope) for a given module.
     *
     * This operation is memoized and the result is cached on the module's definition. It can be called
     * on modules with components that have not fully compiled yet, but the result should not be used
     * until they have.
     * @template T
     * @param {?} moduleType
     * @param {?=} processNgModuleFn
     * @return {?}
     */


    function transitiveScopesFor(moduleType, processNgModuleFn) {
      if (!isNgModule(moduleType)) {
        throw new Error("".concat(moduleType.name, " does not have an ngModuleDef"));
      }
      /** @type {?} */


      const def =
      /** @type {?} */
      getNgModuleDef(moduleType);

      if (def.transitiveCompileScopes !== null) {
        return def.transitiveCompileScopes;
      }
      /** @type {?} */


      const scopes = {
        schemas: def.schemas || null,
        compilation: {
          directives: new Set(),
          pipes: new Set()
        },
        exported: {
          directives: new Set(),
          pipes: new Set()
        }
      };
      maybeUnwrapFn(def.declarations).forEach(
      /**
      * @param {?} declared
      * @return {?}
      */
      declared => {
        /** @type {?} */
        const declaredWithDefs =
        /** @type {?} */
        declared;

        if (getPipeDef(declaredWithDefs)) {
          scopes.compilation.pipes.add(declared);
        } else {
          // Either declared has an ngComponentDef or ngDirectiveDef, or it's a component which hasn't
          // had its template compiled yet. In either case, it gets added to the compilation's
          // directives.
          scopes.compilation.directives.add(declared);
        }
      });
      maybeUnwrapFn(def.imports).forEach(
      /**
      * @template I
      * @param {?} imported
      * @return {?}
      */
      imported => {
        /** @type {?} */
        const importedType =
        /** @type {?} */
        imported;

        if (!isNgModule(importedType)) {
          throw new Error("Importing ".concat(importedType.name, " which does not have an ngModuleDef"));
        }

        if (processNgModuleFn) {
          processNgModuleFn(
          /** @type {?} */
          importedType);
        } // When this module imports another, the imported module's exported directives and pipes are
        // added to the compilation scope of this module.

        /** @type {?} */


        const importedScope = transitiveScopesFor(importedType, processNgModuleFn);
        importedScope.exported.directives.forEach(
        /**
        * @param {?} entry
        * @return {?}
        */
        entry => scopes.compilation.directives.add(entry));
        importedScope.exported.pipes.forEach(
        /**
        * @param {?} entry
        * @return {?}
        */
        entry => scopes.compilation.pipes.add(entry));
      });
      maybeUnwrapFn(def.exports).forEach(
      /**
      * @template E
      * @param {?} exported
      * @return {?}
      */
      exported => {
        /** @type {?} */
        const exportedType =
        /** @type {?} */
        exported; // Either the type is a module, a pipe, or a component/directive (which may not have an
        // ngComponentDef as it might be compiled asynchronously).

        if (isNgModule(exportedType)) {
          // When this module exports another, the exported module's exported directives and pipes are
          // added to both the compilation and exported scopes of this module.

          /** @type {?} */
          const exportedScope = transitiveScopesFor(exportedType, processNgModuleFn);
          exportedScope.exported.directives.forEach(
          /**
          * @param {?} entry
          * @return {?}
          */
          entry => {
            scopes.compilation.directives.add(entry);
            scopes.exported.directives.add(entry);
          });
          exportedScope.exported.pipes.forEach(
          /**
          * @param {?} entry
          * @return {?}
          */
          entry => {
            scopes.compilation.pipes.add(entry);
            scopes.exported.pipes.add(entry);
          });
        } else if (getPipeDef(exportedType)) {
          scopes.exported.pipes.add(exportedType);
        } else {
          scopes.exported.directives.add(exportedType);
        }
      });
      def.transitiveCompileScopes = scopes;
      return scopes;
    }
    /**
     * @param {?} value
     * @return {?}
     */


    function expandModuleWithProviders(value) {
      if (isModuleWithProviders(value)) {
        return value.ngModule;
      }

      return value;
    }
    /**
     * @param {?} value
     * @return {?}
     */


    function isModuleWithProviders(value) {
      return (
        /** @type {?} */
        value.ngModule !== undefined
      );
    }
    /**
     * @template T
     * @param {?} value
     * @return {?}
     */


    function isNgModule(value) {
      return !!getNgModuleDef(value);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Compile an Angular component according to its decorator metadata, and patch the resulting
     * ngComponentDef onto the component type.
     *
     * Compilation may be asynchronous (due to the need to resolve URLs for the component template or
     * other resources, for example). In the event that compilation is not immediate, `compileComponent`
     * will enqueue resource resolution into a global queue and will fail to return the `ngComponentDef`
     * until the global queue has been resolved with a call to `resolveComponentResources`.
     * @param {?} type
     * @param {?} metadata
     * @return {?}
     */


    function compileComponent(type, metadata) {
      /** @type {?} */

      /** @nocollapse */
      let ngComponentDef = null; // Metadata may have resources which need to be resolved.

      maybeQueueResolutionOfComponentResources(type, metadata);
      Object.defineProperty(type, NG_COMPONENT_DEF, {
        get:
        /**
        * @return {?}
        */
        () => {
          /** @type {?} */
          const compiler = getCompilerFacade();

          if (ngComponentDef === null) {
            if (componentNeedsResolution(metadata)) {
              /** @type {?} */
              const error = ["Component '".concat(type.name, "' is not resolved:")];

              if (metadata.templateUrl) {
                error.push(" - templateUrl: ".concat(metadata.templateUrl));
              }

              if (metadata.styleUrls && metadata.styleUrls.length) {
                error.push(" - styleUrls: ".concat(JSON.stringify(metadata.styleUrls)));
              }

              error.push("Did you run and wait for 'resolveComponentResources()'?");
              throw new Error(error.join('\n'));
            }
            /** @type {?} */


            const templateUrl = metadata.templateUrl || "ng:///".concat(type.name, "/template.html");
            /** @type {?} */

            const meta = Object.assign({}, directiveMetadata(type, metadata), {
              typeSourceSpan: compiler.createParseSourceSpan('Component', type.name, templateUrl),
              template: metadata.template || '',
              preserveWhitespaces: metadata.preserveWhitespaces || false,
              styles: metadata.styles || EMPTY_ARRAY,
              animations: metadata.animations,
              directives: [],
              changeDetection: metadata.changeDetection,
              pipes: new Map(),
              encapsulation: metadata.encapsulation || ViewEncapsulation.Emulated,
              interpolation: metadata.interpolation,
              viewProviders: metadata.viewProviders || null
            });

            if (meta.usesInheritance) {
              addBaseDefToUndecoratedParents(type);
            }

            ngComponentDef = compiler.compileComponent(angularCoreEnv, templateUrl, meta); // When NgModule decorator executed, we enqueued the module definition such that
            // it would only dequeue and add itself as module scope to all of its declarations,
            // but only if  if all of its declarations had resolved. This call runs the check
            // to see if any modules that are in the queue can be dequeued and add scope to
            // their declarations.

            flushModuleScopingQueueAsMuchAsPossible(); // If component compilation is async, then the @NgModule annotation which declares the
            // component may execute and set an ngSelectorScope property on the component type. This
            // allows the component to patch itself with directiveDefs from the module after it
            // finishes compiling.

            if (hasSelectorScope(type)) {
              /** @type {?} */
              const scopes = transitiveScopesFor(type.ngSelectorScope);
              patchComponentDefWithScope(ngComponentDef, scopes);
            }
          }

          return ngComponentDef;
        },
        // Make the property configurable in dev mode to allow overriding in tests
        configurable: !!ngDevMode
      }); // Add ngInjectableDef so components are reachable through the module injector by default
      // This is mostly to support injecting components in tests. In real application code,
      // components should be retrieved through the node injector, so this isn't a problem.

      compileInjectable(type);
    }
    /**
     * @template T
     * @param {?} component
     * @return {?}
     */


    function hasSelectorScope(component) {
      return (
        /** @type {?} */
        component.ngSelectorScope !== undefined
      );
    }
    /**
     * Compile an Angular directive according to its decorator metadata, and patch the resulting
     * ngDirectiveDef onto the component type.
     *
     * In the event that compilation is not immediate, `compileDirective` will return a `Promise` which
     * will resolve when compilation completes and the directive becomes usable.
     * @param {?} type
     * @param {?} directive
     * @return {?}
     */


    function compileDirective(type, directive) {
      /** @type {?} */

      /** @nocollapse */
      let ngDirectiveDef = null;
      Object.defineProperty(type, NG_DIRECTIVE_DEF, {
        get:
        /**
        * @return {?}
        */
        () => {
          if (ngDirectiveDef === null) {
            /** @type {?} */
            const name = type && type.name;
            /** @type {?} */

            const sourceMapUrl = "ng:///".concat(name, "/ngDirectiveDef.js");
            /** @type {?} */

            const compiler = getCompilerFacade();
            /** @type {?} */

            const facade = directiveMetadata(
            /** @type {?} */
            type, directive);
            facade.typeSourceSpan = compiler.createParseSourceSpan('Directive', name, sourceMapUrl);

            if (facade.usesInheritance) {
              addBaseDefToUndecoratedParents(type);
            }

            ngDirectiveDef = compiler.compileDirective(angularCoreEnv, sourceMapUrl, facade);
          }

          return ngDirectiveDef;
        },
        // Make the property configurable in dev mode to allow overriding in tests
        configurable: !!ngDevMode
      }); // Add ngInjectableDef so directives are reachable through the module injector by default
      // This is mostly to support injecting directives in tests. In real application code,
      // directives should be retrieved through the node injector, so this isn't a problem.

      compileInjectable(type);
    }
    /**
     * @param {?} type
     * @return {?}
     */


    function extendsDirectlyFromObject(type) {
      return Object.getPrototypeOf(type.prototype) === Object.prototype;
    }
    /**
     * Extract the `R3DirectiveMetadata` for a particular directive (either a `Directive` or a
     * `Component`).
     * @param {?} type
     * @param {?} metadata
     * @return {?}
     */


    function directiveMetadata(type, metadata) {
      // Reflect inputs and outputs.

      /** @type {?} */
      const propMetadata = getReflect().ownPropMetadata(type);
      return {
        name: type.name,
        type: type,
        typeArgumentCount: 0,
        selector:
        /** @type {?} */
        metadata.selector,
        deps: reflectDependencies(type),
        host: metadata.host || EMPTY_OBJ,
        propMetadata: propMetadata,
        inputs: metadata.inputs || EMPTY_ARRAY,
        outputs: metadata.outputs || EMPTY_ARRAY,
        queries: extractQueriesMetadata(type, propMetadata, isContentQuery),
        lifecycle: {
          usesOnChanges: type.prototype.hasOwnProperty('ngOnChanges')
        },
        typeSourceSpan:
        /** @type {?} */
        null,
        usesInheritance: !extendsDirectlyFromObject(type),
        exportAs: extractExportAs(metadata.exportAs),
        providers: metadata.providers || null,
        viewQueries: extractQueriesMetadata(type, propMetadata, isViewQuery)
      };
    }
    /**
     * Adds an `ngBaseDef` to all parent classes of a type that don't have an Angular decorator.
     * @param {?} type
     * @return {?}
     */


    function addBaseDefToUndecoratedParents(type) {
      /** @type {?} */
      const objPrototype = Object.prototype;
      /** @type {?} */

      let parent = Object.getPrototypeOf(type); // Go up the prototype until we hit `Object`.

      while (parent && parent !== objPrototype) {
        // Since inheritance works if the class was annotated already, we only need to add
        // the base def if there are no annotations and the base def hasn't been created already.
        if (!getDirectiveDef(parent) && !getComponentDef(parent) && !getBaseDef(parent)) {
          /** @type {?} */
          const facade = extractBaseDefMetadata(parent);
          facade && compileBase(parent, facade);
        }

        parent = Object.getPrototypeOf(parent);
      }
    }
    /**
     * Compiles the base metadata into a base definition.
     * @param {?} type
     * @param {?} facade
     * @return {?}
     */


    function compileBase(type, facade) {
      /** @type {?} */

      /** @nocollapse */
      let ngBaseDef = null;
      Object.defineProperty(type, NG_BASE_DEF, {
        get:
        /**
        * @return {?}
        */
        () => {
          if (ngBaseDef === null) {
            /** @type {?} */
            const name = type && type.name;
            /** @type {?} */

            const sourceMapUrl = "ng://".concat(name, "/ngBaseDef.js");
            /** @type {?} */

            const compiler = getCompilerFacade();
            ngBaseDef = compiler.compileBase(angularCoreEnv, sourceMapUrl, facade);
          }

          return ngBaseDef;
        },
        // Make the property configurable in dev mode to allow overriding in tests
        configurable: !!ngDevMode
      });
    }
    /**
     * Extracts the metadata necessary to construct an `ngBaseDef` from a class.
     * @param {?} type
     * @return {?}
     */


    function extractBaseDefMetadata(type) {
      /** @type {?} */
      const propMetadata = getReflect().ownPropMetadata(type);
      /** @type {?} */

      const viewQueries = extractQueriesMetadata(type, propMetadata, isViewQuery);
      /** @type {?} */

      const queries = extractQueriesMetadata(type, propMetadata, isContentQuery);
      /** @type {?} */

      let inputs;
      /** @type {?} */

      let outputs; // We only need to know whether there are any HostListener or HostBinding
      // decorators present, the parsing logic is in the compiler already.

      /** @type {?} */

      let hasHostDecorators = false;

      for (const field in propMetadata) {
        propMetadata[field].forEach(
        /**
        * @param {?} ann
        * @return {?}
        */
        ann => {
          /** @type {?} */
          const metadataName = ann.ngMetadataName;

          if (metadataName === 'Input') {
            inputs = inputs || {};
            inputs[field] = ann.bindingPropertyName ? [ann.bindingPropertyName, field] : field;
          } else if (metadataName === 'Output') {
            outputs = outputs || {};
            outputs[field] = ann.bindingPropertyName || field;
          } else if (metadataName === 'HostBinding' || metadataName === 'HostListener') {
            hasHostDecorators = true;
          }
        });
      } // Only generate the base def if there's any info inside it.


      if (inputs || outputs || viewQueries.length || queries.length || hasHostDecorators) {
        return {
          name: type.name,
          type,
          inputs,
          outputs,
          viewQueries,
          queries,
          propMetadata
        };
      }

      return null;
    }
    /**
     * @param {?} selector
     * @return {?}
     */


    function convertToR3QueryPredicate(selector) {
      return typeof selector === 'string' ? splitByComma(selector) : resolveForwardRef(selector);
    }
    /**
     * @param {?} propertyName
     * @param {?} ann
     * @return {?}
     */


    function convertToR3QueryMetadata(propertyName, ann) {
      return {
        propertyName: propertyName,
        predicate: convertToR3QueryPredicate(ann.selector),
        descendants: ann.descendants,
        first: ann.first,
        read: ann.read ? ann.read : null,
        static: !!ann.static
      };
    }
    /**
     * @param {?} type
     * @param {?} propMetadata
     * @param {?} isQueryAnn
     * @return {?}
     */


    function extractQueriesMetadata(type, propMetadata, isQueryAnn) {
      /** @type {?} */
      const queriesMeta = [];

      for (const field in propMetadata) {
        if (propMetadata.hasOwnProperty(field)) {
          /** @type {?} */
          const annotations = propMetadata[field];
          annotations.forEach(
          /**
          * @param {?} ann
          * @return {?}
          */
          ann => {
            if (isQueryAnn(ann)) {
              if (!ann.selector) {
                throw new Error("Can't construct a query for the property \"".concat(field, "\" of ") + "\"".concat(stringifyForError(type), "\" since the query selector wasn't defined."));
              }

              if (annotations.some(isInputAnn)) {
                throw new Error("Cannot combine @Input decorators with query decorators");
              }

              queriesMeta.push(convertToR3QueryMetadata(field, ann));
            }
          });
        }
      }

      return queriesMeta;
    }
    /**
     * @param {?} exportAs
     * @return {?}
     */


    function extractExportAs(exportAs) {
      if (exportAs === undefined) {
        return null;
      }

      return exportAs.split(',').map(
      /**
      * @param {?} part
      * @return {?}
      */
      part => part.trim());
    }
    /**
     * @param {?} value
     * @return {?}
     */


    function isContentQuery(value) {
      /** @type {?} */
      const name = value.ngMetadataName;
      return name === 'ContentChild' || name === 'ContentChildren';
    }
    /**
     * @param {?} value
     * @return {?}
     */


    function isViewQuery(value) {
      /** @type {?} */
      const name = value.ngMetadataName;
      return name === 'ViewChild' || name === 'ViewChildren';
    }
    /**
     * @param {?} value
     * @return {?}
     */


    function isInputAnn(value) {
      return value.ngMetadataName === 'Input';
    }
    /**
     * @param {?} value
     * @return {?}
     */


    function splitByComma(value) {
      return value.split(',').map(
      /**
      * @param {?} piece
      * @return {?}
      */
      piece => piece.trim());
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} type
     * @param {?} meta
     * @return {?}
     */


    function compilePipe(type, meta) {
      /** @type {?} */

      /** @nocollapse */
      let ngPipeDef = null;
      Object.defineProperty(type, NG_PIPE_DEF, {
        get:
        /**
        * @return {?}
        */
        () => {
          if (ngPipeDef === null) {
            /** @type {?} */
            const typeName = type.name;
            ngPipeDef = getCompilerFacade().compilePipe(angularCoreEnv, "ng:///".concat(typeName, "/ngPipeDef.js"), {
              type: type,
              typeArgumentCount: 0,
              name: typeName,
              deps: reflectDependencies(type),
              pipeName: meta.name,
              pure: meta.pure !== undefined ? meta.pure : true
            });
          }

          return ngPipeDef;
        },
        // Make the property configurable in dev mode to allow overriding in tests
        configurable: !!ngDevMode
      });
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Type of the Directive decorator / constructor function.
     * \@publicApi
     * @record
     */


    function DirectiveDecorator() {} // WARNING: interface has both a type and a value, skipping emit


    const ɵ0$f =
    /**
    * @param {?=} dir
    * @return {?}
    */
    (dir = {}) => dir,
          ɵ1$4 =
    /**
    * @param {?} type
    * @param {?} meta
    * @return {?}
    */
    (type, meta) => SWITCH_COMPILE_DIRECTIVE(type, meta);
    /**
     * Type of the Directive metadata.
     *
     * \@publicApi
     * @type {?}
     */


    const Directive = makeDecorator('Directive', ɵ0$f, undefined, undefined, ɵ1$4);
    /**
     * Component decorator interface
     *
     * \@publicApi
     * @record
     */

    function ComponentDecorator() {} // WARNING: interface has both a type and a value, skipping emit


    const ɵ2$1 =
    /**
    * @param {?=} c
    * @return {?}
    */
    (c = {}) => Object.assign({
      changeDetection: ChangeDetectionStrategy.Default
    }, c),
          ɵ3$1 =
    /**
    * @param {?} type
    * @param {?} meta
    * @return {?}
    */
    (type, meta) => SWITCH_COMPILE_COMPONENT(type, meta);
    /**
     * Component decorator and metadata.
     *
     * \@Annotation
     * \@publicApi
     * @type {?}
     */


    const Component = makeDecorator('Component', ɵ2$1, Directive, undefined, ɵ3$1);
    /**
     * Type of the Pipe decorator / constructor function.
     *
     * \@publicApi
     * @record
     */

    function PipeDecorator() {} // WARNING: interface has both a type and a value, skipping emit


    const ɵ4 =
    /**
    * @param {?} p
    * @return {?}
    */
    p => Object.assign({
      pure: true
    }, p),
          ɵ5 =
    /**
    * @param {?} type
    * @param {?} meta
    * @return {?}
    */
    (type, meta) => SWITCH_COMPILE_PIPE(type, meta);
    /**
     * \@Annotation
     * \@publicApi
     * @type {?}
     */


    const Pipe = makeDecorator('Pipe', ɵ4, undefined, undefined, ɵ5);
    /**
     * \@publicApi
     * @record
     */

    function InputDecorator() {} // WARNING: interface has both a type and a value, skipping emit


    const ɵ6 =
    /**
    * @param {?=} bindingPropertyName
    * @return {?}
    */
    bindingPropertyName => ({
      bindingPropertyName
    });
    /**
     * \@Annotation
     * \@publicApi
     * @type {?}
     */


    const Input = makePropDecorator('Input', ɵ6);
    /**
     * Type of the Output decorator / constructor function.
     *
     * \@publicApi
     * @record
     */

    function OutputDecorator() {} // WARNING: interface has both a type and a value, skipping emit


    const ɵ7 =
    /**
    * @param {?=} bindingPropertyName
    * @return {?}
    */
    bindingPropertyName => ({
      bindingPropertyName
    });
    /**
     * \@Annotation
     * \@publicApi
     * @type {?}
     */


    const Output = makePropDecorator('Output', ɵ7);
    /**
     * Type of the HostBinding decorator / constructor function.
     *
     * \@publicApi
     * @record
     */

    function HostBindingDecorator() {} // WARNING: interface has both a type and a value, skipping emit


    const ɵ8 =
    /**
    * @param {?=} hostPropertyName
    * @return {?}
    */
    hostPropertyName => ({
      hostPropertyName
    });
    /**
     * \@Annotation
     * \@publicApi
     * @type {?}
     */


    const HostBinding = makePropDecorator('HostBinding', ɵ8);
    /**
     * Type of the HostListener decorator / constructor function.
     *
     * \@publicApi
     * @record
     */

    function HostListenerDecorator() {} // WARNING: interface has both a type and a value, skipping emit


    const ɵ9 =
    /**
    * @param {?=} eventName
    * @param {?=} args
    * @return {?}
    */
    (eventName, args) => ({
      eventName,
      args
    });
    /**
     * Decorator that binds a DOM event to a host listener and supplies configuration metadata.
     * Angular invokes the supplied handler method when the host element emits the specified event,
     * and updates the bound element with the result.
     *
     * If the handler method returns false, applies `preventDefault` on the bound element.
     *
     * \@usageNotes
     *
     * The following example declares a directive
     * that attaches a click listener to a button and counts clicks.
     *
     * ```ts
     * \@Directive({selector: 'button[counting]'})
     * class CountClicks {
     *   numberOfClicks = 0;
     *
     * \@HostListener('click', ['$event.target'])
     *   onClick(btn) {
     *     console.log('button', btn, 'number of clicks:', this.numberOfClicks++);
     *  }
     * }
     *
     * \@Component({
     *   selector: 'app',
     *   template: '<button counting>Increment</button>',
     * })
     * class App {}
     * ```
     *
     * \@Annotation
     * \@publicApi
     * @type {?}
     */


    const HostListener = makePropDecorator('HostListener', ɵ9);
    /** @type {?} */

    const SWITCH_COMPILE_COMPONENT__POST_R3__ = compileComponent;
    /** @type {?} */

    const SWITCH_COMPILE_DIRECTIVE__POST_R3__ = compileDirective;
    /** @type {?} */

    const SWITCH_COMPILE_PIPE__POST_R3__ = compilePipe;
    /** @type {?} */

    const SWITCH_COMPILE_COMPONENT__PRE_R3__ = noop;
    /** @type {?} */

    const SWITCH_COMPILE_DIRECTIVE__PRE_R3__ = noop;
    /** @type {?} */

    const SWITCH_COMPILE_PIPE__PRE_R3__ = noop;
    /** @type {?} */

    const SWITCH_COMPILE_COMPONENT = SWITCH_COMPILE_COMPONENT__PRE_R3__;
    /** @type {?} */

    const SWITCH_COMPILE_DIRECTIVE = SWITCH_COMPILE_DIRECTIVE__PRE_R3__;
    /** @type {?} */

    const SWITCH_COMPILE_PIPE = SWITCH_COMPILE_PIPE__PRE_R3__;
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Represents the expansion of an `NgModule` into its scopes.
     *
     * A scope is a set of directives and pipes that are visible in a particular context. Each
     * `NgModule` has two scopes. The `compilation` scope is the set of directives and pipes that will
     * be recognized in the templates of components declared by the module. The `exported` scope is the
     * set of directives and pipes exported by a module (that is, module B's exported scope gets added
     * to module A's compilation scope when module A imports B).
     * @record
     */

    function NgModuleTransitiveScopes() {}

    if (false) {}
    /**
     * Runtime link information for NgModules.
     *
     * This is the internal data structure used by the runtime to assemble components, directives,
     * pipes, and injectors.
     *
     * NOTE: Always use `ɵɵdefineNgModule` function to create this object,
     * never create the object directly since the shape of this object
     * can change between versions.
     * @record
     * @template T
     */


    function NgModuleDef() {}

    if (false) {}
    /**
     * A wrapper around an NgModule that associates it with the providers.
     *
     * @param T the module type. In Ivy applications, this must be explicitly
     * provided.
     *
     * \@publicApi
     * @record
     * @template T
     */


    function ModuleWithProviders() {}

    if (false) {}
    /**
     * Type of the NgModule decorator / constructor function.
     *
     * \@publicApi
     * @record
     */


    function NgModuleDecorator() {} // WARNING: interface has both a type and a value, skipping emit


    const ɵ0$g =
    /**
    * @param {?} ngModule
    * @return {?}
    */
    ngModule => ngModule,
          ɵ1$5 =
    /**
    * Decorator that marks the following class as an NgModule, and supplies
    * configuration metadata for it.
    *
    * * The `declarations` and `entryComponents` options configure the compiler
    * with information about what belongs to the NgModule.
    * * The `providers` options configures the NgModule's injector to provide
    * dependencies the NgModule members.
    * * The `imports` and `exports` options bring in members from other modules, and make
    * this module's members available to others.
    * @param {?} type
    * @param {?} meta
    * @return {?}
    */
    (type, meta) => SWITCH_COMPILE_NGMODULE(type, meta);
    /**
     * \@Annotation
     * \@publicApi
     * @type {?}
     */


    const NgModule = makeDecorator('NgModule', ɵ0$g, undefined, undefined, ɵ1$5);
    /**
     * \@description
     * Hook for manual bootstrapping of the application instead of using bootstrap array in \@NgModule
     * annotation.
     *
     * Reference to the current application is provided as a parameter.
     *
     * See ["Bootstrapping"](guide/bootstrapping) and ["Entry components"](guide/entry-components).
     *
     * \@usageNotes
     * ```typescript
     * class AppModule implements DoBootstrap {
     *   ngDoBootstrap(appRef: ApplicationRef) {
     *     appRef.bootstrap(AppComponent); // Or some other component
     *   }
     * }
     * ```
     *
     * \@publicApi
     * @record
     */

    function DoBootstrap() {}

    if (false) {}
    /**
     * @param {?} moduleType
     * @param {?=} metadata
     * @return {?}
     */


    function preR3NgModuleCompile(moduleType, metadata) {
      /** @type {?} */
      let imports = metadata && metadata.imports || [];

      if (metadata && metadata.exports) {
        imports = [...imports, metadata.exports];
      }

      /** @type {?} */
      moduleType.ngInjectorDef = ɵɵdefineInjector({
        factory: convertInjectableProviderToFactory(moduleType, {
          useClass: moduleType
        }),
        providers: metadata && metadata.providers,
        imports: imports
      });
    }
    /** @type {?} */


    const SWITCH_COMPILE_NGMODULE__POST_R3__ = compileNgModule;
    /** @type {?} */

    const SWITCH_COMPILE_NGMODULE__PRE_R3__ = preR3NgModuleCompile;
    /** @type {?} */

    const SWITCH_COMPILE_NGMODULE = SWITCH_COMPILE_NGMODULE__PRE_R3__;
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * A function that will be executed when an application is initialized.
     *
     * \@publicApi
     * @type {?}
     */

    const APP_INITIALIZER = new InjectionToken('Application Initializer');
    /**
     * A class that reflects the state of running {\@link APP_INITIALIZER}s.
     *
     * \@publicApi
     */

    class ApplicationInitStatus {
      /**
       * @param {?} appInits
       */
      constructor(appInits) {
        this.appInits = appInits;
        this.initialized = false;
        this.done = false;
        this.donePromise = new Promise(
        /**
        * @param {?} res
        * @param {?} rej
        * @return {?}
        */
        (res, rej) => {
          this.resolve = res;
          this.reject = rej;
        });
      }
      /**
       * \@internal
       * @return {?}
       */


      runInitializers() {
        if (this.initialized) {
          return;
        }
        /** @type {?} */


        const asyncInitPromises = [];
        /** @type {?} */

        const complete =
        /**
        * @return {?}
        */
        () => {
          /** @type {?} */
          this.done = true;
          this.resolve();
        };

        if (this.appInits) {
          for (let i = 0; i < this.appInits.length; i++) {
            /** @type {?} */
            const initResult = this.appInits[i]();

            if (isPromise(initResult)) {
              asyncInitPromises.push(initResult);
            }
          }
        }

        Promise.all(asyncInitPromises).then(
        /**
        * @return {?}
        */
        () => {
          complete();
        }).catch(
        /**
        * @param {?} e
        * @return {?}
        */
        e => {
          this.reject(e);
        });

        if (asyncInitPromises.length === 0) {
          complete();
        }

        this.initialized = true;
      }

    }

    ApplicationInitStatus.decorators = [{
      type: Injectable
    }];
    /** @nocollapse */

    ApplicationInitStatus.ctorParameters = () => [{
      type: Array,
      decorators: [{
        type: Inject,
        args: [APP_INITIALIZER]
      }, {
        type: Optional
      }]
    }];

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * A DI Token representing a unique string id assigned to the application by Angular and used
     * primarily for prefixing application attributes and CSS styles when
     * {\@link ViewEncapsulation#Emulated ViewEncapsulation.Emulated} is being used.
     *
     * If you need to avoid randomly generated value to be used as an application id, you can provide
     * a custom value via a DI provider <!-- TODO: provider --> configuring the root {\@link Injector}
     * using this token.
     * \@publicApi
     * @type {?}
     */


    const APP_ID = new InjectionToken('AppId');
    /**
     * @return {?}
     */

    function _appIdRandomProviderFactory() {
      return "".concat(_randomChar()).concat(_randomChar()).concat(_randomChar());
    }
    /**
     * Providers that will generate a random APP_ID_TOKEN.
     * \@publicApi
     * @type {?}
     */


    const APP_ID_RANDOM_PROVIDER = {
      provide: APP_ID,
      useFactory: _appIdRandomProviderFactory,
      deps:
      /** @type {?} */
      []
    };
    /**
     * @return {?}
     */

    function _randomChar() {
      return String.fromCharCode(97 + Math.floor(Math.random() * 25));
    }
    /**
     * A function that will be executed when a platform is initialized.
     * \@publicApi
     * @type {?}
     */


    const PLATFORM_INITIALIZER = new InjectionToken('Platform Initializer');
    /**
     * A token that indicates an opaque platform id.
     * \@publicApi
     * @type {?}
     */

    const PLATFORM_ID = new InjectionToken('Platform ID');
    /**
     * All callbacks provided via this token will be called for every component that is bootstrapped.
     * Signature of the callback:
     *
     * `(componentRef: ComponentRef) => void`.
     *
     * \@publicApi
     * @type {?}
     */

    const APP_BOOTSTRAP_LISTENER = new InjectionToken('appBootstrapListener');
    /**
     * A token which indicates the root directory of the application
     * \@publicApi
     * @type {?}
     */

    const PACKAGE_ROOT_URL = new InjectionToken('Application Packages Root URL');
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    class Console {
      /**
       * @param {?} message
       * @return {?}
       */
      log(message) {
        // tslint:disable-next-line:no-console
        console.log(message);
      } // Note: for reporting errors use `DOM.logError()` as it is platform specific

      /**
       * @param {?} message
       * @return {?}
       */


      warn(message) {
        // tslint:disable-next-line:no-console
        console.warn(message);
      }

    }

    Console.decorators = [{
      type: Injectable
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Provide this token to set the locale of your application.
     * It is used for i18n extraction, by i18n pipes (DatePipe, I18nPluralPipe, CurrencyPipe,
     * DecimalPipe and PercentPipe) and by ICU expressions.
     *
     * See the [i18n guide](guide/i18n#setting-up-locale) for more information.
     *
     * \@usageNotes
     * ### Example
     *
     * ```typescript
     * import { LOCALE_ID } from '\@angular/core';
     * import { platformBrowserDynamic } from '\@angular/platform-browser-dynamic';
     * import { AppModule } from './app/app.module';
     *
     * platformBrowserDynamic().bootstrapModule(AppModule, {
     *   providers: [{provide: LOCALE_ID, useValue: 'en-US' }]
     * });
     * ```
     *
     * \@publicApi
     * @type {?}
     */

    const LOCALE_ID$1 = new InjectionToken('LocaleId');
    /**
     * Use this token at bootstrap to provide the content of your translation file (`xtb`,
     * `xlf` or `xlf2`) when you want to translate your application in another language.
     *
     * See the [i18n guide](guide/i18n#merge) for more information.
     *
     * \@usageNotes
     * ### Example
     *
     * ```typescript
     * import { TRANSLATIONS } from '\@angular/core';
     * import { platformBrowserDynamic } from '\@angular/platform-browser-dynamic';
     * import { AppModule } from './app/app.module';
     *
     * // content of your translation file
     * const translations = '....';
     *
     * platformBrowserDynamic().bootstrapModule(AppModule, {
     *   providers: [{provide: TRANSLATIONS, useValue: translations }]
     * });
     * ```
     *
     * \@publicApi
     * @type {?}
     */

    const TRANSLATIONS$1 = new InjectionToken('Translations');
    /**
     * Provide this token at bootstrap to set the format of your {\@link TRANSLATIONS}: `xtb`,
     * `xlf` or `xlf2`.
     *
     * See the [i18n guide](guide/i18n#merge) for more information.
     *
     * \@usageNotes
     * ### Example
     *
     * ```typescript
     * import { TRANSLATIONS_FORMAT } from '\@angular/core';
     * import { platformBrowserDynamic } from '\@angular/platform-browser-dynamic';
     * import { AppModule } from './app/app.module';
     *
     * platformBrowserDynamic().bootstrapModule(AppModule, {
     *   providers: [{provide: TRANSLATIONS_FORMAT, useValue: 'xlf' }]
     * });
     * ```
     *
     * \@publicApi
     * @type {?}
     */

    const TRANSLATIONS_FORMAT = new InjectionToken('TranslationsFormat');
    /** @enum {number} */

    const MissingTranslationStrategy = {
      Error: 0,
      Warning: 1,
      Ignore: 2
    };
    MissingTranslationStrategy[MissingTranslationStrategy.Error] = 'Error';
    MissingTranslationStrategy[MissingTranslationStrategy.Warning] = 'Warning';
    MissingTranslationStrategy[MissingTranslationStrategy.Ignore] = 'Ignore';
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /** @type {?} */

    const SWITCH_IVY_ENABLED__POST_R3__ = true;
    /** @type {?} */

    const SWITCH_IVY_ENABLED__PRE_R3__ = false;
    /** @type {?} */

    const ivyEnabled = SWITCH_IVY_ENABLED__PRE_R3__;
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Combination of NgModuleFactory and ComponentFactorys.
     *
     * \@publicApi
     * @template T
     */

    class ModuleWithComponentFactories {
      /**
       * @param {?} ngModuleFactory
       * @param {?} componentFactories
       */
      constructor(ngModuleFactory, componentFactories) {
        this.ngModuleFactory = ngModuleFactory;
        this.componentFactories = componentFactories;
      }

    }

    if (false) {}
    /**
     * @return {?}
     */


    function _throwError() {
      throw new Error("Runtime compiler is not loaded");
    }
    /** @type {?} */


    const Compiler_compileModuleSync__PRE_R3__ =
    /** @type {?} */
    _throwError;
    /** @type {?} */

    const Compiler_compileModuleSync__POST_R3__ =
    /**
    * @template T
    * @param {?} moduleType
    * @return {?}
    */
    function Compiler_compileModuleSync__POST_R3__(moduleType) {
      return new NgModuleFactory$1(moduleType);
    };
    /** @type {?} */


    const Compiler_compileModuleSync = Compiler_compileModuleSync__PRE_R3__;
    /** @type {?} */

    const Compiler_compileModuleAsync__PRE_R3__ =
    /** @type {?} */
    _throwError;
    /** @type {?} */

    const Compiler_compileModuleAsync__POST_R3__ =
    /**
    * @template T
    * @param {?} moduleType
    * @return {?}
    */
    function Compiler_compileModuleAsync__POST_R3__(moduleType) {
      return Promise.resolve(Compiler_compileModuleSync__POST_R3__(moduleType));
    };
    /** @type {?} */


    const Compiler_compileModuleAsync = Compiler_compileModuleAsync__PRE_R3__;
    /** @type {?} */

    const Compiler_compileModuleAndAllComponentsSync__PRE_R3__ =
    /** @type {?} */
    _throwError;
    /** @type {?} */

    const Compiler_compileModuleAndAllComponentsSync__POST_R3__ =
    /**
    * @template T
    * @param {?} moduleType
    * @return {?}
    */
    function Compiler_compileModuleAndAllComponentsSync__POST_R3__(moduleType) {
      /** @type {?} */
      const ngModuleFactory = Compiler_compileModuleSync__POST_R3__(moduleType);
      /** @type {?} */

      const moduleDef =
      /** @type {?} */
      getNgModuleDef(moduleType);
      /** @type {?} */

      const componentFactories = maybeUnwrapFn(moduleDef.declarations).reduce(
      /**
      * @param {?} factories
      * @param {?} declaration
      * @return {?}
      */
      (factories, declaration) => {
        /** @type {?} */
        const componentDef = getComponentDef(declaration);
        componentDef && factories.push(new ComponentFactory$1(componentDef));
        return factories;
      },
      /** @type {?} */
      []);
      return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);
    };
    /** @type {?} */


    const Compiler_compileModuleAndAllComponentsSync = Compiler_compileModuleAndAllComponentsSync__PRE_R3__;
    /** @type {?} */

    const Compiler_compileModuleAndAllComponentsAsync__PRE_R3__ =
    /** @type {?} */
    _throwError;
    /** @type {?} */

    const Compiler_compileModuleAndAllComponentsAsync__POST_R3__ =
    /**
    * @template T
    * @param {?} moduleType
    * @return {?}
    */
    function Compiler_compileModuleAndAllComponentsAsync__POST_R3__(moduleType) {
      return Promise.resolve(Compiler_compileModuleAndAllComponentsSync__POST_R3__(moduleType));
    };
    /** @type {?} */


    const Compiler_compileModuleAndAllComponentsAsync = Compiler_compileModuleAndAllComponentsAsync__PRE_R3__;
    /**
     * Low-level service for running the angular compiler during runtime
     * to create {\@link ComponentFactory}s, which
     * can later be used to create and render a Component instance.
     *
     * Each `\@NgModule` provides an own `Compiler` to its injector,
     * that will use the directives/pipes of the ng module for compilation
     * of components.
     *
     * \@publicApi
     */

    class Compiler {
      constructor() {
        /**
         * Compiles the given NgModule and all of its components. All templates of the components listed
         * in `entryComponents` have to be inlined.
         */
        this.compileModuleSync = Compiler_compileModuleSync;
        /**
         * Compiles the given NgModule and all of its components
         */

        this.compileModuleAsync = Compiler_compileModuleAsync;
        /**
         * Same as {\@link #compileModuleSync} but also creates ComponentFactories for all components.
         */

        this.compileModuleAndAllComponentsSync = Compiler_compileModuleAndAllComponentsSync;
        /**
         * Same as {\@link #compileModuleAsync} but also creates ComponentFactories for all components.
         */

        this.compileModuleAndAllComponentsAsync = Compiler_compileModuleAndAllComponentsAsync;
      }
      /**
       * Clears all caches.
       * @return {?}
       */


      clearCache() {}
      /**
       * Clears the cache for the given component/ngModule.
       * @param {?} type
       * @return {?}
       */


      clearCacheFor(type) {}
      /**
       * Returns the id for a given NgModule, if one is defined and known to the compiler.
       * @param {?} moduleType
       * @return {?}
       */


      getModuleId(moduleType) {
        return undefined;
      }

    }

    Compiler.decorators = [{
      type: Injectable
    }];

    if (false) {}
    /**
     * Token to provide CompilerOptions in the platform injector.
     *
     * \@publicApi
     * @type {?}
     */


    const COMPILER_OPTIONS = new InjectionToken('compilerOptions');
    /**
     * A factory for creating a Compiler
     *
     * \@publicApi
     * @abstract
     */

    class CompilerFactory {}

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * A scope function for the Web Tracing Framework (WTF).
     *
     * \@publicApi
     * @deprecated the Web Tracing Framework is no longer supported in Angular
     * @record
     */


    function WtfScopeFn() {}
    /**
     * @record
     */


    function WTF() {}

    if (false) {}
    /**
     * @record
     */


    function Trace() {}

    if (false) {}
    /**
     * @record
     */


    function Range() {}
    /**
     * @record
     */


    function Events() {}

    if (false) {}
    /**
     * @record
     */


    function Scope() {}
    /** @type {?} */


    let trace;
    /** @type {?} */

    let events;
    /**
     * @return {?}
     */

    function detectWTF() {
      /** @type {?} */
      const wtf =
      /** @type {?} */
      _global['wtf'];

      if (wtf) {
        trace = wtf['trace'];

        if (trace) {
          events = trace['events'];
          return true;
        }
      }

      return false;
    }
    /**
     * @param {?} signature
     * @param {?=} flags
     * @return {?}
     */


    function createScope(signature, flags = null) {
      return events.createScope(signature, flags);
    }
    /**
     * @template T
     * @param {?} scope
     * @param {?=} returnValue
     * @return {?}
     */


    function leave(scope, returnValue) {
      trace.leaveScope(scope, returnValue);
      return returnValue;
    }
    /**
     * @param {?} rangeType
     * @param {?} action
     * @return {?}
     */


    function startTimeRange(rangeType, action) {
      return trace.beginTimeRange(rangeType, action);
    }
    /**
     * @param {?} range
     * @return {?}
     */


    function endTimeRange(range) {
      trace.endTimeRange(range);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * True if WTF is enabled.
     * @type {?}
     */


    const wtfEnabled = detectWTF();
    /**
     * @param {?=} arg0
     * @param {?=} arg1
     * @return {?}
     */

    function noopScope(arg0, arg1) {
      return null;
    }
    /**
     * Create trace scope.
     *
     * Scopes must be strictly nested and are analogous to stack frames, but
     * do not have to follow the stack frames. Instead it is recommended that they follow logical
     * nesting. You may want to use
     * [Event
     * Signatures](http://google.github.io/tracing-framework/instrumenting-code.html#custom-events)
     * as they are defined in WTF.
     *
     * Used to mark scope entry. The return value is used to leave the scope.
     *
     *     var myScope = wtfCreateScope('MyClass#myMethod(ascii someVal)');
     *
     *     someMethod() {
     *        var s = myScope('Foo'); // 'Foo' gets stored in tracing UI
     *        // DO SOME WORK HERE
     *        return wtfLeave(s, 123); // Return value 123
     *     }
     *
     * Note, adding try-finally block around the work to ensure that `wtfLeave` gets called can
     * negatively impact the performance of your application. For this reason we recommend that
     * you don't add them to ensure that `wtfLeave` gets called. In production `wtfLeave` is a noop and
     * so try-finally block has no value. When debugging perf issues, skipping `wtfLeave`, do to
     * exception, will produce incorrect trace, but presence of exception signifies logic error which
     * needs to be fixed before the app should be profiled. Add try-finally only when you expect that
     * an exception is expected during normal execution while profiling.
     *
     * \@publicApi
     * @deprecated the Web Tracing Framework is no longer supported in Angular
     * @type {?}
     */


    const wtfCreateScope = wtfEnabled ? createScope :
    /**
    * @param {?} signature
    * @param {?=} flags
    * @return {?}
    */
    (signature, flags) => noopScope;
    /**
     * Used to mark end of Scope.
     *
     * - `scope` to end.
     * - `returnValue` (optional) to be passed to the WTF.
     *
     * Returns the `returnValue for easy chaining.
     * \@publicApi
     * @deprecated the Web Tracing Framework is no longer supported in Angular
     * @type {?}
     */

    const wtfLeave = wtfEnabled ? leave :
    /**
    * @param {?} s
    * @param {?=} r
    * @return {?}
    */
    (s, r) => r;
    /**
     * Used to mark Async start. Async are similar to scope but they don't have to be strictly nested.
     * The return value is used in the call to [endAsync]. Async ranges only work if WTF has been
     * enabled.
     *
     *     someMethod() {
     *        var s = wtfStartTimeRange('HTTP:GET', 'some.url');
     *        var future = new Future.delay(5).then((_) {
     *          wtfEndTimeRange(s);
     *        });
     *     }
     * \@publicApi
     * @deprecated the Web Tracing Framework is no longer supported in Angular
     * @type {?}
     */

    const wtfStartTimeRange = wtfEnabled ? startTimeRange :
    /**
    * @param {?} rangeType
    * @param {?} action
    * @return {?}
    */
    (rangeType, action) => null;
    /**
     * Ends a async time range operation.
     * [range] is the return value from [wtfStartTimeRange] Async ranges only work if WTF has been
     * enabled.
     * \@publicApi
     * @deprecated the Web Tracing Framework is no longer supported in Angular
     * @type {?}
     */

    const wtfEndTimeRange = wtfEnabled ? endTimeRange :
    /**
    * @param {?} r
    * @return {?}
    */
    r => null;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    const promise = (() => Promise.resolve(0))();

    function scheduleMicroTask(fn) {
      if (typeof Zone === 'undefined') {
        // use promise to schedule microTask instead of use Zone
        promise.then(() => {
          fn && fn.apply(null, null);
        });
      } else {
        Zone.current.scheduleMicroTask('scheduleMicrotask', fn);
      }
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * An injectable service for executing work inside or outside of the Angular zone.
     *
     * The most common use of this service is to optimize performance when starting a work consisting of
     * one or more asynchronous tasks that don't require UI updates or error handling to be handled by
     * Angular. Such tasks can be kicked off via {\@link #runOutsideAngular} and if needed, these tasks
     * can reenter the Angular zone via {\@link #run}.
     *
     * <!-- TODO: add/fix links to:
     *   - docs explaining zones and the use of zones in Angular and change-detection
     *   - link to runOutsideAngular/run (throughout this file!)
     *   -->
     *
     * \@usageNotes
     * ### Example
     *
     * ```
     * import {Component, NgZone} from '\@angular/core';
     * import {NgIf} from '\@angular/common';
     *
     * \@Component({
     *   selector: 'ng-zone-demo',
     *   template: `
     *     <h2>Demo: NgZone</h2>
     *
     *     <p>Progress: {{progress}}%</p>
     *     <p *ngIf="progress >= 100">Done processing {{label}} of Angular zone!</p>
     *
     *     <button (click)="processWithinAngularZone()">Process within Angular zone</button>
     *     <button (click)="processOutsideOfAngularZone()">Process outside of Angular zone</button>
     *   `,
     * })
     * export class NgZoneDemo {
     *   progress: number = 0;
     *   label: string;
     *
     *   constructor(private _ngZone: NgZone) {}
     *
     *   // Loop inside the Angular zone
     *   // so the UI DOES refresh after each setTimeout cycle
     *   processWithinAngularZone() {
     *     this.label = 'inside';
     *     this.progress = 0;
     *     this._increaseProgress(() => console.log('Inside Done!'));
     *   }
     *
     *   // Loop outside of the Angular zone
     *   // so the UI DOES NOT refresh after each setTimeout cycle
     *   processOutsideOfAngularZone() {
     *     this.label = 'outside';
     *     this.progress = 0;
     *     this._ngZone.runOutsideAngular(() => {
     *       this._increaseProgress(() => {
     *         // reenter the Angular zone and display done
     *         this._ngZone.run(() => { console.log('Outside Done!'); });
     *       });
     *     });
     *   }
     *
     *   _increaseProgress(doneCallback: () => void) {
     *     this.progress += 1;
     *     console.log(`Current progress: ${this.progress}%`);
     *
     *     if (this.progress < 100) {
     *       window.setTimeout(() => this._increaseProgress(doneCallback), 10);
     *     } else {
     *       doneCallback();
     *     }
     *   }
     * }
     * ```
     *
     * \@publicApi
     */


    class NgZone {
      /**
       * @param {?} __0
       */
      constructor({
        enableLongStackTrace = false
      }) {
        this.hasPendingMicrotasks = false;
        this.hasPendingMacrotasks = false;
        /**
         * Whether there are no outstanding microtasks or macrotasks.
         */

        this.isStable = true;
        /**
         * Notifies when code enters Angular Zone. This gets fired first on VM Turn.
         */

        this.onUnstable = new EventEmitter(false);
        /**
         * Notifies when there is no more microtasks enqueued in the current VM Turn.
         * This is a hint for Angular to do change detection, which may enqueue more microtasks.
         * For this reason this event can fire multiple times per VM Turn.
         */

        this.onMicrotaskEmpty = new EventEmitter(false);
        /**
         * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which
         * implies we are about to relinquish VM turn.
         * This event gets called just once.
         */

        this.onStable = new EventEmitter(false);
        /**
         * Notifies that an error has been delivered.
         */

        this.onError = new EventEmitter(false);

        if (typeof Zone == 'undefined') {
          throw new Error("In this configuration Angular requires Zone.js");
        }

        Zone.assertZonePatched();
        /** @type {?} */

        const self =
        /** @type {?} */

        /** @type {?} */
        this;
        self._nesting = 0;
        self._outer = self._inner = Zone.current;

        if (
        /** @type {?} */
        Zone['wtfZoneSpec']) {
          self._inner = self._inner.fork(
          /** @type {?} */
          Zone['wtfZoneSpec']);
        }

        if (
        /** @type {?} */
        Zone['TaskTrackingZoneSpec']) {
          self._inner = self._inner.fork(new
          /** @type {?} */

          /** @type {?} */
          Zone['TaskTrackingZoneSpec']());
        }

        if (enableLongStackTrace &&
        /** @type {?} */
        Zone['longStackTraceZoneSpec']) {
          self._inner = self._inner.fork(
          /** @type {?} */
          Zone['longStackTraceZoneSpec']);
        }

        forkInnerZoneWithAngularBehavior(self);
      }
      /**
       * @return {?}
       */


      static isInAngularZone() {
        return Zone.current.get('isAngularZone') === true;
      }
      /**
       * @return {?}
       */


      static assertInAngularZone() {
        if (!NgZone.isInAngularZone()) {
          throw new Error('Expected to be in Angular Zone, but it is not!');
        }
      }
      /**
       * @return {?}
       */


      static assertNotInAngularZone() {
        if (NgZone.isInAngularZone()) {
          throw new Error('Expected to not be in Angular Zone, but it is!');
        }
      }
      /**
       * Executes the `fn` function synchronously within the Angular zone and returns value returned by
       * the function.
       *
       * Running functions via `run` allows you to reenter Angular zone from a task that was executed
       * outside of the Angular zone (typically started via {\@link #runOutsideAngular}).
       *
       * Any future tasks or microtasks scheduled from within this function will continue executing from
       * within the Angular zone.
       *
       * If a synchronous error happens it will be rethrown and not reported via `onError`.
       * @template T
       * @param {?} fn
       * @param {?=} applyThis
       * @param {?=} applyArgs
       * @return {?}
       */


      run(fn, applyThis, applyArgs) {
        return (
          /** @type {?} */

          /** @type {?} */

          /** @type {?} */
          this._inner.run(fn, applyThis, applyArgs)
        );
      }
      /**
       * Executes the `fn` function synchronously within the Angular zone as a task and returns value
       * returned by the function.
       *
       * Running functions via `run` allows you to reenter Angular zone from a task that was executed
       * outside of the Angular zone (typically started via {\@link #runOutsideAngular}).
       *
       * Any future tasks or microtasks scheduled from within this function will continue executing from
       * within the Angular zone.
       *
       * If a synchronous error happens it will be rethrown and not reported via `onError`.
       * @template T
       * @param {?} fn
       * @param {?=} applyThis
       * @param {?=} applyArgs
       * @param {?=} name
       * @return {?}
       */


      runTask(fn, applyThis, applyArgs, name) {
        /** @type {?} */
        const zone =
        /** @type {?} */

        /** @type {?} */
        this._inner;
        /** @type {?} */

        const task = zone.scheduleEventTask('NgZoneEvent: ' + name, fn, EMPTY_PAYLOAD, noop$1, noop$1);

        try {
          return (
            /** @type {?} */
            zone.runTask(task, applyThis, applyArgs)
          );
        } finally {
          zone.cancelTask(task);
        }
      }
      /**
       * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not
       * rethrown.
       * @template T
       * @param {?} fn
       * @param {?=} applyThis
       * @param {?=} applyArgs
       * @return {?}
       */


      runGuarded(fn, applyThis, applyArgs) {
        return (
          /** @type {?} */

          /** @type {?} */

          /** @type {?} */
          this._inner.runGuarded(fn, applyThis, applyArgs)
        );
      }
      /**
       * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by
       * the function.
       *
       * Running functions via {\@link #runOutsideAngular} allows you to escape Angular's zone and do
       * work that
       * doesn't trigger Angular change-detection or is subject to Angular's error handling.
       *
       * Any future tasks or microtasks scheduled from within this function will continue executing from
       * outside of the Angular zone.
       *
       * Use {\@link #run} to reenter the Angular zone and do work that updates the application model.
       * @template T
       * @param {?} fn
       * @return {?}
       */


      runOutsideAngular(fn) {
        return (
          /** @type {?} */

          /** @type {?} */

          /** @type {?} */
          this._outer.run(fn)
        );
      }

    }

    if (false) {}
    /**
     * @return {?}
     */


    function noop$1() {}
    /** @type {?} */


    const EMPTY_PAYLOAD = {};
    /**
     * @record
     */

    function NgZonePrivate() {}

    if (false) {}
    /**
     * @param {?} zone
     * @return {?}
     */


    function checkStable(zone) {
      if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {
        try {
          zone._nesting++;
          zone.onMicrotaskEmpty.emit(null);
        } finally {
          zone._nesting--;

          if (!zone.hasPendingMicrotasks) {
            try {
              zone.runOutsideAngular(
              /**
              * @return {?}
              */
              () => zone.onStable.emit(null));
            } finally {
              zone.isStable = true;
            }
          }
        }
      }
    }
    /**
     * @param {?} zone
     * @return {?}
     */


    function forkInnerZoneWithAngularBehavior(zone) {
      zone._inner = zone._inner.fork({
        name: 'angular',
        properties:
        /** @type {?} */
        {
          'isAngularZone': true
        },
        onInvokeTask:
        /**
        * @param {?} delegate
        * @param {?} current
        * @param {?} target
        * @param {?} task
        * @param {?} applyThis
        * @param {?} applyArgs
        * @return {?}
        */
        (delegate, current, target, task, applyThis, applyArgs) => {
          try {
            onEnter(zone);
            return delegate.invokeTask(target, task, applyThis, applyArgs);
          } finally {
            onLeave(zone);
          }
        },
        onInvoke:
        /**
        * @param {?} delegate
        * @param {?} current
        * @param {?} target
        * @param {?} callback
        * @param {?} applyThis
        * @param {?=} applyArgs
        * @param {?=} source
        * @return {?}
        */
        (delegate, current, target, callback, applyThis, applyArgs, source) => {
          try {
            onEnter(zone);
            return delegate.invoke(target, callback, applyThis, applyArgs, source);
          } finally {
            onLeave(zone);
          }
        },
        onHasTask:
        /**
        * @param {?} delegate
        * @param {?} current
        * @param {?} target
        * @param {?} hasTaskState
        * @return {?}
        */
        (delegate, current, target, hasTaskState) => {
          delegate.hasTask(target, hasTaskState);

          if (current === target) {
            // We are only interested in hasTask events which originate from our zone
            // (A child hasTask event is not interesting to us)
            if (hasTaskState.change == 'microTask') {
              zone.hasPendingMicrotasks = hasTaskState.microTask;
              checkStable(zone);
            } else if (hasTaskState.change == 'macroTask') {
              zone.hasPendingMacrotasks = hasTaskState.macroTask;
            }
          }
        },
        onHandleError:
        /**
        * @param {?} delegate
        * @param {?} current
        * @param {?} target
        * @param {?} error
        * @return {?}
        */
        (delegate, current, target, error) => {
          delegate.handleError(target, error);
          zone.runOutsideAngular(
          /**
          * @return {?}
          */
          () => zone.onError.emit(error));
          return false;
        }
      });
    }
    /**
     * @param {?} zone
     * @return {?}
     */


    function onEnter(zone) {
      zone._nesting++;

      if (zone.isStable) {
        zone.isStable = false;
        zone.onUnstable.emit(null);
      }
    }
    /**
     * @param {?} zone
     * @return {?}
     */


    function onLeave(zone) {
      zone._nesting--;
      checkStable(zone);
    }
    /**
     * Provides a noop implementation of `NgZone` which does nothing. This zone requires explicit calls
     * to framework to perform rendering.
     */


    class NoopNgZone {
      constructor() {
        this.hasPendingMicrotasks = false;
        this.hasPendingMacrotasks = false;
        this.isStable = true;
        this.onUnstable = new EventEmitter();
        this.onMicrotaskEmpty = new EventEmitter();
        this.onStable = new EventEmitter();
        this.onError = new EventEmitter();
      }
      /**
       * @param {?} fn
       * @return {?}
       */


      run(fn) {
        return fn();
      }
      /**
       * @param {?} fn
       * @return {?}
       */


      runGuarded(fn) {
        return fn();
      }
      /**
       * @param {?} fn
       * @return {?}
       */


      runOutsideAngular(fn) {
        return fn();
      }
      /**
       * @template T
       * @param {?} fn
       * @return {?}
       */


      runTask(fn) {
        return fn();
      }

    }

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @record
     */


    function PendingMacrotask() {}

    if (false) {}
    /**
     * @record
     */


    function TaskData() {}

    if (false) {}
    /**
     * @record
     */


    function WaitCallback() {}

    if (false) {}
    /**
     * The Testability service provides testing hooks that can be accessed from
     * the browser and by services such as Protractor. Each bootstrapped Angular
     * application on the page will have an instance of Testability.
     * \@publicApi
     */


    class Testability {
      /**
       * @param {?} _ngZone
       */
      constructor(_ngZone) {
        this._ngZone = _ngZone;
        this._pendingCount = 0;
        this._isZoneStable = true;
        /**
         * Whether any work was done since the last 'whenStable' callback. This is
         * useful to detect if this could have potentially destabilized another
         * component while it is stabilizing.
         * \@internal
         */

        this._didWork = false;
        this._callbacks = [];
        this.taskTrackingZone = null;

        this._watchAngularEvents();

        _ngZone.run(
        /**
        * @return {?}
        */
        () => {
          this.taskTrackingZone = typeof Zone == 'undefined' ? null : Zone.current.get('TaskTrackingZone');
        });
      }
      /**
       * @private
       * @return {?}
       */


      _watchAngularEvents() {
        this._ngZone.onUnstable.subscribe({
          next:
          /**
          * @return {?}
          */
          () => {
            this._didWork = true;
            this._isZoneStable = false;
          }
        });

        this._ngZone.runOutsideAngular(
        /**
        * @return {?}
        */
        () => {
          this._ngZone.onStable.subscribe({
            next:
            /**
            * @return {?}
            */
            () => {
              NgZone.assertNotInAngularZone();
              scheduleMicroTask(
              /**
              * @return {?}
              */
              () => {
                this._isZoneStable = true;

                this._runCallbacksIfReady();
              });
            }
          });
        });
      }
      /**
       * Increases the number of pending request
       * @deprecated pending requests are now tracked with zones.
       * @return {?}
       */


      increasePendingRequestCount() {
        this._pendingCount += 1;
        this._didWork = true;
        return this._pendingCount;
      }
      /**
       * Decreases the number of pending request
       * @deprecated pending requests are now tracked with zones
       * @return {?}
       */


      decreasePendingRequestCount() {
        this._pendingCount -= 1;

        if (this._pendingCount < 0) {
          throw new Error('pending async requests below zero');
        }

        this._runCallbacksIfReady();

        return this._pendingCount;
      }
      /**
       * Whether an associated application is stable
       * @return {?}
       */


      isStable() {
        return this._isZoneStable && this._pendingCount === 0 && !this._ngZone.hasPendingMacrotasks;
      }
      /**
       * @private
       * @return {?}
       */


      _runCallbacksIfReady() {
        if (this.isStable()) {
          // Schedules the call backs in a new frame so that it is always async.
          scheduleMicroTask(
          /**
          * @return {?}
          */
          () => {
            while (this._callbacks.length !== 0) {
              /** @type {?} */
              let cb =
              /** @type {?} */
              this._callbacks.pop();

              clearTimeout(cb.timeoutId);
              cb.doneCb(this._didWork);
            }

            this._didWork = false;
          });
        } else {
          // Still not stable, send updates.

          /** @type {?} */
          let pending = this.getPendingTasks();
          this._callbacks = this._callbacks.filter(
          /**
          * @param {?} cb
          * @return {?}
          */
          cb => {
            if (cb.updateCb && cb.updateCb(pending)) {
              clearTimeout(cb.timeoutId);
              return false;
            }

            return true;
          });
          this._didWork = true;
        }
      }
      /**
       * @private
       * @return {?}
       */


      getPendingTasks() {
        if (!this.taskTrackingZone) {
          return [];
        } // Copy the tasks data so that we don't leak tasks.


        return this.taskTrackingZone.macroTasks.map(
        /**
        * @param {?} t
        * @return {?}
        */
        t => {
          return {
            source: t.source,
            // From TaskTrackingZone:
            // https://github.com/angular/zone.js/blob/master/lib/zone-spec/task-tracking.ts#L40
            creationLocation:
            /** @type {?} */

            /** @type {?} */
            t.creationLocation,
            data: t.data
          };
        });
      }
      /**
       * @private
       * @param {?} cb
       * @param {?=} timeout
       * @param {?=} updateCb
       * @return {?}
       */


      addCallback(cb, timeout, updateCb) {
        /** @type {?} */
        let timeoutId = -1;

        if (timeout && timeout > 0) {
          timeoutId = setTimeout(
          /**
          * @return {?}
          */
          () => {
            this._callbacks = this._callbacks.filter(
            /**
            * @param {?} cb
            * @return {?}
            */
            cb => cb.timeoutId !== timeoutId);
            cb(this._didWork, this.getPendingTasks());
          }, timeout);
        }

        this._callbacks.push(
        /** @type {?} */
        {
          doneCb: cb,
          timeoutId: timeoutId,
          updateCb: updateCb
        });
      }
      /**
       * Wait for the application to be stable with a timeout. If the timeout is reached before that
       * happens, the callback receives a list of the macro tasks that were pending, otherwise null.
       *
       * @param {?} doneCb The callback to invoke when Angular is stable or the timeout expires
       *    whichever comes first.
       * @param {?=} timeout Optional. The maximum time to wait for Angular to become stable. If not
       *    specified, whenStable() will wait forever.
       * @param {?=} updateCb Optional. If specified, this callback will be invoked whenever the set of
       *    pending macrotasks changes. If this callback returns true doneCb will not be invoked
       *    and no further updates will be issued.
       * @return {?}
       */


      whenStable(doneCb, timeout, updateCb) {
        if (updateCb && !this.taskTrackingZone) {
          throw new Error('Task tracking zone is required when passing an update callback to ' + 'whenStable(). Is "zone.js/dist/task-tracking.js" loaded?');
        } // These arguments are 'Function' above to keep the public API simple.


        this.addCallback(
        /** @type {?} */
        doneCb, timeout,
        /** @type {?} */
        updateCb);

        this._runCallbacksIfReady();
      }
      /**
       * Get the number of pending requests
       * @deprecated pending requests are now tracked with zones
       * @return {?}
       */


      getPendingRequestCount() {
        return this._pendingCount;
      }
      /**
       * Find providers by name
       * @param {?} using The root element to search from
       * @param {?} provider The name of binding variable
       * @param {?} exactMatch Whether using exactMatch
       * @return {?}
       */


      findProviders(using, provider, exactMatch) {
        // TODO(juliemr): implement.
        return [];
      }

    }

    Testability.decorators = [{
      type: Injectable
    }];
    /** @nocollapse */

    Testability.ctorParameters = () => [{
      type: NgZone
    }];

    if (false) {}
    /**
     * A global registry of {\@link Testability} instances for specific elements.
     * \@publicApi
     */


    class TestabilityRegistry {
      constructor() {
        /**
         * \@internal
         */
        this._applications = new Map();

        _testabilityGetter.addToWindow(this);
      }
      /**
       * Registers an application with a testability hook so that it can be tracked
       * @param {?} token token of application, root element
       * @param {?} testability Testability hook
       * @return {?}
       */


      registerApplication(token, testability) {
        this._applications.set(token, testability);
      }
      /**
       * Unregisters an application.
       * @param {?} token token of application, root element
       * @return {?}
       */


      unregisterApplication(token) {
        this._applications.delete(token);
      }
      /**
       * Unregisters all applications
       * @return {?}
       */


      unregisterAllApplications() {
        this._applications.clear();
      }
      /**
       * Get a testability hook associated with the application
       * @param {?} elem root element
       * @return {?}
       */


      getTestability(elem) {
        return this._applications.get(elem) || null;
      }
      /**
       * Get all registered testabilities
       * @return {?}
       */


      getAllTestabilities() {
        return Array.from(this._applications.values());
      }
      /**
       * Get all registered applications(root elements)
       * @return {?}
       */


      getAllRootElements() {
        return Array.from(this._applications.keys());
      }
      /**
       * Find testability of a node in the Tree
       * @param {?} elem node
       * @param {?=} findInAncestors whether finding testability in ancestors if testability was not found in
       * current node
       * @return {?}
       */


      findTestabilityInTree(elem, findInAncestors = true) {
        return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors);
      }

    }

    TestabilityRegistry.decorators = [{
      type: Injectable
    }];
    /** @nocollapse */

    TestabilityRegistry.ctorParameters = () => [];

    if (false) {}
    /**
     * Adapter interface for retrieving the `Testability` service associated for a
     * particular context.
     *
     * \@publicApi
     * @record
     */


    function GetTestability() {}

    if (false) {}

    class _NoopGetTestability {
      /**
       * @param {?} registry
       * @return {?}
       */
      addToWindow(registry) {}
      /**
       * @param {?} registry
       * @param {?} elem
       * @param {?} findInAncestors
       * @return {?}
       */


      findTestabilityInTree(registry, elem, findInAncestors) {
        return null;
      }

    }
    /**
     * Set the {\@link GetTestability} implementation used by the Angular testing framework.
     * \@publicApi
     * @param {?} getter
     * @return {?}
     */


    function setTestabilityGetter(getter) {
      _testabilityGetter = getter;
    }
    /** @type {?} */


    let _testabilityGetter = new _NoopGetTestability();
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    let _platform;
    /** @type {?} */


    let compileNgModuleFactory = compileNgModuleFactory__PRE_R3__;
    /**
     * @template M
     * @param {?} injector
     * @param {?} options
     * @param {?} moduleType
     * @return {?}
     */

    function compileNgModuleFactory__PRE_R3__(injector, options, moduleType) {
      /** @type {?} */
      const compilerFactory = injector.get(CompilerFactory);
      /** @type {?} */

      const compiler = compilerFactory.createCompiler([options]);
      return compiler.compileModuleAsync(moduleType);
    }
    /**
     * @template M
     * @param {?} injector
     * @param {?} options
     * @param {?} moduleType
     * @return {?}
     */


    function compileNgModuleFactory__POST_R3__(injector, options, moduleType) {
      ngDevMode && assertNgModuleType(moduleType);
      /** @type {?} */

      const moduleFactory = new NgModuleFactory$1(moduleType);

      if (isComponentResourceResolutionQueueEmpty()) {
        return Promise.resolve(moduleFactory);
      }
      /** @type {?} */


      const compilerOptions = injector.get(COMPILER_OPTIONS, []).concat(options);
      /** @type {?} */

      const compilerProviders = _mergeArrays(compilerOptions.map(
      /**
      * @param {?} o
      * @return {?}
      */
      o =>
      /** @type {?} */
      o.providers)); // In case there are no compiler providers, we just return the module factory as
      // there won't be any resource loader. This can happen with Ivy, because AOT compiled
      // modules can be still passed through "bootstrapModule". In that case we shouldn't
      // unnecessarily require the JIT compiler.


      if (compilerProviders.length === 0) {
        return Promise.resolve(moduleFactory);
      }
      /** @type {?} */


      const compiler = getCompilerFacade();
      /** @type {?} */

      const compilerInjector = Injector.create({
        providers: compilerProviders
      });
      /** @type {?} */

      const resourceLoader = compilerInjector.get(compiler.ResourceLoader); // The resource loader can also return a string while the "resolveComponentResources"
      // always expects a promise. Therefore we need to wrap the returned value in a promise.

      return resolveComponentResources(
      /**
      * @param {?} url
      * @return {?}
      */
      url => Promise.resolve(resourceLoader.get(url))).then(
      /**
      * @return {?}
      */
      () => moduleFactory);
    }
    /** @type {?} */


    let isBoundToModule = isBoundToModule__PRE_R3__;
    /**
     * @template C
     * @param {?} cf
     * @return {?}
     */

    function isBoundToModule__PRE_R3__(cf) {
      return cf instanceof ComponentFactoryBoundToModule;
    }
    /**
     * @template C
     * @param {?} cf
     * @return {?}
     */


    function isBoundToModule__POST_R3__(cf) {
      return (
        /** @type {?} */
        cf.isBoundToModule
      );
    }
    /** @type {?} */


    const ALLOW_MULTIPLE_PLATFORMS = new InjectionToken('AllowMultipleToken');
    /**
     * A token for third-party components that can register themselves with NgProbe.
     *
     * \@publicApi
     */

    class NgProbeToken {
      /**
       * @param {?} name
       * @param {?} token
       */
      constructor(name, token) {
        this.name = name;
        this.token = token;
      }

    }

    if (false) {}
    /**
     * Creates a platform.
     * Platforms have to be eagerly created via this function.
     *
     * \@publicApi
     * @param {?} injector
     * @return {?}
     */


    function createPlatform(injector) {
      if (_platform && !_platform.destroyed && !_platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
        throw new Error('There can be only one platform. Destroy the previous one to create a new one.');
      }

      _platform = injector.get(PlatformRef);
      /** @type {?} */

      const inits = injector.get(PLATFORM_INITIALIZER, null);
      if (inits) inits.forEach(
      /**
      * @param {?} init
      * @return {?}
      */
      init => init());
      return _platform;
    }
    /**
     * Creates a factory for a platform
     *
     * \@publicApi
     * @param {?} parentPlatformFactory
     * @param {?} name
     * @param {?=} providers
     * @return {?}
     */


    function createPlatformFactory(parentPlatformFactory, name, providers = []) {
      /** @type {?} */
      const desc = "Platform: ".concat(name);
      /** @type {?} */

      const marker = new InjectionToken(desc);
      return (
        /**
        * @param {?=} extraProviders
        * @return {?}
        */
        (extraProviders = []) => {
          /** @type {?} */
          let platform = getPlatform();

          if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {
            if (parentPlatformFactory) {
              parentPlatformFactory(providers.concat(extraProviders).concat({
                provide: marker,
                useValue: true
              }));
            } else {
              /** @type {?} */
              const injectedProviders = providers.concat(extraProviders).concat({
                provide: marker,
                useValue: true
              });
              createPlatform(Injector.create({
                providers: injectedProviders,
                name: desc
              }));
            }
          }

          return assertPlatform(marker);
        }
      );
    }
    /**
     * Checks that there currently is a platform which contains the given token as a provider.
     *
     * \@publicApi
     * @param {?} requiredToken
     * @return {?}
     */


    function assertPlatform(requiredToken) {
      /** @type {?} */
      const platform = getPlatform();

      if (!platform) {
        throw new Error('No platform exists!');
      }

      if (!platform.injector.get(requiredToken, null)) {
        throw new Error('A platform with a different configuration has been created. Please destroy it first.');
      }

      return platform;
    }
    /**
     * Destroy the existing platform.
     *
     * \@publicApi
     * @return {?}
     */


    function destroyPlatform() {
      if (_platform && !_platform.destroyed) {
        _platform.destroy();
      }
    }
    /**
     * Returns the current platform.
     *
     * \@publicApi
     * @return {?}
     */


    function getPlatform() {
      return _platform && !_platform.destroyed ? _platform : null;
    }
    /**
     * Provides additional options to the bootstraping process.
     *
     *
     * @record
     */


    function BootstrapOptions() {}

    if (false) {}
    /**
     * The Angular platform is the entry point for Angular on a web page. Each page
     * has exactly one platform, and services (such as reflection) which are common
     * to every Angular application running on the page are bound in its scope.
     *
     * A page's platform is initialized implicitly when a platform is created via a platform factory
     * (e.g. {\@link platformBrowser}), or explicitly by calling the {\@link createPlatform} function.
     *
     * \@publicApi
     */


    class PlatformRef {
      /**
       * \@internal
       * @param {?} _injector
       */
      constructor(_injector) {
        this._injector = _injector;
        this._modules = [];
        this._destroyListeners = [];
        this._destroyed = false;
      }
      /**
       * Creates an instance of an `\@NgModule` for the given platform
       * for offline compilation.
       *
       * \@usageNotes
       * ### Simple Example
       *
       * ```typescript
       * my_module.ts:
       *
       * \@NgModule({
       *   imports: [BrowserModule]
       * })
       * class MyModule {}
       *
       * main.ts:
       * import {MyModuleNgFactory} from './my_module.ngfactory';
       * import {platformBrowser} from '\@angular/platform-browser';
       *
       * let moduleRef = platformBrowser().bootstrapModuleFactory(MyModuleNgFactory);
       * ```
       * @template M
       * @param {?} moduleFactory
       * @param {?=} options
       * @return {?}
       */


      bootstrapModuleFactory(moduleFactory, options) {
        // Note: We need to create the NgZone _before_ we instantiate the module,
        // as instantiating the module creates some providers eagerly.
        // So we create a mini parent injector that just contains the new NgZone and
        // pass that as parent to the NgModuleFactory.

        /** @type {?} */
        const ngZoneOption = options ? options.ngZone : undefined;
        /** @type {?} */

        const ngZone = getNgZone(ngZoneOption);
        /** @type {?} */

        const providers = [{
          provide: NgZone,
          useValue: ngZone
        }]; // Attention: Don't use ApplicationRef.run here,
        // as we want to be sure that all possible constructor calls are inside `ngZone.run`!

        return ngZone.run(
        /**
        * @return {?}
        */
        () => {
          /** @type {?} */
          const ngZoneInjector = Injector.create({
            providers: providers,
            parent: this.injector,
            name: moduleFactory.moduleType.name
          });
          /** @type {?} */

          const moduleRef =
          /** @type {?} */
          moduleFactory.create(ngZoneInjector);
          /** @type {?} */

          const exceptionHandler = moduleRef.injector.get(ErrorHandler, null);

          if (!exceptionHandler) {
            throw new Error('No ErrorHandler. Is platform module (BrowserModule) included?');
          } // If the `LOCALE_ID` provider is defined at bootstrap we set the value for runtime i18n (ivy)


          if (ivyEnabled) {
            /** @type {?} */
            const localeId = moduleRef.injector.get(LOCALE_ID$1, DEFAULT_LOCALE_ID);
            setLocaleId(localeId || DEFAULT_LOCALE_ID);
          }

          moduleRef.onDestroy(
          /**
          * @return {?}
          */
          () => remove(this._modules, moduleRef));

          /** @type {?} */
          ngZone.runOutsideAngular(
          /**
          * @return {?}
          */
          () =>
          /** @type {?} */
          ngZone.onError.subscribe({
            next:
            /**
            * @param {?} error
            * @return {?}
            */
            error => {
              exceptionHandler.handleError(error);
            }
          }));
          return _callAndReportToErrorHandler(exceptionHandler,
          /** @type {?} */
          ngZone,
          /**
          * @return {?}
          */
          () => {
            /** @type {?} */
            const initStatus = moduleRef.injector.get(ApplicationInitStatus);
            initStatus.runInitializers();
            return initStatus.donePromise.then(
            /**
            * @return {?}
            */
            () => {
              this._moduleDoBootstrap(moduleRef);

              return moduleRef;
            });
          });
        });
      }
      /**
       * Creates an instance of an `\@NgModule` for a given platform using the given runtime compiler.
       *
       * \@usageNotes
       * ### Simple Example
       *
       * ```typescript
       * \@NgModule({
       *   imports: [BrowserModule]
       * })
       * class MyModule {}
       *
       * let moduleRef = platformBrowser().bootstrapModule(MyModule);
       * ```
       *
       * @template M
       * @param {?} moduleType
       * @param {?=} compilerOptions
       * @return {?}
       */


      bootstrapModule(moduleType, compilerOptions = []) {
        /** @type {?} */
        const options = optionsReducer({}, compilerOptions);
        return compileNgModuleFactory(this.injector, options, moduleType).then(
        /**
        * @param {?} moduleFactory
        * @return {?}
        */
        moduleFactory => this.bootstrapModuleFactory(moduleFactory, options));
      }
      /**
       * @private
       * @param {?} moduleRef
       * @return {?}
       */


      _moduleDoBootstrap(moduleRef) {
        /** @type {?} */
        const appRef =
        /** @type {?} */
        moduleRef.injector.get(ApplicationRef);

        if (moduleRef._bootstrapComponents.length > 0) {
          moduleRef._bootstrapComponents.forEach(
          /**
          * @param {?} f
          * @return {?}
          */
          f => appRef.bootstrap(f));
        } else if (moduleRef.instance.ngDoBootstrap) {
          moduleRef.instance.ngDoBootstrap(appRef);
        } else {
          throw new Error("The module ".concat(stringify(moduleRef.instance.constructor), " was bootstrapped, but it does not declare \"@NgModule.bootstrap\" components nor a \"ngDoBootstrap\" method. ") + "Please define one of these.");
        }

        this._modules.push(moduleRef);
      }
      /**
       * Register a listener to be called when the platform is disposed.
       * @param {?} callback
       * @return {?}
       */


      onDestroy(callback) {
        this._destroyListeners.push(callback);
      }
      /**
       * Retrieve the platform {\@link Injector}, which is the parent injector for
       * every Angular application on the page and provides singleton providers.
       * @return {?}
       */


      get injector() {
        return this._injector;
      }
      /**
       * Destroy the Angular platform and all Angular applications on the page.
       * @return {?}
       */


      destroy() {
        if (this._destroyed) {
          throw new Error('The platform has already been destroyed!');
        }

        this._modules.slice().forEach(
        /**
        * @param {?} module
        * @return {?}
        */
        module => module.destroy());

        this._destroyListeners.forEach(
        /**
        * @param {?} listener
        * @return {?}
        */
        listener => listener());

        this._destroyed = true;
      }
      /**
       * @return {?}
       */


      get destroyed() {
        return this._destroyed;
      }

    }

    PlatformRef.decorators = [{
      type: Injectable
    }];
    /** @nocollapse */

    PlatformRef.ctorParameters = () => [{
      type: Injector
    }];

    if (false) {}
    /**
     * @param {?=} ngZoneOption
     * @return {?}
     */


    function getNgZone(ngZoneOption) {
      /** @type {?} */
      let ngZone;

      if (ngZoneOption === 'noop') {
        ngZone = new NoopNgZone();
      } else {
        ngZone = (ngZoneOption === 'zone.js' ? undefined : ngZoneOption) || new NgZone({
          enableLongStackTrace: isDevMode()
        });
      }

      return ngZone;
    }
    /**
     * @param {?} errorHandler
     * @param {?} ngZone
     * @param {?} callback
     * @return {?}
     */


    function _callAndReportToErrorHandler(errorHandler, ngZone, callback) {
      try {
        /** @type {?} */
        const result = callback();

        if (isPromise(result)) {
          return result.catch(
          /**
          * @param {?} e
          * @return {?}
          */
          e => {
            ngZone.runOutsideAngular(
            /**
            * @return {?}
            */
            () => errorHandler.handleError(e)); // rethrow as the exception handler might not do it

            throw e;
          });
        }

        return result;
      } catch (e) {
        ngZone.runOutsideAngular(
        /**
        * @return {?}
        */
        () => errorHandler.handleError(e)); // rethrow as the exception handler might not do it

        throw e;
      }
    }
    /**
     * @template T
     * @param {?} dst
     * @param {?} objs
     * @return {?}
     */


    function optionsReducer(dst, objs) {
      if (Array.isArray(objs)) {
        dst = objs.reduce(optionsReducer, dst);
      } else {
        dst = Object.assign({}, dst,
        /** @type {?} */
        objs);
      }

      return dst;
    }
    /**
     * A reference to an Angular application running on a page.
     *
     * \@usageNotes
     *
     * {\@a is-stable-examples}
     * ### isStable examples and caveats
     *
     * Note two important points about `isStable`, demonstrated in the examples below:
     * - the application will never be stable if you start any kind
     * of recurrent asynchronous task when the application starts
     * (for example for a polling process, started with a `setInterval`, a `setTimeout`
     * or using RxJS operators like `interval`);
     * - the `isStable` Observable runs outside of the Angular zone.
     *
     * Let's imagine that you start a recurrent task
     * (here incrementing a counter, using RxJS `interval`),
     * and at the same time subscribe to `isStable`.
     *
     * ```
     * constructor(appRef: ApplicationRef) {
     *   appRef.isStable.pipe(
     *      filter(stable => stable)
     *   ).subscribe(() => console.log('App is stable now');
     *   interval(1000).subscribe(counter => console.log(counter));
     * }
     * ```
     * In this example, `isStable` will never emit `true`,
     * and the trace "App is stable now" will never get logged.
     *
     * If you want to execute something when the app is stable,
     * you have to wait for the application to be stable
     * before starting your polling process.
     *
     * ```
     * constructor(appRef: ApplicationRef) {
     *   appRef.isStable.pipe(
     *     first(stable => stable),
     *     tap(stable => console.log('App is stable now')),
     *     switchMap(() => interval(1000))
     *   ).subscribe(counter => console.log(counter));
     * }
     * ```
     * In this example, the trace "App is stable now" will be logged
     * and then the counter starts incrementing every second.
     *
     * Note also that this Observable runs outside of the Angular zone,
     * which means that the code in the subscription
     * to this Observable will not trigger the change detection.
     *
     * Let's imagine that instead of logging the counter value,
     * you update a field of your component
     * and display it in its template.
     *
     * ```
     * constructor(appRef: ApplicationRef) {
     *   appRef.isStable.pipe(
     *     first(stable => stable),
     *     switchMap(() => interval(1000))
     *   ).subscribe(counter => this.value = counter);
     * }
     * ```
     * As the `isStable` Observable runs outside the zone,
     * the `value` field will be updated properly,
     * but the template will not be refreshed!
     *
     * You'll have to manually trigger the change detection to update the template.
     *
     * ```
     * constructor(appRef: ApplicationRef, cd: ChangeDetectorRef) {
     *   appRef.isStable.pipe(
     *     first(stable => stable),
     *     switchMap(() => interval(1000))
     *   ).subscribe(counter => {
     *     this.value = counter;
     *     cd.detectChanges();
     *   });
     * }
     * ```
     *
     * Or make the subscription callback run inside the zone.
     *
     * ```
     * constructor(appRef: ApplicationRef, zone: NgZone) {
     *   appRef.isStable.pipe(
     *     first(stable => stable),
     *     switchMap(() => interval(1000))
     *   ).subscribe(counter => zone.run(() => this.value = counter));
     * }
     * ```
     *
     * \@publicApi
     */


    class ApplicationRef {
      /**
       * \@internal
       * @param {?} _zone
       * @param {?} _console
       * @param {?} _injector
       * @param {?} _exceptionHandler
       * @param {?} _componentFactoryResolver
       * @param {?} _initStatus
       */
      constructor(_zone, _console, _injector, _exceptionHandler, _componentFactoryResolver, _initStatus) {
        this._zone = _zone;
        this._console = _console;
        this._injector = _injector;
        this._exceptionHandler = _exceptionHandler;
        this._componentFactoryResolver = _componentFactoryResolver;
        this._initStatus = _initStatus;
        this._bootstrapListeners = [];
        this._views = [];
        this._runningTick = false;
        this._enforceNoNewChanges = false;
        this._stable = true;
        /**
         * Get a list of component types registered to this application.
         * This list is populated even before the component is created.
         */

        this.componentTypes = [];
        /**
         * Get a list of components registered to this application.
         */

        this.components = [];
        this._enforceNoNewChanges = isDevMode();

        this._zone.onMicrotaskEmpty.subscribe({
          next:
          /**
          * @return {?}
          */
          () => {
            this._zone.run(
            /**
            * @return {?}
            */
            () => {
              this.tick();
            });
          }
        });
        /** @type {?} */


        const isCurrentlyStable = new rxjs__WEBPACK_IMPORTED_MODULE_0__["Observable"](
        /**
        * @param {?} observer
        * @return {?}
        */
        observer => {
          this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks;

          this._zone.runOutsideAngular(
          /**
          * @return {?}
          */
          () => {
            observer.next(this._stable);
            observer.complete();
          });
        });
        /** @type {?} */

        const isStable = new rxjs__WEBPACK_IMPORTED_MODULE_0__["Observable"](
        /**
        * @param {?} observer
        * @return {?}
        */
        observer => {
          // Create the subscription to onStable outside the Angular Zone so that
          // the callback is run outside the Angular Zone.

          /** @type {?} */
          let stableSub;

          this._zone.runOutsideAngular(
          /**
          * @return {?}
          */
          () => {
            stableSub = this._zone.onStable.subscribe(
            /**
            * @return {?}
            */
            () => {
              NgZone.assertNotInAngularZone(); // Check whether there are no pending macro/micro tasks in the next tick
              // to allow for NgZone to update the state.

              scheduleMicroTask(
              /**
              * @return {?}
              */
              () => {
                if (!this._stable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks) {
                  this._stable = true;
                  observer.next(true);
                }
              });
            });
          });
          /** @type {?} */


          const unstableSub = this._zone.onUnstable.subscribe(
          /**
          * @return {?}
          */
          () => {
            NgZone.assertInAngularZone();

            if (this._stable) {
              this._stable = false;

              this._zone.runOutsideAngular(
              /**
              * @return {?}
              */
              () => {
                observer.next(false);
              });
            }
          });

          return (
            /**
            * @return {?}
            */
            () => {
              stableSub.unsubscribe();
              unstableSub.unsubscribe();
            }
          );
        });

        /** @type {?} */
        this.isStable = Object(rxjs__WEBPACK_IMPORTED_MODULE_0__["merge"])(isCurrentlyStable, isStable.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_1__["share"])()));
      }
      /**
       * Bootstrap a new component at the root level of the application.
       *
       * \@usageNotes
       * ### Bootstrap process
       *
       * When bootstrapping a new root component into an application, Angular mounts the
       * specified application component onto DOM elements identified by the componentType's
       * selector and kicks off automatic change detection to finish initializing the component.
       *
       * Optionally, a component can be mounted onto a DOM element that does not match the
       * componentType's selector.
       *
       * ### Example
       * {\@example core/ts/platform/platform.ts region='longform'}
       * @template C
       * @param {?} componentOrFactory
       * @param {?=} rootSelectorOrNode
       * @return {?}
       */


      bootstrap(componentOrFactory, rootSelectorOrNode) {
        if (!this._initStatus.done) {
          throw new Error('Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.');
        }
        /** @type {?} */


        let componentFactory;

        if (componentOrFactory instanceof ComponentFactory) {
          componentFactory = componentOrFactory;
        } else {
          componentFactory =
          /** @type {?} */
          this._componentFactoryResolver.resolveComponentFactory(componentOrFactory);
        }

        this.componentTypes.push(componentFactory.componentType); // Create a factory associated with the current module if it's not bound to some other

        /** @type {?} */

        const ngModule = isBoundToModule(componentFactory) ? null : this._injector.get(NgModuleRef);
        /** @type {?} */

        const selectorOrNode = rootSelectorOrNode || componentFactory.selector;
        /** @type {?} */

        const compRef = componentFactory.create(Injector.NULL, [], selectorOrNode, ngModule);
        compRef.onDestroy(
        /**
        * @return {?}
        */
        () => {
          this._unloadComponent(compRef);
        });
        /** @type {?} */

        const testability = compRef.injector.get(Testability, null);

        if (testability) {
          compRef.injector.get(TestabilityRegistry).registerApplication(compRef.location.nativeElement, testability);
        }

        this._loadComponent(compRef);

        if (isDevMode()) {
          this._console.log("Angular is running in the development mode. Call enableProdMode() to enable the production mode.");
        }

        return compRef;
      }
      /**
       * Invoke this method to explicitly process change detection and its side-effects.
       *
       * In development mode, `tick()` also performs a second change detection cycle to ensure that no
       * further changes are detected. If additional changes are picked up during this second cycle,
       * bindings in the app have side-effects that cannot be resolved in a single change detection
       * pass.
       * In this case, Angular throws an error, since an Angular application can only have one change
       * detection pass during which all change detection must complete.
       * @return {?}
       */


      tick() {
        if (this._runningTick) {
          throw new Error('ApplicationRef.tick is called recursively');
        }
        /** @type {?} */


        const scope = ApplicationRef._tickScope();

        try {
          this._runningTick = true;

          for (let view of this._views) {
            view.detectChanges();
          }

          if (this._enforceNoNewChanges) {
            for (let view of this._views) {
              view.checkNoChanges();
            }
          }
        } catch (e) {
          // Attention: Don't rethrow as it could cancel subscriptions to Observables!
          this._zone.runOutsideAngular(
          /**
          * @return {?}
          */
          () => this._exceptionHandler.handleError(e));
        } finally {
          this._runningTick = false;
          wtfLeave(scope);
        }
      }
      /**
       * Attaches a view so that it will be dirty checked.
       * The view will be automatically detached when it is destroyed.
       * This will throw if the view is already attached to a ViewContainer.
       * @param {?} viewRef
       * @return {?}
       */


      attachView(viewRef) {
        /** @type {?} */
        const view =
        /** @type {?} */
        viewRef;

        this._views.push(view);

        view.attachToAppRef(this);
      }
      /**
       * Detaches a view from dirty checking again.
       * @param {?} viewRef
       * @return {?}
       */


      detachView(viewRef) {
        /** @type {?} */
        const view =
        /** @type {?} */
        viewRef;
        remove(this._views, view);
        view.detachFromAppRef();
      }
      /**
       * @private
       * @param {?} componentRef
       * @return {?}
       */


      _loadComponent(componentRef) {
        this.attachView(componentRef.hostView);
        this.tick();
        this.components.push(componentRef); // Get the listeners lazily to prevent DI cycles.

        /** @type {?} */

        const listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, []).concat(this._bootstrapListeners);

        listeners.forEach(
        /**
        * @param {?} listener
        * @return {?}
        */
        listener => listener(componentRef));
      }
      /**
       * @private
       * @param {?} componentRef
       * @return {?}
       */


      _unloadComponent(componentRef) {
        this.detachView(componentRef.hostView);
        remove(this.components, componentRef);
      }
      /**
       * \@internal
       * @return {?}
       */


      ngOnDestroy() {
        // TODO(alxhub): Dispose of the NgZone.
        this._views.slice().forEach(
        /**
        * @param {?} view
        * @return {?}
        */
        view => view.destroy());
      }
      /**
       * Returns the number of attached views.
       * @return {?}
       */


      get viewCount() {
        return this._views.length;
      }

    }
    /**
     * \@internal
     */


    ApplicationRef._tickScope = wtfCreateScope('ApplicationRef#tick()');
    ApplicationRef.decorators = [{
      type: Injectable
    }];
    /** @nocollapse */

    ApplicationRef.ctorParameters = () => [{
      type: NgZone
    }, {
      type: Console
    }, {
      type: Injector
    }, {
      type: ErrorHandler
    }, {
      type: ComponentFactoryResolver
    }, {
      type: ApplicationInitStatus
    }];

    if (false) {}
    /**
     * @template T
     * @param {?} list
     * @param {?} el
     * @return {?}
     */


    function remove(list, el) {
      /** @type {?} */
      const index = list.indexOf(el);

      if (index > -1) {
        list.splice(index, 1);
      }
    }
    /**
     * @param {?} parts
     * @return {?}
     */


    function _mergeArrays(parts) {
      /** @type {?} */
      const result = [];
      parts.forEach(
      /**
      * @param {?} part
      * @return {?}
      */
      part => part && result.push(...part));
      return result;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Used to load ng module factories.
     *
     * \@publicApi
     * @deprecated the `string` form of `loadChildren` is deprecated, and `NgModuleFactoryLoader` is
     * part of its implementation. See `LoadChildren` for more details.
     * @abstract
     */


    class NgModuleFactoryLoader {}

    if (false) {}
    /**
     * @param {?} id
     * @return {?}
     */


    function getModuleFactory__PRE_R3__(id) {
      /** @type {?} */
      const factory =
      /** @type {?} */
      getRegisteredNgModuleType(id);
      if (!factory) throw noModuleError(id);
      return factory;
    }
    /**
     * @param {?} id
     * @return {?}
     */


    function getModuleFactory__POST_R3__(id) {
      /** @type {?} */
      const type =
      /** @type {?} */
      getRegisteredNgModuleType(id);
      if (!type) throw noModuleError(id);
      return new NgModuleFactory$1(type);
    }
    /**
     * Returns the NgModuleFactory with the given id, if it exists and has been loaded.
     * Factories for modules that do not specify an `id` cannot be retrieved. Throws if the module
     * cannot be found.
     * \@publicApi
     * @type {?}
     */


    const getModuleFactory = getModuleFactory__PRE_R3__;
    /**
     * @param {?} id
     * @return {?}
     */

    function noModuleError(id) {
      return new Error("No module with ID ".concat(id, " loaded"));
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    const _SEPARATOR = '#';
    /** @type {?} */

    const FACTORY_CLASS_SUFFIX = 'NgFactory';
    /**
     * Configuration for SystemJsNgModuleLoader.
     * token.
     *
     * \@publicApi
     * @deprecated the `string` form of `loadChildren` is deprecated, and `SystemJsNgModuleLoaderConfig`
     * is part of its implementation. See `LoadChildren` for more details.
     * @abstract
     */

    class SystemJsNgModuleLoaderConfig {}

    if (false) {}
    /** @type {?} */


    const DEFAULT_CONFIG = {
      factoryPathPrefix: '',
      factoryPathSuffix: '.ngfactory'
    };
    /**
     * NgModuleFactoryLoader that uses SystemJS to load NgModuleFactory
     * \@publicApi
     * @deprecated the `string` form of `loadChildren` is deprecated, and `SystemJsNgModuleLoader` is
     * part of its implementation. See `LoadChildren` for more details.
     */

    class SystemJsNgModuleLoader {
      /**
       * @param {?} _compiler
       * @param {?=} config
       */
      constructor(_compiler, config) {
        this._compiler = _compiler;
        this._config = config || DEFAULT_CONFIG;
      }
      /**
       * @param {?} path
       * @return {?}
       */


      load(path) {
        /** @type {?} */
        const legacyOfflineMode = !ivyEnabled && this._compiler instanceof Compiler;
        return legacyOfflineMode ? this.loadFactory(path) : this.loadAndCompile(path);
      }
      /**
       * @private
       * @param {?} path
       * @return {?}
       */


      loadAndCompile(path) {
        let [module, exportName] = path.split(_SEPARATOR);

        if (exportName === undefined) {
          exportName = 'default';
        }

        return __webpack_require__("./$$_lazy_route_resource lazy recursive")(module).then(
        /**
        * @param {?} module
        * @return {?}
        */
        module => module[exportName]).then(
        /**
        * @param {?} type
        * @return {?}
        */
        type => checkNotEmpty(type, module, exportName)).then(
        /**
        * @param {?} type
        * @return {?}
        */
        type => this._compiler.compileModuleAsync(type));
      }
      /**
       * @private
       * @param {?} path
       * @return {?}
       */


      loadFactory(path) {
        let [module, exportName] = path.split(_SEPARATOR);
        /** @type {?} */

        let factoryClassSuffix = FACTORY_CLASS_SUFFIX;

        if (exportName === undefined) {
          exportName = 'default';
          factoryClassSuffix = '';
        }

        return __webpack_require__("./$$_lazy_route_resource lazy recursive")(this._config.factoryPathPrefix + module + this._config.factoryPathSuffix).then(
        /**
        * @param {?} module
        * @return {?}
        */
        module => module[exportName + factoryClassSuffix]).then(
        /**
        * @param {?} factory
        * @return {?}
        */
        factory => checkNotEmpty(factory, module, exportName));
      }

    }

    SystemJsNgModuleLoader.decorators = [{
      type: Injectable
    }];
    /** @nocollapse */

    SystemJsNgModuleLoader.ctorParameters = () => [{
      type: Compiler
    }, {
      type: SystemJsNgModuleLoaderConfig,
      decorators: [{
        type: Optional
      }]
    }];

    if (false) {}
    /**
     * @param {?} value
     * @param {?} modulePath
     * @param {?} exportName
     * @return {?}
     */


    function checkNotEmpty(value, modulePath, exportName) {
      if (!value) {
        throw new Error("Cannot find '".concat(exportName, "' in '").concat(modulePath, "'"));
      }

      return value;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Represents an Angular [view](guide/glossary#view),
     * specifically the [host view](guide/glossary#view-tree) that is defined by a component.
     * Also serves as the base class
     * that adds destroy methods for [embedded views](guide/glossary#view-tree).
     *
     * @see `EmbeddedViewRef`
     *
     * \@publicApi
     * @abstract
     */


    class ViewRef$1 extends ChangeDetectorRef {}

    if (false) {}
    /**
     * Represents an Angular [view](guide/glossary#view) in a view container.
     * An [embedded view](guide/glossary#view-tree) can be referenced from a component
     * other than the hosting component whose template defines it, or it can be defined
     * independently by a `TemplateRef`.
     *
     * Properties of elements in a view can change, but the structure (number and order) of elements in
     * a view cannot. Change the structure of elements by inserting, moving, or
     * removing nested views in a view container.
     *
     * @see `ViewContainerRef`
     *
     * \@usageNotes
     *
     * The following template breaks down into two separate `TemplateRef` instances,
     * an outer one and an inner one.
     *
     * ```
     * Count: {{items.length}}
     * <ul>
     *   <li *ngFor="let  item of items">{{item}}</li>
     * </ul>
     * ```
     *
     * This is the outer `TemplateRef`:
     *
     * ```
     * Count: {{items.length}}
     * <ul>
     *   <ng-template ngFor let-item [ngForOf]="items"></ng-template>
     * </ul>
     * ```
     *
     * This is the inner `TemplateRef`:
     *
     * ```
     *   <li>{{item}}</li>
     * ```
     *
     * The outer and inner `TemplateRef` instances are assembled into views as follows:
     *
     * ```
     * <!-- ViewRef: outer-0 -->
     * Count: 2
     * <ul>
     *   <ng-template view-container-ref></ng-template>
     *   <!-- ViewRef: inner-1 --><li>first</li><!-- /ViewRef: inner-1 -->
     *   <!-- ViewRef: inner-2 --><li>second</li><!-- /ViewRef: inner-2 -->
     * </ul>
     * <!-- /ViewRef: outer-0 -->
     * ```
     * \@publicApi
     * @abstract
     * @template C
     */


    class EmbeddedViewRef extends ViewRef$1 {}

    if (false) {}
    /**
     * @record
     */


    function InternalViewRef() {}

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * \@publicApi
     */


    class DebugEventListener {
      /**
       * @param {?} name
       * @param {?} callback
       */
      constructor(name, callback) {
        this.name = name;
        this.callback = callback;
      }

    }

    if (false) {} // WARNING: interface has both a type and a value, skipping emit


    class DebugNode__PRE_R3__ {
      /**
       * @param {?} nativeNode
       * @param {?} parent
       * @param {?} _debugContext
       */
      constructor(nativeNode, parent, _debugContext) {
        this.listeners = [];
        this.parent = null;
        this._debugContext = _debugContext;
        this.nativeNode = nativeNode;

        if (parent && parent instanceof DebugElement__PRE_R3__) {
          parent.addChild(this);
        }
      }
      /**
       * @return {?}
       */


      get injector() {
        return this._debugContext.injector;
      }
      /**
       * @return {?}
       */


      get componentInstance() {
        return this._debugContext.component;
      }
      /**
       * @return {?}
       */


      get context() {
        return this._debugContext.context;
      }
      /**
       * @return {?}
       */


      get references() {
        return this._debugContext.references;
      }
      /**
       * @return {?}
       */


      get providerTokens() {
        return this._debugContext.providerTokens;
      }

    }

    if (false) {} // WARNING: interface has both a type and a value, skipping emit


    class DebugElement__PRE_R3__ extends DebugNode__PRE_R3__ {
      /**
       * @param {?} nativeNode
       * @param {?} parent
       * @param {?} _debugContext
       */
      constructor(nativeNode, parent, _debugContext) {
        super(nativeNode, parent, _debugContext);
        this.properties = {};
        this.attributes = {};
        this.classes = {};
        this.styles = {};
        this.childNodes = [];
        this.nativeElement = nativeNode;
      }
      /**
       * @param {?} child
       * @return {?}
       */


      addChild(child) {
        if (child) {
          this.childNodes.push(child);

          /** @type {?} */
          child.parent = this;
        }
      }
      /**
       * @param {?} child
       * @return {?}
       */


      removeChild(child) {
        /** @type {?} */
        const childIndex = this.childNodes.indexOf(child);

        if (childIndex !== -1) {
          /** @type {?} */
          child.parent = null;
          this.childNodes.splice(childIndex, 1);
        }
      }
      /**
       * @param {?} child
       * @param {?} newChildren
       * @return {?}
       */


      insertChildrenAfter(child, newChildren) {
        /** @type {?} */
        const siblingIndex = this.childNodes.indexOf(child);

        if (siblingIndex !== -1) {
          this.childNodes.splice(siblingIndex + 1, 0, ...newChildren);
          newChildren.forEach(
          /**
          * @param {?} c
          * @return {?}
          */
          c => {
            if (c.parent) {
              /** @type {?} */
              c.parent.removeChild(c);
            }

            /** @type {?} */
            child.parent = this;
          });
        }
      }
      /**
       * @param {?} refChild
       * @param {?} newChild
       * @return {?}
       */


      insertBefore(refChild, newChild) {
        /** @type {?} */
        const refIndex = this.childNodes.indexOf(refChild);

        if (refIndex === -1) {
          this.addChild(newChild);
        } else {
          if (newChild.parent) {
            /** @type {?} */
            newChild.parent.removeChild(newChild);
          }

          /** @type {?} */
          newChild.parent = this;
          this.childNodes.splice(refIndex, 0, newChild);
        }
      }
      /**
       * @param {?} predicate
       * @return {?}
       */


      query(predicate) {
        /** @type {?} */
        const results = this.queryAll(predicate);
        return results[0] || null;
      }
      /**
       * @param {?} predicate
       * @return {?}
       */


      queryAll(predicate) {
        /** @type {?} */
        const matches = [];

        _queryElementChildren(this, predicate, matches);

        return matches;
      }
      /**
       * @param {?} predicate
       * @return {?}
       */


      queryAllNodes(predicate) {
        /** @type {?} */
        const matches = [];

        _queryNodeChildren(this, predicate, matches);

        return matches;
      }
      /**
       * @return {?}
       */


      get children() {
        return (
          /** @type {?} */
          this.childNodes //
          .filter(
          /**
          * @param {?} node
          * @return {?}
          */
          node => node instanceof DebugElement__PRE_R3__)
        );
      }
      /**
       * @param {?} eventName
       * @param {?} eventObj
       * @return {?}
       */


      triggerEventHandler(eventName, eventObj) {
        this.listeners.forEach(
        /**
        * @param {?} listener
        * @return {?}
        */
        listener => {
          if (listener.name == eventName) {
            listener.callback(eventObj);
          }
        });
      }

    }

    if (false) {}
    /**
     * \@publicApi
     * @param {?} debugEls
     * @return {?}
     */


    function asNativeElements(debugEls) {
      return debugEls.map(
      /**
      * @param {?} el
      * @return {?}
      */
      el => el.nativeElement);
    }
    /**
     * @param {?} element
     * @param {?} predicate
     * @param {?} matches
     * @return {?}
     */


    function _queryElementChildren(element, predicate, matches) {
      element.childNodes.forEach(
      /**
      * @param {?} node
      * @return {?}
      */
      node => {
        if (node instanceof DebugElement__PRE_R3__) {
          if (predicate(node)) {
            matches.push(node);
          }

          _queryElementChildren(node, predicate, matches);
        }
      });
    }
    /**
     * @param {?} parentNode
     * @param {?} predicate
     * @param {?} matches
     * @return {?}
     */


    function _queryNodeChildren(parentNode, predicate, matches) {
      if (parentNode instanceof DebugElement__PRE_R3__) {
        parentNode.childNodes.forEach(
        /**
        * @param {?} node
        * @return {?}
        */
        node => {
          if (predicate(node)) {
            matches.push(node);
          }

          if (node instanceof DebugElement__PRE_R3__) {
            _queryNodeChildren(node, predicate, matches);
          }
        });
      }
    }

    class DebugNode__POST_R3__ {
      /**
       * @param {?} nativeNode
       */
      constructor(nativeNode) {
        this.nativeNode = nativeNode;
      }
      /**
       * @return {?}
       */


      get parent() {
        /** @type {?} */
        const parent =
        /** @type {?} */
        this.nativeNode.parentNode;
        return parent ? new DebugElement__POST_R3__(parent) : null;
      }
      /**
       * @return {?}
       */


      get injector() {
        return getInjector(this.nativeNode);
      }
      /**
       * @return {?}
       */


      get componentInstance() {
        /** @type {?} */
        const nativeElement = this.nativeNode;
        return nativeElement && (getComponent(
        /** @type {?} */
        nativeElement) || getViewComponent(nativeElement));
      }
      /**
       * @return {?}
       */


      get context() {
        return getComponent(
        /** @type {?} */
        this.nativeNode) || getContext$1(
        /** @type {?} */
        this.nativeNode);
      }
      /**
       * @return {?}
       */


      get listeners() {
        return getListeners(
        /** @type {?} */
        this.nativeNode).filter(isBrowserEvents);
      }
      /**
       * @return {?}
       */


      get references() {
        return getLocalRefs(this.nativeNode);
      }
      /**
       * @return {?}
       */


      get providerTokens() {
        return getInjectionTokens(
        /** @type {?} */
        this.nativeNode);
      }

    }

    if (false) {}

    class DebugElement__POST_R3__ extends DebugNode__POST_R3__ {
      /**
       * @param {?} nativeNode
       */
      constructor(nativeNode) {
        ngDevMode && assertDomNode(nativeNode);
        super(nativeNode);
      }
      /**
       * @return {?}
       */


      get nativeElement() {
        return this.nativeNode.nodeType == Node.ELEMENT_NODE ?
        /** @type {?} */
        this.nativeNode : null;
      }
      /**
       * @return {?}
       */


      get name() {
        return (
          /** @type {?} */
          this.nativeElement.nodeName
        );
      }
      /**
       *  Gets a map of property names to property values for an element.
       *
       *  This map includes:
       *  - Regular property bindings (e.g. `[id]="id"`)
       *  - Host property bindings (e.g. `host: { '[id]': "id" }`)
       *  - Interpolated property bindings (e.g. `id="{{ value }}")
       *
       *  It does not include:
       *  - input property bindings (e.g. `[myCustomInput]="value"`)
       *  - attribute bindings (e.g. `[attr.role]="menu"`)
       * @return {?}
       */


      get properties() {
        /** @type {?} */
        const context =
        /** @type {?} */
        loadLContext(this.nativeNode);
        /** @type {?} */

        const lView = context.lView;
        /** @type {?} */

        const tData = lView[TVIEW].data;
        /** @type {?} */

        const tNode =
        /** @type {?} */
        tData[context.nodeIndex];
        /** @type {?} */

        const properties = collectPropertyBindings(tNode, lView, tData);
        /** @type {?} */

        const hostProperties = collectHostPropertyBindings(tNode, lView, tData);
        /** @type {?} */

        const className = collectClassNames(this);
        /** @type {?} */

        const output = Object.assign({}, properties, hostProperties);

        if (className) {
          output['className'] = output['className'] ? output['className'] + " ".concat(className) : className;
        }

        return output;
      }
      /**
       * @return {?}
       */


      get attributes() {
        /** @type {?} */
        const attributes = {};
        /** @type {?} */

        const element = this.nativeElement;

        if (!element) {
          return attributes;
        }
        /** @type {?} */


        const context = loadLContext(element);
        /** @type {?} */

        const lView = context.lView;
        /** @type {?} */

        const tNodeAttrs =
        /** @type {?} */
        lView[TVIEW].data[context.nodeIndex].attrs;
        /** @type {?} */

        const lowercaseTNodeAttrs = []; // For debug nodes we take the element's attribute directly from the DOM since it allows us
        // to account for ones that weren't set via bindings (e.g. ViewEngine keeps track of the ones
        // that are set through `Renderer2`). The problem is that the browser will lowercase all names,
        // however since we have the attributes already on the TNode, we can preserve the case by going
        // through them once, adding them to the `attributes` map and putting their lower-cased name
        // into an array. Afterwards when we're going through the native DOM attributes, we can check
        // whether we haven't run into an attribute already through the TNode.

        if (tNodeAttrs) {
          /** @type {?} */
          let i = 0;

          while (i < tNodeAttrs.length) {
            /** @type {?} */
            const attrName = tNodeAttrs[i]; // Stop as soon as we hit a marker. We only care about the regular attributes. Everything
            // else will be handled below when we read the final attributes off the DOM.

            if (typeof attrName !== 'string') break;
            /** @type {?} */

            const attrValue = tNodeAttrs[i + 1];
            attributes[attrName] =
            /** @type {?} */
            attrValue;
            lowercaseTNodeAttrs.push(attrName.toLowerCase());
            i += 2;
          }
        }
        /** @type {?} */


        const eAttrs = element.attributes;

        for (let i = 0; i < eAttrs.length; i++) {
          /** @type {?} */
          const attr = eAttrs[i]; // Make sure that we don't assign the same attribute both in its
          // case-sensitive form and the lower-cased one from the browser.

          if (lowercaseTNodeAttrs.indexOf(attr.name) === -1) {
            attributes[attr.name] = attr.value;
          }
        }

        return attributes;
      }
      /**
       * @return {?}
       */


      get styles() {
        return _getStylingDebugInfo(this.nativeElement, false);
      }
      /**
       * @return {?}
       */


      get classes() {
        return _getStylingDebugInfo(this.nativeElement, true);
      }
      /**
       * @return {?}
       */


      get childNodes() {
        /** @type {?} */
        const childNodes = this.nativeNode.childNodes;
        /** @type {?} */

        const children = [];

        for (let i = 0; i < childNodes.length; i++) {
          /** @type {?} */
          const element = childNodes[i];
          children.push(getDebugNode__POST_R3__(element));
        }

        return children;
      }
      /**
       * @return {?}
       */


      get children() {
        /** @type {?} */
        const nativeElement = this.nativeElement;
        if (!nativeElement) return [];
        /** @type {?} */

        const childNodes = nativeElement.children;
        /** @type {?} */

        const children = [];

        for (let i = 0; i < childNodes.length; i++) {
          /** @type {?} */
          const element = childNodes[i];
          children.push(getDebugNode__POST_R3__(element));
        }

        return children;
      }
      /**
       * @param {?} predicate
       * @return {?}
       */


      query(predicate) {
        /** @type {?} */
        const results = this.queryAll(predicate);
        return results[0] || null;
      }
      /**
       * @param {?} predicate
       * @return {?}
       */


      queryAll(predicate) {
        /** @type {?} */
        const matches = [];

        _queryAllR3(this, predicate, matches, true);

        return matches;
      }
      /**
       * @param {?} predicate
       * @return {?}
       */


      queryAllNodes(predicate) {
        /** @type {?} */
        const matches = [];

        _queryAllR3(this, predicate, matches, false);

        return matches;
      }
      /**
       * @param {?} eventName
       * @param {?} eventObj
       * @return {?}
       */


      triggerEventHandler(eventName, eventObj) {
        this.listeners.forEach(
        /**
        * @param {?} listener
        * @return {?}
        */
        listener => {
          if (listener.name === eventName) {
            listener.callback(eventObj);
          }
        });
      }

    }
    /**
     * @param {?} element
     * @param {?} isClassBased
     * @return {?}
     */


    function _getStylingDebugInfo(element, isClassBased) {
      if (element) {
        /** @type {?} */
        const context = loadLContextFromNode(element);
        /** @type {?} */

        const lView = context.lView;
        /** @type {?} */

        const tData = lView[TVIEW].data;
        /** @type {?} */

        const tNode =
        /** @type {?} */
        tData[context.nodeIndex];

        if (isClassBased) {
          return isStylingContext(tNode.classes) ? new NodeStylingDebug(
          /** @type {?} */
          tNode.classes, lView, true).values : stylingMapToStringMap(tNode.classes);
        } else {
          return isStylingContext(tNode.styles) ? new NodeStylingDebug(
          /** @type {?} */
          tNode.styles, lView, false).values : stylingMapToStringMap(tNode.styles);
        }
      }

      return {};
    }
    /**
     * @param {?} parentElement
     * @param {?} predicate
     * @param {?} matches
     * @param {?} elementsOnly
     * @return {?}
     */


    function _queryAllR3(parentElement, predicate, matches, elementsOnly) {
      /** @type {?} */
      const context =
      /** @type {?} */
      loadLContext(parentElement.nativeNode);
      /** @type {?} */

      const parentTNode =
      /** @type {?} */
      context.lView[TVIEW].data[context.nodeIndex];

      _queryNodeChildrenR3(parentTNode, context.lView, predicate, matches, elementsOnly, parentElement.nativeNode);
    }
    /**
     * Recursively match the current TNode against the predicate, and goes on with the next ones.
     *
     * @param {?} tNode the current TNode
     * @param {?} lView the LView of this TNode
     * @param {?} predicate the predicate to match
     * @param {?} matches the list of positive matches
     * @param {?} elementsOnly whether only elements should be searched
     * @param {?} rootNativeNode the root native node on which predicate should not be matched
     * @return {?}
     */


    function _queryNodeChildrenR3(tNode, lView, predicate, matches, elementsOnly, rootNativeNode) {
      /** @type {?} */
      const nativeNode = getNativeByTNodeOrNull(tNode, lView); // For each type of TNode, specific logic is executed.

      if (tNode.type === 3
      /* Element */
      || tNode.type === 4
      /* ElementContainer */
      ) {
          // Case 1: the TNode is an element
          // The native node has to be checked.
          _addQueryMatchR3(nativeNode, predicate, matches, elementsOnly, rootNativeNode);

          if (isComponent(tNode)) {
            // If the element is the host of a component, then all nodes in its view have to be processed.
            // Note: the component's content (tNode.child) will be processed from the insertion points.

            /** @type {?} */
            const componentView = getComponentViewByIndex(tNode.index, lView);

            if (componentView && componentView[TVIEW].firstChild) {
              _queryNodeChildrenR3(
              /** @type {?} */
              componentView[TVIEW].firstChild, componentView, predicate, matches, elementsOnly, rootNativeNode);
            }
          } else {
            if (tNode.child) {
              // Otherwise, its children have to be processed.
              _queryNodeChildrenR3(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode);
            } // We also have to query the DOM directly in order to catch elements inserted through
            // Renderer2. Note that this is __not__ optimal, because we're walking similar trees multiple
            // times. ViewEngine could do it more efficiently, because all the insertions go through
            // Renderer2, however that's not the case in Ivy. This approach is being used because:
            // 1. Matching the ViewEngine behavior would mean potentially introducing a depedency
            //    from `Renderer2` to Ivy which could bring Ivy code into ViewEngine.
            // 2. We would have to make `Renderer3` "know" about debug nodes.
            // 3. It allows us to capture nodes that were inserted directly via the DOM.


            nativeNode && _queryNativeNodeDescendants(nativeNode, predicate, matches, elementsOnly);
          } // In all cases, if a dynamic container exists for this node, each view inside it has to be
          // processed.

          /** @type {?} */


          const nodeOrContainer = lView[tNode.index];

          if (isLContainer(nodeOrContainer)) {
            _queryNodeChildrenInContainerR3(nodeOrContainer, predicate, matches, elementsOnly, rootNativeNode);
          }
        } else if (tNode.type === 0
      /* Container */
      ) {
          // Case 2: the TNode is a container
          // The native node has to be checked.

          /** @type {?} */
          const lContainer = lView[tNode.index];

          _addQueryMatchR3(lContainer[NATIVE], predicate, matches, elementsOnly, rootNativeNode); // Each view inside the container has to be processed.


          _queryNodeChildrenInContainerR3(lContainer, predicate, matches, elementsOnly, rootNativeNode);
        } else if (tNode.type === 1
      /* Projection */
      ) {
          // Case 3: the TNode is a projection insertion point (i.e. a <ng-content>).
          // The nodes projected at this location all need to be processed.

          /** @type {?} */
          const componentView = findComponentView(
          /** @type {?} */
          lView);
          /** @type {?} */

          const componentHost =
          /** @type {?} */
          componentView[T_HOST];
          /** @type {?} */

          const head =
          /** @type {?} */
          componentHost.projection[
          /** @type {?} */
          tNode.projection];

          if (Array.isArray(head)) {
            for (let nativeNode of head) {
              _addQueryMatchR3(nativeNode, predicate, matches, elementsOnly, rootNativeNode);
            }
          } else if (head) {
            /** @type {?} */
            const nextLView =
            /** @type {?} */

            /** @type {?} */
            componentView[PARENT];
            /** @type {?} */

            const nextTNode =
            /** @type {?} */
            nextLView[TVIEW].data[head.index];

            _queryNodeChildrenR3(nextTNode, nextLView, predicate, matches, elementsOnly, rootNativeNode);
          }
        } else if (tNode.child) {
        // Case 4: the TNode is a view.
        _queryNodeChildrenR3(tNode.child, lView, predicate, matches, elementsOnly, rootNativeNode);
      } // We don't want to go to the next sibling of the root node.


      if (rootNativeNode !== nativeNode) {
        // To determine the next node to be processed, we need to use the next or the projectionNext
        // link, depending on whether the current node has been projected.

        /** @type {?} */
        const nextTNode = tNode.flags & 2
        /* isProjected */
        ? tNode.projectionNext : tNode.next;

        if (nextTNode) {
          _queryNodeChildrenR3(nextTNode, lView, predicate, matches, elementsOnly, rootNativeNode);
        }
      }
    }
    /**
     * Process all TNodes in a given container.
     *
     * @param {?} lContainer the container to be processed
     * @param {?} predicate the predicate to match
     * @param {?} matches the list of positive matches
     * @param {?} elementsOnly whether only elements should be searched
     * @param {?} rootNativeNode the root native node on which predicate should not be matched
     * @return {?}
     */


    function _queryNodeChildrenInContainerR3(lContainer, predicate, matches, elementsOnly, rootNativeNode) {
      for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {
        /** @type {?} */
        const childView = lContainer[i];

        _queryNodeChildrenR3(
        /** @type {?} */
        childView[TVIEW].node, childView, predicate, matches, elementsOnly, rootNativeNode);
      }
    }
    /**
     * Match the current native node against the predicate.
     *
     * @param {?} nativeNode the current native node
     * @param {?} predicate the predicate to match
     * @param {?} matches the list of positive matches
     * @param {?} elementsOnly whether only elements should be searched
     * @param {?} rootNativeNode the root native node on which predicate should not be matched
     * @return {?}
     */


    function _addQueryMatchR3(nativeNode, predicate, matches, elementsOnly, rootNativeNode) {
      if (rootNativeNode !== nativeNode) {
        /** @type {?} */
        const debugNode = getDebugNode(nativeNode);

        if (!debugNode) {
          return;
        } // Type of the "predicate and "matches" array are set based on the value of
        // the "elementsOnly" parameter. TypeScript is not able to properly infer these
        // types with generics, so we manually cast the parameters accordingly.


        if (elementsOnly && debugNode instanceof DebugElement__POST_R3__ && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
          matches.push(debugNode);
        } else if (!elementsOnly &&
        /** @type {?} */
        predicate(debugNode) &&
        /** @type {?} */
        matches.indexOf(debugNode) === -1) {
          /** @type {?} */
          matches.push(debugNode);
        }
      }
    }
    /**
     * Match all the descendants of a DOM node against a predicate.
     *
     * @param {?} parentNode
     * @param {?} predicate the predicate to match
     * @param {?} matches the list of positive matches
     * @param {?} elementsOnly whether only elements should be searched
     * @return {?}
     */


    function _queryNativeNodeDescendants(parentNode, predicate, matches, elementsOnly) {
      /** @type {?} */
      const nodes = parentNode.childNodes;
      /** @type {?} */

      const length = nodes.length;

      for (let i = 0; i < length; i++) {
        /** @type {?} */
        const node = nodes[i];
        /** @type {?} */

        const debugNode = getDebugNode(node);

        if (debugNode) {
          if (elementsOnly && debugNode instanceof DebugElement__POST_R3__ && predicate(debugNode) && matches.indexOf(debugNode) === -1) {
            matches.push(debugNode);
          } else if (!elementsOnly &&
          /** @type {?} */
          predicate(debugNode) &&
          /** @type {?} */
          matches.indexOf(debugNode) === -1) {
            /** @type {?} */
            matches.push(debugNode);
          }

          _queryNativeNodeDescendants(node, predicate, matches, elementsOnly);
        }
      }
    }
    /**
     * Iterates through the property bindings for a given node and generates
     * a map of property names to values. This map only contains property bindings
     * defined in templates, not in host bindings.
     * @param {?} tNode
     * @param {?} lView
     * @param {?} tData
     * @return {?}
     */


    function collectPropertyBindings(tNode, lView, tData) {
      /** @type {?} */
      const properties = {};
      /** @type {?} */

      let bindingIndex = getFirstBindingIndex(tNode.propertyMetadataStartIndex, tData);

      while (bindingIndex < tNode.propertyMetadataEndIndex) {
        /** @type {?} */
        let value;
        /** @type {?} */

        let propMetadata =
        /** @type {?} */
        tData[bindingIndex];

        while (!isPropMetadataString(propMetadata)) {
          // This is the first value for an interpolation. We need to build up
          // the full interpolation by combining runtime values in LView with
          // the static interstitial values stored in TData.
          value = (value || '') + renderStringify(lView[bindingIndex]) + tData[bindingIndex];
          propMetadata =
          /** @type {?} */
          tData[++bindingIndex];
        }

        value = value === undefined ? lView[bindingIndex] : value += lView[bindingIndex]; // Property metadata string has 3 parts: property name, prefix, and suffix

        /** @type {?} */

        const metadataParts = propMetadata.split(INTERPOLATION_DELIMITER);
        /** @type {?} */

        const propertyName = metadataParts[0]; // Attr bindings don't have property names and should be skipped

        if (propertyName) {
          // Wrap value with prefix and suffix (will be '' for normal bindings), if they're defined.
          // Avoid wrapping for normal bindings so that the value doesn't get cast to a string.
          properties[propertyName] = metadataParts[1] && metadataParts[2] ? metadataParts[1] + value + metadataParts[2] : value;
        }

        bindingIndex++;
      }

      return properties;
    }
    /**
     * Retrieves the first binding index that holds values for this property
     * binding.
     *
     * For normal bindings (e.g. `[id]="id"`), the binding index is the
     * same as the metadata index. For interpolations (e.g. `id="{{id}}-{{name}}"`),
     * there can be multiple binding values, so we might have to loop backwards
     * from the metadata index until we find the first one.
     *
     * @param {?} metadataIndex The index of the first property metadata string for
     * this node.
     * @param {?} tData The data array for the current TView
     * @return {?} The first binding index for this binding
     */


    function getFirstBindingIndex(metadataIndex, tData) {
      /** @type {?} */
      let currentBindingIndex = metadataIndex - 1; // If the slot before the metadata holds a string, we know that this
      // metadata applies to an interpolation with at least 2 bindings, and
      // we need to search further to access the first binding value.

      /** @type {?} */

      let currentValue = tData[currentBindingIndex]; // We need to iterate until we hit either a:
      // - TNode (it is an element slot marking the end of `consts` section), OR a
      // - metadata string (slot is attribute metadata or a previous node's property metadata)

      while (typeof currentValue === 'string' && !isPropMetadataString(currentValue)) {
        currentValue = tData[--currentBindingIndex];
      }

      return currentBindingIndex + 1;
    }
    /**
     * @param {?} tNode
     * @param {?} lView
     * @param {?} tData
     * @return {?}
     */


    function collectHostPropertyBindings(tNode, lView, tData) {
      /** @type {?} */
      const properties = {}; // Host binding values for a node are stored after directives on that node

      /** @type {?} */

      let hostPropIndex = tNode.directiveEnd;
      /** @type {?} */

      let propMetadata =
      /** @type {?} */
      tData[hostPropIndex]; // When we reach a value in TView.data that is not a string, we know we've
      // hit the next node's providers and directives and should stop copying data.

      while (typeof propMetadata === 'string') {
        /** @type {?} */
        const propertyName = propMetadata.split(INTERPOLATION_DELIMITER)[0];
        properties[propertyName] = lView[hostPropIndex];
        propMetadata = tData[++hostPropIndex];
      }

      return properties;
    }
    /**
     * @param {?} debugElement
     * @return {?}
     */


    function collectClassNames(debugElement) {
      /** @type {?} */
      const classes = debugElement.classes;
      /** @type {?} */

      let output = '';

      for (const className of Object.keys(classes)) {
        if (classes[className]) {
          output = output ? output + " ".concat(className) : className;
        }
      }

      return output;
    } // Need to keep the nodes in a global Map so that multiple angular apps are supported.

    /** @type {?} */


    const _nativeNodeToDebugNode = new Map();
    /**
     * @param {?} nativeNode
     * @return {?}
     */


    function getDebugNode__PRE_R3__(nativeNode) {
      return _nativeNodeToDebugNode.get(nativeNode) || null;
    }
    /** @type {?} */


    const NG_DEBUG_PROPERTY = '__ng_debug__';
    /**
     * @param {?} nativeNode
     * @return {?}
     */

    function getDebugNode__POST_R3__(nativeNode) {
      if (nativeNode instanceof Node) {
        if (!nativeNode.hasOwnProperty(NG_DEBUG_PROPERTY)) {
          /** @type {?} */
          nativeNode[NG_DEBUG_PROPERTY] = nativeNode.nodeType == Node.ELEMENT_NODE ? new DebugElement__POST_R3__(
          /** @type {?} */
          nativeNode) : new DebugNode__POST_R3__(nativeNode);
        }

        return (
          /** @type {?} */
          nativeNode[NG_DEBUG_PROPERTY]
        );
      }

      return null;
    }
    /**
     * \@publicApi
     * @type {?}
     */


    const getDebugNode = getDebugNode__PRE_R3__;
    /**
     * @return {?}
     */

    function getAllDebugNodes() {
      return Array.from(_nativeNodeToDebugNode.values());
    }
    /**
     * @param {?} node
     * @return {?}
     */


    function indexDebugNode(node) {
      _nativeNodeToDebugNode.set(node.nativeNode, node);
    }
    /**
     * @param {?} node
     * @return {?}
     */


    function removeDebugNodeFromIndex(node) {
      _nativeNodeToDebugNode.delete(node.nativeNode);
    }
    /**
     * A boolean-valued function over a value, possibly including context information
     * regarding that value's position in an array.
     *
     * \@publicApi
     * @record
     * @template T
     */


    function Predicate() {}
    /**
     * \@publicApi
     * @type {?}
     */


    const DebugNode$1 = DebugNode__PRE_R3__;
    /**
     * \@publicApi
     * @type {?}
     */

    const DebugElement = DebugElement__PRE_R3__;
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */

    const _CORE_PLATFORM_PROVIDERS = [// Set a default platform name for platforms that don't set it explicitly.
    {
      provide: PLATFORM_ID,
      useValue: 'unknown'
    }, {
      provide: PlatformRef,
      deps: [Injector]
    }, {
      provide: TestabilityRegistry,
      deps: []
    }, {
      provide: Console,
      deps: []
    }];
    /**
     * This platform has to be included in any other platform
     *
     * \@publicApi
     * @type {?}
     */

    const platformCore = createPlatformFactory(null, 'core', _CORE_PLATFORM_PROVIDERS);
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @return {?}
     */

    function _iterableDiffersFactory() {
      return defaultIterableDiffers;
    }
    /**
     * @return {?}
     */


    function _keyValueDiffersFactory() {
      return defaultKeyValueDiffers;
    }
    /**
     * @param {?=} locale
     * @return {?}
     */


    function _localeFactory(locale) {
      if (locale) {
        if (ivyEnabled) {
          setLocaleId(locale);
        }

        return locale;
      } // Use `goog.LOCALE` as default value for `LOCALE_ID` token for Closure Compiler.
      // Note: default `goog.LOCALE` value is `en`, when Angular used `en-US`. In order to preserve
      // backwards compatibility, we use Angular default value over Closure Compiler's one.


      if (ngI18nClosureMode && typeof goog !== 'undefined' && goog.LOCALE !== 'en') {
        if (ivyEnabled) {
          setLocaleId(goog.LOCALE);
        }

        return goog.LOCALE;
      }

      return DEFAULT_LOCALE_ID;
    }
    /**
     * A built-in [dependency injection token](guide/glossary#di-token)
     * that is used to configure the root injector for bootstrapping.
     * @type {?}
     */


    const APPLICATION_MODULE_PROVIDERS = [{
      provide: ApplicationRef,
      useClass: ApplicationRef,
      deps: [NgZone, Console, Injector, ErrorHandler, ComponentFactoryResolver, ApplicationInitStatus]
    }, {
      provide: SCHEDULER,
      deps: [NgZone],
      useFactory: zoneSchedulerFactory
    }, {
      provide: ApplicationInitStatus,
      useClass: ApplicationInitStatus,
      deps: [[new Optional(), APP_INITIALIZER]]
    }, {
      provide: Compiler,
      useClass: Compiler,
      deps: []
    }, APP_ID_RANDOM_PROVIDER, {
      provide: IterableDiffers,
      useFactory: _iterableDiffersFactory,
      deps: []
    }, {
      provide: KeyValueDiffers,
      useFactory: _keyValueDiffersFactory,
      deps: []
    }, {
      provide: LOCALE_ID$1,
      useFactory: _localeFactory,
      deps: [[new Inject(LOCALE_ID$1), new Optional(), new SkipSelf()]]
    }];
    /**
     * Schedule work at next available slot.
     *
     * In Ivy this is just `requestAnimationFrame`. For compatibility reasons when bootstrapped
     * using `platformRef.bootstrap` we need to use `NgZone.onStable` as the scheduling mechanism.
     * This overrides the scheduling mechanism in Ivy to `NgZone.onStable`.
     *
     * @param {?} ngZone NgZone to use for scheduling.
     * @return {?}
     */

    function zoneSchedulerFactory(ngZone) {
      /** @type {?} */
      let queue = [];
      ngZone.onStable.subscribe(
      /**
      * @return {?}
      */
      () => {
        while (queue.length) {
          /** @type {?} */
          queue.pop()();
        }
      });
      return (
        /**
        * @param {?} fn
        * @return {?}
        */
        function (fn) {
          queue.push(fn);
        }
      );
    }
    /**
     * Configures the root injector for an app with
     * providers of `\@angular/core` dependencies that `ApplicationRef` needs
     * to bootstrap components.
     *
     * Re-exported by `BrowserModule`, which is included automatically in the root
     * `AppModule` when you create a new app with the CLI `new` command.
     *
     * \@publicApi
     */


    class ApplicationModule {
      // Inject ApplicationRef to make it eager...

      /**
       * @param {?} appRef
       */
      constructor(appRef) {}

    }

    ApplicationModule.decorators = [{
      type: NgModule,
      args: [{
        providers: APPLICATION_MODULE_PROVIDERS
      }]
    }];
    /** @nocollapse */

    ApplicationModule.ctorParameters = () => [{
      type: ApplicationRef
    }];
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} flags
     * @param {?} matchedQueriesDsl
     * @param {?} ngContentIndex
     * @param {?} childCount
     * @param {?=} handleEvent
     * @param {?=} templateFactory
     * @return {?}
     */


    function anchorDef(flags, matchedQueriesDsl, ngContentIndex, childCount, handleEvent, templateFactory) {
      flags |= 1
      /* TypeElement */
      ;
      const {
        matchedQueries,
        references,
        matchedQueryIds
      } = splitMatchedQueriesDsl(matchedQueriesDsl);
      /** @type {?} */

      const template = templateFactory ? resolveDefinition(templateFactory) : null;
      return {
        // will bet set by the view definition
        nodeIndex: -1,
        parent: null,
        renderParent: null,
        bindingIndex: -1,
        outputIndex: -1,
        // regular values
        flags,
        checkIndex: -1,
        childFlags: 0,
        directChildFlags: 0,
        childMatchedQueries: 0,
        matchedQueries,
        matchedQueryIds,
        references,
        ngContentIndex,
        childCount,
        bindings: [],
        bindingFlags: 0,
        outputs: [],
        element: {
          ns: null,
          name: null,
          attrs: null,
          template,
          componentProvider: null,
          componentView: null,
          componentRendererType: null,
          publicProviders: null,
          allProviders: null,
          handleEvent: handleEvent || NOOP
        },
        provider: null,
        text: null,
        query: null,
        ngContent: null
      };
    }
    /**
     * @param {?} checkIndex
     * @param {?} flags
     * @param {?} matchedQueriesDsl
     * @param {?} ngContentIndex
     * @param {?} childCount
     * @param {?} namespaceAndName
     * @param {?=} fixedAttrs
     * @param {?=} bindings
     * @param {?=} outputs
     * @param {?=} handleEvent
     * @param {?=} componentView
     * @param {?=} componentRendererType
     * @return {?}
     */


    function elementDef(checkIndex, flags, matchedQueriesDsl, ngContentIndex, childCount, namespaceAndName, fixedAttrs = [], bindings, outputs, handleEvent, componentView, componentRendererType) {
      if (!handleEvent) {
        handleEvent = NOOP;
      }

      const {
        matchedQueries,
        references,
        matchedQueryIds
      } = splitMatchedQueriesDsl(matchedQueriesDsl);
      /** @type {?} */

      let ns =
      /** @type {?} */
      null;
      /** @type {?} */

      let name =
      /** @type {?} */
      null;

      if (namespaceAndName) {
        [ns, name] = splitNamespace(namespaceAndName);
      }

      bindings = bindings || [];
      /** @type {?} */

      const bindingDefs = new Array(bindings.length);

      for (let i = 0; i < bindings.length; i++) {
        const [bindingFlags, namespaceAndName, suffixOrSecurityContext] = bindings[i];
        const [ns, name] = splitNamespace(namespaceAndName);
        /** @type {?} */

        let securityContext =
        /** @type {?} */
        undefined;
        /** @type {?} */

        let suffix =
        /** @type {?} */
        undefined;

        switch (bindingFlags & 15
        /* Types */
        ) {
          case 4
          /* TypeElementStyle */
          :
            suffix =
            /** @type {?} */
            suffixOrSecurityContext;
            break;

          case 1
          /* TypeElementAttribute */
          :
          case 8
          /* TypeProperty */
          :
            securityContext =
            /** @type {?} */
            suffixOrSecurityContext;
            break;
        }

        bindingDefs[i] = {
          flags: bindingFlags,
          ns,
          name,
          nonMinifiedName: name,
          securityContext,
          suffix
        };
      }

      outputs = outputs || [];
      /** @type {?} */

      const outputDefs = new Array(outputs.length);

      for (let i = 0; i < outputs.length; i++) {
        const [target, eventName] = outputs[i];
        outputDefs[i] = {
          type: 0
          /* ElementOutput */
          ,
          target:
          /** @type {?} */
          target,
          eventName,
          propName: null
        };
      }

      fixedAttrs = fixedAttrs || [];
      /** @type {?} */

      const attrs =
      /** @type {?} */
      fixedAttrs.map(
      /**
      * @param {?} __0
      * @return {?}
      */
      ([namespaceAndName, value]) => {
        const [ns, name] = splitNamespace(namespaceAndName);
        return [ns, name, value];
      });
      componentRendererType = resolveRendererType2(componentRendererType);

      if (componentView) {
        flags |= 33554432
        /* ComponentView */
        ;
      }

      flags |= 1
      /* TypeElement */
      ;
      return {
        // will bet set by the view definition
        nodeIndex: -1,
        parent: null,
        renderParent: null,
        bindingIndex: -1,
        outputIndex: -1,
        // regular values
        checkIndex,
        flags,
        childFlags: 0,
        directChildFlags: 0,
        childMatchedQueries: 0,
        matchedQueries,
        matchedQueryIds,
        references,
        ngContentIndex,
        childCount,
        bindings: bindingDefs,
        bindingFlags: calcBindingFlags(bindingDefs),
        outputs: outputDefs,
        element: {
          ns,
          name,
          attrs,
          template: null,
          // will bet set by the view definition
          componentProvider: null,
          componentView: componentView || null,
          componentRendererType: componentRendererType,
          publicProviders: null,
          allProviders: null,
          handleEvent: handleEvent || NOOP
        },
        provider: null,
        text: null,
        query: null,
        ngContent: null
      };
    }
    /**
     * @param {?} view
     * @param {?} renderHost
     * @param {?} def
     * @return {?}
     */


    function createElement(view, renderHost, def) {
      /** @type {?} */
      const elDef =
      /** @type {?} */
      def.element;
      /** @type {?} */

      const rootSelectorOrNode = view.root.selectorOrNode;
      /** @type {?} */

      const renderer = view.renderer;
      /** @type {?} */

      let el;

      if (view.parent || !rootSelectorOrNode) {
        if (elDef.name) {
          el = renderer.createElement(elDef.name, elDef.ns);
        } else {
          el = renderer.createComment('');
        }
        /** @type {?} */


        const parentEl = getParentRenderElement(view, renderHost, def);

        if (parentEl) {
          renderer.appendChild(parentEl, el);
        }
      } else {
        // when using native Shadow DOM, do not clear the root element contents to allow slot projection

        /** @type {?} */
        const preserveContent = !!elDef.componentRendererType && elDef.componentRendererType.encapsulation === ViewEncapsulation.ShadowDom;
        el = renderer.selectRootElement(rootSelectorOrNode, preserveContent);
      }

      if (elDef.attrs) {
        for (let i = 0; i < elDef.attrs.length; i++) {
          const [ns, name, value] = elDef.attrs[i];
          renderer.setAttribute(el, name, value, ns);
        }
      }

      return el;
    }
    /**
     * @param {?} view
     * @param {?} compView
     * @param {?} def
     * @param {?} el
     * @return {?}
     */


    function listenToElementOutputs(view, compView, def, el) {
      for (let i = 0; i < def.outputs.length; i++) {
        /** @type {?} */
        const output = def.outputs[i];
        /** @type {?} */

        const handleEventClosure = renderEventHandlerClosure(view, def.nodeIndex, elementEventFullName(output.target, output.eventName));
        /** @type {?} */

        let listenTarget = output.target;
        /** @type {?} */

        let listenerView = view;

        if (output.target === 'component') {
          listenTarget = null;
          listenerView = compView;
        }
        /** @type {?} */


        const disposable =
        /** @type {?} */
        listenerView.renderer.listen(listenTarget || el, output.eventName, handleEventClosure);

        /** @type {?} */
        view.disposables[def.outputIndex + i] = disposable;
      }
    }
    /**
     * @param {?} view
     * @param {?} index
     * @param {?} eventName
     * @return {?}
     */


    function renderEventHandlerClosure(view, index, eventName) {
      return (
        /**
        * @param {?} event
        * @return {?}
        */
        event => dispatchEvent(view, index, eventName, event)
      );
    }
    /**
     * @param {?} view
     * @param {?} def
     * @param {?} v0
     * @param {?} v1
     * @param {?} v2
     * @param {?} v3
     * @param {?} v4
     * @param {?} v5
     * @param {?} v6
     * @param {?} v7
     * @param {?} v8
     * @param {?} v9
     * @return {?}
     */


    function checkAndUpdateElementInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
      /** @type {?} */
      const bindLen = def.bindings.length;
      /** @type {?} */

      let changed = false;
      if (bindLen > 0 && checkAndUpdateElementValue(view, def, 0, v0)) changed = true;
      if (bindLen > 1 && checkAndUpdateElementValue(view, def, 1, v1)) changed = true;
      if (bindLen > 2 && checkAndUpdateElementValue(view, def, 2, v2)) changed = true;
      if (bindLen > 3 && checkAndUpdateElementValue(view, def, 3, v3)) changed = true;
      if (bindLen > 4 && checkAndUpdateElementValue(view, def, 4, v4)) changed = true;
      if (bindLen > 5 && checkAndUpdateElementValue(view, def, 5, v5)) changed = true;
      if (bindLen > 6 && checkAndUpdateElementValue(view, def, 6, v6)) changed = true;
      if (bindLen > 7 && checkAndUpdateElementValue(view, def, 7, v7)) changed = true;
      if (bindLen > 8 && checkAndUpdateElementValue(view, def, 8, v8)) changed = true;
      if (bindLen > 9 && checkAndUpdateElementValue(view, def, 9, v9)) changed = true;
      return changed;
    }
    /**
     * @param {?} view
     * @param {?} def
     * @param {?} values
     * @return {?}
     */


    function checkAndUpdateElementDynamic(view, def, values) {
      /** @type {?} */
      let changed = false;

      for (let i = 0; i < values.length; i++) {
        if (checkAndUpdateElementValue(view, def, i, values[i])) changed = true;
      }

      return changed;
    }
    /**
     * @param {?} view
     * @param {?} def
     * @param {?} bindingIdx
     * @param {?} value
     * @return {?}
     */


    function checkAndUpdateElementValue(view, def, bindingIdx, value) {
      if (!checkAndUpdateBinding(view, def, bindingIdx, value)) {
        return false;
      }
      /** @type {?} */


      const binding = def.bindings[bindingIdx];
      /** @type {?} */

      const elData = asElementData(view, def.nodeIndex);
      /** @type {?} */

      const renderNode = elData.renderElement;
      /** @type {?} */

      const name =
      /** @type {?} */
      binding.name;

      switch (binding.flags & 15
      /* Types */
      ) {
        case 1
        /* TypeElementAttribute */
        :
          setElementAttribute(view, binding, renderNode, binding.ns, name, value);
          break;

        case 2
        /* TypeElementClass */
        :
          setElementClass(view, renderNode, name, value);
          break;

        case 4
        /* TypeElementStyle */
        :
          setElementStyle(view, binding, renderNode, name, value);
          break;

        case 8
        /* TypeProperty */
        :
          /** @type {?} */
          const bindView = def.flags & 33554432
          /* ComponentView */
          && binding.flags & 32
          /* SyntheticHostProperty */
          ? elData.componentView : view;
          setElementProperty(bindView, binding, renderNode, name, value);
          break;
      }

      return true;
    }
    /**
     * @param {?} view
     * @param {?} binding
     * @param {?} renderNode
     * @param {?} ns
     * @param {?} name
     * @param {?} value
     * @return {?}
     */


    function setElementAttribute(view, binding, renderNode, ns, name, value) {
      /** @type {?} */
      const securityContext = binding.securityContext;
      /** @type {?} */

      let renderValue = securityContext ? view.root.sanitizer.sanitize(securityContext, value) : value;
      renderValue = renderValue != null ? renderValue.toString() : null;
      /** @type {?} */

      const renderer = view.renderer;

      if (value != null) {
        renderer.setAttribute(renderNode, name, renderValue, ns);
      } else {
        renderer.removeAttribute(renderNode, name, ns);
      }
    }
    /**
     * @param {?} view
     * @param {?} renderNode
     * @param {?} name
     * @param {?} value
     * @return {?}
     */


    function setElementClass(view, renderNode, name, value) {
      /** @type {?} */
      const renderer = view.renderer;

      if (value) {
        renderer.addClass(renderNode, name);
      } else {
        renderer.removeClass(renderNode, name);
      }
    }
    /**
     * @param {?} view
     * @param {?} binding
     * @param {?} renderNode
     * @param {?} name
     * @param {?} value
     * @return {?}
     */


    function setElementStyle(view, binding, renderNode, name, value) {
      /** @type {?} */
      let renderValue = view.root.sanitizer.sanitize(SecurityContext.STYLE,
      /** @type {?} */
      value);

      if (renderValue != null) {
        renderValue = renderValue.toString();
        /** @type {?} */

        const unit = binding.suffix;

        if (unit != null) {
          renderValue = renderValue + unit;
        }
      } else {
        renderValue = null;
      }
      /** @type {?} */


      const renderer = view.renderer;

      if (renderValue != null) {
        renderer.setStyle(renderNode, name, renderValue);
      } else {
        renderer.removeStyle(renderNode, name);
      }
    }
    /**
     * @param {?} view
     * @param {?} binding
     * @param {?} renderNode
     * @param {?} name
     * @param {?} value
     * @return {?}
     */


    function setElementProperty(view, binding, renderNode, name, value) {
      /** @type {?} */
      const securityContext = binding.securityContext;
      /** @type {?} */

      let renderValue = securityContext ? view.root.sanitizer.sanitize(securityContext, value) : value;
      view.renderer.setProperty(renderNode, name, renderValue);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} flags
     * @param {?} id
     * @param {?} bindings
     * @return {?}
     */


    function queryDef(flags, id, bindings) {
      /** @type {?} */
      let bindingDefs = [];

      for (let propName in bindings) {
        /** @type {?} */
        const bindingType = bindings[propName];
        bindingDefs.push({
          propName,
          bindingType
        });
      }

      return {
        // will bet set by the view definition
        nodeIndex: -1,
        parent: null,
        renderParent: null,
        bindingIndex: -1,
        outputIndex: -1,
        // regular values
        // TODO(vicb): check
        checkIndex: -1,
        flags,
        childFlags: 0,
        directChildFlags: 0,
        childMatchedQueries: 0,
        ngContentIndex: -1,
        matchedQueries: {},
        matchedQueryIds: 0,
        references: {},
        childCount: 0,
        bindings: [],
        bindingFlags: 0,
        outputs: [],
        element: null,
        provider: null,
        text: null,
        query: {
          id,
          filterId: filterQueryId(id),
          bindings: bindingDefs
        },
        ngContent: null
      };
    }
    /**
     * @return {?}
     */


    function createQuery() {
      return new QueryList();
    }
    /**
     * @param {?} view
     * @return {?}
     */


    function dirtyParentQueries(view) {
      /** @type {?} */
      const queryIds = view.def.nodeMatchedQueries;

      while (view.parent && isEmbeddedView(view)) {
        /** @type {?} */
        let tplDef =
        /** @type {?} */
        view.parentNodeDef;
        view = view.parent; // content queries

        /** @type {?} */

        const end = tplDef.nodeIndex + tplDef.childCount;

        for (let i = 0; i <= end; i++) {
          /** @type {?} */
          const nodeDef = view.def.nodes[i];

          if (nodeDef.flags & 67108864
          /* TypeContentQuery */
          && nodeDef.flags & 536870912
          /* DynamicQuery */
          && (
          /** @type {?} */
          nodeDef.query.filterId & queryIds) ===
          /** @type {?} */
          nodeDef.query.filterId) {
            asQueryList(view, i).setDirty();
          }

          if (nodeDef.flags & 1
          /* TypeElement */
          && i + nodeDef.childCount < tplDef.nodeIndex || !(nodeDef.childFlags & 67108864
          /* TypeContentQuery */
          ) || !(nodeDef.childFlags & 536870912
          /* DynamicQuery */
          )) {
            // skip elements that don't contain the template element or no query.
            i += nodeDef.childCount;
          }
        }
      } // view queries


      if (view.def.nodeFlags & 134217728
      /* TypeViewQuery */
      ) {
          for (let i = 0; i < view.def.nodes.length; i++) {
            /** @type {?} */
            const nodeDef = view.def.nodes[i];

            if (nodeDef.flags & 134217728
            /* TypeViewQuery */
            && nodeDef.flags & 536870912
            /* DynamicQuery */
            ) {
              asQueryList(view, i).setDirty();
            } // only visit the root nodes


            i += nodeDef.childCount;
          }
        }
    }
    /**
     * @param {?} view
     * @param {?} nodeDef
     * @return {?}
     */


    function checkAndUpdateQuery(view, nodeDef) {
      /** @type {?} */
      const queryList = asQueryList(view, nodeDef.nodeIndex);

      if (!queryList.dirty) {
        return;
      }
      /** @type {?} */


      let directiveInstance;
      /** @type {?} */

      let newValues =
      /** @type {?} */
      undefined;

      if (nodeDef.flags & 67108864
      /* TypeContentQuery */
      ) {
          /** @type {?} */
          const elementDef =
          /** @type {?} */

          /** @type {?} */
          nodeDef.parent.parent;
          newValues = calcQueryValues(view, elementDef.nodeIndex, elementDef.nodeIndex + elementDef.childCount,
          /** @type {?} */
          nodeDef.query, []);
          directiveInstance = asProviderData(view,
          /** @type {?} */
          nodeDef.parent.nodeIndex).instance;
        } else if (nodeDef.flags & 134217728
      /* TypeViewQuery */
      ) {
          newValues = calcQueryValues(view, 0, view.def.nodes.length - 1,
          /** @type {?} */
          nodeDef.query, []);
          directiveInstance = view.component;
        }

      queryList.reset(newValues);
      /** @type {?} */

      const bindings =
      /** @type {?} */
      nodeDef.query.bindings;
      /** @type {?} */

      let notify = false;

      for (let i = 0; i < bindings.length; i++) {
        /** @type {?} */
        const binding = bindings[i];
        /** @type {?} */

        let boundValue;

        switch (binding.bindingType) {
          case 0
          /* First */
          :
            boundValue = queryList.first;
            break;

          case 1
          /* All */
          :
            boundValue = queryList;
            notify = true;
            break;
        }

        directiveInstance[binding.propName] = boundValue;
      }

      if (notify) {
        queryList.notifyOnChanges();
      }
    }
    /**
     * @param {?} view
     * @param {?} startIndex
     * @param {?} endIndex
     * @param {?} queryDef
     * @param {?} values
     * @return {?}
     */


    function calcQueryValues(view, startIndex, endIndex, queryDef, values) {
      for (let i = startIndex; i <= endIndex; i++) {
        /** @type {?} */
        const nodeDef = view.def.nodes[i];
        /** @type {?} */

        const valueType = nodeDef.matchedQueries[queryDef.id];

        if (valueType != null) {
          values.push(getQueryValue(view, nodeDef, valueType));
        }

        if (nodeDef.flags & 1
        /* TypeElement */
        &&
        /** @type {?} */
        nodeDef.element.template && (
        /** @type {?} */

        /** @type {?} */
        nodeDef.element.template.nodeMatchedQueries & queryDef.filterId) === queryDef.filterId) {
          /** @type {?} */
          const elementData = asElementData(view, i); // check embedded views that were attached at the place of their template,
          // but process child nodes first if some match the query (see issue #16568)

          if ((nodeDef.childMatchedQueries & queryDef.filterId) === queryDef.filterId) {
            calcQueryValues(view, i + 1, i + nodeDef.childCount, queryDef, values);
            i += nodeDef.childCount;
          }

          if (nodeDef.flags & 16777216
          /* EmbeddedViews */
          ) {
              /** @type {?} */
              const embeddedViews =
              /** @type {?} */
              elementData.viewContainer._embeddedViews;

              for (let k = 0; k < embeddedViews.length; k++) {
                /** @type {?} */
                const embeddedView = embeddedViews[k];
                /** @type {?} */

                const dvc = declaredViewContainer(embeddedView);

                if (dvc && dvc === elementData) {
                  calcQueryValues(embeddedView, 0, embeddedView.def.nodes.length - 1, queryDef, values);
                }
              }
            }
          /** @type {?} */


          const projectedViews = elementData.template._projectedViews;

          if (projectedViews) {
            for (let k = 0; k < projectedViews.length; k++) {
              /** @type {?} */
              const projectedView = projectedViews[k];
              calcQueryValues(projectedView, 0, projectedView.def.nodes.length - 1, queryDef, values);
            }
          }
        }

        if ((nodeDef.childMatchedQueries & queryDef.filterId) !== queryDef.filterId) {
          // if no child matches the query, skip the children.
          i += nodeDef.childCount;
        }
      }

      return values;
    }
    /**
     * @param {?} view
     * @param {?} nodeDef
     * @param {?} queryValueType
     * @return {?}
     */


    function getQueryValue(view, nodeDef, queryValueType) {
      if (queryValueType != null) {
        // a match
        switch (queryValueType) {
          case 1
          /* RenderElement */
          :
            return asElementData(view, nodeDef.nodeIndex).renderElement;

          case 0
          /* ElementRef */
          :
            return new ElementRef(asElementData(view, nodeDef.nodeIndex).renderElement);

          case 2
          /* TemplateRef */
          :
            return asElementData(view, nodeDef.nodeIndex).template;

          case 3
          /* ViewContainerRef */
          :
            return asElementData(view, nodeDef.nodeIndex).viewContainer;

          case 4
          /* Provider */
          :
            return asProviderData(view, nodeDef.nodeIndex).instance;
        }
      }
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} ngContentIndex
     * @param {?} index
     * @return {?}
     */


    function ngContentDef(ngContentIndex, index) {
      return {
        // will bet set by the view definition
        nodeIndex: -1,
        parent: null,
        renderParent: null,
        bindingIndex: -1,
        outputIndex: -1,
        // regular values
        checkIndex: -1,
        flags: 8
        /* TypeNgContent */
        ,
        childFlags: 0,
        directChildFlags: 0,
        childMatchedQueries: 0,
        matchedQueries: {},
        matchedQueryIds: 0,
        references: {},
        ngContentIndex,
        childCount: 0,
        bindings: [],
        bindingFlags: 0,
        outputs: [],
        element: null,
        provider: null,
        text: null,
        query: null,
        ngContent: {
          index
        }
      };
    }
    /**
     * @param {?} view
     * @param {?} renderHost
     * @param {?} def
     * @return {?}
     */


    function appendNgContent(view, renderHost, def) {
      /** @type {?} */
      const parentEl = getParentRenderElement(view, renderHost, def);

      if (!parentEl) {
        // Nothing to do if there is no parent element.
        return;
      }
      /** @type {?} */


      const ngContentIndex =
      /** @type {?} */
      def.ngContent.index;
      visitProjectedRenderNodes(view, ngContentIndex, 1
      /* AppendChild */
      , parentEl, null, undefined);
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} checkIndex
     * @param {?} argCount
     * @return {?}
     */


    function purePipeDef(checkIndex, argCount) {
      // argCount + 1 to include the pipe as first arg
      return _pureExpressionDef(128
      /* TypePurePipe */
      , checkIndex, new Array(argCount + 1));
    }
    /**
     * @param {?} checkIndex
     * @param {?} argCount
     * @return {?}
     */


    function pureArrayDef(checkIndex, argCount) {
      return _pureExpressionDef(32
      /* TypePureArray */
      , checkIndex, new Array(argCount));
    }
    /**
     * @param {?} checkIndex
     * @param {?} propToIndex
     * @return {?}
     */


    function pureObjectDef(checkIndex, propToIndex) {
      /** @type {?} */
      const keys = Object.keys(propToIndex);
      /** @type {?} */

      const nbKeys = keys.length;
      /** @type {?} */

      const propertyNames = new Array(nbKeys);

      for (let i = 0; i < nbKeys; i++) {
        /** @type {?} */
        const key = keys[i];
        /** @type {?} */

        const index = propToIndex[key];
        propertyNames[index] = key;
      }

      return _pureExpressionDef(64
      /* TypePureObject */
      , checkIndex, propertyNames);
    }
    /**
     * @param {?} flags
     * @param {?} checkIndex
     * @param {?} propertyNames
     * @return {?}
     */


    function _pureExpressionDef(flags, checkIndex, propertyNames) {
      /** @type {?} */
      const bindings = new Array(propertyNames.length);

      for (let i = 0; i < propertyNames.length; i++) {
        /** @type {?} */
        const prop = propertyNames[i];
        bindings[i] = {
          flags: 8
          /* TypeProperty */
          ,
          name: prop,
          ns: null,
          nonMinifiedName: prop,
          securityContext: null,
          suffix: null
        };
      }

      return {
        // will bet set by the view definition
        nodeIndex: -1,
        parent: null,
        renderParent: null,
        bindingIndex: -1,
        outputIndex: -1,
        // regular values
        checkIndex,
        flags,
        childFlags: 0,
        directChildFlags: 0,
        childMatchedQueries: 0,
        matchedQueries: {},
        matchedQueryIds: 0,
        references: {},
        ngContentIndex: -1,
        childCount: 0,
        bindings,
        bindingFlags: calcBindingFlags(bindings),
        outputs: [],
        element: null,
        provider: null,
        text: null,
        query: null,
        ngContent: null
      };
    }
    /**
     * @param {?} view
     * @param {?} def
     * @return {?}
     */


    function createPureExpression(view, def) {
      return {
        value: undefined
      };
    }
    /**
     * @param {?} view
     * @param {?} def
     * @param {?} v0
     * @param {?} v1
     * @param {?} v2
     * @param {?} v3
     * @param {?} v4
     * @param {?} v5
     * @param {?} v6
     * @param {?} v7
     * @param {?} v8
     * @param {?} v9
     * @return {?}
     */


    function checkAndUpdatePureExpressionInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
      /** @type {?} */
      const bindings = def.bindings;
      /** @type {?} */

      let changed = false;
      /** @type {?} */

      const bindLen = bindings.length;
      if (bindLen > 0 && checkAndUpdateBinding(view, def, 0, v0)) changed = true;
      if (bindLen > 1 && checkAndUpdateBinding(view, def, 1, v1)) changed = true;
      if (bindLen > 2 && checkAndUpdateBinding(view, def, 2, v2)) changed = true;
      if (bindLen > 3 && checkAndUpdateBinding(view, def, 3, v3)) changed = true;
      if (bindLen > 4 && checkAndUpdateBinding(view, def, 4, v4)) changed = true;
      if (bindLen > 5 && checkAndUpdateBinding(view, def, 5, v5)) changed = true;
      if (bindLen > 6 && checkAndUpdateBinding(view, def, 6, v6)) changed = true;
      if (bindLen > 7 && checkAndUpdateBinding(view, def, 7, v7)) changed = true;
      if (bindLen > 8 && checkAndUpdateBinding(view, def, 8, v8)) changed = true;
      if (bindLen > 9 && checkAndUpdateBinding(view, def, 9, v9)) changed = true;

      if (changed) {
        /** @type {?} */
        const data = asPureExpressionData(view, def.nodeIndex);
        /** @type {?} */

        let value;

        switch (def.flags & 201347067
        /* Types */
        ) {
          case 32
          /* TypePureArray */
          :
            value = new Array(bindings.length);
            if (bindLen > 0) value[0] = v0;
            if (bindLen > 1) value[1] = v1;
            if (bindLen > 2) value[2] = v2;
            if (bindLen > 3) value[3] = v3;
            if (bindLen > 4) value[4] = v4;
            if (bindLen > 5) value[5] = v5;
            if (bindLen > 6) value[6] = v6;
            if (bindLen > 7) value[7] = v7;
            if (bindLen > 8) value[8] = v8;
            if (bindLen > 9) value[9] = v9;
            break;

          case 64
          /* TypePureObject */
          :
            value = {};
            if (bindLen > 0) value[
            /** @type {?} */
            bindings[0].name] = v0;
            if (bindLen > 1) value[
            /** @type {?} */
            bindings[1].name] = v1;
            if (bindLen > 2) value[
            /** @type {?} */
            bindings[2].name] = v2;
            if (bindLen > 3) value[
            /** @type {?} */
            bindings[3].name] = v3;
            if (bindLen > 4) value[
            /** @type {?} */
            bindings[4].name] = v4;
            if (bindLen > 5) value[
            /** @type {?} */
            bindings[5].name] = v5;
            if (bindLen > 6) value[
            /** @type {?} */
            bindings[6].name] = v6;
            if (bindLen > 7) value[
            /** @type {?} */
            bindings[7].name] = v7;
            if (bindLen > 8) value[
            /** @type {?} */
            bindings[8].name] = v8;
            if (bindLen > 9) value[
            /** @type {?} */
            bindings[9].name] = v9;
            break;

          case 128
          /* TypePurePipe */
          :
            /** @type {?} */
            const pipe = v0;

            switch (bindLen) {
              case 1:
                value = pipe.transform(v0);
                break;

              case 2:
                value = pipe.transform(v1);
                break;

              case 3:
                value = pipe.transform(v1, v2);
                break;

              case 4:
                value = pipe.transform(v1, v2, v3);
                break;

              case 5:
                value = pipe.transform(v1, v2, v3, v4);
                break;

              case 6:
                value = pipe.transform(v1, v2, v3, v4, v5);
                break;

              case 7:
                value = pipe.transform(v1, v2, v3, v4, v5, v6);
                break;

              case 8:
                value = pipe.transform(v1, v2, v3, v4, v5, v6, v7);
                break;

              case 9:
                value = pipe.transform(v1, v2, v3, v4, v5, v6, v7, v8);
                break;

              case 10:
                value = pipe.transform(v1, v2, v3, v4, v5, v6, v7, v8, v9);
                break;
            }

            break;
        }

        data.value = value;
      }

      return changed;
    }
    /**
     * @param {?} view
     * @param {?} def
     * @param {?} values
     * @return {?}
     */


    function checkAndUpdatePureExpressionDynamic(view, def, values) {
      /** @type {?} */
      const bindings = def.bindings;
      /** @type {?} */

      let changed = false;

      for (let i = 0; i < values.length; i++) {
        // Note: We need to loop over all values, so that
        // the old values are updates as well!
        if (checkAndUpdateBinding(view, def, i, values[i])) {
          changed = true;
        }
      }

      if (changed) {
        /** @type {?} */
        const data = asPureExpressionData(view, def.nodeIndex);
        /** @type {?} */

        let value;

        switch (def.flags & 201347067
        /* Types */
        ) {
          case 32
          /* TypePureArray */
          :
            value = values;
            break;

          case 64
          /* TypePureObject */
          :
            value = {};

            for (let i = 0; i < values.length; i++) {
              value[
              /** @type {?} */
              bindings[i].name] = values[i];
            }

            break;

          case 128
          /* TypePurePipe */
          :
            /** @type {?} */
            const pipe = values[0];
            /** @type {?} */

            const params = values.slice(1);
            value =
            /** @type {?} */
            pipe.transform(...params);
            break;
        }

        data.value = value;
      }

      return changed;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} checkIndex
     * @param {?} ngContentIndex
     * @param {?} staticText
     * @return {?}
     */


    function textDef(checkIndex, ngContentIndex, staticText) {
      /** @type {?} */
      const bindings = new Array(staticText.length - 1);

      for (let i = 1; i < staticText.length; i++) {
        bindings[i - 1] = {
          flags: 8
          /* TypeProperty */
          ,
          name: null,
          ns: null,
          nonMinifiedName: null,
          securityContext: null,
          suffix: staticText[i]
        };
      }

      return {
        // will bet set by the view definition
        nodeIndex: -1,
        parent: null,
        renderParent: null,
        bindingIndex: -1,
        outputIndex: -1,
        // regular values
        checkIndex,
        flags: 2
        /* TypeText */
        ,
        childFlags: 0,
        directChildFlags: 0,
        childMatchedQueries: 0,
        matchedQueries: {},
        matchedQueryIds: 0,
        references: {},
        ngContentIndex,
        childCount: 0,
        bindings,
        bindingFlags: 8
        /* TypeProperty */
        ,
        outputs: [],
        element: null,
        provider: null,
        text: {
          prefix: staticText[0]
        },
        query: null,
        ngContent: null
      };
    }
    /**
     * @param {?} view
     * @param {?} renderHost
     * @param {?} def
     * @return {?}
     */


    function createText(view, renderHost, def) {
      /** @type {?} */
      let renderNode;
      /** @type {?} */

      const renderer = view.renderer;
      renderNode = renderer.createText(
      /** @type {?} */
      def.text.prefix);
      /** @type {?} */

      const parentEl = getParentRenderElement(view, renderHost, def);

      if (parentEl) {
        renderer.appendChild(parentEl, renderNode);
      }

      return {
        renderText: renderNode
      };
    }
    /**
     * @param {?} view
     * @param {?} def
     * @param {?} v0
     * @param {?} v1
     * @param {?} v2
     * @param {?} v3
     * @param {?} v4
     * @param {?} v5
     * @param {?} v6
     * @param {?} v7
     * @param {?} v8
     * @param {?} v9
     * @return {?}
     */


    function checkAndUpdateTextInline(view, def, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
      /** @type {?} */
      let changed = false;
      /** @type {?} */

      const bindings = def.bindings;
      /** @type {?} */

      const bindLen = bindings.length;
      if (bindLen > 0 && checkAndUpdateBinding(view, def, 0, v0)) changed = true;
      if (bindLen > 1 && checkAndUpdateBinding(view, def, 1, v1)) changed = true;
      if (bindLen > 2 && checkAndUpdateBinding(view, def, 2, v2)) changed = true;
      if (bindLen > 3 && checkAndUpdateBinding(view, def, 3, v3)) changed = true;
      if (bindLen > 4 && checkAndUpdateBinding(view, def, 4, v4)) changed = true;
      if (bindLen > 5 && checkAndUpdateBinding(view, def, 5, v5)) changed = true;
      if (bindLen > 6 && checkAndUpdateBinding(view, def, 6, v6)) changed = true;
      if (bindLen > 7 && checkAndUpdateBinding(view, def, 7, v7)) changed = true;
      if (bindLen > 8 && checkAndUpdateBinding(view, def, 8, v8)) changed = true;
      if (bindLen > 9 && checkAndUpdateBinding(view, def, 9, v9)) changed = true;

      if (changed) {
        /** @type {?} */
        let value =
        /** @type {?} */
        def.text.prefix;
        if (bindLen > 0) value += _addInterpolationPart(v0, bindings[0]);
        if (bindLen > 1) value += _addInterpolationPart(v1, bindings[1]);
        if (bindLen > 2) value += _addInterpolationPart(v2, bindings[2]);
        if (bindLen > 3) value += _addInterpolationPart(v3, bindings[3]);
        if (bindLen > 4) value += _addInterpolationPart(v4, bindings[4]);
        if (bindLen > 5) value += _addInterpolationPart(v5, bindings[5]);
        if (bindLen > 6) value += _addInterpolationPart(v6, bindings[6]);
        if (bindLen > 7) value += _addInterpolationPart(v7, bindings[7]);
        if (bindLen > 8) value += _addInterpolationPart(v8, bindings[8]);
        if (bindLen > 9) value += _addInterpolationPart(v9, bindings[9]);
        /** @type {?} */

        const renderNode = asTextData(view, def.nodeIndex).renderText;
        view.renderer.setValue(renderNode, value);
      }

      return changed;
    }
    /**
     * @param {?} view
     * @param {?} def
     * @param {?} values
     * @return {?}
     */


    function checkAndUpdateTextDynamic(view, def, values) {
      /** @type {?} */
      const bindings = def.bindings;
      /** @type {?} */

      let changed = false;

      for (let i = 0; i < values.length; i++) {
        // Note: We need to loop over all values, so that
        // the old values are updates as well!
        if (checkAndUpdateBinding(view, def, i, values[i])) {
          changed = true;
        }
      }

      if (changed) {
        /** @type {?} */
        let value = '';

        for (let i = 0; i < values.length; i++) {
          value = value + _addInterpolationPart(values[i], bindings[i]);
        }

        value =
        /** @type {?} */
        def.text.prefix + value;
        /** @type {?} */

        const renderNode = asTextData(view, def.nodeIndex).renderText;
        view.renderer.setValue(renderNode, value);
      }

      return changed;
    }
    /**
     * @param {?} value
     * @param {?} binding
     * @return {?}
     */


    function _addInterpolationPart(value, binding) {
      /** @type {?} */
      const valueStr = value != null ? value.toString() : '';
      return valueStr + binding.suffix;
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} flags
     * @param {?} nodes
     * @param {?=} updateDirectives
     * @param {?=} updateRenderer
     * @return {?}
     */


    function viewDef(flags, nodes, updateDirectives, updateRenderer) {
      // clone nodes and set auto calculated values

      /** @type {?} */
      let viewBindingCount = 0;
      /** @type {?} */

      let viewDisposableCount = 0;
      /** @type {?} */

      let viewNodeFlags = 0;
      /** @type {?} */

      let viewRootNodeFlags = 0;
      /** @type {?} */

      let viewMatchedQueries = 0;
      /** @type {?} */

      let currentParent = null;
      /** @type {?} */

      let currentRenderParent = null;
      /** @type {?} */

      let currentElementHasPublicProviders = false;
      /** @type {?} */

      let currentElementHasPrivateProviders = false;
      /** @type {?} */

      let lastRenderRootNode = null;

      for (let i = 0; i < nodes.length; i++) {
        /** @type {?} */
        const node = nodes[i];
        node.nodeIndex = i;
        node.parent = currentParent;
        node.bindingIndex = viewBindingCount;
        node.outputIndex = viewDisposableCount;
        node.renderParent = currentRenderParent;
        viewNodeFlags |= node.flags;
        viewMatchedQueries |= node.matchedQueryIds;

        if (node.element) {
          /** @type {?} */
          const elDef = node.element;
          elDef.publicProviders = currentParent ?
          /** @type {?} */
          currentParent.element.publicProviders : Object.create(null);
          elDef.allProviders = elDef.publicProviders; // Note: We assume that all providers of an element are before any child element!

          currentElementHasPublicProviders = false;
          currentElementHasPrivateProviders = false;

          if (node.element.template) {
            viewMatchedQueries |= node.element.template.nodeMatchedQueries;
          }
        }

        validateNode(currentParent, node, nodes.length);
        viewBindingCount += node.bindings.length;
        viewDisposableCount += node.outputs.length;

        if (!currentRenderParent && node.flags & 3
        /* CatRenderNode */
        ) {
          lastRenderRootNode = node;
        }

        if (node.flags & 20224
        /* CatProvider */
        ) {
            if (!currentElementHasPublicProviders) {
              currentElementHasPublicProviders = true; // Use prototypical inheritance to not get O(n^2) complexity...

              /** @type {?} */

              /** @type {?} */
              currentParent.element.publicProviders = Object.create(
              /** @type {?} */

              /** @type {?} */
              currentParent.element.publicProviders);

              /** @type {?} */

              /** @type {?} */
              currentParent.element.allProviders =
              /** @type {?} */

              /** @type {?} */
              currentParent.element.publicProviders;
            }
            /** @type {?} */


            const isPrivateService = (node.flags & 8192
            /* PrivateProvider */
            ) !== 0;
            /** @type {?} */

            const isComponent = (node.flags & 32768
            /* Component */
            ) !== 0;

            if (!isPrivateService || isComponent) {
              /** @type {?} */

              /** @type {?} */

              /** @type {?} */
              currentParent.element.publicProviders[tokenKey(
              /** @type {?} */
              node.provider.token)] = node;
            } else {
              if (!currentElementHasPrivateProviders) {
                currentElementHasPrivateProviders = true; // Use prototypical inheritance to not get O(n^2) complexity...

                /** @type {?} */

                /** @type {?} */
                currentParent.element.allProviders = Object.create(
                /** @type {?} */

                /** @type {?} */
                currentParent.element.publicProviders);
              }

              /** @type {?} */

              /** @type {?} */

              /** @type {?} */
              currentParent.element.allProviders[tokenKey(
              /** @type {?} */
              node.provider.token)] = node;
            }

            if (isComponent) {
              /** @type {?} */

              /** @type {?} */
              currentParent.element.componentProvider = node;
            }
          }

        if (currentParent) {
          currentParent.childFlags |= node.flags;
          currentParent.directChildFlags |= node.flags;
          currentParent.childMatchedQueries |= node.matchedQueryIds;

          if (node.element && node.element.template) {
            currentParent.childMatchedQueries |= node.element.template.nodeMatchedQueries;
          }
        } else {
          viewRootNodeFlags |= node.flags;
        }

        if (node.childCount > 0) {
          currentParent = node;

          if (!isNgContainer(node)) {
            currentRenderParent = node;
          }
        } else {
          // When the current node has no children, check if it is the last children of its parent.
          // When it is, propagate the flags up.
          // The loop is required because an element could be the last transitive children of several
          // elements. We loop to either the root or the highest opened element (= with remaining
          // children)
          while (currentParent && i === currentParent.nodeIndex + currentParent.childCount) {
            /** @type {?} */
            const newParent = currentParent.parent;

            if (newParent) {
              newParent.childFlags |= currentParent.childFlags;
              newParent.childMatchedQueries |= currentParent.childMatchedQueries;
            }

            currentParent = newParent; // We also need to update the render parent & account for ng-container

            if (currentParent && isNgContainer(currentParent)) {
              currentRenderParent = currentParent.renderParent;
            } else {
              currentRenderParent = currentParent;
            }
          }
        }
      }
      /** @type {?} */


      const handleEvent =
      /**
      * @param {?} view
      * @param {?} nodeIndex
      * @param {?} eventName
      * @param {?} event
      * @return {?}
      */
      (view, nodeIndex, eventName, event) =>
      /** @type {?} */

      /** @type {?} */
      nodes[nodeIndex].element.handleEvent(view, eventName, event);

      return {
        // Will be filled later...
        factory: null,
        nodeFlags: viewNodeFlags,
        rootNodeFlags: viewRootNodeFlags,
        nodeMatchedQueries: viewMatchedQueries,
        flags,
        nodes: nodes,
        updateDirectives: updateDirectives || NOOP,
        updateRenderer: updateRenderer || NOOP,
        handleEvent,
        bindingCount: viewBindingCount,
        outputCount: viewDisposableCount,
        lastRenderRootNode
      };
    }
    /**
     * @param {?} node
     * @return {?}
     */


    function isNgContainer(node) {
      return (node.flags & 1
      /* TypeElement */
      ) !== 0 &&
      /** @type {?} */
      node.element.name === null;
    }
    /**
     * @param {?} parent
     * @param {?} node
     * @param {?} nodeCount
     * @return {?}
     */


    function validateNode(parent, node, nodeCount) {
      /** @type {?} */
      const template = node.element && node.element.template;

      if (template) {
        if (!template.lastRenderRootNode) {
          throw new Error("Illegal State: Embedded templates without nodes are not allowed!");
        }

        if (template.lastRenderRootNode && template.lastRenderRootNode.flags & 16777216
        /* EmbeddedViews */
        ) {
            throw new Error("Illegal State: Last root node of a template can't have embedded views, at index ".concat(node.nodeIndex, "!"));
          }
      }

      if (node.flags & 20224
      /* CatProvider */
      ) {
          /** @type {?} */
          const parentFlags = parent ? parent.flags : 0;

          if ((parentFlags & 1
          /* TypeElement */
          ) === 0) {
            throw new Error("Illegal State: StaticProvider/Directive nodes need to be children of elements or anchors, at index ".concat(node.nodeIndex, "!"));
          }
        }

      if (node.query) {
        if (node.flags & 67108864
        /* TypeContentQuery */
        && (!parent || (parent.flags & 16384
        /* TypeDirective */
        ) === 0)) {
          throw new Error("Illegal State: Content Query nodes need to be children of directives, at index ".concat(node.nodeIndex, "!"));
        }

        if (node.flags & 134217728
        /* TypeViewQuery */
        && parent) {
          throw new Error("Illegal State: View Query nodes have to be top level nodes, at index ".concat(node.nodeIndex, "!"));
        }
      }

      if (node.childCount) {
        /** @type {?} */
        const parentEnd = parent ? parent.nodeIndex + parent.childCount : nodeCount - 1;

        if (node.nodeIndex <= parentEnd && node.nodeIndex + node.childCount > parentEnd) {
          throw new Error("Illegal State: childCount of node leads outside of parent, at index ".concat(node.nodeIndex, "!"));
        }
      }
    }
    /**
     * @param {?} parent
     * @param {?} anchorDef
     * @param {?} viewDef
     * @param {?=} context
     * @return {?}
     */


    function createEmbeddedView(parent, anchorDef, viewDef, context) {
      // embedded views are seen as siblings to the anchor, so we need
      // to get the parent of the anchor and use it as parentIndex.

      /** @type {?} */
      const view = createView(parent.root, parent.renderer, parent, anchorDef, viewDef);
      initView(view, parent.component, context);
      createViewNodes(view);
      return view;
    }
    /**
     * @param {?} root
     * @param {?} def
     * @param {?=} context
     * @return {?}
     */


    function createRootView(root, def, context) {
      /** @type {?} */
      const view = createView(root, root.renderer, null, null, def);
      initView(view, context, context);
      createViewNodes(view);
      return view;
    }
    /**
     * @param {?} parentView
     * @param {?} nodeDef
     * @param {?} viewDef
     * @param {?} hostElement
     * @return {?}
     */


    function createComponentView(parentView, nodeDef, viewDef, hostElement) {
      /** @type {?} */
      const rendererType =
      /** @type {?} */
      nodeDef.element.componentRendererType;
      /** @type {?} */

      let compRenderer;

      if (!rendererType) {
        compRenderer = parentView.root.renderer;
      } else {
        compRenderer = parentView.root.rendererFactory.createRenderer(hostElement, rendererType);
      }

      return createView(parentView.root, compRenderer, parentView,
      /** @type {?} */
      nodeDef.element.componentProvider, viewDef);
    }
    /**
     * @param {?} root
     * @param {?} renderer
     * @param {?} parent
     * @param {?} parentNodeDef
     * @param {?} def
     * @return {?}
     */


    function createView(root, renderer, parent, parentNodeDef, def) {
      /** @type {?} */
      const nodes = new Array(def.nodes.length);
      /** @type {?} */

      const disposables = def.outputCount ? new Array(def.outputCount) : null;
      /** @type {?} */

      const view = {
        def,
        parent,
        viewContainerParent: null,
        parentNodeDef,
        context: null,
        component: null,
        nodes,
        state: 13
        /* CatInit */
        ,
        root,
        renderer,
        oldValues: new Array(def.bindingCount),
        disposables,
        initIndex: -1
      };
      return view;
    }
    /**
     * @param {?} view
     * @param {?} component
     * @param {?} context
     * @return {?}
     */


    function initView(view, component, context) {
      view.component = component;
      view.context = context;
    }
    /**
     * @param {?} view
     * @return {?}
     */


    function createViewNodes(view) {
      /** @type {?} */
      let renderHost;

      if (isComponentView(view)) {
        /** @type {?} */
        const hostDef = view.parentNodeDef;
        renderHost = asElementData(
        /** @type {?} */
        view.parent,
        /** @type {?} */

        /** @type {?} */
        hostDef.parent.nodeIndex).renderElement;
      }
      /** @type {?} */


      const def = view.def;
      /** @type {?} */

      const nodes = view.nodes;

      for (let i = 0; i < def.nodes.length; i++) {
        /** @type {?} */
        const nodeDef = def.nodes[i];
        Services.setCurrentNode(view, i);
        /** @type {?} */

        let nodeData;

        switch (nodeDef.flags & 201347067
        /* Types */
        ) {
          case 1
          /* TypeElement */
          :
            /** @type {?} */
            const el =
            /** @type {?} */
            createElement(view, renderHost, nodeDef);
            /** @type {?} */

            let componentView =
            /** @type {?} */
            undefined;

            if (nodeDef.flags & 33554432
            /* ComponentView */
            ) {
                /** @type {?} */
                const compViewDef = resolveDefinition(
                /** @type {?} */

                /** @type {?} */
                nodeDef.element.componentView);
                componentView = Services.createComponentView(view, nodeDef, compViewDef, el);
              }

            listenToElementOutputs(view, componentView, nodeDef, el);
            nodeData =
            /** @type {?} */
            {
              renderElement: el,
              componentView,
              viewContainer: null,
              template:
              /** @type {?} */
              nodeDef.element.template ? createTemplateData(view, nodeDef) : undefined
            };

            if (nodeDef.flags & 16777216
            /* EmbeddedViews */
            ) {
                nodeData.viewContainer = createViewContainerData(view, nodeDef, nodeData);
              }

            break;

          case 2
          /* TypeText */
          :
            nodeData =
            /** @type {?} */
            createText(view, renderHost, nodeDef);
            break;

          case 512
          /* TypeClassProvider */
          :
          case 1024
          /* TypeFactoryProvider */
          :
          case 2048
          /* TypeUseExistingProvider */
          :
          case 256
          /* TypeValueProvider */
          :
            {
              nodeData = nodes[i];

              if (!nodeData && !(nodeDef.flags & 4096
              /* LazyProvider */
              )) {
                /** @type {?} */
                const instance = createProviderInstance(view, nodeDef);
                nodeData =
                /** @type {?} */
                {
                  instance
                };
              }

              break;
            }

          case 16
          /* TypePipe */
          :
            {
              /** @type {?} */
              const instance = createPipeInstance(view, nodeDef);
              nodeData =
              /** @type {?} */
              {
                instance
              };
              break;
            }

          case 16384
          /* TypeDirective */
          :
            {
              nodeData = nodes[i];

              if (!nodeData) {
                /** @type {?} */
                const instance = createDirectiveInstance(view, nodeDef);
                nodeData =
                /** @type {?} */
                {
                  instance
                };
              }

              if (nodeDef.flags & 32768
              /* Component */
              ) {
                  /** @type {?} */
                  const compView = asElementData(view,
                  /** @type {?} */
                  nodeDef.parent.nodeIndex).componentView;
                  initView(compView, nodeData.instance, nodeData.instance);
                }

              break;
            }

          case 32
          /* TypePureArray */
          :
          case 64
          /* TypePureObject */
          :
          case 128
          /* TypePurePipe */
          :
            nodeData =
            /** @type {?} */
            createPureExpression(view, nodeDef);
            break;

          case 67108864
          /* TypeContentQuery */
          :
          case 134217728
          /* TypeViewQuery */
          :
            nodeData =
            /** @type {?} */
            createQuery();
            break;

          case 8
          /* TypeNgContent */
          :
            appendNgContent(view, renderHost, nodeDef); // no runtime data needed for NgContent...

            nodeData = undefined;
            break;
        }

        nodes[i] = nodeData;
      } // Create the ViewData.nodes of component views after we created everything else,
      // so that e.g. ng-content works


      execComponentViewsAction(view, ViewAction.CreateViewNodes); // fill static content and view queries

      execQueriesAction(view, 67108864
      /* TypeContentQuery */
      | 134217728
      /* TypeViewQuery */
      , 268435456
      /* StaticQuery */
      , 0
      /* CheckAndUpdate */
      );
    }
    /**
     * @param {?} view
     * @return {?}
     */


    function checkNoChangesView(view) {
      markProjectedViewsForCheck(view);
      Services.updateDirectives(view, 1
      /* CheckNoChanges */
      );
      execEmbeddedViewsAction(view, ViewAction.CheckNoChanges);
      Services.updateRenderer(view, 1
      /* CheckNoChanges */
      );
      execComponentViewsAction(view, ViewAction.CheckNoChanges); // Note: We don't check queries for changes as we didn't do this in v2.x.
      // TODO(tbosch): investigate if we can enable the check again in v5.x with a nicer error message.

      view.state &= ~(64
      /* CheckProjectedViews */
      | 32
      /* CheckProjectedView */
      );
    }
    /**
     * @param {?} view
     * @return {?}
     */


    function checkAndUpdateView(view) {
      if (view.state & 1
      /* BeforeFirstCheck */
      ) {
          view.state &= ~1
          /* BeforeFirstCheck */
          ;
          view.state |= 2
          /* FirstCheck */
          ;
        } else {
        view.state &= ~2
        /* FirstCheck */
        ;
      }

      shiftInitState(view, 0
      /* InitState_BeforeInit */
      , 256
      /* InitState_CallingOnInit */
      );
      markProjectedViewsForCheck(view);
      Services.updateDirectives(view, 0
      /* CheckAndUpdate */
      );
      execEmbeddedViewsAction(view, ViewAction.CheckAndUpdate);
      execQueriesAction(view, 67108864
      /* TypeContentQuery */
      , 536870912
      /* DynamicQuery */
      , 0
      /* CheckAndUpdate */
      );
      /** @type {?} */

      let callInit = shiftInitState(view, 256
      /* InitState_CallingOnInit */
      , 512
      /* InitState_CallingAfterContentInit */
      );
      callLifecycleHooksChildrenFirst(view, 2097152
      /* AfterContentChecked */
      | (callInit ? 1048576
      /* AfterContentInit */
      : 0));
      Services.updateRenderer(view, 0
      /* CheckAndUpdate */
      );
      execComponentViewsAction(view, ViewAction.CheckAndUpdate);
      execQueriesAction(view, 134217728
      /* TypeViewQuery */
      , 536870912
      /* DynamicQuery */
      , 0
      /* CheckAndUpdate */
      );
      callInit = shiftInitState(view, 512
      /* InitState_CallingAfterContentInit */
      , 768
      /* InitState_CallingAfterViewInit */
      );
      callLifecycleHooksChildrenFirst(view, 8388608
      /* AfterViewChecked */
      | (callInit ? 4194304
      /* AfterViewInit */
      : 0));

      if (view.def.flags & 2
      /* OnPush */
      ) {
          view.state &= ~8
          /* ChecksEnabled */
          ;
        }

      view.state &= ~(64
      /* CheckProjectedViews */
      | 32
      /* CheckProjectedView */
      );
      shiftInitState(view, 768
      /* InitState_CallingAfterViewInit */
      , 1024
      /* InitState_AfterInit */
      );
    }
    /**
     * @param {?} view
     * @param {?} nodeDef
     * @param {?} argStyle
     * @param {?=} v0
     * @param {?=} v1
     * @param {?=} v2
     * @param {?=} v3
     * @param {?=} v4
     * @param {?=} v5
     * @param {?=} v6
     * @param {?=} v7
     * @param {?=} v8
     * @param {?=} v9
     * @return {?}
     */


    function checkAndUpdateNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
      if (argStyle === 0
      /* Inline */
      ) {
          return checkAndUpdateNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
        } else {
        return checkAndUpdateNodeDynamic(view, nodeDef, v0);
      }
    }
    /**
     * @param {?} view
     * @return {?}
     */


    function markProjectedViewsForCheck(view) {
      /** @type {?} */
      const def = view.def;

      if (!(def.nodeFlags & 4
      /* ProjectedTemplate */
      )) {
        return;
      }

      for (let i = 0; i < def.nodes.length; i++) {
        /** @type {?} */
        const nodeDef = def.nodes[i];

        if (nodeDef.flags & 4
        /* ProjectedTemplate */
        ) {
            /** @type {?} */
            const projectedViews = asElementData(view, i).template._projectedViews;

            if (projectedViews) {
              for (let i = 0; i < projectedViews.length; i++) {
                /** @type {?} */
                const projectedView = projectedViews[i];
                projectedView.state |= 32
                /* CheckProjectedView */
                ;
                markParentViewsForCheckProjectedViews(projectedView, view);
              }
            }
          } else if ((nodeDef.childFlags & 4
        /* ProjectedTemplate */
        ) === 0) {
          // a parent with leafs
          // no child is a component,
          // then skip the children
          i += nodeDef.childCount;
        }
      }
    }
    /**
     * @param {?} view
     * @param {?} nodeDef
     * @param {?=} v0
     * @param {?=} v1
     * @param {?=} v2
     * @param {?=} v3
     * @param {?=} v4
     * @param {?=} v5
     * @param {?=} v6
     * @param {?=} v7
     * @param {?=} v8
     * @param {?=} v9
     * @return {?}
     */


    function checkAndUpdateNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
      switch (nodeDef.flags & 201347067
      /* Types */
      ) {
        case 1
        /* TypeElement */
        :
          return checkAndUpdateElementInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);

        case 2
        /* TypeText */
        :
          return checkAndUpdateTextInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);

        case 16384
        /* TypeDirective */
        :
          return checkAndUpdateDirectiveInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);

        case 32
        /* TypePureArray */
        :
        case 64
        /* TypePureObject */
        :
        case 128
        /* TypePurePipe */
        :
          return checkAndUpdatePureExpressionInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);

        default:
          throw 'unreachable';
      }
    }
    /**
     * @param {?} view
     * @param {?} nodeDef
     * @param {?} values
     * @return {?}
     */


    function checkAndUpdateNodeDynamic(view, nodeDef, values) {
      switch (nodeDef.flags & 201347067
      /* Types */
      ) {
        case 1
        /* TypeElement */
        :
          return checkAndUpdateElementDynamic(view, nodeDef, values);

        case 2
        /* TypeText */
        :
          return checkAndUpdateTextDynamic(view, nodeDef, values);

        case 16384
        /* TypeDirective */
        :
          return checkAndUpdateDirectiveDynamic(view, nodeDef, values);

        case 32
        /* TypePureArray */
        :
        case 64
        /* TypePureObject */
        :
        case 128
        /* TypePurePipe */
        :
          return checkAndUpdatePureExpressionDynamic(view, nodeDef, values);

        default:
          throw 'unreachable';
      }
    }
    /**
     * @param {?} view
     * @param {?} nodeDef
     * @param {?} argStyle
     * @param {?=} v0
     * @param {?=} v1
     * @param {?=} v2
     * @param {?=} v3
     * @param {?=} v4
     * @param {?=} v5
     * @param {?=} v6
     * @param {?=} v7
     * @param {?=} v8
     * @param {?=} v9
     * @return {?}
     */


    function checkNoChangesNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
      if (argStyle === 0
      /* Inline */
      ) {
          checkNoChangesNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
        } else {
        checkNoChangesNodeDynamic(view, nodeDef, v0);
      } // Returning false is ok here as we would have thrown in case of a change.


      return false;
    }
    /**
     * @param {?} view
     * @param {?} nodeDef
     * @param {?} v0
     * @param {?} v1
     * @param {?} v2
     * @param {?} v3
     * @param {?} v4
     * @param {?} v5
     * @param {?} v6
     * @param {?} v7
     * @param {?} v8
     * @param {?} v9
     * @return {?}
     */


    function checkNoChangesNodeInline(view, nodeDef, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
      /** @type {?} */
      const bindLen = nodeDef.bindings.length;
      if (bindLen > 0) checkBindingNoChanges(view, nodeDef, 0, v0);
      if (bindLen > 1) checkBindingNoChanges(view, nodeDef, 1, v1);
      if (bindLen > 2) checkBindingNoChanges(view, nodeDef, 2, v2);
      if (bindLen > 3) checkBindingNoChanges(view, nodeDef, 3, v3);
      if (bindLen > 4) checkBindingNoChanges(view, nodeDef, 4, v4);
      if (bindLen > 5) checkBindingNoChanges(view, nodeDef, 5, v5);
      if (bindLen > 6) checkBindingNoChanges(view, nodeDef, 6, v6);
      if (bindLen > 7) checkBindingNoChanges(view, nodeDef, 7, v7);
      if (bindLen > 8) checkBindingNoChanges(view, nodeDef, 8, v8);
      if (bindLen > 9) checkBindingNoChanges(view, nodeDef, 9, v9);
    }
    /**
     * @param {?} view
     * @param {?} nodeDef
     * @param {?} values
     * @return {?}
     */


    function checkNoChangesNodeDynamic(view, nodeDef, values) {
      for (let i = 0; i < values.length; i++) {
        checkBindingNoChanges(view, nodeDef, i, values[i]);
      }
    }
    /**
     * Workaround https://github.com/angular/tsickle/issues/497
     * @suppress {misplacedTypeAnnotation}
     * @param {?} view
     * @param {?} nodeDef
     * @return {?}
     */


    function checkNoChangesQuery(view, nodeDef) {
      /** @type {?} */
      const queryList = asQueryList(view, nodeDef.nodeIndex);

      if (queryList.dirty) {
        throw expressionChangedAfterItHasBeenCheckedError(Services.createDebugContext(view, nodeDef.nodeIndex), "Query ".concat(
        /** @type {?} */
        nodeDef.query.id, " not dirty"), "Query ".concat(
        /** @type {?} */
        nodeDef.query.id, " dirty"), (view.state & 1
        /* BeforeFirstCheck */
        ) !== 0);
      }
    }
    /**
     * @param {?} view
     * @return {?}
     */


    function destroyView(view) {
      if (view.state & 128
      /* Destroyed */
      ) {
          return;
        }

      execEmbeddedViewsAction(view, ViewAction.Destroy);
      execComponentViewsAction(view, ViewAction.Destroy);
      callLifecycleHooksChildrenFirst(view, 131072
      /* OnDestroy */
      );

      if (view.disposables) {
        for (let i = 0; i < view.disposables.length; i++) {
          view.disposables[i]();
        }
      }

      detachProjectedView(view);

      if (view.renderer.destroyNode) {
        destroyViewNodes(view);
      }

      if (isComponentView(view)) {
        view.renderer.destroy();
      }

      view.state |= 128
      /* Destroyed */
      ;
    }
    /**
     * @param {?} view
     * @return {?}
     */


    function destroyViewNodes(view) {
      /** @type {?} */
      const len = view.def.nodes.length;

      for (let i = 0; i < len; i++) {
        /** @type {?} */
        const def = view.def.nodes[i];

        if (def.flags & 1
        /* TypeElement */
        ) {
            /** @type {?} */
            view.renderer.destroyNode(asElementData(view, i).renderElement);
          } else if (def.flags & 2
        /* TypeText */
        ) {
            /** @type {?} */
            view.renderer.destroyNode(asTextData(view, i).renderText);
          } else if (def.flags & 67108864
        /* TypeContentQuery */
        || def.flags & 134217728
        /* TypeViewQuery */
        ) {
            asQueryList(view, i).destroy();
          }
      }
    }
    /** @enum {number} */


    const ViewAction = {
      CreateViewNodes: 0,
      CheckNoChanges: 1,
      CheckNoChangesProjectedViews: 2,
      CheckAndUpdate: 3,
      CheckAndUpdateProjectedViews: 4,
      Destroy: 5
    };
    ViewAction[ViewAction.CreateViewNodes] = 'CreateViewNodes';
    ViewAction[ViewAction.CheckNoChanges] = 'CheckNoChanges';
    ViewAction[ViewAction.CheckNoChangesProjectedViews] = 'CheckNoChangesProjectedViews';
    ViewAction[ViewAction.CheckAndUpdate] = 'CheckAndUpdate';
    ViewAction[ViewAction.CheckAndUpdateProjectedViews] = 'CheckAndUpdateProjectedViews';
    ViewAction[ViewAction.Destroy] = 'Destroy';
    /**
     * @param {?} view
     * @param {?} action
     * @return {?}
     */

    function execComponentViewsAction(view, action) {
      /** @type {?} */
      const def = view.def;

      if (!(def.nodeFlags & 33554432
      /* ComponentView */
      )) {
        return;
      }

      for (let i = 0; i < def.nodes.length; i++) {
        /** @type {?} */
        const nodeDef = def.nodes[i];

        if (nodeDef.flags & 33554432
        /* ComponentView */
        ) {
            // a leaf
            callViewAction(asElementData(view, i).componentView, action);
          } else if ((nodeDef.childFlags & 33554432
        /* ComponentView */
        ) === 0) {
          // a parent with leafs
          // no child is a component,
          // then skip the children
          i += nodeDef.childCount;
        }
      }
    }
    /**
     * @param {?} view
     * @param {?} action
     * @return {?}
     */


    function execEmbeddedViewsAction(view, action) {
      /** @type {?} */
      const def = view.def;

      if (!(def.nodeFlags & 16777216
      /* EmbeddedViews */
      )) {
        return;
      }

      for (let i = 0; i < def.nodes.length; i++) {
        /** @type {?} */
        const nodeDef = def.nodes[i];

        if (nodeDef.flags & 16777216
        /* EmbeddedViews */
        ) {
            // a leaf

            /** @type {?} */
            const embeddedViews =
            /** @type {?} */
            asElementData(view, i).viewContainer._embeddedViews;

            for (let k = 0; k < embeddedViews.length; k++) {
              callViewAction(embeddedViews[k], action);
            }
          } else if ((nodeDef.childFlags & 16777216
        /* EmbeddedViews */
        ) === 0) {
          // a parent with leafs
          // no child is a component,
          // then skip the children
          i += nodeDef.childCount;
        }
      }
    }
    /**
     * @param {?} view
     * @param {?} action
     * @return {?}
     */


    function callViewAction(view, action) {
      /** @type {?} */
      const viewState = view.state;

      switch (action) {
        case ViewAction.CheckNoChanges:
          if ((viewState & 128
          /* Destroyed */
          ) === 0) {
            if ((viewState & 12
            /* CatDetectChanges */
            ) === 12
            /* CatDetectChanges */
            ) {
                checkNoChangesView(view);
              } else if (viewState & 64
            /* CheckProjectedViews */
            ) {
                execProjectedViewsAction(view, ViewAction.CheckNoChangesProjectedViews);
              }
          }

          break;

        case ViewAction.CheckNoChangesProjectedViews:
          if ((viewState & 128
          /* Destroyed */
          ) === 0) {
            if (viewState & 32
            /* CheckProjectedView */
            ) {
                checkNoChangesView(view);
              } else if (viewState & 64
            /* CheckProjectedViews */
            ) {
                execProjectedViewsAction(view, action);
              }
          }

          break;

        case ViewAction.CheckAndUpdate:
          if ((viewState & 128
          /* Destroyed */
          ) === 0) {
            if ((viewState & 12
            /* CatDetectChanges */
            ) === 12
            /* CatDetectChanges */
            ) {
                checkAndUpdateView(view);
              } else if (viewState & 64
            /* CheckProjectedViews */
            ) {
                execProjectedViewsAction(view, ViewAction.CheckAndUpdateProjectedViews);
              }
          }

          break;

        case ViewAction.CheckAndUpdateProjectedViews:
          if ((viewState & 128
          /* Destroyed */
          ) === 0) {
            if (viewState & 32
            /* CheckProjectedView */
            ) {
                checkAndUpdateView(view);
              } else if (viewState & 64
            /* CheckProjectedViews */
            ) {
                execProjectedViewsAction(view, action);
              }
          }

          break;

        case ViewAction.Destroy:
          // Note: destroyView recurses over all views,
          // so we don't need to special case projected views here.
          destroyView(view);
          break;

        case ViewAction.CreateViewNodes:
          createViewNodes(view);
          break;
      }
    }
    /**
     * @param {?} view
     * @param {?} action
     * @return {?}
     */


    function execProjectedViewsAction(view, action) {
      execEmbeddedViewsAction(view, action);
      execComponentViewsAction(view, action);
    }
    /**
     * @param {?} view
     * @param {?} queryFlags
     * @param {?} staticDynamicQueryFlag
     * @param {?} checkType
     * @return {?}
     */


    function execQueriesAction(view, queryFlags, staticDynamicQueryFlag, checkType) {
      if (!(view.def.nodeFlags & queryFlags) || !(view.def.nodeFlags & staticDynamicQueryFlag)) {
        return;
      }
      /** @type {?} */


      const nodeCount = view.def.nodes.length;

      for (let i = 0; i < nodeCount; i++) {
        /** @type {?} */
        const nodeDef = view.def.nodes[i];

        if (nodeDef.flags & queryFlags && nodeDef.flags & staticDynamicQueryFlag) {
          Services.setCurrentNode(view, nodeDef.nodeIndex);

          switch (checkType) {
            case 0
            /* CheckAndUpdate */
            :
              checkAndUpdateQuery(view, nodeDef);
              break;

            case 1
            /* CheckNoChanges */
            :
              checkNoChangesQuery(view, nodeDef);
              break;
          }
        }

        if (!(nodeDef.childFlags & queryFlags) || !(nodeDef.childFlags & staticDynamicQueryFlag)) {
          // no child has a matching query
          // then skip the children
          i += nodeDef.childCount;
        }
      }
    }
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /** @type {?} */


    let initialized = false;
    /**
     * @return {?}
     */

    function initServicesIfNeeded() {
      if (initialized) {
        return;
      }

      initialized = true;
      /** @type {?} */

      const services = isDevMode() ? createDebugServices() : createProdServices();
      Services.setCurrentNode = services.setCurrentNode;
      Services.createRootView = services.createRootView;
      Services.createEmbeddedView = services.createEmbeddedView;
      Services.createComponentView = services.createComponentView;
      Services.createNgModuleRef = services.createNgModuleRef;
      Services.overrideProvider = services.overrideProvider;
      Services.overrideComponentView = services.overrideComponentView;
      Services.clearOverrides = services.clearOverrides;
      Services.checkAndUpdateView = services.checkAndUpdateView;
      Services.checkNoChangesView = services.checkNoChangesView;
      Services.destroyView = services.destroyView;
      Services.resolveDep = resolveDep;
      Services.createDebugContext = services.createDebugContext;
      Services.handleEvent = services.handleEvent;
      Services.updateDirectives = services.updateDirectives;
      Services.updateRenderer = services.updateRenderer;
      Services.dirtyParentQueries = dirtyParentQueries;
    }
    /**
     * @return {?}
     */


    function createProdServices() {
      return {
        setCurrentNode:
        /**
        * @return {?}
        */
        () => {},
        createRootView: createProdRootView,
        createEmbeddedView: createEmbeddedView,
        createComponentView: createComponentView,
        createNgModuleRef: createNgModuleRef,
        overrideProvider: NOOP,
        overrideComponentView: NOOP,
        clearOverrides: NOOP,
        checkAndUpdateView: checkAndUpdateView,
        checkNoChangesView: checkNoChangesView,
        destroyView: destroyView,
        createDebugContext:
        /**
        * @param {?} view
        * @param {?} nodeIndex
        * @return {?}
        */
        (view, nodeIndex) => new DebugContext_(view, nodeIndex),
        handleEvent:
        /**
        * @param {?} view
        * @param {?} nodeIndex
        * @param {?} eventName
        * @param {?} event
        * @return {?}
        */
        (view, nodeIndex, eventName, event) => view.def.handleEvent(view, nodeIndex, eventName, event),
        updateDirectives:
        /**
        * @param {?} view
        * @param {?} checkType
        * @return {?}
        */
        (view, checkType) => view.def.updateDirectives(checkType === 0
        /* CheckAndUpdate */
        ? prodCheckAndUpdateNode : prodCheckNoChangesNode, view),
        updateRenderer:
        /**
        * @param {?} view
        * @param {?} checkType
        * @return {?}
        */
        (view, checkType) => view.def.updateRenderer(checkType === 0
        /* CheckAndUpdate */
        ? prodCheckAndUpdateNode : prodCheckNoChangesNode, view)
      };
    }
    /**
     * @return {?}
     */


    function createDebugServices() {
      return {
        setCurrentNode: debugSetCurrentNode,
        createRootView: debugCreateRootView,
        createEmbeddedView: debugCreateEmbeddedView,
        createComponentView: debugCreateComponentView,
        createNgModuleRef: debugCreateNgModuleRef,
        overrideProvider: debugOverrideProvider,
        overrideComponentView: debugOverrideComponentView,
        clearOverrides: debugClearOverrides,
        checkAndUpdateView: debugCheckAndUpdateView,
        checkNoChangesView: debugCheckNoChangesView,
        destroyView: debugDestroyView,
        createDebugContext:
        /**
        * @param {?} view
        * @param {?} nodeIndex
        * @return {?}
        */
        (view, nodeIndex) => new DebugContext_(view, nodeIndex),
        handleEvent: debugHandleEvent,
        updateDirectives: debugUpdateDirectives,
        updateRenderer: debugUpdateRenderer
      };
    }
    /**
     * @param {?} elInjector
     * @param {?} projectableNodes
     * @param {?} rootSelectorOrNode
     * @param {?} def
     * @param {?} ngModule
     * @param {?=} context
     * @return {?}
     */


    function createProdRootView(elInjector, projectableNodes, rootSelectorOrNode, def, ngModule, context) {
      /** @type {?} */
      const rendererFactory = ngModule.injector.get(RendererFactory2);
      return createRootView(createRootData(elInjector, ngModule, rendererFactory, projectableNodes, rootSelectorOrNode), def, context);
    }
    /**
     * @param {?} elInjector
     * @param {?} projectableNodes
     * @param {?} rootSelectorOrNode
     * @param {?} def
     * @param {?} ngModule
     * @param {?=} context
     * @return {?}
     */


    function debugCreateRootView(elInjector, projectableNodes, rootSelectorOrNode, def, ngModule, context) {
      /** @type {?} */
      const rendererFactory = ngModule.injector.get(RendererFactory2);
      /** @type {?} */

      const root = createRootData(elInjector, ngModule, new DebugRendererFactory2(rendererFactory), projectableNodes, rootSelectorOrNode);
      /** @type {?} */

      const defWithOverride = applyProviderOverridesToView(def);
      return callWithDebugContext(DebugAction.create, createRootView, null, [root, defWithOverride, context]);
    }
    /**
     * @param {?} elInjector
     * @param {?} ngModule
     * @param {?} rendererFactory
     * @param {?} projectableNodes
     * @param {?} rootSelectorOrNode
     * @return {?}
     */


    function createRootData(elInjector, ngModule, rendererFactory, projectableNodes, rootSelectorOrNode) {
      /** @type {?} */
      const sanitizer = ngModule.injector.get(Sanitizer);
      /** @type {?} */

      const errorHandler = ngModule.injector.get(ErrorHandler);
      /** @type {?} */

      const renderer = rendererFactory.createRenderer(null, null);
      return {
        ngModule,
        injector: elInjector,
        projectableNodes,
        selectorOrNode: rootSelectorOrNode,
        sanitizer,
        rendererFactory,
        renderer,
        errorHandler
      };
    }
    /**
     * @param {?} parentView
     * @param {?} anchorDef
     * @param {?} viewDef
     * @param {?=} context
     * @return {?}
     */


    function debugCreateEmbeddedView(parentView, anchorDef, viewDef, context) {
      /** @type {?} */
      const defWithOverride = applyProviderOverridesToView(viewDef);
      return callWithDebugContext(DebugAction.create, createEmbeddedView, null, [parentView, anchorDef, defWithOverride, context]);
    }
    /**
     * @param {?} parentView
     * @param {?} nodeDef
     * @param {?} viewDef
     * @param {?} hostElement
     * @return {?}
     */


    function debugCreateComponentView(parentView, nodeDef, viewDef, hostElement) {
      /** @type {?} */
      const overrideComponentView = viewDefOverrides.get(
      /** @type {?} */

      /** @type {?} */

      /** @type {?} */
      nodeDef.element.componentProvider.provider.token);

      if (overrideComponentView) {
        viewDef = overrideComponentView;
      } else {
        viewDef = applyProviderOverridesToView(viewDef);
      }

      return callWithDebugContext(DebugAction.create, createComponentView, null, [parentView, nodeDef, viewDef, hostElement]);
    }
    /**
     * @param {?} moduleType
     * @param {?} parentInjector
     * @param {?} bootstrapComponents
     * @param {?} def
     * @return {?}
     */


    function debugCreateNgModuleRef(moduleType, parentInjector, bootstrapComponents, def) {
      /** @type {?} */
      const defWithOverride = applyProviderOverridesToNgModule(def);
      return createNgModuleRef(moduleType, parentInjector, bootstrapComponents, defWithOverride);
    }
    /** @type {?} */


    const providerOverrides = new Map();
    /** @type {?} */

    const providerOverridesWithScope = new Map();
    /** @type {?} */

    const viewDefOverrides = new Map();
    /**
     * @param {?} override
     * @return {?}
     */

    function debugOverrideProvider(override) {
      providerOverrides.set(override.token, override);
      /** @type {?} */

      let injectableDef;

      if (typeof override.token === 'function' && (injectableDef = getInjectableDef(override.token)) && typeof injectableDef.providedIn === 'function') {
        providerOverridesWithScope.set(
        /** @type {?} */
        override.token, override);
      }
    }
    /**
     * @param {?} comp
     * @param {?} compFactory
     * @return {?}
     */


    function debugOverrideComponentView(comp, compFactory) {
      /** @type {?} */
      const hostViewDef = resolveDefinition(getComponentViewDefinitionFactory(compFactory));
      /** @type {?} */

      const compViewDef = resolveDefinition(
      /** @type {?} */

      /** @type {?} */
      hostViewDef.nodes[0].element.componentView);
      viewDefOverrides.set(comp, compViewDef);
    }
    /**
     * @return {?}
     */


    function debugClearOverrides() {
      providerOverrides.clear();
      providerOverridesWithScope.clear();
      viewDefOverrides.clear();
    } // Notes about the algorithm:
    // 1) Locate the providers of an element and check if one of them was overwritten
    // 2) Change the providers of that element
    //
    // We only create new datastructures if we need to, to keep perf impact
    // reasonable.

    /**
     * @param {?} def
     * @return {?}
     */


    function applyProviderOverridesToView(def) {
      if (providerOverrides.size === 0) {
        return def;
      }
      /** @type {?} */


      const elementIndicesWithOverwrittenProviders = findElementIndicesWithOverwrittenProviders(def);

      if (elementIndicesWithOverwrittenProviders.length === 0) {
        return def;
      } // clone the whole view definition,
      // as it maintains references between the nodes that are hard to update.


      def =
      /** @type {?} */
      def.factory(
      /**
      * @return {?}
      */
      () => NOOP);

      for (let i = 0; i < elementIndicesWithOverwrittenProviders.length; i++) {
        applyProviderOverridesToElement(def, elementIndicesWithOverwrittenProviders[i]);
      }

      return def;
      /**
       * @param {?} def
       * @return {?}
       */

      function findElementIndicesWithOverwrittenProviders(def) {
        /** @type {?} */
        const elIndicesWithOverwrittenProviders = [];
        /** @type {?} */

        let lastElementDef = null;

        for (let i = 0; i < def.nodes.length; i++) {
          /** @type {?} */
          const nodeDef = def.nodes[i];

          if (nodeDef.flags & 1
          /* TypeElement */
          ) {
              lastElementDef = nodeDef;
            }

          if (lastElementDef && nodeDef.flags & 3840
          /* CatProviderNoDirective */
          && providerOverrides.has(
          /** @type {?} */
          nodeDef.provider.token)) {
            elIndicesWithOverwrittenProviders.push(
            /** @type {?} */
            lastElementDef.nodeIndex);
            lastElementDef = null;
          }
        }

        return elIndicesWithOverwrittenProviders;
      }
      /**
       * @param {?} viewDef
       * @param {?} elIndex
       * @return {?}
       */


      function applyProviderOverridesToElement(viewDef, elIndex) {
        for (let i = elIndex + 1; i < viewDef.nodes.length; i++) {
          /** @type {?} */
          const nodeDef = viewDef.nodes[i];

          if (nodeDef.flags & 1
          /* TypeElement */
          ) {
              // stop at the next element
              return;
            }

          if (nodeDef.flags & 3840
          /* CatProviderNoDirective */
          ) {
              /** @type {?} */
              const provider =
              /** @type {?} */
              nodeDef.provider;
              /** @type {?} */

              const override = providerOverrides.get(provider.token);

              if (override) {
                nodeDef.flags = nodeDef.flags & ~3840
                /* CatProviderNoDirective */
                | override.flags;
                provider.deps = splitDepsDsl(override.deps);
                provider.value = override.value;
              }
            }
        }
      }
    } // Notes about the algorithm:
    // We only create new datastructures if we need to, to keep perf impact
    // reasonable.

    /**
     * @param {?} def
     * @return {?}
     */


    function applyProviderOverridesToNgModule(def) {
      const {
        hasOverrides,
        hasDeprecatedOverrides
      } = calcHasOverrides(def);

      if (!hasOverrides) {
        return def;
      } // clone the whole view definition,
      // as it maintains references between the nodes that are hard to update.


      def =
      /** @type {?} */
      def.factory(
      /**
      * @return {?}
      */
      () => NOOP);
      applyProviderOverrides(def);
      return def;
      /**
       * @param {?} def
       * @return {?}
       */

      function calcHasOverrides(def) {
        /** @type {?} */
        let hasOverrides = false;
        /** @type {?} */

        let hasDeprecatedOverrides = false;

        if (providerOverrides.size === 0) {
          return {
            hasOverrides,
            hasDeprecatedOverrides
          };
        }

        def.providers.forEach(
        /**
        * @param {?} node
        * @return {?}
        */
        node => {
          /** @type {?} */
          const override = providerOverrides.get(node.token);

          if (node.flags & 3840
          /* CatProviderNoDirective */
          && override) {
            hasOverrides = true;
            hasDeprecatedOverrides = hasDeprecatedOverrides || override.deprecatedBehavior;
          }
        });
        def.modules.forEach(
        /**
        * @param {?} module
        * @return {?}
        */
        module => {
          providerOverridesWithScope.forEach(
          /**
          * @param {?} override
          * @param {?} token
          * @return {?}
          */
          (override, token) => {
            if (
            /** @type {?} */
            getInjectableDef(token).providedIn === module) {
              hasOverrides = true;
              hasDeprecatedOverrides = hasDeprecatedOverrides || override.deprecatedBehavior;
            }
          });
        });
        return {
          hasOverrides,
          hasDeprecatedOverrides
        };
      }
      /**
       * @param {?} def
       * @return {?}
       */


      function applyProviderOverrides(def) {
        for (let i = 0; i < def.providers.length; i++) {
          /** @type {?} */
          const provider = def.providers[i];

          if (hasDeprecatedOverrides) {
            // We had a bug where me made
            // all providers lazy. Keep this logic behind a flag
            // for migrating existing users.
            provider.flags |= 4096
            /* LazyProvider */
            ;
          }
          /** @type {?} */


          const override = providerOverrides.get(provider.token);

          if (override) {
            provider.flags = provider.flags & ~3840
            /* CatProviderNoDirective */
            | override.flags;
            provider.deps = splitDepsDsl(override.deps);
            provider.value = override.value;
          }
        }

        if (providerOverridesWithScope.size > 0) {
          /** @type {?} */
          let moduleSet = new Set(def.modules);
          providerOverridesWithScope.forEach(
          /**
          * @param {?} override
          * @param {?} token
          * @return {?}
          */
          (override, token) => {
            if (moduleSet.has(
            /** @type {?} */
            getInjectableDef(token).providedIn)) {
              /** @type {?} */
              let provider = {
                token: token,
                flags: override.flags | (hasDeprecatedOverrides ? 4096
                /* LazyProvider */
                : 0
                /* None */
                ),
                deps: splitDepsDsl(override.deps),
                value: override.value,
                index: def.providers.length
              };
              def.providers.push(provider);
              def.providersByKey[tokenKey(token)] = provider;
            }
          });
        }
      }
    }
    /**
     * @param {?} view
     * @param {?} checkIndex
     * @param {?} argStyle
     * @param {?=} v0
     * @param {?=} v1
     * @param {?=} v2
     * @param {?=} v3
     * @param {?=} v4
     * @param {?=} v5
     * @param {?=} v6
     * @param {?=} v7
     * @param {?=} v8
     * @param {?=} v9
     * @return {?}
     */


    function prodCheckAndUpdateNode(view, checkIndex, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
      /** @type {?} */
      const nodeDef = view.def.nodes[checkIndex];
      checkAndUpdateNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
      return nodeDef.flags & 224
      /* CatPureExpression */
      ? asPureExpressionData(view, checkIndex).value : undefined;
    }
    /**
     * @param {?} view
     * @param {?} checkIndex
     * @param {?} argStyle
     * @param {?=} v0
     * @param {?=} v1
     * @param {?=} v2
     * @param {?=} v3
     * @param {?=} v4
     * @param {?=} v5
     * @param {?=} v6
     * @param {?=} v7
     * @param {?=} v8
     * @param {?=} v9
     * @return {?}
     */


    function prodCheckNoChangesNode(view, checkIndex, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) {
      /** @type {?} */
      const nodeDef = view.def.nodes[checkIndex];
      checkNoChangesNode(view, nodeDef, argStyle, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9);
      return nodeDef.flags & 224
      /* CatPureExpression */
      ? asPureExpressionData(view, checkIndex).value : undefined;
    }
    /**
     * @param {?} view
     * @return {?}
     */


    function debugCheckAndUpdateView(view) {
      return callWithDebugContext(DebugAction.detectChanges, checkAndUpdateView, null, [view]);
    }
    /**
     * @param {?} view
     * @return {?}
     */


    function debugCheckNoChangesView(view) {
      return callWithDebugContext(DebugAction.checkNoChanges, checkNoChangesView, null, [view]);
    }
    /**
     * @param {?} view
     * @return {?}
     */


    function debugDestroyView(view) {
      return callWithDebugContext(DebugAction.destroy, destroyView, null, [view]);
    }
    /** @enum {number} */


    const DebugAction = {
      create: 0,
      detectChanges: 1,
      checkNoChanges: 2,
      destroy: 3,
      handleEvent: 4
    };
    DebugAction[DebugAction.create] = 'create';
    DebugAction[DebugAction.detectChanges] = 'detectChanges';
    DebugAction[DebugAction.checkNoChanges] = 'checkNoChanges';
    DebugAction[DebugAction.destroy] = 'destroy';
    DebugAction[DebugAction.handleEvent] = 'handleEvent';
    /** @type {?} */

    let _currentAction;
    /** @type {?} */


    let _currentView;
    /** @type {?} */


    let _currentNodeIndex;
    /**
     * @param {?} view
     * @param {?} nodeIndex
     * @return {?}
     */


    function debugSetCurrentNode(view, nodeIndex) {
      _currentView = view;
      _currentNodeIndex = nodeIndex;
    }
    /**
     * @param {?} view
     * @param {?} nodeIndex
     * @param {?} eventName
     * @param {?} event
     * @return {?}
     */


    function debugHandleEvent(view, nodeIndex, eventName, event) {
      debugSetCurrentNode(view, nodeIndex);
      return callWithDebugContext(DebugAction.handleEvent, view.def.handleEvent, null, [view, nodeIndex, eventName, event]);
    }
    /**
     * @param {?} view
     * @param {?} checkType
     * @return {?}
     */


    function debugUpdateDirectives(view, checkType) {
      if (view.state & 128
      /* Destroyed */
      ) {
          throw viewDestroyedError(DebugAction[_currentAction]);
        }

      debugSetCurrentNode(view, nextDirectiveWithBinding(view, 0));
      return view.def.updateDirectives(debugCheckDirectivesFn, view);
      /**
       * @param {?} view
       * @param {?} nodeIndex
       * @param {?} argStyle
       * @param {...?} values
       * @return {?}
       */

      function debugCheckDirectivesFn(view, nodeIndex, argStyle, ...values) {
        /** @type {?} */
        const nodeDef = view.def.nodes[nodeIndex];

        if (checkType === 0
        /* CheckAndUpdate */
        ) {
            debugCheckAndUpdateNode(view, nodeDef, argStyle, values);
          } else {
          debugCheckNoChangesNode(view, nodeDef, argStyle, values);
        }

        if (nodeDef.flags & 16384
        /* TypeDirective */
        ) {
            debugSetCurrentNode(view, nextDirectiveWithBinding(view, nodeIndex));
          }

        return nodeDef.flags & 224
        /* CatPureExpression */
        ? asPureExpressionData(view, nodeDef.nodeIndex).value : undefined;
      }
    }
    /**
     * @param {?} view
     * @param {?} checkType
     * @return {?}
     */


    function debugUpdateRenderer(view, checkType) {
      if (view.state & 128
      /* Destroyed */
      ) {
          throw viewDestroyedError(DebugAction[_currentAction]);
        }

      debugSetCurrentNode(view, nextRenderNodeWithBinding(view, 0));
      return view.def.updateRenderer(debugCheckRenderNodeFn, view);
      /**
       * @param {?} view
       * @param {?} nodeIndex
       * @param {?} argStyle
       * @param {...?} values
       * @return {?}
       */

      function debugCheckRenderNodeFn(view, nodeIndex, argStyle, ...values) {
        /** @type {?} */
        const nodeDef = view.def.nodes[nodeIndex];

        if (checkType === 0
        /* CheckAndUpdate */
        ) {
            debugCheckAndUpdateNode(view, nodeDef, argStyle, values);
          } else {
          debugCheckNoChangesNode(view, nodeDef, argStyle, values);
        }

        if (nodeDef.flags & 3
        /* CatRenderNode */
        ) {
            debugSetCurrentNode(view, nextRenderNodeWithBinding(view, nodeIndex));
          }

        return nodeDef.flags & 224
        /* CatPureExpression */
        ? asPureExpressionData(view, nodeDef.nodeIndex).value : undefined;
      }
    }
    /**
     * @param {?} view
     * @param {?} nodeDef
     * @param {?} argStyle
     * @param {?} givenValues
     * @return {?}
     */


    function debugCheckAndUpdateNode(view, nodeDef, argStyle, givenValues) {
      /** @type {?} */
      const changed =
      /** @type {?} */
      checkAndUpdateNode(view, nodeDef, argStyle, ...givenValues);

      if (changed) {
        /** @type {?} */
        const values = argStyle === 1
        /* Dynamic */
        ? givenValues[0] : givenValues;

        if (nodeDef.flags & 16384
        /* TypeDirective */
        ) {
            /** @type {?} */
            const bindingValues = {};

            for (let i = 0; i < nodeDef.bindings.length; i++) {
              /** @type {?} */
              const binding = nodeDef.bindings[i];
              /** @type {?} */

              const value = values[i];

              if (binding.flags & 8
              /* TypeProperty */
              ) {
                  bindingValues[normalizeDebugBindingName(
                  /** @type {?} */
                  binding.nonMinifiedName)] = normalizeDebugBindingValue(value);
                }
            }
            /** @type {?} */


            const elDef =
            /** @type {?} */
            nodeDef.parent;
            /** @type {?} */

            const el = asElementData(view, elDef.nodeIndex).renderElement;

            if (!
            /** @type {?} */
            elDef.element.name) {
              // a comment.
              view.renderer.setValue(el, "bindings=".concat(JSON.stringify(bindingValues, null, 2)));
            } else {
              // a regular element.
              for (let attr in bindingValues) {
                /** @type {?} */
                const value = bindingValues[attr];

                if (value != null) {
                  view.renderer.setAttribute(el, attr, value);
                } else {
                  view.renderer.removeAttribute(el, attr);
                }
              }
            }
          }
      }
    }
    /**
     * @param {?} view
     * @param {?} nodeDef
     * @param {?} argStyle
     * @param {?} values
     * @return {?}
     */


    function debugCheckNoChangesNode(view, nodeDef, argStyle, values) {
      /** @type {?} */
      checkNoChangesNode(view, nodeDef, argStyle, ...values);
    }
    /**
     * @param {?} view
     * @param {?} nodeIndex
     * @return {?}
     */


    function nextDirectiveWithBinding(view, nodeIndex) {
      for (let i = nodeIndex; i < view.def.nodes.length; i++) {
        /** @type {?} */
        const nodeDef = view.def.nodes[i];

        if (nodeDef.flags & 16384
        /* TypeDirective */
        && nodeDef.bindings && nodeDef.bindings.length) {
          return i;
        }
      }

      return null;
    }
    /**
     * @param {?} view
     * @param {?} nodeIndex
     * @return {?}
     */


    function nextRenderNodeWithBinding(view, nodeIndex) {
      for (let i = nodeIndex; i < view.def.nodes.length; i++) {
        /** @type {?} */
        const nodeDef = view.def.nodes[i];

        if (nodeDef.flags & 3
        /* CatRenderNode */
        && nodeDef.bindings && nodeDef.bindings.length) {
          return i;
        }
      }

      return null;
    }

    class DebugContext_ {
      /**
       * @param {?} view
       * @param {?} nodeIndex
       */
      constructor(view, nodeIndex) {
        this.view = view;
        this.nodeIndex = nodeIndex;

        if (nodeIndex == null) {
          this.nodeIndex = nodeIndex = 0;
        }

        this.nodeDef = view.def.nodes[nodeIndex];
        /** @type {?} */

        let elDef = this.nodeDef;
        /** @type {?} */

        let elView = view;

        while (elDef && (elDef.flags & 1
        /* TypeElement */
        ) === 0) {
          elDef =
          /** @type {?} */
          elDef.parent;
        }

        if (!elDef) {
          while (!elDef && elView) {
            elDef =
            /** @type {?} */
            viewParentEl(elView);
            elView =
            /** @type {?} */
            elView.parent;
          }
        }

        this.elDef = elDef;
        this.elView = elView;
      }
      /**
       * @private
       * @return {?}
       */


      get elOrCompView() {
        // Has to be done lazily as we use the DebugContext also during creation of elements...
        return asElementData(this.elView, this.elDef.nodeIndex).componentView || this.view;
      }
      /**
       * @return {?}
       */


      get injector() {
        return createInjector$1(this.elView, this.elDef);
      }
      /**
       * @return {?}
       */


      get component() {
        return this.elOrCompView.component;
      }
      /**
       * @return {?}
       */


      get context() {
        return this.elOrCompView.context;
      }
      /**
       * @return {?}
       */


      get providerTokens() {
        /** @type {?} */
        const tokens = [];

        if (this.elDef) {
          for (let i = this.elDef.nodeIndex + 1; i <= this.elDef.nodeIndex + this.elDef.childCount; i++) {
            /** @type {?} */
            const childDef = this.elView.def.nodes[i];

            if (childDef.flags & 20224
            /* CatProvider */
            ) {
                tokens.push(
                /** @type {?} */
                childDef.provider.token);
              }

            i += childDef.childCount;
          }
        }

        return tokens;
      }
      /**
       * @return {?}
       */


      get references() {
        /** @type {?} */
        const references = {};

        if (this.elDef) {
          collectReferences(this.elView, this.elDef, references);

          for (let i = this.elDef.nodeIndex + 1; i <= this.elDef.nodeIndex + this.elDef.childCount; i++) {
            /** @type {?} */
            const childDef = this.elView.def.nodes[i];

            if (childDef.flags & 20224
            /* CatProvider */
            ) {
                collectReferences(this.elView, childDef, references);
              }

            i += childDef.childCount;
          }
        }

        return references;
      }
      /**
       * @return {?}
       */


      get componentRenderElement() {
        /** @type {?} */
        const elData = findHostElement(this.elOrCompView);
        return elData ? elData.renderElement : undefined;
      }
      /**
       * @return {?}
       */


      get renderNode() {
        return this.nodeDef.flags & 2
        /* TypeText */
        ? renderNode(this.view, this.nodeDef) : renderNode(this.elView, this.elDef);
      }
      /**
       * @param {?} console
       * @param {...?} values
       * @return {?}
       */


      logError(console, ...values) {
        /** @type {?} */
        let logViewDef;
        /** @type {?} */

        let logNodeIndex;

        if (this.nodeDef.flags & 2
        /* TypeText */
        ) {
            logViewDef = this.view.def;
            logNodeIndex = this.nodeDef.nodeIndex;
          } else {
          logViewDef = this.elView.def;
          logNodeIndex = this.elDef.nodeIndex;
        } // Note: we only generate a log function for text and element nodes
        // to make the generated code as small as possible.

        /** @type {?} */


        const renderNodeIndex = getRenderNodeIndex(logViewDef, logNodeIndex);
        /** @type {?} */

        let currRenderNodeIndex = -1;
        /** @type {?} */

        let nodeLogger =
        /**
        * @return {?}
        */
        () => {
          currRenderNodeIndex++;

          if (currRenderNodeIndex === renderNodeIndex) {
            return console.error.bind(console, ...values);
          } else {
            return NOOP;
          }
        };

        /** @type {?} */
        logViewDef.factory(nodeLogger);

        if (currRenderNodeIndex < renderNodeIndex) {
          console.error('Illegal state: the ViewDefinitionFactory did not call the logger!');

          /** @type {?} */
          console.error(...values);
        }
      }

    }

    if (false) {}
    /**
     * @param {?} viewDef
     * @param {?} nodeIndex
     * @return {?}
     */


    function getRenderNodeIndex(viewDef, nodeIndex) {
      /** @type {?} */
      let renderNodeIndex = -1;

      for (let i = 0; i <= nodeIndex; i++) {
        /** @type {?} */
        const nodeDef = viewDef.nodes[i];

        if (nodeDef.flags & 3
        /* CatRenderNode */
        ) {
            renderNodeIndex++;
          }
      }

      return renderNodeIndex;
    }
    /**
     * @param {?} view
     * @return {?}
     */


    function findHostElement(view) {
      while (view && !isComponentView(view)) {
        view =
        /** @type {?} */
        view.parent;
      }

      if (view.parent) {
        return asElementData(view.parent,
        /** @type {?} */
        viewParentEl(view).nodeIndex);
      }

      return null;
    }
    /**
     * @param {?} view
     * @param {?} nodeDef
     * @param {?} references
     * @return {?}
     */


    function collectReferences(view, nodeDef, references) {
      for (let refName in nodeDef.references) {
        references[refName] = getQueryValue(view, nodeDef, nodeDef.references[refName]);
      }
    }
    /**
     * @param {?} action
     * @param {?} fn
     * @param {?} self
     * @param {?} args
     * @return {?}
     */


    function callWithDebugContext(action, fn, self, args) {
      /** @type {?} */
      const oldAction = _currentAction;
      /** @type {?} */

      const oldView = _currentView;
      /** @type {?} */

      const oldNodeIndex = _currentNodeIndex;

      try {
        _currentAction = action;
        /** @type {?} */

        const result = fn.apply(self, args);
        _currentView = oldView;
        _currentNodeIndex = oldNodeIndex;
        _currentAction = oldAction;
        return result;
      } catch (e) {
        if (isViewDebugError(e) || !_currentView) {
          throw e;
        }

        throw viewWrappedDebugError(e,
        /** @type {?} */
        getCurrentDebugContext());
      }
    }
    /**
     * @return {?}
     */


    function getCurrentDebugContext() {
      return _currentView ? new DebugContext_(_currentView, _currentNodeIndex) : null;
    }

    class DebugRendererFactory2 {
      /**
       * @param {?} delegate
       */
      constructor(delegate) {
        this.delegate = delegate;
      }
      /**
       * @param {?} element
       * @param {?} renderData
       * @return {?}
       */


      createRenderer(element, renderData) {
        return new DebugRenderer2(this.delegate.createRenderer(element, renderData));
      }
      /**
       * @return {?}
       */


      begin() {
        if (this.delegate.begin) {
          this.delegate.begin();
        }
      }
      /**
       * @return {?}
       */


      end() {
        if (this.delegate.end) {
          this.delegate.end();
        }
      }
      /**
       * @return {?}
       */


      whenRenderingDone() {
        if (this.delegate.whenRenderingDone) {
          return this.delegate.whenRenderingDone();
        }

        return Promise.resolve(null);
      }

    }

    if (false) {}

    class DebugRenderer2 {
      /**
       * @param {?} delegate
       */
      constructor(delegate) {
        this.delegate = delegate;
        /**
         * Factory function used to create a `DebugContext` when a node is created.
         *
         * The `DebugContext` allows to retrieve information about the nodes that are useful in tests.
         *
         * The factory is configurable so that the `DebugRenderer2` could instantiate either a View Engine
         * or a Render context.
         */

        this.debugContextFactory = getCurrentDebugContext;
        this.data = this.delegate.data;
      }
      /**
       * @private
       * @param {?} nativeElement
       * @return {?}
       */


      createDebugContext(nativeElement) {
        return this.debugContextFactory(nativeElement);
      }
      /**
       * @param {?} node
       * @return {?}
       */


      destroyNode(node) {
        /** @type {?} */
        const debugNode =
        /** @type {?} */
        getDebugNode(node);
        removeDebugNodeFromIndex(debugNode);

        if (debugNode instanceof DebugNode__PRE_R3__) {
          debugNode.listeners.length = 0;
        }

        if (this.delegate.destroyNode) {
          this.delegate.destroyNode(node);
        }
      }
      /**
       * @return {?}
       */


      destroy() {
        this.delegate.destroy();
      }
      /**
       * @param {?} name
       * @param {?=} namespace
       * @return {?}
       */


      createElement(name, namespace) {
        /** @type {?} */
        const el = this.delegate.createElement(name, namespace);
        /** @type {?} */

        const debugCtx = this.createDebugContext(el);

        if (debugCtx) {
          /** @type {?} */
          const debugEl = new DebugElement__PRE_R3__(el, null, debugCtx);

          /** @type {?} */
          debugEl.name = name;
          indexDebugNode(debugEl);
        }

        return el;
      }
      /**
       * @param {?} value
       * @return {?}
       */


      createComment(value) {
        /** @type {?} */
        const comment = this.delegate.createComment(value);
        /** @type {?} */

        const debugCtx = this.createDebugContext(comment);

        if (debugCtx) {
          indexDebugNode(new DebugNode__PRE_R3__(comment, null, debugCtx));
        }

        return comment;
      }
      /**
       * @param {?} value
       * @return {?}
       */


      createText(value) {
        /** @type {?} */
        const text = this.delegate.createText(value);
        /** @type {?} */

        const debugCtx = this.createDebugContext(text);

        if (debugCtx) {
          indexDebugNode(new DebugNode__PRE_R3__(text, null, debugCtx));
        }

        return text;
      }
      /**
       * @param {?} parent
       * @param {?} newChild
       * @return {?}
       */


      appendChild(parent, newChild) {
        /** @type {?} */
        const debugEl = getDebugNode(parent);
        /** @type {?} */

        const debugChildEl = getDebugNode(newChild);

        if (debugEl && debugChildEl && debugEl instanceof DebugElement__PRE_R3__) {
          debugEl.addChild(debugChildEl);
        }

        this.delegate.appendChild(parent, newChild);
      }
      /**
       * @param {?} parent
       * @param {?} newChild
       * @param {?} refChild
       * @return {?}
       */


      insertBefore(parent, newChild, refChild) {
        /** @type {?} */
        const debugEl = getDebugNode(parent);
        /** @type {?} */

        const debugChildEl = getDebugNode(newChild);
        /** @type {?} */

        const debugRefEl =
        /** @type {?} */
        getDebugNode(refChild);

        if (debugEl && debugChildEl && debugEl instanceof DebugElement__PRE_R3__) {
          debugEl.insertBefore(debugRefEl, debugChildEl);
        }

        this.delegate.insertBefore(parent, newChild, refChild);
      }
      /**
       * @param {?} parent
       * @param {?} oldChild
       * @return {?}
       */


      removeChild(parent, oldChild) {
        /** @type {?} */
        const debugEl = getDebugNode(parent);
        /** @type {?} */

        const debugChildEl = getDebugNode(oldChild);

        if (debugEl && debugChildEl && debugEl instanceof DebugElement__PRE_R3__) {
          debugEl.removeChild(debugChildEl);
        }

        this.delegate.removeChild(parent, oldChild);
      }
      /**
       * @param {?} selectorOrNode
       * @param {?=} preserveContent
       * @return {?}
       */


      selectRootElement(selectorOrNode, preserveContent) {
        /** @type {?} */
        const el = this.delegate.selectRootElement(selectorOrNode, preserveContent);
        /** @type {?} */

        const debugCtx = getCurrentDebugContext();

        if (debugCtx) {
          indexDebugNode(new DebugElement__PRE_R3__(el, null, debugCtx));
        }

        return el;
      }
      /**
       * @param {?} el
       * @param {?} name
       * @param {?} value
       * @param {?=} namespace
       * @return {?}
       */


      setAttribute(el, name, value, namespace) {
        /** @type {?} */
        const debugEl = getDebugNode(el);

        if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {
          /** @type {?} */
          const fullName = namespace ? namespace + ':' + name : name;
          debugEl.attributes[fullName] = value;
        }

        this.delegate.setAttribute(el, name, value, namespace);
      }
      /**
       * @param {?} el
       * @param {?} name
       * @param {?=} namespace
       * @return {?}
       */


      removeAttribute(el, name, namespace) {
        /** @type {?} */
        const debugEl = getDebugNode(el);

        if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {
          /** @type {?} */
          const fullName = namespace ? namespace + ':' + name : name;
          debugEl.attributes[fullName] = null;
        }

        this.delegate.removeAttribute(el, name, namespace);
      }
      /**
       * @param {?} el
       * @param {?} name
       * @return {?}
       */


      addClass(el, name) {
        /** @type {?} */
        const debugEl = getDebugNode(el);

        if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {
          debugEl.classes[name] = true;
        }

        this.delegate.addClass(el, name);
      }
      /**
       * @param {?} el
       * @param {?} name
       * @return {?}
       */


      removeClass(el, name) {
        /** @type {?} */
        const debugEl = getDebugNode(el);

        if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {
          debugEl.classes[name] = false;
        }

        this.delegate.removeClass(el, name);
      }
      /**
       * @param {?} el
       * @param {?} style
       * @param {?} value
       * @param {?} flags
       * @return {?}
       */


      setStyle(el, style, value, flags) {
        /** @type {?} */
        const debugEl = getDebugNode(el);

        if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {
          debugEl.styles[style] = value;
        }

        this.delegate.setStyle(el, style, value, flags);
      }
      /**
       * @param {?} el
       * @param {?} style
       * @param {?} flags
       * @return {?}
       */


      removeStyle(el, style, flags) {
        /** @type {?} */
        const debugEl = getDebugNode(el);

        if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {
          debugEl.styles[style] = null;
        }

        this.delegate.removeStyle(el, style, flags);
      }
      /**
       * @param {?} el
       * @param {?} name
       * @param {?} value
       * @return {?}
       */


      setProperty(el, name, value) {
        /** @type {?} */
        const debugEl = getDebugNode(el);

        if (debugEl && debugEl instanceof DebugElement__PRE_R3__) {
          debugEl.properties[name] = value;
        }

        this.delegate.setProperty(el, name, value);
      }
      /**
       * @param {?} target
       * @param {?} eventName
       * @param {?} callback
       * @return {?}
       */


      listen(target, eventName, callback) {
        if (typeof target !== 'string') {
          /** @type {?} */
          const debugEl = getDebugNode(target);

          if (debugEl) {
            debugEl.listeners.push(new DebugEventListener(eventName, callback));
          }
        }

        return this.delegate.listen(target, eventName, callback);
      }
      /**
       * @param {?} node
       * @return {?}
       */


      parentNode(node) {
        return this.delegate.parentNode(node);
      }
      /**
       * @param {?} node
       * @return {?}
       */


      nextSibling(node) {
        return this.delegate.nextSibling(node);
      }
      /**
       * @param {?} node
       * @param {?} value
       * @return {?}
       */


      setValue(node, value) {
        return this.delegate.setValue(node, value);
      }

    }

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @param {?} override
     * @return {?}
     */


    function overrideProvider(override) {
      initServicesIfNeeded();
      return Services.overrideProvider(override);
    }
    /**
     * @param {?} comp
     * @param {?} componentFactory
     * @return {?}
     */


    function overrideComponentView(comp, componentFactory) {
      initServicesIfNeeded();
      return Services.overrideComponentView(comp, componentFactory);
    }
    /**
     * @return {?}
     */


    function clearOverrides() {
      initServicesIfNeeded();
      return Services.clearOverrides();
    } // Attention: this function is called as top level function.
    // Putting any logic in here will destroy closure tree shaking!

    /**
     * @param {?} ngModuleType
     * @param {?} bootstrapComponents
     * @param {?} defFactory
     * @return {?}
     */


    function createNgModuleFactory(ngModuleType, bootstrapComponents, defFactory) {
      return new NgModuleFactory_(ngModuleType, bootstrapComponents, defFactory);
    }
    /**
     * @param {?} def
     * @return {?}
     */


    function cloneNgModuleDefinition(def) {
      /** @type {?} */
      const providers = Array.from(def.providers);
      /** @type {?} */

      const modules = Array.from(def.modules);
      /** @type {?} */

      const providersByKey = {};

      for (const key in def.providersByKey) {
        providersByKey[key] = def.providersByKey[key];
      }

      return {
        factory: def.factory,
        isRoot: def.isRoot,
        providers,
        modules,
        providersByKey
      };
    }

    class NgModuleFactory_ extends NgModuleFactory {
      /**
       * @param {?} moduleType
       * @param {?} _bootstrapComponents
       * @param {?} _ngModuleDefFactory
       */
      constructor(moduleType, _bootstrapComponents, _ngModuleDefFactory) {
        // Attention: this ctor is called as top level function.
        // Putting any logic in here will destroy closure tree shaking!
        super();
        this.moduleType = moduleType;
        this._bootstrapComponents = _bootstrapComponents;
        this._ngModuleDefFactory = _ngModuleDefFactory;
      }
      /**
       * @param {?} parentInjector
       * @return {?}
       */


      create(parentInjector) {
        initServicesIfNeeded(); // Clone the NgModuleDefinition so that any tree shakeable provider definition
        // added to this instance of the NgModuleRef doesn't affect the cached copy.
        // See https://github.com/angular/angular/issues/25018.

        /** @type {?} */

        const def = cloneNgModuleDefinition(resolveDefinition(this._ngModuleDefFactory));
        return Services.createNgModuleRef(this.moduleType, parentInjector || Injector.NULL, this._bootstrapComponents, def);
      }

    }

    if (false) {}
    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
     */

    /**
     * Generated bundle index. Do not edit.
     */
    //# sourceMappingURL=core.js.map

    /***/

  },

  /***/
  "./node_modules/@angular/localize/fesm2015/init.js":
  /*!*********************************************************!*\
    !*** ./node_modules/@angular/localize/fesm2015/init.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesAngularLocalizeFesm2015InitJs(module, exports) {
    /**
     * @license Angular v9.1.0
     * (c) 2010-2020 Google LLC. https://angular.io/
     * License: MIT
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const __globalThis = typeof globalThis !== 'undefined' && globalThis;

    const __window = typeof window !== 'undefined' && window;

    const __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && self;

    const __global = typeof global !== 'undefined' && global; // Always use __globalThis if available; this is the spec-defined global variable across all
    // environments.
    // Then fallback to __global first; in Node tests both __global and __window may be defined.


    const _global = __globalThis || __global || __window || __self;
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Tag a template literal string for localization.
     *
     * For example:
     *
     * ```ts
     * $localize `some string to localize`
     * ```
     *
     * **Providing meaning, description and id**
     *
     * You can optionally specify one or more of `meaning`, `description` and `id` for a localized
     * string by pre-pending it with a colon delimited block of the form:
     *
     * ```ts
     * $localize`:meaning|description@@id:source message text`;
     *
     * $localize`:meaning|:source message text`;
     * $localize`:description:source message text`;
     * $localize`:@@id:source message text`;
     * ```
     *
     * This format is the same as that used for `i18n` markers in Angular templates. See the
     * [Angular 18n guide](guide/i18n#template-translations).
     *
     * **Naming placeholders**
     *
     * If the template literal string contains expressions, then the expressions will be automatically
     * associated with placeholder names for you.
     *
     * For example:
     *
     * ```ts
     * $localize `Hi ${name}! There are ${items.length} items.`;
     * ```
     *
     * will generate a message-source of `Hi {$PH}! There are {$PH_1} items`.
     *
     * The recommended practice is to name the placeholder associated with each expression though.
     *
     * Do this by providing the placeholder name wrapped in `:` characters directly after the
     * expression. These placeholder names are stripped out of the rendered localized string.
     *
     * For example, to name the `items.length` expression placeholder `itemCount` you write:
     *
     * ```ts
     * $localize `There are ${items.length}:itemCount: items`;
     * ```
     *
     * **Escaping colon markers**
     *
     * If you need to use a `:` character directly at the start of a tagged string that has no
     * metadata block, or directly after a substitution expression that has no name you must escape
     * the `:` by preceding it with a backslash:
     *
     * For example:
     *
     * ```ts
     * // message has a metadata block so no need to escape colon
     * $localize `:some description::this message starts with a colon (:)`;
     * // no metadata block so the colon must be escaped
     * $localize `\:this message starts with a colon (:)`;
     * ```
     *
     * ```ts
     * // named substitution so no need to escape colon
     * $localize `${label}:label:: ${}`
     * // anonymous substitution so colon must be escaped
     * $localize `${label}\: ${}`
     * ```
     *
     * **Processing localized strings:**
     *
     * There are three scenarios:
     *
     * * **compile-time inlining**: the `$localize` tag is transformed at compile time by a
     * transpiler, removing the tag and replacing the template literal string with a translated
     * literal string from a collection of translations provided to the transpilation tool.
     *
     * * **run-time evaluation**: the `$localize` tag is a run-time function that replaces and
     * reorders the parts (static strings and expressions) of the template literal string with strings
     * from a collection of translations loaded at run-time.
     *
     * * **pass-through evaluation**: the `$localize` tag is a run-time function that simply evaluates
     * the original template literal string without applying any translations to the parts. This
     * version is used during development or where there is no need to translate the localized
     * template literals.
     * @param messageParts a collection of the static parts of the template string.
     * @param expressions a collection of the values of each placeholder in the template string.
     * @returns the translated string, with the `messageParts` and `expressions` interleaved together.
     */


    const $localize = function $localize(messageParts, ...expressions) {
      if ($localize.translate) {
        // Don't use array expansion here to avoid the compiler adding `__read()` helper unnecessarily.
        const translation = $localize.translate(messageParts, expressions);
        messageParts = translation[0];
        expressions = translation[1];
      }

      let message = stripBlock(messageParts[0], messageParts.raw[0]);

      for (let i = 1; i < messageParts.length; i++) {
        message += expressions[i - 1] + stripBlock(messageParts[i], messageParts.raw[i]);
      }

      return message;
    };

    const BLOCK_MARKER = ':';
    /**
     * Strip a delimited "block" from the start of the `messagePart`, if it is found.
     *
     * If a marker character (:) actually appears in the content at the start of a tagged string or
     * after a substitution expression, where a block has not been provided the character must be
     * escaped with a backslash, `\:`. This function checks for this by looking at the `raw`
     * messagePart, which should still contain the backslash.
     *
     * @param messagePart The cooked message part to process.
     * @param rawMessagePart The raw message part to check.
     * @returns the message part with the placeholder name stripped, if found.
     * @throws an error if the block is unterminated
     */

    function stripBlock(messagePart, rawMessagePart) {
      return rawMessagePart.charAt(0) === BLOCK_MARKER ? messagePart.substring(findEndOfBlock(messagePart, rawMessagePart) + 1) : messagePart;
    }
    /**
     * Find the end of a "marked block" indicated by the first non-escaped colon.
     *
     * @param cooked The cooked string (where escaped chars have been processed)
     * @param raw The raw string (where escape sequences are still in place)
     *
     * @returns the index of the end of block marker
     * @throws an error if the block is unterminated
     */


    function findEndOfBlock(cooked, raw) {
      /***********************************************************************************************
       * This function is repeated in `src/utils/messages.ts` and the two should be kept in sync.
       * The reason is that this file is marked as having side-effects, and if we import `messages.ts`
       * into it, the whole of `src/utils` will be included in this bundle and none of the functions
       * will be tree shaken.
       ***********************************************************************************************/
      for (let cookedIndex = 1, rawIndex = 1; cookedIndex < cooked.length; cookedIndex++, rawIndex++) {
        if (raw[rawIndex] === '\\') {
          rawIndex++;
        } else if (cooked[cookedIndex] === BLOCK_MARKER) {
          return cookedIndex;
        }
      }

      throw new Error("Unterminated $localize metadata block in \"".concat(raw, "\"."));
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // Attach $localize to the global context, as a side-effect of this module.


    _global.$localize = $localize; //# sourceMappingURL=init.js.map

    /***/
  },

  /***/
  "./node_modules/core-js/es/date/index.js":
  /*!***********************************************!*\
    !*** ./node_modules/core-js/es/date/index.js ***!
    \***********************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsEsDateIndexJs(module, exports, __webpack_require__) {
    __webpack_require__(
    /*! ../../modules/es.date.now */
    "./node_modules/core-js/modules/es.date.now.js");

    __webpack_require__(
    /*! ../../modules/es.date.to-json */
    "./node_modules/core-js/modules/es.date.to-json.js");

    __webpack_require__(
    /*! ../../modules/es.date.to-iso-string */
    "./node_modules/core-js/modules/es.date.to-iso-string.js");

    __webpack_require__(
    /*! ../../modules/es.date.to-string */
    "./node_modules/core-js/modules/es.date.to-string.js");

    __webpack_require__(
    /*! ../../modules/es.date.to-primitive */
    "./node_modules/core-js/modules/es.date.to-primitive.js");

    var path = __webpack_require__(
    /*! ../../internals/path */
    "./node_modules/core-js/internals/path.js");

    module.exports = path.Date;
    /***/
  },

  /***/
  "./node_modules/core-js/es/math/index.js":
  /*!***********************************************!*\
    !*** ./node_modules/core-js/es/math/index.js ***!
    \***********************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsEsMathIndexJs(module, exports, __webpack_require__) {
    __webpack_require__(
    /*! ../../modules/es.math.acosh */
    "./node_modules/core-js/modules/es.math.acosh.js");

    __webpack_require__(
    /*! ../../modules/es.math.asinh */
    "./node_modules/core-js/modules/es.math.asinh.js");

    __webpack_require__(
    /*! ../../modules/es.math.atanh */
    "./node_modules/core-js/modules/es.math.atanh.js");

    __webpack_require__(
    /*! ../../modules/es.math.cbrt */
    "./node_modules/core-js/modules/es.math.cbrt.js");

    __webpack_require__(
    /*! ../../modules/es.math.clz32 */
    "./node_modules/core-js/modules/es.math.clz32.js");

    __webpack_require__(
    /*! ../../modules/es.math.cosh */
    "./node_modules/core-js/modules/es.math.cosh.js");

    __webpack_require__(
    /*! ../../modules/es.math.expm1 */
    "./node_modules/core-js/modules/es.math.expm1.js");

    __webpack_require__(
    /*! ../../modules/es.math.fround */
    "./node_modules/core-js/modules/es.math.fround.js");

    __webpack_require__(
    /*! ../../modules/es.math.hypot */
    "./node_modules/core-js/modules/es.math.hypot.js");

    __webpack_require__(
    /*! ../../modules/es.math.imul */
    "./node_modules/core-js/modules/es.math.imul.js");

    __webpack_require__(
    /*! ../../modules/es.math.log10 */
    "./node_modules/core-js/modules/es.math.log10.js");

    __webpack_require__(
    /*! ../../modules/es.math.log1p */
    "./node_modules/core-js/modules/es.math.log1p.js");

    __webpack_require__(
    /*! ../../modules/es.math.log2 */
    "./node_modules/core-js/modules/es.math.log2.js");

    __webpack_require__(
    /*! ../../modules/es.math.sign */
    "./node_modules/core-js/modules/es.math.sign.js");

    __webpack_require__(
    /*! ../../modules/es.math.sinh */
    "./node_modules/core-js/modules/es.math.sinh.js");

    __webpack_require__(
    /*! ../../modules/es.math.tanh */
    "./node_modules/core-js/modules/es.math.tanh.js");

    __webpack_require__(
    /*! ../../modules/es.math.to-string-tag */
    "./node_modules/core-js/modules/es.math.to-string-tag.js");

    __webpack_require__(
    /*! ../../modules/es.math.trunc */
    "./node_modules/core-js/modules/es.math.trunc.js");

    var path = __webpack_require__(
    /*! ../../internals/path */
    "./node_modules/core-js/internals/path.js");

    module.exports = path.Math;
    /***/
  },

  /***/
  "./node_modules/core-js/es/number/index.js":
  /*!*************************************************!*\
    !*** ./node_modules/core-js/es/number/index.js ***!
    \*************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsEsNumberIndexJs(module, exports, __webpack_require__) {
    __webpack_require__(
    /*! ../../modules/es.number.constructor */
    "./node_modules/core-js/modules/es.number.constructor.js");

    __webpack_require__(
    /*! ../../modules/es.number.epsilon */
    "./node_modules/core-js/modules/es.number.epsilon.js");

    __webpack_require__(
    /*! ../../modules/es.number.is-finite */
    "./node_modules/core-js/modules/es.number.is-finite.js");

    __webpack_require__(
    /*! ../../modules/es.number.is-integer */
    "./node_modules/core-js/modules/es.number.is-integer.js");

    __webpack_require__(
    /*! ../../modules/es.number.is-nan */
    "./node_modules/core-js/modules/es.number.is-nan.js");

    __webpack_require__(
    /*! ../../modules/es.number.is-safe-integer */
    "./node_modules/core-js/modules/es.number.is-safe-integer.js");

    __webpack_require__(
    /*! ../../modules/es.number.max-safe-integer */
    "./node_modules/core-js/modules/es.number.max-safe-integer.js");

    __webpack_require__(
    /*! ../../modules/es.number.min-safe-integer */
    "./node_modules/core-js/modules/es.number.min-safe-integer.js");

    __webpack_require__(
    /*! ../../modules/es.number.parse-float */
    "./node_modules/core-js/modules/es.number.parse-float.js");

    __webpack_require__(
    /*! ../../modules/es.number.parse-int */
    "./node_modules/core-js/modules/es.number.parse-int.js");

    __webpack_require__(
    /*! ../../modules/es.number.to-fixed */
    "./node_modules/core-js/modules/es.number.to-fixed.js");

    __webpack_require__(
    /*! ../../modules/es.number.to-precision */
    "./node_modules/core-js/modules/es.number.to-precision.js");

    var path = __webpack_require__(
    /*! ../../internals/path */
    "./node_modules/core-js/internals/path.js");

    module.exports = path.Number;
    /***/
  },

  /***/
  "./node_modules/core-js/es/reflect/index.js":
  /*!**************************************************!*\
    !*** ./node_modules/core-js/es/reflect/index.js ***!
    \**************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsEsReflectIndexJs(module, exports, __webpack_require__) {
    __webpack_require__(
    /*! ../../modules/es.reflect.apply */
    "./node_modules/core-js/modules/es.reflect.apply.js");

    __webpack_require__(
    /*! ../../modules/es.reflect.construct */
    "./node_modules/core-js/modules/es.reflect.construct.js");

    __webpack_require__(
    /*! ../../modules/es.reflect.define-property */
    "./node_modules/core-js/modules/es.reflect.define-property.js");

    __webpack_require__(
    /*! ../../modules/es.reflect.delete-property */
    "./node_modules/core-js/modules/es.reflect.delete-property.js");

    __webpack_require__(
    /*! ../../modules/es.reflect.get */
    "./node_modules/core-js/modules/es.reflect.get.js");

    __webpack_require__(
    /*! ../../modules/es.reflect.get-own-property-descriptor */
    "./node_modules/core-js/modules/es.reflect.get-own-property-descriptor.js");

    __webpack_require__(
    /*! ../../modules/es.reflect.get-prototype-of */
    "./node_modules/core-js/modules/es.reflect.get-prototype-of.js");

    __webpack_require__(
    /*! ../../modules/es.reflect.has */
    "./node_modules/core-js/modules/es.reflect.has.js");

    __webpack_require__(
    /*! ../../modules/es.reflect.is-extensible */
    "./node_modules/core-js/modules/es.reflect.is-extensible.js");

    __webpack_require__(
    /*! ../../modules/es.reflect.own-keys */
    "./node_modules/core-js/modules/es.reflect.own-keys.js");

    __webpack_require__(
    /*! ../../modules/es.reflect.prevent-extensions */
    "./node_modules/core-js/modules/es.reflect.prevent-extensions.js");

    __webpack_require__(
    /*! ../../modules/es.reflect.set */
    "./node_modules/core-js/modules/es.reflect.set.js");

    __webpack_require__(
    /*! ../../modules/es.reflect.set-prototype-of */
    "./node_modules/core-js/modules/es.reflect.set-prototype-of.js");

    var path = __webpack_require__(
    /*! ../../internals/path */
    "./node_modules/core-js/internals/path.js");

    module.exports = path.Reflect;
    /***/
  },

  /***/
  "./node_modules/core-js/es/symbol/index.js":
  /*!*************************************************!*\
    !*** ./node_modules/core-js/es/symbol/index.js ***!
    \*************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsEsSymbolIndexJs(module, exports, __webpack_require__) {
    __webpack_require__(
    /*! ../../modules/es.array.concat */
    "./node_modules/core-js/modules/es.array.concat.js");

    __webpack_require__(
    /*! ../../modules/es.object.to-string */
    "./node_modules/core-js/modules/es.object.to-string.js");

    __webpack_require__(
    /*! ../../modules/es.symbol */
    "./node_modules/core-js/modules/es.symbol.js");

    __webpack_require__(
    /*! ../../modules/es.symbol.async-iterator */
    "./node_modules/core-js/modules/es.symbol.async-iterator.js");

    __webpack_require__(
    /*! ../../modules/es.symbol.description */
    "./node_modules/core-js/modules/es.symbol.description.js");

    __webpack_require__(
    /*! ../../modules/es.symbol.has-instance */
    "./node_modules/core-js/modules/es.symbol.has-instance.js");

    __webpack_require__(
    /*! ../../modules/es.symbol.is-concat-spreadable */
    "./node_modules/core-js/modules/es.symbol.is-concat-spreadable.js");

    __webpack_require__(
    /*! ../../modules/es.symbol.iterator */
    "./node_modules/core-js/modules/es.symbol.iterator.js");

    __webpack_require__(
    /*! ../../modules/es.symbol.match */
    "./node_modules/core-js/modules/es.symbol.match.js");

    __webpack_require__(
    /*! ../../modules/es.symbol.match-all */
    "./node_modules/core-js/modules/es.symbol.match-all.js");

    __webpack_require__(
    /*! ../../modules/es.symbol.replace */
    "./node_modules/core-js/modules/es.symbol.replace.js");

    __webpack_require__(
    /*! ../../modules/es.symbol.search */
    "./node_modules/core-js/modules/es.symbol.search.js");

    __webpack_require__(
    /*! ../../modules/es.symbol.species */
    "./node_modules/core-js/modules/es.symbol.species.js");

    __webpack_require__(
    /*! ../../modules/es.symbol.split */
    "./node_modules/core-js/modules/es.symbol.split.js");

    __webpack_require__(
    /*! ../../modules/es.symbol.to-primitive */
    "./node_modules/core-js/modules/es.symbol.to-primitive.js");

    __webpack_require__(
    /*! ../../modules/es.symbol.to-string-tag */
    "./node_modules/core-js/modules/es.symbol.to-string-tag.js");

    __webpack_require__(
    /*! ../../modules/es.symbol.unscopables */
    "./node_modules/core-js/modules/es.symbol.unscopables.js");

    __webpack_require__(
    /*! ../../modules/es.math.to-string-tag */
    "./node_modules/core-js/modules/es.math.to-string-tag.js");

    __webpack_require__(
    /*! ../../modules/es.json.to-string-tag */
    "./node_modules/core-js/modules/es.json.to-string-tag.js");

    var path = __webpack_require__(
    /*! ../../internals/path */
    "./node_modules/core-js/internals/path.js");

    module.exports = path.Symbol;
    /***/
  },

  /***/
  "./node_modules/core-js/internals/a-function.js":
  /*!******************************************************!*\
    !*** ./node_modules/core-js/internals/a-function.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsAFunctionJs(module, exports) {
    module.exports = function (it) {
      if (typeof it != 'function') {
        throw TypeError(String(it) + ' is not a function');
      }

      return it;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/a-possible-prototype.js":
  /*!****************************************************************!*\
    !*** ./node_modules/core-js/internals/a-possible-prototype.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsAPossiblePrototypeJs(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    module.exports = function (it) {
      if (!isObject(it) && it !== null) {
        throw TypeError("Can't set " + String(it) + ' as a prototype');
      }

      return it;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/add-to-unscopables.js":
  /*!**************************************************************!*\
    !*** ./node_modules/core-js/internals/add-to-unscopables.js ***!
    \**************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsAddToUnscopablesJs(module, exports, __webpack_require__) {
    var wellKnownSymbol = __webpack_require__(
    /*! ../internals/well-known-symbol */
    "./node_modules/core-js/internals/well-known-symbol.js");

    var create = __webpack_require__(
    /*! ../internals/object-create */
    "./node_modules/core-js/internals/object-create.js");

    var definePropertyModule = __webpack_require__(
    /*! ../internals/object-define-property */
    "./node_modules/core-js/internals/object-define-property.js");

    var UNSCOPABLES = wellKnownSymbol('unscopables');
    var ArrayPrototype = Array.prototype; // Array.prototype[@@unscopables]
    // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

    if (ArrayPrototype[UNSCOPABLES] == undefined) {
      definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
        configurable: true,
        value: create(null)
      });
    } // add a key to Array.prototype[@@unscopables]


    module.exports = function (key) {
      ArrayPrototype[UNSCOPABLES][key] = true;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/advance-string-index.js":
  /*!****************************************************************!*\
    !*** ./node_modules/core-js/internals/advance-string-index.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsAdvanceStringIndexJs(module, exports, __webpack_require__) {
    "use strict";

    var charAt = __webpack_require__(
    /*! ../internals/string-multibyte */
    "./node_modules/core-js/internals/string-multibyte.js").charAt; // `AdvanceStringIndex` abstract operation
    // https://tc39.github.io/ecma262/#sec-advancestringindex


    module.exports = function (S, index, unicode) {
      return index + (unicode ? charAt(S, index).length : 1);
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/an-instance.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/internals/an-instance.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsAnInstanceJs(module, exports) {
    module.exports = function (it, Constructor, name) {
      if (!(it instanceof Constructor)) {
        throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
      }

      return it;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/an-object.js":
  /*!*****************************************************!*\
    !*** ./node_modules/core-js/internals/an-object.js ***!
    \*****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsAnObjectJs(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    module.exports = function (it) {
      if (!isObject(it)) {
        throw TypeError(String(it) + ' is not an object');
      }

      return it;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/array-copy-within.js":
  /*!*************************************************************!*\
    !*** ./node_modules/core-js/internals/array-copy-within.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsArrayCopyWithinJs(module, exports, __webpack_require__) {
    "use strict";

    var toObject = __webpack_require__(
    /*! ../internals/to-object */
    "./node_modules/core-js/internals/to-object.js");

    var toAbsoluteIndex = __webpack_require__(
    /*! ../internals/to-absolute-index */
    "./node_modules/core-js/internals/to-absolute-index.js");

    var toLength = __webpack_require__(
    /*! ../internals/to-length */
    "./node_modules/core-js/internals/to-length.js");

    var min = Math.min; // `Array.prototype.copyWithin` method implementation
    // https://tc39.github.io/ecma262/#sec-array.prototype.copywithin

    module.exports = [].copyWithin || function copyWithin(target
    /* = 0 */
    , start
    /* = 0, end = @length */
    ) {
      var O = toObject(this);
      var len = toLength(O.length);
      var to = toAbsoluteIndex(target, len);
      var from = toAbsoluteIndex(start, len);
      var end = arguments.length > 2 ? arguments[2] : undefined;
      var count = min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
      var inc = 1;

      if (from < to && to < from + count) {
        inc = -1;
        from += count - 1;
        to += count - 1;
      }

      while (count-- > 0) {
        if (from in O) O[to] = O[from];else delete O[to];
        to += inc;
        from += inc;
      }

      return O;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/array-fill.js":
  /*!******************************************************!*\
    !*** ./node_modules/core-js/internals/array-fill.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsArrayFillJs(module, exports, __webpack_require__) {
    "use strict";

    var toObject = __webpack_require__(
    /*! ../internals/to-object */
    "./node_modules/core-js/internals/to-object.js");

    var toAbsoluteIndex = __webpack_require__(
    /*! ../internals/to-absolute-index */
    "./node_modules/core-js/internals/to-absolute-index.js");

    var toLength = __webpack_require__(
    /*! ../internals/to-length */
    "./node_modules/core-js/internals/to-length.js"); // `Array.prototype.fill` method implementation
    // https://tc39.github.io/ecma262/#sec-array.prototype.fill


    module.exports = function fill(value
    /* , start = 0, end = @length */
    ) {
      var O = toObject(this);
      var length = toLength(O.length);
      var argumentsLength = arguments.length;
      var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
      var end = argumentsLength > 2 ? arguments[2] : undefined;
      var endPos = end === undefined ? length : toAbsoluteIndex(end, length);

      while (endPos > index) O[index++] = value;

      return O;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/array-for-each.js":
  /*!**********************************************************!*\
    !*** ./node_modules/core-js/internals/array-for-each.js ***!
    \**********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsArrayForEachJs(module, exports, __webpack_require__) {
    "use strict";

    var $forEach = __webpack_require__(
    /*! ../internals/array-iteration */
    "./node_modules/core-js/internals/array-iteration.js").forEach;

    var arrayMethodIsStrict = __webpack_require__(
    /*! ../internals/array-method-is-strict */
    "./node_modules/core-js/internals/array-method-is-strict.js");

    var arrayMethodUsesToLength = __webpack_require__(
    /*! ../internals/array-method-uses-to-length */
    "./node_modules/core-js/internals/array-method-uses-to-length.js");

    var STRICT_METHOD = arrayMethodIsStrict('forEach');
    var USES_TO_LENGTH = arrayMethodUsesToLength('forEach'); // `Array.prototype.forEach` method implementation
    // https://tc39.github.io/ecma262/#sec-array.prototype.foreach

    module.exports = !STRICT_METHOD || !USES_TO_LENGTH ? function forEach(callbackfn
    /* , thisArg */
    ) {
      return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    } : [].forEach;
    /***/
  },

  /***/
  "./node_modules/core-js/internals/array-from.js":
  /*!******************************************************!*\
    !*** ./node_modules/core-js/internals/array-from.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsArrayFromJs(module, exports, __webpack_require__) {
    "use strict";

    var bind = __webpack_require__(
    /*! ../internals/function-bind-context */
    "./node_modules/core-js/internals/function-bind-context.js");

    var toObject = __webpack_require__(
    /*! ../internals/to-object */
    "./node_modules/core-js/internals/to-object.js");

    var callWithSafeIterationClosing = __webpack_require__(
    /*! ../internals/call-with-safe-iteration-closing */
    "./node_modules/core-js/internals/call-with-safe-iteration-closing.js");

    var isArrayIteratorMethod = __webpack_require__(
    /*! ../internals/is-array-iterator-method */
    "./node_modules/core-js/internals/is-array-iterator-method.js");

    var toLength = __webpack_require__(
    /*! ../internals/to-length */
    "./node_modules/core-js/internals/to-length.js");

    var createProperty = __webpack_require__(
    /*! ../internals/create-property */
    "./node_modules/core-js/internals/create-property.js");

    var getIteratorMethod = __webpack_require__(
    /*! ../internals/get-iterator-method */
    "./node_modules/core-js/internals/get-iterator-method.js"); // `Array.from` method implementation
    // https://tc39.github.io/ecma262/#sec-array.from


    module.exports = function from(arrayLike
    /* , mapfn = undefined, thisArg = undefined */
    ) {
      var O = toObject(arrayLike);
      var C = typeof this == 'function' ? this : Array;
      var argumentsLength = arguments.length;
      var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
      var mapping = mapfn !== undefined;
      var iteratorMethod = getIteratorMethod(O);
      var index = 0;
      var length, result, step, iterator, next, value;
      if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2); // if the target is not iterable or it's an array with the default iterator - use a simple case

      if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
        iterator = iteratorMethod.call(O);
        next = iterator.next;
        result = new C();

        for (; !(step = next.call(iterator)).done; index++) {
          value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
          createProperty(result, index, value);
        }
      } else {
        length = toLength(O.length);
        result = new C(length);

        for (; length > index; index++) {
          value = mapping ? mapfn(O[index], index) : O[index];
          createProperty(result, index, value);
        }
      }

      result.length = index;
      return result;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/array-includes.js":
  /*!**********************************************************!*\
    !*** ./node_modules/core-js/internals/array-includes.js ***!
    \**********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsArrayIncludesJs(module, exports, __webpack_require__) {
    var toIndexedObject = __webpack_require__(
    /*! ../internals/to-indexed-object */
    "./node_modules/core-js/internals/to-indexed-object.js");

    var toLength = __webpack_require__(
    /*! ../internals/to-length */
    "./node_modules/core-js/internals/to-length.js");

    var toAbsoluteIndex = __webpack_require__(
    /*! ../internals/to-absolute-index */
    "./node_modules/core-js/internals/to-absolute-index.js"); // `Array.prototype.{ indexOf, includes }` methods implementation


    var createMethod = function createMethod(IS_INCLUDES) {
      return function ($this, el, fromIndex) {
        var O = toIndexedObject($this);
        var length = toLength(O.length);
        var index = toAbsoluteIndex(fromIndex, length);
        var value; // Array#includes uses SameValueZero equality algorithm
        // eslint-disable-next-line no-self-compare

        if (IS_INCLUDES && el != el) while (length > index) {
          value = O[index++]; // eslint-disable-next-line no-self-compare

          if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
        } else for (; length > index; index++) {
          if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
        }
        return !IS_INCLUDES && -1;
      };
    };

    module.exports = {
      // `Array.prototype.includes` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.includes
      includes: createMethod(true),
      // `Array.prototype.indexOf` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
      indexOf: createMethod(false)
    };
    /***/
  },

  /***/
  "./node_modules/core-js/internals/array-iteration.js":
  /*!***********************************************************!*\
    !*** ./node_modules/core-js/internals/array-iteration.js ***!
    \***********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsArrayIterationJs(module, exports, __webpack_require__) {
    var bind = __webpack_require__(
    /*! ../internals/function-bind-context */
    "./node_modules/core-js/internals/function-bind-context.js");

    var IndexedObject = __webpack_require__(
    /*! ../internals/indexed-object */
    "./node_modules/core-js/internals/indexed-object.js");

    var toObject = __webpack_require__(
    /*! ../internals/to-object */
    "./node_modules/core-js/internals/to-object.js");

    var toLength = __webpack_require__(
    /*! ../internals/to-length */
    "./node_modules/core-js/internals/to-length.js");

    var arraySpeciesCreate = __webpack_require__(
    /*! ../internals/array-species-create */
    "./node_modules/core-js/internals/array-species-create.js");

    var push = [].push; // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation

    var createMethod = function createMethod(TYPE) {
      var IS_MAP = TYPE == 1;
      var IS_FILTER = TYPE == 2;
      var IS_SOME = TYPE == 3;
      var IS_EVERY = TYPE == 4;
      var IS_FIND_INDEX = TYPE == 6;
      var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
      return function ($this, callbackfn, that, specificCreate) {
        var O = toObject($this);
        var self = IndexedObject(O);
        var boundFunction = bind(callbackfn, that, 3);
        var length = toLength(self.length);
        var index = 0;
        var create = specificCreate || arraySpeciesCreate;
        var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
        var value, result;

        for (; length > index; index++) if (NO_HOLES || index in self) {
          value = self[index];
          result = boundFunction(value, index, O);

          if (TYPE) {
            if (IS_MAP) target[index] = result; // map
            else if (result) switch (TYPE) {
                case 3:
                  return true;
                // some

                case 5:
                  return value;
                // find

                case 6:
                  return index;
                // findIndex

                case 2:
                  push.call(target, value);
                // filter
              } else if (IS_EVERY) return false; // every
          }
        }

        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
      };
    };

    module.exports = {
      // `Array.prototype.forEach` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
      forEach: createMethod(0),
      // `Array.prototype.map` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.map
      map: createMethod(1),
      // `Array.prototype.filter` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.filter
      filter: createMethod(2),
      // `Array.prototype.some` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.some
      some: createMethod(3),
      // `Array.prototype.every` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.every
      every: createMethod(4),
      // `Array.prototype.find` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.find
      find: createMethod(5),
      // `Array.prototype.findIndex` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
      findIndex: createMethod(6)
    };
    /***/
  },

  /***/
  "./node_modules/core-js/internals/array-last-index-of.js":
  /*!***************************************************************!*\
    !*** ./node_modules/core-js/internals/array-last-index-of.js ***!
    \***************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsArrayLastIndexOfJs(module, exports, __webpack_require__) {
    "use strict";

    var toIndexedObject = __webpack_require__(
    /*! ../internals/to-indexed-object */
    "./node_modules/core-js/internals/to-indexed-object.js");

    var toInteger = __webpack_require__(
    /*! ../internals/to-integer */
    "./node_modules/core-js/internals/to-integer.js");

    var toLength = __webpack_require__(
    /*! ../internals/to-length */
    "./node_modules/core-js/internals/to-length.js");

    var arrayMethodIsStrict = __webpack_require__(
    /*! ../internals/array-method-is-strict */
    "./node_modules/core-js/internals/array-method-is-strict.js");

    var arrayMethodUsesToLength = __webpack_require__(
    /*! ../internals/array-method-uses-to-length */
    "./node_modules/core-js/internals/array-method-uses-to-length.js");

    var min = Math.min;
    var nativeLastIndexOf = [].lastIndexOf;
    var NEGATIVE_ZERO = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
    var STRICT_METHOD = arrayMethodIsStrict('lastIndexOf'); // For preventing possible almost infinite loop in non-standard implementations, test the forward version of the method

    var USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', {
      ACCESSORS: true,
      1: 0
    });
    var FORCED = NEGATIVE_ZERO || !STRICT_METHOD || !USES_TO_LENGTH; // `Array.prototype.lastIndexOf` method implementation
    // https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof

    module.exports = FORCED ? function lastIndexOf(searchElement
    /* , fromIndex = @[*-1] */
    ) {
      // convert -0 to +0
      if (NEGATIVE_ZERO) return nativeLastIndexOf.apply(this, arguments) || 0;
      var O = toIndexedObject(this);
      var length = toLength(O.length);
      var index = length - 1;
      if (arguments.length > 1) index = min(index, toInteger(arguments[1]));
      if (index < 0) index = length + index;

      for (; index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;

      return -1;
    } : nativeLastIndexOf;
    /***/
  },

  /***/
  "./node_modules/core-js/internals/array-method-has-species-support.js":
  /*!****************************************************************************!*\
    !*** ./node_modules/core-js/internals/array-method-has-species-support.js ***!
    \****************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsArrayMethodHasSpeciesSupportJs(module, exports, __webpack_require__) {
    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var wellKnownSymbol = __webpack_require__(
    /*! ../internals/well-known-symbol */
    "./node_modules/core-js/internals/well-known-symbol.js");

    var V8_VERSION = __webpack_require__(
    /*! ../internals/engine-v8-version */
    "./node_modules/core-js/internals/engine-v8-version.js");

    var SPECIES = wellKnownSymbol('species');

    module.exports = function (METHOD_NAME) {
      // We can't use this feature detection in V8 since it causes
      // deoptimization and serious performance degradation
      // https://github.com/zloirock/core-js/issues/677
      return V8_VERSION >= 51 || !fails(function () {
        var array = [];
        var constructor = array.constructor = {};

        constructor[SPECIES] = function () {
          return {
            foo: 1
          };
        };

        return array[METHOD_NAME](Boolean).foo !== 1;
      });
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/array-method-is-strict.js":
  /*!******************************************************************!*\
    !*** ./node_modules/core-js/internals/array-method-is-strict.js ***!
    \******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsArrayMethodIsStrictJs(module, exports, __webpack_require__) {
    "use strict";

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    module.exports = function (METHOD_NAME, argument) {
      var method = [][METHOD_NAME];
      return !!method && fails(function () {
        // eslint-disable-next-line no-useless-call,no-throw-literal
        method.call(null, argument || function () {
          throw 1;
        }, 1);
      });
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/array-method-uses-to-length.js":
  /*!***********************************************************************!*\
    !*** ./node_modules/core-js/internals/array-method-uses-to-length.js ***!
    \***********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsArrayMethodUsesToLengthJs(module, exports, __webpack_require__) {
    var DESCRIPTORS = __webpack_require__(
    /*! ../internals/descriptors */
    "./node_modules/core-js/internals/descriptors.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var has = __webpack_require__(
    /*! ../internals/has */
    "./node_modules/core-js/internals/has.js");

    var defineProperty = Object.defineProperty;
    var cache = {};

    var thrower = function thrower(it) {
      throw it;
    };

    module.exports = function (METHOD_NAME, options) {
      if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];
      if (!options) options = {};
      var method = [][METHOD_NAME];
      var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;
      var argument0 = has(options, 0) ? options[0] : thrower;
      var argument1 = has(options, 1) ? options[1] : undefined;
      return cache[METHOD_NAME] = !!method && !fails(function () {
        if (ACCESSORS && !DESCRIPTORS) return true;
        var O = {
          length: -1
        };
        if (ACCESSORS) defineProperty(O, 1, {
          enumerable: true,
          get: thrower
        });else O[1] = 1;
        method.call(O, argument0, argument1);
      });
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/array-reduce.js":
  /*!********************************************************!*\
    !*** ./node_modules/core-js/internals/array-reduce.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsArrayReduceJs(module, exports, __webpack_require__) {
    var aFunction = __webpack_require__(
    /*! ../internals/a-function */
    "./node_modules/core-js/internals/a-function.js");

    var toObject = __webpack_require__(
    /*! ../internals/to-object */
    "./node_modules/core-js/internals/to-object.js");

    var IndexedObject = __webpack_require__(
    /*! ../internals/indexed-object */
    "./node_modules/core-js/internals/indexed-object.js");

    var toLength = __webpack_require__(
    /*! ../internals/to-length */
    "./node_modules/core-js/internals/to-length.js"); // `Array.prototype.{ reduce, reduceRight }` methods implementation


    var createMethod = function createMethod(IS_RIGHT) {
      return function (that, callbackfn, argumentsLength, memo) {
        aFunction(callbackfn);
        var O = toObject(that);
        var self = IndexedObject(O);
        var length = toLength(O.length);
        var index = IS_RIGHT ? length - 1 : 0;
        var i = IS_RIGHT ? -1 : 1;
        if (argumentsLength < 2) while (true) {
          if (index in self) {
            memo = self[index];
            index += i;
            break;
          }

          index += i;

          if (IS_RIGHT ? index < 0 : length <= index) {
            throw TypeError('Reduce of empty array with no initial value');
          }
        }

        for (; IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
          memo = callbackfn(memo, self[index], index, O);
        }

        return memo;
      };
    };

    module.exports = {
      // `Array.prototype.reduce` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
      left: createMethod(false),
      // `Array.prototype.reduceRight` method
      // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
      right: createMethod(true)
    };
    /***/
  },

  /***/
  "./node_modules/core-js/internals/array-species-create.js":
  /*!****************************************************************!*\
    !*** ./node_modules/core-js/internals/array-species-create.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsArraySpeciesCreateJs(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    var isArray = __webpack_require__(
    /*! ../internals/is-array */
    "./node_modules/core-js/internals/is-array.js");

    var wellKnownSymbol = __webpack_require__(
    /*! ../internals/well-known-symbol */
    "./node_modules/core-js/internals/well-known-symbol.js");

    var SPECIES = wellKnownSymbol('species'); // `ArraySpeciesCreate` abstract operation
    // https://tc39.github.io/ecma262/#sec-arrayspeciescreate

    module.exports = function (originalArray, length) {
      var C;

      if (isArray(originalArray)) {
        C = originalArray.constructor; // cross-realm fallback

        if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;else if (isObject(C)) {
          C = C[SPECIES];
          if (C === null) C = undefined;
        }
      }

      return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/call-with-safe-iteration-closing.js":
  /*!****************************************************************************!*\
    !*** ./node_modules/core-js/internals/call-with-safe-iteration-closing.js ***!
    \****************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsCallWithSafeIterationClosingJs(module, exports, __webpack_require__) {
    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js"); // call something on iterator step with safe closing on error


    module.exports = function (iterator, fn, value, ENTRIES) {
      try {
        return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
      } catch (error) {
        var returnMethod = iterator['return'];
        if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
        throw error;
      }
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/check-correctness-of-iteration.js":
  /*!**************************************************************************!*\
    !*** ./node_modules/core-js/internals/check-correctness-of-iteration.js ***!
    \**************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsCheckCorrectnessOfIterationJs(module, exports, __webpack_require__) {
    var wellKnownSymbol = __webpack_require__(
    /*! ../internals/well-known-symbol */
    "./node_modules/core-js/internals/well-known-symbol.js");

    var ITERATOR = wellKnownSymbol('iterator');
    var SAFE_CLOSING = false;

    try {
      var called = 0;
      var iteratorWithReturn = {
        next: function next() {
          return {
            done: !!called++
          };
        },
        'return': function _return() {
          SAFE_CLOSING = true;
        }
      };

      iteratorWithReturn[ITERATOR] = function () {
        return this;
      }; // eslint-disable-next-line no-throw-literal


      Array.from(iteratorWithReturn, function () {
        throw 2;
      });
    } catch (error) {
      /* empty */
    }

    module.exports = function (exec, SKIP_CLOSING) {
      if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
      var ITERATION_SUPPORT = false;

      try {
        var object = {};

        object[ITERATOR] = function () {
          return {
            next: function next() {
              return {
                done: ITERATION_SUPPORT = true
              };
            }
          };
        };

        exec(object);
      } catch (error) {
        /* empty */
      }

      return ITERATION_SUPPORT;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/classof-raw.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/internals/classof-raw.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsClassofRawJs(module, exports) {
    var toString = {}.toString;

    module.exports = function (it) {
      return toString.call(it).slice(8, -1);
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/classof.js":
  /*!***************************************************!*\
    !*** ./node_modules/core-js/internals/classof.js ***!
    \***************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsClassofJs(module, exports, __webpack_require__) {
    var TO_STRING_TAG_SUPPORT = __webpack_require__(
    /*! ../internals/to-string-tag-support */
    "./node_modules/core-js/internals/to-string-tag-support.js");

    var classofRaw = __webpack_require__(
    /*! ../internals/classof-raw */
    "./node_modules/core-js/internals/classof-raw.js");

    var wellKnownSymbol = __webpack_require__(
    /*! ../internals/well-known-symbol */
    "./node_modules/core-js/internals/well-known-symbol.js");

    var TO_STRING_TAG = wellKnownSymbol('toStringTag'); // ES3 wrong here

    var CORRECT_ARGUMENTS = classofRaw(function () {
      return arguments;
    }()) == 'Arguments'; // fallback for IE11 Script Access Denied error

    var tryGet = function tryGet(it, key) {
      try {
        return it[key];
      } catch (error) {
        /* empty */
      }
    }; // getting tag from ES6+ `Object.prototype.toString`


    module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
      var O, tag, result;
      return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
      : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag // builtinTag case
      : CORRECT_ARGUMENTS ? classofRaw(O) // ES3 arguments fallback
      : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
    };
    /***/
  },

  /***/
  "./node_modules/core-js/internals/collection-strong.js":
  /*!*************************************************************!*\
    !*** ./node_modules/core-js/internals/collection-strong.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsCollectionStrongJs(module, exports, __webpack_require__) {
    "use strict";

    var defineProperty = __webpack_require__(
    /*! ../internals/object-define-property */
    "./node_modules/core-js/internals/object-define-property.js").f;

    var create = __webpack_require__(
    /*! ../internals/object-create */
    "./node_modules/core-js/internals/object-create.js");

    var redefineAll = __webpack_require__(
    /*! ../internals/redefine-all */
    "./node_modules/core-js/internals/redefine-all.js");

    var bind = __webpack_require__(
    /*! ../internals/function-bind-context */
    "./node_modules/core-js/internals/function-bind-context.js");

    var anInstance = __webpack_require__(
    /*! ../internals/an-instance */
    "./node_modules/core-js/internals/an-instance.js");

    var iterate = __webpack_require__(
    /*! ../internals/iterate */
    "./node_modules/core-js/internals/iterate.js");

    var defineIterator = __webpack_require__(
    /*! ../internals/define-iterator */
    "./node_modules/core-js/internals/define-iterator.js");

    var setSpecies = __webpack_require__(
    /*! ../internals/set-species */
    "./node_modules/core-js/internals/set-species.js");

    var DESCRIPTORS = __webpack_require__(
    /*! ../internals/descriptors */
    "./node_modules/core-js/internals/descriptors.js");

    var fastKey = __webpack_require__(
    /*! ../internals/internal-metadata */
    "./node_modules/core-js/internals/internal-metadata.js").fastKey;

    var InternalStateModule = __webpack_require__(
    /*! ../internals/internal-state */
    "./node_modules/core-js/internals/internal-state.js");

    var setInternalState = InternalStateModule.set;
    var internalStateGetterFor = InternalStateModule.getterFor;
    module.exports = {
      getConstructor: function getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
        var C = wrapper(function (that, iterable) {
          anInstance(that, C, CONSTRUCTOR_NAME);
          setInternalState(that, {
            type: CONSTRUCTOR_NAME,
            index: create(null),
            first: undefined,
            last: undefined,
            size: 0
          });
          if (!DESCRIPTORS) that.size = 0;
          if (iterable != undefined) iterate(iterable, that[ADDER], that, IS_MAP);
        });
        var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

        var define = function define(that, key, value) {
          var state = getInternalState(that);
          var entry = getEntry(that, key);
          var previous, index; // change existing entry

          if (entry) {
            entry.value = value; // create new entry
          } else {
            state.last = entry = {
              index: index = fastKey(key, true),
              key: key,
              value: value,
              previous: previous = state.last,
              next: undefined,
              removed: false
            };
            if (!state.first) state.first = entry;
            if (previous) previous.next = entry;
            if (DESCRIPTORS) state.size++;else that.size++; // add to index

            if (index !== 'F') state.index[index] = entry;
          }

          return that;
        };

        var getEntry = function getEntry(that, key) {
          var state = getInternalState(that); // fast case

          var index = fastKey(key);
          var entry;
          if (index !== 'F') return state.index[index]; // frozen object case

          for (entry = state.first; entry; entry = entry.next) {
            if (entry.key == key) return entry;
          }
        };

        redefineAll(C.prototype, {
          // 23.1.3.1 Map.prototype.clear()
          // 23.2.3.2 Set.prototype.clear()
          clear: function clear() {
            var that = this;
            var state = getInternalState(that);
            var data = state.index;
            var entry = state.first;

            while (entry) {
              entry.removed = true;
              if (entry.previous) entry.previous = entry.previous.next = undefined;
              delete data[entry.index];
              entry = entry.next;
            }

            state.first = state.last = undefined;
            if (DESCRIPTORS) state.size = 0;else that.size = 0;
          },
          // 23.1.3.3 Map.prototype.delete(key)
          // 23.2.3.4 Set.prototype.delete(value)
          'delete': function _delete(key) {
            var that = this;
            var state = getInternalState(that);
            var entry = getEntry(that, key);

            if (entry) {
              var next = entry.next;
              var prev = entry.previous;
              delete state.index[entry.index];
              entry.removed = true;
              if (prev) prev.next = next;
              if (next) next.previous = prev;
              if (state.first == entry) state.first = next;
              if (state.last == entry) state.last = prev;
              if (DESCRIPTORS) state.size--;else that.size--;
            }

            return !!entry;
          },
          // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
          // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
          forEach: function forEach(callbackfn
          /* , that = undefined */
          ) {
            var state = getInternalState(this);
            var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
            var entry;

            while (entry = entry ? entry.next : state.first) {
              boundFunction(entry.value, entry.key, this); // revert to the last existing entry

              while (entry && entry.removed) entry = entry.previous;
            }
          },
          // 23.1.3.7 Map.prototype.has(key)
          // 23.2.3.7 Set.prototype.has(value)
          has: function has(key) {
            return !!getEntry(this, key);
          }
        });
        redefineAll(C.prototype, IS_MAP ? {
          // 23.1.3.6 Map.prototype.get(key)
          get: function get(key) {
            var entry = getEntry(this, key);
            return entry && entry.value;
          },
          // 23.1.3.9 Map.prototype.set(key, value)
          set: function set(key, value) {
            return define(this, key === 0 ? 0 : key, value);
          }
        } : {
          // 23.2.3.1 Set.prototype.add(value)
          add: function add(value) {
            return define(this, value = value === 0 ? 0 : value, value);
          }
        });
        if (DESCRIPTORS) defineProperty(C.prototype, 'size', {
          get: function get() {
            return getInternalState(this).size;
          }
        });
        return C;
      },
      setStrong: function setStrong(C, CONSTRUCTOR_NAME, IS_MAP) {
        var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
        var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
        var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME); // add .keys, .values, .entries, [@@iterator]
        // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11

        defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {
          setInternalState(this, {
            type: ITERATOR_NAME,
            target: iterated,
            state: getInternalCollectionState(iterated),
            kind: kind,
            last: undefined
          });
        }, function () {
          var state = getInternalIteratorState(this);
          var kind = state.kind;
          var entry = state.last; // revert to the last existing entry

          while (entry && entry.removed) entry = entry.previous; // get next entry


          if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
            // or finish the iteration
            state.target = undefined;
            return {
              value: undefined,
              done: true
            };
          } // return step by kind


          if (kind == 'keys') return {
            value: entry.key,
            done: false
          };
          if (kind == 'values') return {
            value: entry.value,
            done: false
          };
          return {
            value: [entry.key, entry.value],
            done: false
          };
        }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2

        setSpecies(CONSTRUCTOR_NAME);
      }
    };
    /***/
  },

  /***/
  "./node_modules/core-js/internals/collection-weak.js":
  /*!***********************************************************!*\
    !*** ./node_modules/core-js/internals/collection-weak.js ***!
    \***********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsCollectionWeakJs(module, exports, __webpack_require__) {
    "use strict";

    var redefineAll = __webpack_require__(
    /*! ../internals/redefine-all */
    "./node_modules/core-js/internals/redefine-all.js");

    var getWeakData = __webpack_require__(
    /*! ../internals/internal-metadata */
    "./node_modules/core-js/internals/internal-metadata.js").getWeakData;

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    var anInstance = __webpack_require__(
    /*! ../internals/an-instance */
    "./node_modules/core-js/internals/an-instance.js");

    var iterate = __webpack_require__(
    /*! ../internals/iterate */
    "./node_modules/core-js/internals/iterate.js");

    var ArrayIterationModule = __webpack_require__(
    /*! ../internals/array-iteration */
    "./node_modules/core-js/internals/array-iteration.js");

    var $has = __webpack_require__(
    /*! ../internals/has */
    "./node_modules/core-js/internals/has.js");

    var InternalStateModule = __webpack_require__(
    /*! ../internals/internal-state */
    "./node_modules/core-js/internals/internal-state.js");

    var setInternalState = InternalStateModule.set;
    var internalStateGetterFor = InternalStateModule.getterFor;
    var find = ArrayIterationModule.find;
    var findIndex = ArrayIterationModule.findIndex;
    var id = 0; // fallback for uncaught frozen keys

    var uncaughtFrozenStore = function uncaughtFrozenStore(store) {
      return store.frozen || (store.frozen = new UncaughtFrozenStore());
    };

    var UncaughtFrozenStore = function UncaughtFrozenStore() {
      this.entries = [];
    };

    var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
      return find(store.entries, function (it) {
        return it[0] === key;
      });
    };

    UncaughtFrozenStore.prototype = {
      get: function get(key) {
        var entry = findUncaughtFrozen(this, key);
        if (entry) return entry[1];
      },
      has: function has(key) {
        return !!findUncaughtFrozen(this, key);
      },
      set: function set(key, value) {
        var entry = findUncaughtFrozen(this, key);
        if (entry) entry[1] = value;else this.entries.push([key, value]);
      },
      'delete': function _delete(key) {
        var index = findIndex(this.entries, function (it) {
          return it[0] === key;
        });
        if (~index) this.entries.splice(index, 1);
        return !!~index;
      }
    };
    module.exports = {
      getConstructor: function getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
        var C = wrapper(function (that, iterable) {
          anInstance(that, C, CONSTRUCTOR_NAME);
          setInternalState(that, {
            type: CONSTRUCTOR_NAME,
            id: id++,
            frozen: undefined
          });
          if (iterable != undefined) iterate(iterable, that[ADDER], that, IS_MAP);
        });
        var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

        var define = function define(that, key, value) {
          var state = getInternalState(that);
          var data = getWeakData(anObject(key), true);
          if (data === true) uncaughtFrozenStore(state).set(key, value);else data[state.id] = value;
          return that;
        };

        redefineAll(C.prototype, {
          // 23.3.3.2 WeakMap.prototype.delete(key)
          // 23.4.3.3 WeakSet.prototype.delete(value)
          'delete': function _delete(key) {
            var state = getInternalState(this);
            if (!isObject(key)) return false;
            var data = getWeakData(key);
            if (data === true) return uncaughtFrozenStore(state)['delete'](key);
            return data && $has(data, state.id) && delete data[state.id];
          },
          // 23.3.3.4 WeakMap.prototype.has(key)
          // 23.4.3.4 WeakSet.prototype.has(value)
          has: function has(key) {
            var state = getInternalState(this);
            if (!isObject(key)) return false;
            var data = getWeakData(key);
            if (data === true) return uncaughtFrozenStore(state).has(key);
            return data && $has(data, state.id);
          }
        });
        redefineAll(C.prototype, IS_MAP ? {
          // 23.3.3.3 WeakMap.prototype.get(key)
          get: function get(key) {
            var state = getInternalState(this);

            if (isObject(key)) {
              var data = getWeakData(key);
              if (data === true) return uncaughtFrozenStore(state).get(key);
              return data ? data[state.id] : undefined;
            }
          },
          // 23.3.3.5 WeakMap.prototype.set(key, value)
          set: function set(key, value) {
            return define(this, key, value);
          }
        } : {
          // 23.4.3.1 WeakSet.prototype.add(value)
          add: function add(value) {
            return define(this, value, true);
          }
        });
        return C;
      }
    };
    /***/
  },

  /***/
  "./node_modules/core-js/internals/collection.js":
  /*!******************************************************!*\
    !*** ./node_modules/core-js/internals/collection.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsCollectionJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    var isForced = __webpack_require__(
    /*! ../internals/is-forced */
    "./node_modules/core-js/internals/is-forced.js");

    var redefine = __webpack_require__(
    /*! ../internals/redefine */
    "./node_modules/core-js/internals/redefine.js");

    var InternalMetadataModule = __webpack_require__(
    /*! ../internals/internal-metadata */
    "./node_modules/core-js/internals/internal-metadata.js");

    var iterate = __webpack_require__(
    /*! ../internals/iterate */
    "./node_modules/core-js/internals/iterate.js");

    var anInstance = __webpack_require__(
    /*! ../internals/an-instance */
    "./node_modules/core-js/internals/an-instance.js");

    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var checkCorrectnessOfIteration = __webpack_require__(
    /*! ../internals/check-correctness-of-iteration */
    "./node_modules/core-js/internals/check-correctness-of-iteration.js");

    var setToStringTag = __webpack_require__(
    /*! ../internals/set-to-string-tag */
    "./node_modules/core-js/internals/set-to-string-tag.js");

    var inheritIfRequired = __webpack_require__(
    /*! ../internals/inherit-if-required */
    "./node_modules/core-js/internals/inherit-if-required.js");

    module.exports = function (CONSTRUCTOR_NAME, wrapper, common) {
      var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
      var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
      var ADDER = IS_MAP ? 'set' : 'add';
      var NativeConstructor = global[CONSTRUCTOR_NAME];
      var NativePrototype = NativeConstructor && NativeConstructor.prototype;
      var Constructor = NativeConstructor;
      var exported = {};

      var fixMethod = function fixMethod(KEY) {
        var nativeMethod = NativePrototype[KEY];
        redefine(NativePrototype, KEY, KEY == 'add' ? function add(value) {
          nativeMethod.call(this, value === 0 ? 0 : value);
          return this;
        } : KEY == 'delete' ? function (key) {
          return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
        } : KEY == 'get' ? function get(key) {
          return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);
        } : KEY == 'has' ? function has(key) {
          return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
        } : function set(key, value) {
          nativeMethod.call(this, key === 0 ? 0 : key, value);
          return this;
        });
      }; // eslint-disable-next-line max-len


      if (isForced(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
        new NativeConstructor().entries().next();
      })))) {
        // create collection constructor
        Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
        InternalMetadataModule.REQUIRED = true;
      } else if (isForced(CONSTRUCTOR_NAME, true)) {
        var instance = new Constructor(); // early implementations not supports chaining

        var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance; // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false

        var THROWS_ON_PRIMITIVES = fails(function () {
          instance.has(1);
        }); // most early implementations doesn't supports iterables, most modern - not close it correctly
        // eslint-disable-next-line no-new

        var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) {
          new NativeConstructor(iterable);
        }); // for early implementations -0 and +0 not the same

        var BUGGY_ZERO = !IS_WEAK && fails(function () {
          // V8 ~ Chromium 42- fails only with 5+ elements
          var $instance = new NativeConstructor();
          var index = 5;

          while (index--) $instance[ADDER](index, index);

          return !$instance.has(-0);
        });

        if (!ACCEPT_ITERABLES) {
          Constructor = wrapper(function (dummy, iterable) {
            anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
            var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
            if (iterable != undefined) iterate(iterable, that[ADDER], that, IS_MAP);
            return that;
          });
          Constructor.prototype = NativePrototype;
          NativePrototype.constructor = Constructor;
        }

        if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
          fixMethod('delete');
          fixMethod('has');
          IS_MAP && fixMethod('get');
        }

        if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); // weak collections should not contains .clear method

        if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
      }

      exported[CONSTRUCTOR_NAME] = Constructor;
      $({
        global: true,
        forced: Constructor != NativeConstructor
      }, exported);
      setToStringTag(Constructor, CONSTRUCTOR_NAME);
      if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);
      return Constructor;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/copy-constructor-properties.js":
  /*!***********************************************************************!*\
    !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!
    \***********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsCopyConstructorPropertiesJs(module, exports, __webpack_require__) {
    var has = __webpack_require__(
    /*! ../internals/has */
    "./node_modules/core-js/internals/has.js");

    var ownKeys = __webpack_require__(
    /*! ../internals/own-keys */
    "./node_modules/core-js/internals/own-keys.js");

    var getOwnPropertyDescriptorModule = __webpack_require__(
    /*! ../internals/object-get-own-property-descriptor */
    "./node_modules/core-js/internals/object-get-own-property-descriptor.js");

    var definePropertyModule = __webpack_require__(
    /*! ../internals/object-define-property */
    "./node_modules/core-js/internals/object-define-property.js");

    module.exports = function (target, source) {
      var keys = ownKeys(source);
      var defineProperty = definePropertyModule.f;
      var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;

      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
      }
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/correct-is-regexp-logic.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/core-js/internals/correct-is-regexp-logic.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsCorrectIsRegexpLogicJs(module, exports, __webpack_require__) {
    var wellKnownSymbol = __webpack_require__(
    /*! ../internals/well-known-symbol */
    "./node_modules/core-js/internals/well-known-symbol.js");

    var MATCH = wellKnownSymbol('match');

    module.exports = function (METHOD_NAME) {
      var regexp = /./;

      try {
        '/./'[METHOD_NAME](regexp);
      } catch (e) {
        try {
          regexp[MATCH] = false;
          return '/./'[METHOD_NAME](regexp);
        } catch (f) {
          /* empty */
        }
      }

      return false;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/correct-prototype-getter.js":
  /*!********************************************************************!*\
    !*** ./node_modules/core-js/internals/correct-prototype-getter.js ***!
    \********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsCorrectPrototypeGetterJs(module, exports, __webpack_require__) {
    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    module.exports = !fails(function () {
      function F() {
        /* empty */
      }

      F.prototype.constructor = null;
      return Object.getPrototypeOf(new F()) !== F.prototype;
    });
    /***/
  },

  /***/
  "./node_modules/core-js/internals/create-html.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/internals/create-html.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsCreateHtmlJs(module, exports, __webpack_require__) {
    var requireObjectCoercible = __webpack_require__(
    /*! ../internals/require-object-coercible */
    "./node_modules/core-js/internals/require-object-coercible.js");

    var quot = /"/g; // B.2.3.2.1 CreateHTML(string, tag, attribute, value)
    // https://tc39.github.io/ecma262/#sec-createhtml

    module.exports = function (string, tag, attribute, value) {
      var S = String(requireObjectCoercible(string));
      var p1 = '<' + tag;
      if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
      return p1 + '>' + S + '</' + tag + '>';
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/create-iterator-constructor.js":
  /*!***********************************************************************!*\
    !*** ./node_modules/core-js/internals/create-iterator-constructor.js ***!
    \***********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsCreateIteratorConstructorJs(module, exports, __webpack_require__) {
    "use strict";

    var IteratorPrototype = __webpack_require__(
    /*! ../internals/iterators-core */
    "./node_modules/core-js/internals/iterators-core.js").IteratorPrototype;

    var create = __webpack_require__(
    /*! ../internals/object-create */
    "./node_modules/core-js/internals/object-create.js");

    var createPropertyDescriptor = __webpack_require__(
    /*! ../internals/create-property-descriptor */
    "./node_modules/core-js/internals/create-property-descriptor.js");

    var setToStringTag = __webpack_require__(
    /*! ../internals/set-to-string-tag */
    "./node_modules/core-js/internals/set-to-string-tag.js");

    var Iterators = __webpack_require__(
    /*! ../internals/iterators */
    "./node_modules/core-js/internals/iterators.js");

    var returnThis = function returnThis() {
      return this;
    };

    module.exports = function (IteratorConstructor, NAME, next) {
      var TO_STRING_TAG = NAME + ' Iterator';
      IteratorConstructor.prototype = create(IteratorPrototype, {
        next: createPropertyDescriptor(1, next)
      });
      setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
      Iterators[TO_STRING_TAG] = returnThis;
      return IteratorConstructor;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/create-non-enumerable-property.js":
  /*!**************************************************************************!*\
    !*** ./node_modules/core-js/internals/create-non-enumerable-property.js ***!
    \**************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsCreateNonEnumerablePropertyJs(module, exports, __webpack_require__) {
    var DESCRIPTORS = __webpack_require__(
    /*! ../internals/descriptors */
    "./node_modules/core-js/internals/descriptors.js");

    var definePropertyModule = __webpack_require__(
    /*! ../internals/object-define-property */
    "./node_modules/core-js/internals/object-define-property.js");

    var createPropertyDescriptor = __webpack_require__(
    /*! ../internals/create-property-descriptor */
    "./node_modules/core-js/internals/create-property-descriptor.js");

    module.exports = DESCRIPTORS ? function (object, key, value) {
      return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
    } : function (object, key, value) {
      object[key] = value;
      return object;
    };
    /***/
  },

  /***/
  "./node_modules/core-js/internals/create-property-descriptor.js":
  /*!**********************************************************************!*\
    !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!
    \**********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsCreatePropertyDescriptorJs(module, exports) {
    module.exports = function (bitmap, value) {
      return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value: value
      };
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/create-property.js":
  /*!***********************************************************!*\
    !*** ./node_modules/core-js/internals/create-property.js ***!
    \***********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsCreatePropertyJs(module, exports, __webpack_require__) {
    "use strict";

    var toPrimitive = __webpack_require__(
    /*! ../internals/to-primitive */
    "./node_modules/core-js/internals/to-primitive.js");

    var definePropertyModule = __webpack_require__(
    /*! ../internals/object-define-property */
    "./node_modules/core-js/internals/object-define-property.js");

    var createPropertyDescriptor = __webpack_require__(
    /*! ../internals/create-property-descriptor */
    "./node_modules/core-js/internals/create-property-descriptor.js");

    module.exports = function (object, key, value) {
      var propertyKey = toPrimitive(key);
      if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));else object[propertyKey] = value;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/date-to-iso-string.js":
  /*!**************************************************************!*\
    !*** ./node_modules/core-js/internals/date-to-iso-string.js ***!
    \**************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsDateToIsoStringJs(module, exports, __webpack_require__) {
    "use strict";

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var padStart = __webpack_require__(
    /*! ../internals/string-pad */
    "./node_modules/core-js/internals/string-pad.js").start;

    var abs = Math.abs;
    var DatePrototype = Date.prototype;
    var getTime = DatePrototype.getTime;
    var nativeDateToISOString = DatePrototype.toISOString; // `Date.prototype.toISOString` method implementation
    // https://tc39.github.io/ecma262/#sec-date.prototype.toisostring
    // PhantomJS / old WebKit fails here:

    module.exports = fails(function () {
      return nativeDateToISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
    }) || !fails(function () {
      nativeDateToISOString.call(new Date(NaN));
    }) ? function toISOString() {
      if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
      var date = this;
      var year = date.getUTCFullYear();
      var milliseconds = date.getUTCMilliseconds();
      var sign = year < 0 ? '-' : year > 9999 ? '+' : '';
      return sign + padStart(abs(year), sign ? 6 : 4, 0) + '-' + padStart(date.getUTCMonth() + 1, 2, 0) + '-' + padStart(date.getUTCDate(), 2, 0) + 'T' + padStart(date.getUTCHours(), 2, 0) + ':' + padStart(date.getUTCMinutes(), 2, 0) + ':' + padStart(date.getUTCSeconds(), 2, 0) + '.' + padStart(milliseconds, 3, 0) + 'Z';
    } : nativeDateToISOString;
    /***/
  },

  /***/
  "./node_modules/core-js/internals/date-to-primitive.js":
  /*!*************************************************************!*\
    !*** ./node_modules/core-js/internals/date-to-primitive.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsDateToPrimitiveJs(module, exports, __webpack_require__) {
    "use strict";

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var toPrimitive = __webpack_require__(
    /*! ../internals/to-primitive */
    "./node_modules/core-js/internals/to-primitive.js");

    module.exports = function (hint) {
      if (hint !== 'string' && hint !== 'number' && hint !== 'default') {
        throw TypeError('Incorrect hint');
      }

      return toPrimitive(anObject(this), hint !== 'number');
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/define-iterator.js":
  /*!***********************************************************!*\
    !*** ./node_modules/core-js/internals/define-iterator.js ***!
    \***********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsDefineIteratorJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var createIteratorConstructor = __webpack_require__(
    /*! ../internals/create-iterator-constructor */
    "./node_modules/core-js/internals/create-iterator-constructor.js");

    var getPrototypeOf = __webpack_require__(
    /*! ../internals/object-get-prototype-of */
    "./node_modules/core-js/internals/object-get-prototype-of.js");

    var setPrototypeOf = __webpack_require__(
    /*! ../internals/object-set-prototype-of */
    "./node_modules/core-js/internals/object-set-prototype-of.js");

    var setToStringTag = __webpack_require__(
    /*! ../internals/set-to-string-tag */
    "./node_modules/core-js/internals/set-to-string-tag.js");

    var createNonEnumerableProperty = __webpack_require__(
    /*! ../internals/create-non-enumerable-property */
    "./node_modules/core-js/internals/create-non-enumerable-property.js");

    var redefine = __webpack_require__(
    /*! ../internals/redefine */
    "./node_modules/core-js/internals/redefine.js");

    var wellKnownSymbol = __webpack_require__(
    /*! ../internals/well-known-symbol */
    "./node_modules/core-js/internals/well-known-symbol.js");

    var IS_PURE = __webpack_require__(
    /*! ../internals/is-pure */
    "./node_modules/core-js/internals/is-pure.js");

    var Iterators = __webpack_require__(
    /*! ../internals/iterators */
    "./node_modules/core-js/internals/iterators.js");

    var IteratorsCore = __webpack_require__(
    /*! ../internals/iterators-core */
    "./node_modules/core-js/internals/iterators-core.js");

    var IteratorPrototype = IteratorsCore.IteratorPrototype;
    var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
    var ITERATOR = wellKnownSymbol('iterator');
    var KEYS = 'keys';
    var VALUES = 'values';
    var ENTRIES = 'entries';

    var returnThis = function returnThis() {
      return this;
    };

    module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
      createIteratorConstructor(IteratorConstructor, NAME, next);

      var getIterationMethod = function getIterationMethod(KIND) {
        if (KIND === DEFAULT && defaultIterator) return defaultIterator;
        if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];

        switch (KIND) {
          case KEYS:
            return function keys() {
              return new IteratorConstructor(this, KIND);
            };

          case VALUES:
            return function values() {
              return new IteratorConstructor(this, KIND);
            };

          case ENTRIES:
            return function entries() {
              return new IteratorConstructor(this, KIND);
            };
        }

        return function () {
          return new IteratorConstructor(this);
        };
      };

      var TO_STRING_TAG = NAME + ' Iterator';
      var INCORRECT_VALUES_NAME = false;
      var IterablePrototype = Iterable.prototype;
      var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];
      var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
      var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
      var CurrentIteratorPrototype, methods, KEY; // fix native

      if (anyNativeIterator) {
        CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));

        if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
          if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
            if (setPrototypeOf) {
              setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
            } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
              createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
            }
          } // Set @@toStringTag to native iterators


          setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
          if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
        }
      } // fix Array#{values, @@iterator}.name in V8 / FF


      if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
        INCORRECT_VALUES_NAME = true;

        defaultIterator = function values() {
          return nativeIterator.call(this);
        };
      } // define iterator


      if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
        createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
      }

      Iterators[NAME] = defaultIterator; // export additional methods

      if (DEFAULT) {
        methods = {
          values: getIterationMethod(VALUES),
          keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
          entries: getIterationMethod(ENTRIES)
        };
        if (FORCED) for (KEY in methods) {
          if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
            redefine(IterablePrototype, KEY, methods[KEY]);
          }
        } else $({
          target: NAME,
          proto: true,
          forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
        }, methods);
      }

      return methods;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/define-well-known-symbol.js":
  /*!********************************************************************!*\
    !*** ./node_modules/core-js/internals/define-well-known-symbol.js ***!
    \********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsDefineWellKnownSymbolJs(module, exports, __webpack_require__) {
    var path = __webpack_require__(
    /*! ../internals/path */
    "./node_modules/core-js/internals/path.js");

    var has = __webpack_require__(
    /*! ../internals/has */
    "./node_modules/core-js/internals/has.js");

    var wrappedWellKnownSymbolModule = __webpack_require__(
    /*! ../internals/well-known-symbol-wrapped */
    "./node_modules/core-js/internals/well-known-symbol-wrapped.js");

    var defineProperty = __webpack_require__(
    /*! ../internals/object-define-property */
    "./node_modules/core-js/internals/object-define-property.js").f;

    module.exports = function (NAME) {
      var Symbol = path.Symbol || (path.Symbol = {});
      if (!has(Symbol, NAME)) defineProperty(Symbol, NAME, {
        value: wrappedWellKnownSymbolModule.f(NAME)
      });
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/descriptors.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/internals/descriptors.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsDescriptorsJs(module, exports, __webpack_require__) {
    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js"); // Thank's IE8 for his funny defineProperty


    module.exports = !fails(function () {
      return Object.defineProperty({}, 1, {
        get: function get() {
          return 7;
        }
      })[1] != 7;
    });
    /***/
  },

  /***/
  "./node_modules/core-js/internals/document-create-element.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/core-js/internals/document-create-element.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsDocumentCreateElementJs(module, exports, __webpack_require__) {
    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    var document = global.document; // typeof document.createElement is 'object' in old IE

    var EXISTS = isObject(document) && isObject(document.createElement);

    module.exports = function (it) {
      return EXISTS ? document.createElement(it) : {};
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/dom-iterables.js":
  /*!*********************************************************!*\
    !*** ./node_modules/core-js/internals/dom-iterables.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsDomIterablesJs(module, exports) {
    // iterable DOM collections
    // flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
    module.exports = {
      CSSRuleList: 0,
      CSSStyleDeclaration: 0,
      CSSValueList: 0,
      ClientRectList: 0,
      DOMRectList: 0,
      DOMStringList: 0,
      DOMTokenList: 1,
      DataTransferItemList: 0,
      FileList: 0,
      HTMLAllCollection: 0,
      HTMLCollection: 0,
      HTMLFormElement: 0,
      HTMLSelectElement: 0,
      MediaList: 0,
      MimeTypeArray: 0,
      NamedNodeMap: 0,
      NodeList: 1,
      PaintRequestList: 0,
      Plugin: 0,
      PluginArray: 0,
      SVGLengthList: 0,
      SVGNumberList: 0,
      SVGPathSegList: 0,
      SVGPointList: 0,
      SVGStringList: 0,
      SVGTransformList: 0,
      SourceBufferList: 0,
      StyleSheetList: 0,
      TextTrackCueList: 0,
      TextTrackList: 0,
      TouchList: 0
    };
    /***/
  },

  /***/
  "./node_modules/core-js/internals/engine-is-ios.js":
  /*!*********************************************************!*\
    !*** ./node_modules/core-js/internals/engine-is-ios.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsEngineIsIosJs(module, exports, __webpack_require__) {
    var userAgent = __webpack_require__(
    /*! ../internals/engine-user-agent */
    "./node_modules/core-js/internals/engine-user-agent.js");

    module.exports = /(iphone|ipod|ipad).*applewebkit/i.test(userAgent);
    /***/
  },

  /***/
  "./node_modules/core-js/internals/engine-user-agent.js":
  /*!*************************************************************!*\
    !*** ./node_modules/core-js/internals/engine-user-agent.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsEngineUserAgentJs(module, exports, __webpack_require__) {
    var getBuiltIn = __webpack_require__(
    /*! ../internals/get-built-in */
    "./node_modules/core-js/internals/get-built-in.js");

    module.exports = getBuiltIn('navigator', 'userAgent') || '';
    /***/
  },

  /***/
  "./node_modules/core-js/internals/engine-v8-version.js":
  /*!*************************************************************!*\
    !*** ./node_modules/core-js/internals/engine-v8-version.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsEngineV8VersionJs(module, exports, __webpack_require__) {
    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    var userAgent = __webpack_require__(
    /*! ../internals/engine-user-agent */
    "./node_modules/core-js/internals/engine-user-agent.js");

    var process = global.process;
    var versions = process && process.versions;
    var v8 = versions && versions.v8;
    var match, version;

    if (v8) {
      match = v8.split('.');
      version = match[0] + match[1];
    } else if (userAgent) {
      match = userAgent.match(/Edge\/(\d+)/);

      if (!match || match[1] >= 74) {
        match = userAgent.match(/Chrome\/(\d+)/);
        if (match) version = match[1];
      }
    }

    module.exports = version && +version;
    /***/
  },

  /***/
  "./node_modules/core-js/internals/enum-bug-keys.js":
  /*!*********************************************************!*\
    !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsEnumBugKeysJs(module, exports) {
    // IE8- don't enum bug keys
    module.exports = ['constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf'];
    /***/
  },

  /***/
  "./node_modules/core-js/internals/export.js":
  /*!**************************************************!*\
    !*** ./node_modules/core-js/internals/export.js ***!
    \**************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsExportJs(module, exports, __webpack_require__) {
    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    var getOwnPropertyDescriptor = __webpack_require__(
    /*! ../internals/object-get-own-property-descriptor */
    "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;

    var createNonEnumerableProperty = __webpack_require__(
    /*! ../internals/create-non-enumerable-property */
    "./node_modules/core-js/internals/create-non-enumerable-property.js");

    var redefine = __webpack_require__(
    /*! ../internals/redefine */
    "./node_modules/core-js/internals/redefine.js");

    var setGlobal = __webpack_require__(
    /*! ../internals/set-global */
    "./node_modules/core-js/internals/set-global.js");

    var copyConstructorProperties = __webpack_require__(
    /*! ../internals/copy-constructor-properties */
    "./node_modules/core-js/internals/copy-constructor-properties.js");

    var isForced = __webpack_require__(
    /*! ../internals/is-forced */
    "./node_modules/core-js/internals/is-forced.js");
    /*
      options.target      - name of the target object
      options.global      - target is the global object
      options.stat        - export as static methods of target
      options.proto       - export as prototype methods of target
      options.real        - real prototype method for the `pure` version
      options.forced      - export even if the native feature is available
      options.bind        - bind methods to the target, required for the `pure` version
      options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
      options.unsafe      - use the simple assignment of property instead of delete + defineProperty
      options.sham        - add a flag to not completely full polyfills
      options.enumerable  - export as enumerable property
      options.noTargetGet - prevent calling a getter on target
    */


    module.exports = function (options, source) {
      var TARGET = options.target;
      var GLOBAL = options.global;
      var STATIC = options.stat;
      var FORCED, target, key, targetProperty, sourceProperty, descriptor;

      if (GLOBAL) {
        target = global;
      } else if (STATIC) {
        target = global[TARGET] || setGlobal(TARGET, {});
      } else {
        target = (global[TARGET] || {}).prototype;
      }

      if (target) for (key in source) {
        sourceProperty = source[key];

        if (options.noTargetGet) {
          descriptor = getOwnPropertyDescriptor(target, key);
          targetProperty = descriptor && descriptor.value;
        } else targetProperty = target[key];

        FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); // contained in target

        if (!FORCED && targetProperty !== undefined) {
          if (typeof sourceProperty === typeof targetProperty) continue;
          copyConstructorProperties(sourceProperty, targetProperty);
        } // add a flag to not completely full polyfills


        if (options.sham || targetProperty && targetProperty.sham) {
          createNonEnumerableProperty(sourceProperty, 'sham', true);
        } // extend global


        redefine(target, key, sourceProperty, options);
      }
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/fails.js":
  /*!*************************************************!*\
    !*** ./node_modules/core-js/internals/fails.js ***!
    \*************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsFailsJs(module, exports) {
    module.exports = function (exec) {
      try {
        return !!exec();
      } catch (error) {
        return true;
      }
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js":
  /*!******************************************************************************!*\
    !*** ./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js ***!
    \******************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsFixRegexpWellKnownSymbolLogicJs(module, exports, __webpack_require__) {
    "use strict"; // TODO: Remove from `core-js@4` since it's moved to entry points

    __webpack_require__(
    /*! ../modules/es.regexp.exec */
    "./node_modules/core-js/modules/es.regexp.exec.js");

    var redefine = __webpack_require__(
    /*! ../internals/redefine */
    "./node_modules/core-js/internals/redefine.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var wellKnownSymbol = __webpack_require__(
    /*! ../internals/well-known-symbol */
    "./node_modules/core-js/internals/well-known-symbol.js");

    var regexpExec = __webpack_require__(
    /*! ../internals/regexp-exec */
    "./node_modules/core-js/internals/regexp-exec.js");

    var createNonEnumerableProperty = __webpack_require__(
    /*! ../internals/create-non-enumerable-property */
    "./node_modules/core-js/internals/create-non-enumerable-property.js");

    var SPECIES = wellKnownSymbol('species');
    var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
      // #replace needs built-in support for named groups.
      // #match works fine because it just return the exec results, even if it has
      // a "grops" property.
      var re = /./;

      re.exec = function () {
        var result = [];
        result.groups = {
          a: '7'
        };
        return result;
      };

      return ''.replace(re, '$<a>') !== '7';
    }); // IE <= 11 replaces $0 with the whole match, as if it was $&
    // https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0

    var REPLACE_KEEPS_$0 = function () {
      return 'a'.replace(/./, '$0') === '$0';
    }();

    var REPLACE = wellKnownSymbol('replace'); // Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string

    var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = function () {
      if (/./[REPLACE]) {
        return /./[REPLACE]('a', '$0') === '';
      }

      return false;
    }(); // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
    // Weex JS has frozen built-in prototypes, so use try / catch wrapper


    var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
      var re = /(?:)/;
      var originalExec = re.exec;

      re.exec = function () {
        return originalExec.apply(this, arguments);
      };

      var result = 'ab'.split(re);
      return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
    });

    module.exports = function (KEY, length, exec, sham) {
      var SYMBOL = wellKnownSymbol(KEY);
      var DELEGATES_TO_SYMBOL = !fails(function () {
        // String methods call symbol-named RegEp methods
        var O = {};

        O[SYMBOL] = function () {
          return 7;
        };

        return ''[KEY](O) != 7;
      });
      var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
        // Symbol-named RegExp methods call .exec
        var execCalled = false;
        var re = /a/;

        if (KEY === 'split') {
          // We can't use real regex here since it causes deoptimization
          // and serious performance degradation in V8
          // https://github.com/zloirock/core-js/issues/306
          re = {}; // RegExp[@@split] doesn't call the regex's exec method, but first creates
          // a new one. We need to return the patched regex when creating the new one.

          re.constructor = {};

          re.constructor[SPECIES] = function () {
            return re;
          };

          re.flags = '';
          re[SYMBOL] = /./[SYMBOL];
        }

        re.exec = function () {
          execCalled = true;
          return null;
        };

        re[SYMBOL]('');
        return !execCalled;
      });

      if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !(REPLACE_SUPPORTS_NAMED_GROUPS && REPLACE_KEEPS_$0 && !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE) || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
        var nativeRegExpMethod = /./[SYMBOL];
        var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
          if (regexp.exec === regexpExec) {
            if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
              // The native String method already delegates to @@method (this
              // polyfilled function), leasing to infinite recursion.
              // We avoid it by directly calling the native @@method method.
              return {
                done: true,
                value: nativeRegExpMethod.call(regexp, str, arg2)
              };
            }

            return {
              done: true,
              value: nativeMethod.call(str, regexp, arg2)
            };
          }

          return {
            done: false
          };
        }, {
          REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
          REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
        });
        var stringMethod = methods[0];
        var regexMethod = methods[1];
        redefine(String.prototype, KEY, stringMethod);
        redefine(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
        // 21.2.5.11 RegExp.prototype[@@split](string, limit)
        ? function (string, arg) {
          return regexMethod.call(string, this, arg);
        } // 21.2.5.6 RegExp.prototype[@@match](string)
        // 21.2.5.9 RegExp.prototype[@@search](string)
        : function (string) {
          return regexMethod.call(string, this);
        });
      }

      if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/freezing.js":
  /*!****************************************************!*\
    !*** ./node_modules/core-js/internals/freezing.js ***!
    \****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsFreezingJs(module, exports, __webpack_require__) {
    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    module.exports = !fails(function () {
      return Object.isExtensible(Object.preventExtensions({}));
    });
    /***/
  },

  /***/
  "./node_modules/core-js/internals/function-bind-context.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/core-js/internals/function-bind-context.js ***!
    \*****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsFunctionBindContextJs(module, exports, __webpack_require__) {
    var aFunction = __webpack_require__(
    /*! ../internals/a-function */
    "./node_modules/core-js/internals/a-function.js"); // optional / simple context binding


    module.exports = function (fn, that, length) {
      aFunction(fn);
      if (that === undefined) return fn;

      switch (length) {
        case 0:
          return function () {
            return fn.call(that);
          };

        case 1:
          return function (a) {
            return fn.call(that, a);
          };

        case 2:
          return function (a, b) {
            return fn.call(that, a, b);
          };

        case 3:
          return function (a, b, c) {
            return fn.call(that, a, b, c);
          };
      }

      return function ()
      /* ...args */
      {
        return fn.apply(that, arguments);
      };
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/function-bind.js":
  /*!*********************************************************!*\
    !*** ./node_modules/core-js/internals/function-bind.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsFunctionBindJs(module, exports, __webpack_require__) {
    "use strict";

    var aFunction = __webpack_require__(
    /*! ../internals/a-function */
    "./node_modules/core-js/internals/a-function.js");

    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    var slice = [].slice;
    var factories = {};

    var construct = function construct(C, argsLength, args) {
      if (!(argsLength in factories)) {
        for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']'; // eslint-disable-next-line no-new-func


        factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
      }

      return factories[argsLength](C, args);
    }; // `Function.prototype.bind` method implementation
    // https://tc39.github.io/ecma262/#sec-function.prototype.bind


    module.exports = Function.bind || function bind(that
    /* , ...args */
    ) {
      var fn = aFunction(this);
      var partArgs = slice.call(arguments, 1);

      var boundFunction = function bound()
      /* args... */
      {
        var args = partArgs.concat(slice.call(arguments));
        return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
      };

      if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
      return boundFunction;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/get-built-in.js":
  /*!********************************************************!*\
    !*** ./node_modules/core-js/internals/get-built-in.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsGetBuiltInJs(module, exports, __webpack_require__) {
    var path = __webpack_require__(
    /*! ../internals/path */
    "./node_modules/core-js/internals/path.js");

    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    var aFunction = function aFunction(variable) {
      return typeof variable == 'function' ? variable : undefined;
    };

    module.exports = function (namespace, method) {
      return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace]) : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/get-iterator-method.js":
  /*!***************************************************************!*\
    !*** ./node_modules/core-js/internals/get-iterator-method.js ***!
    \***************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsGetIteratorMethodJs(module, exports, __webpack_require__) {
    var classof = __webpack_require__(
    /*! ../internals/classof */
    "./node_modules/core-js/internals/classof.js");

    var Iterators = __webpack_require__(
    /*! ../internals/iterators */
    "./node_modules/core-js/internals/iterators.js");

    var wellKnownSymbol = __webpack_require__(
    /*! ../internals/well-known-symbol */
    "./node_modules/core-js/internals/well-known-symbol.js");

    var ITERATOR = wellKnownSymbol('iterator');

    module.exports = function (it) {
      if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/global.js":
  /*!**************************************************!*\
    !*** ./node_modules/core-js/internals/global.js ***!
    \**************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsGlobalJs(module, exports) {
    var check = function check(it) {
      return it && it.Math == Math && it;
    }; // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028


    module.exports = // eslint-disable-next-line no-undef
    check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || check(typeof self == 'object' && self) || check(typeof global == 'object' && global) || // eslint-disable-next-line no-new-func
    Function('return this')();
    /***/
  },

  /***/
  "./node_modules/core-js/internals/has.js":
  /*!***********************************************!*\
    !*** ./node_modules/core-js/internals/has.js ***!
    \***********************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsHasJs(module, exports) {
    var hasOwnProperty = {}.hasOwnProperty;

    module.exports = function (it, key) {
      return hasOwnProperty.call(it, key);
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/hidden-keys.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/internals/hidden-keys.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsHiddenKeysJs(module, exports) {
    module.exports = {};
    /***/
  },

  /***/
  "./node_modules/core-js/internals/host-report-errors.js":
  /*!**************************************************************!*\
    !*** ./node_modules/core-js/internals/host-report-errors.js ***!
    \**************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsHostReportErrorsJs(module, exports, __webpack_require__) {
    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    module.exports = function (a, b) {
      var console = global.console;

      if (console && console.error) {
        arguments.length === 1 ? console.error(a) : console.error(a, b);
      }
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/html.js":
  /*!************************************************!*\
    !*** ./node_modules/core-js/internals/html.js ***!
    \************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsHtmlJs(module, exports, __webpack_require__) {
    var getBuiltIn = __webpack_require__(
    /*! ../internals/get-built-in */
    "./node_modules/core-js/internals/get-built-in.js");

    module.exports = getBuiltIn('document', 'documentElement');
    /***/
  },

  /***/
  "./node_modules/core-js/internals/ie8-dom-define.js":
  /*!**********************************************************!*\
    !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!
    \**********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsIe8DomDefineJs(module, exports, __webpack_require__) {
    var DESCRIPTORS = __webpack_require__(
    /*! ../internals/descriptors */
    "./node_modules/core-js/internals/descriptors.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var createElement = __webpack_require__(
    /*! ../internals/document-create-element */
    "./node_modules/core-js/internals/document-create-element.js"); // Thank's IE8 for his funny defineProperty


    module.exports = !DESCRIPTORS && !fails(function () {
      return Object.defineProperty(createElement('div'), 'a', {
        get: function get() {
          return 7;
        }
      }).a != 7;
    });
    /***/
  },

  /***/
  "./node_modules/core-js/internals/indexed-object.js":
  /*!**********************************************************!*\
    !*** ./node_modules/core-js/internals/indexed-object.js ***!
    \**********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsIndexedObjectJs(module, exports, __webpack_require__) {
    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var classof = __webpack_require__(
    /*! ../internals/classof-raw */
    "./node_modules/core-js/internals/classof-raw.js");

    var split = ''.split; // fallback for non-array-like ES3 and non-enumerable old V8 strings

    module.exports = fails(function () {
      // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
      // eslint-disable-next-line no-prototype-builtins
      return !Object('z').propertyIsEnumerable(0);
    }) ? function (it) {
      return classof(it) == 'String' ? split.call(it, '') : Object(it);
    } : Object;
    /***/
  },

  /***/
  "./node_modules/core-js/internals/inherit-if-required.js":
  /*!***************************************************************!*\
    !*** ./node_modules/core-js/internals/inherit-if-required.js ***!
    \***************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsInheritIfRequiredJs(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    var setPrototypeOf = __webpack_require__(
    /*! ../internals/object-set-prototype-of */
    "./node_modules/core-js/internals/object-set-prototype-of.js"); // makes subclassing work correct for wrapped built-ins


    module.exports = function ($this, dummy, Wrapper) {
      var NewTarget, NewTargetPrototype;
      if ( // it can work only with native `setPrototypeOf`
      setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
      typeof (NewTarget = dummy.constructor) == 'function' && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) setPrototypeOf($this, NewTargetPrototype);
      return $this;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/inspect-source.js":
  /*!**********************************************************!*\
    !*** ./node_modules/core-js/internals/inspect-source.js ***!
    \**********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsInspectSourceJs(module, exports, __webpack_require__) {
    var store = __webpack_require__(
    /*! ../internals/shared-store */
    "./node_modules/core-js/internals/shared-store.js");

    var functionToString = Function.toString; // this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper

    if (typeof store.inspectSource != 'function') {
      store.inspectSource = function (it) {
        return functionToString.call(it);
      };
    }

    module.exports = store.inspectSource;
    /***/
  },

  /***/
  "./node_modules/core-js/internals/internal-metadata.js":
  /*!*************************************************************!*\
    !*** ./node_modules/core-js/internals/internal-metadata.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsInternalMetadataJs(module, exports, __webpack_require__) {
    var hiddenKeys = __webpack_require__(
    /*! ../internals/hidden-keys */
    "./node_modules/core-js/internals/hidden-keys.js");

    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    var has = __webpack_require__(
    /*! ../internals/has */
    "./node_modules/core-js/internals/has.js");

    var defineProperty = __webpack_require__(
    /*! ../internals/object-define-property */
    "./node_modules/core-js/internals/object-define-property.js").f;

    var uid = __webpack_require__(
    /*! ../internals/uid */
    "./node_modules/core-js/internals/uid.js");

    var FREEZING = __webpack_require__(
    /*! ../internals/freezing */
    "./node_modules/core-js/internals/freezing.js");

    var METADATA = uid('meta');
    var id = 0;

    var isExtensible = Object.isExtensible || function () {
      return true;
    };

    var setMetadata = function setMetadata(it) {
      defineProperty(it, METADATA, {
        value: {
          objectID: 'O' + ++id,
          // object ID
          weakData: {} // weak collections IDs

        }
      });
    };

    var fastKey = function fastKey(it, create) {
      // return a primitive with prefix
      if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

      if (!has(it, METADATA)) {
        // can't set metadata to uncaught frozen object
        if (!isExtensible(it)) return 'F'; // not necessary to add metadata

        if (!create) return 'E'; // add missing metadata

        setMetadata(it); // return object ID
      }

      return it[METADATA].objectID;
    };

    var getWeakData = function getWeakData(it, create) {
      if (!has(it, METADATA)) {
        // can't set metadata to uncaught frozen object
        if (!isExtensible(it)) return true; // not necessary to add metadata

        if (!create) return false; // add missing metadata

        setMetadata(it); // return the store of weak collections IDs
      }

      return it[METADATA].weakData;
    }; // add metadata on freeze-family methods calling


    var onFreeze = function onFreeze(it) {
      if (FREEZING && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
      return it;
    };

    var meta = module.exports = {
      REQUIRED: false,
      fastKey: fastKey,
      getWeakData: getWeakData,
      onFreeze: onFreeze
    };
    hiddenKeys[METADATA] = true;
    /***/
  },

  /***/
  "./node_modules/core-js/internals/internal-state.js":
  /*!**********************************************************!*\
    !*** ./node_modules/core-js/internals/internal-state.js ***!
    \**********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsInternalStateJs(module, exports, __webpack_require__) {
    var NATIVE_WEAK_MAP = __webpack_require__(
    /*! ../internals/native-weak-map */
    "./node_modules/core-js/internals/native-weak-map.js");

    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    var createNonEnumerableProperty = __webpack_require__(
    /*! ../internals/create-non-enumerable-property */
    "./node_modules/core-js/internals/create-non-enumerable-property.js");

    var objectHas = __webpack_require__(
    /*! ../internals/has */
    "./node_modules/core-js/internals/has.js");

    var sharedKey = __webpack_require__(
    /*! ../internals/shared-key */
    "./node_modules/core-js/internals/shared-key.js");

    var hiddenKeys = __webpack_require__(
    /*! ../internals/hidden-keys */
    "./node_modules/core-js/internals/hidden-keys.js");

    var WeakMap = global.WeakMap;
    var set, get, has;

    var enforce = function enforce(it) {
      return has(it) ? get(it) : set(it, {});
    };

    var getterFor = function getterFor(TYPE) {
      return function (it) {
        var state;

        if (!isObject(it) || (state = get(it)).type !== TYPE) {
          throw TypeError('Incompatible receiver, ' + TYPE + ' required');
        }

        return state;
      };
    };

    if (NATIVE_WEAK_MAP) {
      var store = new WeakMap();
      var wmget = store.get;
      var wmhas = store.has;
      var wmset = store.set;

      set = function set(it, metadata) {
        wmset.call(store, it, metadata);
        return metadata;
      };

      get = function get(it) {
        return wmget.call(store, it) || {};
      };

      has = function has(it) {
        return wmhas.call(store, it);
      };
    } else {
      var STATE = sharedKey('state');
      hiddenKeys[STATE] = true;

      set = function set(it, metadata) {
        createNonEnumerableProperty(it, STATE, metadata);
        return metadata;
      };

      get = function get(it) {
        return objectHas(it, STATE) ? it[STATE] : {};
      };

      has = function has(it) {
        return objectHas(it, STATE);
      };
    }

    module.exports = {
      set: set,
      get: get,
      has: has,
      enforce: enforce,
      getterFor: getterFor
    };
    /***/
  },

  /***/
  "./node_modules/core-js/internals/is-array-iterator-method.js":
  /*!********************************************************************!*\
    !*** ./node_modules/core-js/internals/is-array-iterator-method.js ***!
    \********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsIsArrayIteratorMethodJs(module, exports, __webpack_require__) {
    var wellKnownSymbol = __webpack_require__(
    /*! ../internals/well-known-symbol */
    "./node_modules/core-js/internals/well-known-symbol.js");

    var Iterators = __webpack_require__(
    /*! ../internals/iterators */
    "./node_modules/core-js/internals/iterators.js");

    var ITERATOR = wellKnownSymbol('iterator');
    var ArrayPrototype = Array.prototype; // check on default Array iterator

    module.exports = function (it) {
      return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/is-array.js":
  /*!****************************************************!*\
    !*** ./node_modules/core-js/internals/is-array.js ***!
    \****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsIsArrayJs(module, exports, __webpack_require__) {
    var classof = __webpack_require__(
    /*! ../internals/classof-raw */
    "./node_modules/core-js/internals/classof-raw.js"); // `IsArray` abstract operation
    // https://tc39.github.io/ecma262/#sec-isarray


    module.exports = Array.isArray || function isArray(arg) {
      return classof(arg) == 'Array';
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/is-forced.js":
  /*!*****************************************************!*\
    !*** ./node_modules/core-js/internals/is-forced.js ***!
    \*****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsIsForcedJs(module, exports, __webpack_require__) {
    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var replacement = /#|\.prototype\./;

    var isForced = function isForced(feature, detection) {
      var value = data[normalize(feature)];
      return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection;
    };

    var normalize = isForced.normalize = function (string) {
      return String(string).replace(replacement, '.').toLowerCase();
    };

    var data = isForced.data = {};
    var NATIVE = isForced.NATIVE = 'N';
    var POLYFILL = isForced.POLYFILL = 'P';
    module.exports = isForced;
    /***/
  },

  /***/
  "./node_modules/core-js/internals/is-integer.js":
  /*!******************************************************!*\
    !*** ./node_modules/core-js/internals/is-integer.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsIsIntegerJs(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    var floor = Math.floor; // `Number.isInteger` method implementation
    // https://tc39.github.io/ecma262/#sec-number.isinteger

    module.exports = function isInteger(it) {
      return !isObject(it) && isFinite(it) && floor(it) === it;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/is-object.js":
  /*!*****************************************************!*\
    !*** ./node_modules/core-js/internals/is-object.js ***!
    \*****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsIsObjectJs(module, exports) {
    module.exports = function (it) {
      return typeof it === 'object' ? it !== null : typeof it === 'function';
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/is-pure.js":
  /*!***************************************************!*\
    !*** ./node_modules/core-js/internals/is-pure.js ***!
    \***************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsIsPureJs(module, exports) {
    module.exports = false;
    /***/
  },

  /***/
  "./node_modules/core-js/internals/is-regexp.js":
  /*!*****************************************************!*\
    !*** ./node_modules/core-js/internals/is-regexp.js ***!
    \*****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsIsRegexpJs(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    var classof = __webpack_require__(
    /*! ../internals/classof-raw */
    "./node_modules/core-js/internals/classof-raw.js");

    var wellKnownSymbol = __webpack_require__(
    /*! ../internals/well-known-symbol */
    "./node_modules/core-js/internals/well-known-symbol.js");

    var MATCH = wellKnownSymbol('match'); // `IsRegExp` abstract operation
    // https://tc39.github.io/ecma262/#sec-isregexp

    module.exports = function (it) {
      var isRegExp;
      return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/iterate.js":
  /*!***************************************************!*\
    !*** ./node_modules/core-js/internals/iterate.js ***!
    \***************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsIterateJs(module, exports, __webpack_require__) {
    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var isArrayIteratorMethod = __webpack_require__(
    /*! ../internals/is-array-iterator-method */
    "./node_modules/core-js/internals/is-array-iterator-method.js");

    var toLength = __webpack_require__(
    /*! ../internals/to-length */
    "./node_modules/core-js/internals/to-length.js");

    var bind = __webpack_require__(
    /*! ../internals/function-bind-context */
    "./node_modules/core-js/internals/function-bind-context.js");

    var getIteratorMethod = __webpack_require__(
    /*! ../internals/get-iterator-method */
    "./node_modules/core-js/internals/get-iterator-method.js");

    var callWithSafeIterationClosing = __webpack_require__(
    /*! ../internals/call-with-safe-iteration-closing */
    "./node_modules/core-js/internals/call-with-safe-iteration-closing.js");

    var Result = function Result(stopped, result) {
      this.stopped = stopped;
      this.result = result;
    };

    var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
      var boundFunction = bind(fn, that, AS_ENTRIES ? 2 : 1);
      var iterator, iterFn, index, length, result, next, step;

      if (IS_ITERATOR) {
        iterator = iterable;
      } else {
        iterFn = getIteratorMethod(iterable);
        if (typeof iterFn != 'function') throw TypeError('Target is not iterable'); // optimisation for array iterators

        if (isArrayIteratorMethod(iterFn)) {
          for (index = 0, length = toLength(iterable.length); length > index; index++) {
            result = AS_ENTRIES ? boundFunction(anObject(step = iterable[index])[0], step[1]) : boundFunction(iterable[index]);
            if (result && result instanceof Result) return result;
          }

          return new Result(false);
        }

        iterator = iterFn.call(iterable);
      }

      next = iterator.next;

      while (!(step = next.call(iterator)).done) {
        result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
        if (typeof result == 'object' && result && result instanceof Result) return result;
      }

      return new Result(false);
    };

    iterate.stop = function (result) {
      return new Result(true, result);
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/iterators-core.js":
  /*!**********************************************************!*\
    !*** ./node_modules/core-js/internals/iterators-core.js ***!
    \**********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsIteratorsCoreJs(module, exports, __webpack_require__) {
    "use strict";

    var getPrototypeOf = __webpack_require__(
    /*! ../internals/object-get-prototype-of */
    "./node_modules/core-js/internals/object-get-prototype-of.js");

    var createNonEnumerableProperty = __webpack_require__(
    /*! ../internals/create-non-enumerable-property */
    "./node_modules/core-js/internals/create-non-enumerable-property.js");

    var has = __webpack_require__(
    /*! ../internals/has */
    "./node_modules/core-js/internals/has.js");

    var wellKnownSymbol = __webpack_require__(
    /*! ../internals/well-known-symbol */
    "./node_modules/core-js/internals/well-known-symbol.js");

    var IS_PURE = __webpack_require__(
    /*! ../internals/is-pure */
    "./node_modules/core-js/internals/is-pure.js");

    var ITERATOR = wellKnownSymbol('iterator');
    var BUGGY_SAFARI_ITERATORS = false;

    var returnThis = function returnThis() {
      return this;
    }; // `%IteratorPrototype%` object
    // https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object


    var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

    if ([].keys) {
      arrayIterator = [].keys(); // Safari 8 has buggy iterators w/o `next`

      if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;else {
        PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
        if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
      }
    }

    if (IteratorPrototype == undefined) IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

    if (!IS_PURE && !has(IteratorPrototype, ITERATOR)) {
      createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
    }

    module.exports = {
      IteratorPrototype: IteratorPrototype,
      BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
    };
    /***/
  },

  /***/
  "./node_modules/core-js/internals/iterators.js":
  /*!*****************************************************!*\
    !*** ./node_modules/core-js/internals/iterators.js ***!
    \*****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsIteratorsJs(module, exports) {
    module.exports = {};
    /***/
  },

  /***/
  "./node_modules/core-js/internals/math-expm1.js":
  /*!******************************************************!*\
    !*** ./node_modules/core-js/internals/math-expm1.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsMathExpm1Js(module, exports) {
    var nativeExpm1 = Math.expm1;
    var exp = Math.exp; // `Math.expm1` method implementation
    // https://tc39.github.io/ecma262/#sec-math.expm1

    module.exports = !nativeExpm1 // Old FF bug
    || nativeExpm1(10) > 22025.465794806719 || nativeExpm1(10) < 22025.4657948067165168 // Tor Browser bug
    || nativeExpm1(-2e-17) != -2e-17 ? function expm1(x) {
      return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;
    } : nativeExpm1;
    /***/
  },

  /***/
  "./node_modules/core-js/internals/math-fround.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/internals/math-fround.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsMathFroundJs(module, exports, __webpack_require__) {
    var sign = __webpack_require__(
    /*! ../internals/math-sign */
    "./node_modules/core-js/internals/math-sign.js");

    var abs = Math.abs;
    var pow = Math.pow;
    var EPSILON = pow(2, -52);
    var EPSILON32 = pow(2, -23);
    var MAX32 = pow(2, 127) * (2 - EPSILON32);
    var MIN32 = pow(2, -126);

    var roundTiesToEven = function roundTiesToEven(n) {
      return n + 1 / EPSILON - 1 / EPSILON;
    }; // `Math.fround` method implementation
    // https://tc39.github.io/ecma262/#sec-math.fround


    module.exports = Math.fround || function fround(x) {
      var $abs = abs(x);
      var $sign = sign(x);
      var a, result;
      if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
      a = (1 + EPSILON32 / EPSILON) * $abs;
      result = a - (a - $abs); // eslint-disable-next-line no-self-compare

      if (result > MAX32 || result != result) return $sign * Infinity;
      return $sign * result;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/math-log1p.js":
  /*!******************************************************!*\
    !*** ./node_modules/core-js/internals/math-log1p.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsMathLog1pJs(module, exports) {
    var log = Math.log; // `Math.log1p` method implementation
    // https://tc39.github.io/ecma262/#sec-math.log1p

    module.exports = Math.log1p || function log1p(x) {
      return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log(1 + x);
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/math-sign.js":
  /*!*****************************************************!*\
    !*** ./node_modules/core-js/internals/math-sign.js ***!
    \*****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsMathSignJs(module, exports) {
    // `Math.sign` method implementation
    // https://tc39.github.io/ecma262/#sec-math.sign
    module.exports = Math.sign || function sign(x) {
      // eslint-disable-next-line no-self-compare
      return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/microtask.js":
  /*!*****************************************************!*\
    !*** ./node_modules/core-js/internals/microtask.js ***!
    \*****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsMicrotaskJs(module, exports, __webpack_require__) {
    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    var getOwnPropertyDescriptor = __webpack_require__(
    /*! ../internals/object-get-own-property-descriptor */
    "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;

    var classof = __webpack_require__(
    /*! ../internals/classof-raw */
    "./node_modules/core-js/internals/classof-raw.js");

    var macrotask = __webpack_require__(
    /*! ../internals/task */
    "./node_modules/core-js/internals/task.js").set;

    var IS_IOS = __webpack_require__(
    /*! ../internals/engine-is-ios */
    "./node_modules/core-js/internals/engine-is-ios.js");

    var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
    var process = global.process;
    var Promise = global.Promise;
    var IS_NODE = classof(process) == 'process'; // Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`

    var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');
    var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
    var flush, head, last, notify, toggle, node, promise, then; // modern engines have queueMicrotask method

    if (!queueMicrotask) {
      flush = function flush() {
        var parent, fn;
        if (IS_NODE && (parent = process.domain)) parent.exit();

        while (head) {
          fn = head.fn;
          head = head.next;

          try {
            fn();
          } catch (error) {
            if (head) notify();else last = undefined;
            throw error;
          }
        }

        last = undefined;
        if (parent) parent.enter();
      }; // Node.js


      if (IS_NODE) {
        notify = function notify() {
          process.nextTick(flush);
        }; // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339

      } else if (MutationObserver && !IS_IOS) {
        toggle = true;
        node = document.createTextNode('');
        new MutationObserver(flush).observe(node, {
          characterData: true
        });

        notify = function notify() {
          node.data = toggle = !toggle;
        }; // environments with maybe non-completely correct, but existent Promise

      } else if (Promise && Promise.resolve) {
        // Promise.resolve without an argument throws an error in LG WebOS 2
        promise = Promise.resolve(undefined);
        then = promise.then;

        notify = function notify() {
          then.call(promise, flush);
        }; // for other environments - macrotask based on:
        // - setImmediate
        // - MessageChannel
        // - window.postMessag
        // - onreadystatechange
        // - setTimeout

      } else {
        notify = function notify() {
          // strange IE + webpack dev server bug - use .call(global)
          macrotask.call(global, flush);
        };
      }
    }

    module.exports = queueMicrotask || function (fn) {
      var task = {
        fn: fn,
        next: undefined
      };
      if (last) last.next = task;

      if (!head) {
        head = task;
        notify();
      }

      last = task;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/native-promise-constructor.js":
  /*!**********************************************************************!*\
    !*** ./node_modules/core-js/internals/native-promise-constructor.js ***!
    \**********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsNativePromiseConstructorJs(module, exports, __webpack_require__) {
    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    module.exports = global.Promise;
    /***/
  },

  /***/
  "./node_modules/core-js/internals/native-symbol.js":
  /*!*********************************************************!*\
    !*** ./node_modules/core-js/internals/native-symbol.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsNativeSymbolJs(module, exports, __webpack_require__) {
    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
      // Chrome 38 Symbol has incorrect toString conversion
      // eslint-disable-next-line no-undef
      return !String(Symbol());
    });
    /***/
  },

  /***/
  "./node_modules/core-js/internals/native-weak-map.js":
  /*!***********************************************************!*\
    !*** ./node_modules/core-js/internals/native-weak-map.js ***!
    \***********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsNativeWeakMapJs(module, exports, __webpack_require__) {
    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    var inspectSource = __webpack_require__(
    /*! ../internals/inspect-source */
    "./node_modules/core-js/internals/inspect-source.js");

    var WeakMap = global.WeakMap;
    module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));
    /***/
  },

  /***/
  "./node_modules/core-js/internals/new-promise-capability.js":
  /*!******************************************************************!*\
    !*** ./node_modules/core-js/internals/new-promise-capability.js ***!
    \******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsNewPromiseCapabilityJs(module, exports, __webpack_require__) {
    "use strict";

    var aFunction = __webpack_require__(
    /*! ../internals/a-function */
    "./node_modules/core-js/internals/a-function.js");

    var PromiseCapability = function PromiseCapability(C) {
      var resolve, reject;
      this.promise = new C(function ($$resolve, $$reject) {
        if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
        resolve = $$resolve;
        reject = $$reject;
      });
      this.resolve = aFunction(resolve);
      this.reject = aFunction(reject);
    }; // 25.4.1.5 NewPromiseCapability(C)


    module.exports.f = function (C) {
      return new PromiseCapability(C);
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/not-a-regexp.js":
  /*!********************************************************!*\
    !*** ./node_modules/core-js/internals/not-a-regexp.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsNotARegexpJs(module, exports, __webpack_require__) {
    var isRegExp = __webpack_require__(
    /*! ../internals/is-regexp */
    "./node_modules/core-js/internals/is-regexp.js");

    module.exports = function (it) {
      if (isRegExp(it)) {
        throw TypeError("The method doesn't accept regular expressions");
      }

      return it;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/number-is-finite.js":
  /*!************************************************************!*\
    !*** ./node_modules/core-js/internals/number-is-finite.js ***!
    \************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsNumberIsFiniteJs(module, exports, __webpack_require__) {
    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    var globalIsFinite = global.isFinite; // `Number.isFinite` method
    // https://tc39.github.io/ecma262/#sec-number.isfinite

    module.exports = Number.isFinite || function isFinite(it) {
      return typeof it == 'number' && globalIsFinite(it);
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/number-parse-float.js":
  /*!**************************************************************!*\
    !*** ./node_modules/core-js/internals/number-parse-float.js ***!
    \**************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsNumberParseFloatJs(module, exports, __webpack_require__) {
    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    var trim = __webpack_require__(
    /*! ../internals/string-trim */
    "./node_modules/core-js/internals/string-trim.js").trim;

    var whitespaces = __webpack_require__(
    /*! ../internals/whitespaces */
    "./node_modules/core-js/internals/whitespaces.js");

    var $parseFloat = global.parseFloat;
    var FORCED = 1 / $parseFloat(whitespaces + '-0') !== -Infinity; // `parseFloat` method
    // https://tc39.github.io/ecma262/#sec-parsefloat-string

    module.exports = FORCED ? function parseFloat(string) {
      var trimmedString = trim(String(string));
      var result = $parseFloat(trimmedString);
      return result === 0 && trimmedString.charAt(0) == '-' ? -0 : result;
    } : $parseFloat;
    /***/
  },

  /***/
  "./node_modules/core-js/internals/number-parse-int.js":
  /*!************************************************************!*\
    !*** ./node_modules/core-js/internals/number-parse-int.js ***!
    \************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsNumberParseIntJs(module, exports, __webpack_require__) {
    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    var trim = __webpack_require__(
    /*! ../internals/string-trim */
    "./node_modules/core-js/internals/string-trim.js").trim;

    var whitespaces = __webpack_require__(
    /*! ../internals/whitespaces */
    "./node_modules/core-js/internals/whitespaces.js");

    var $parseInt = global.parseInt;
    var hex = /^[+-]?0[Xx]/;
    var FORCED = $parseInt(whitespaces + '08') !== 8 || $parseInt(whitespaces + '0x16') !== 22; // `parseInt` method
    // https://tc39.github.io/ecma262/#sec-parseint-string-radix

    module.exports = FORCED ? function parseInt(string, radix) {
      var S = trim(String(string));
      return $parseInt(S, radix >>> 0 || (hex.test(S) ? 16 : 10));
    } : $parseInt;
    /***/
  },

  /***/
  "./node_modules/core-js/internals/object-assign.js":
  /*!*********************************************************!*\
    !*** ./node_modules/core-js/internals/object-assign.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsObjectAssignJs(module, exports, __webpack_require__) {
    "use strict";

    var DESCRIPTORS = __webpack_require__(
    /*! ../internals/descriptors */
    "./node_modules/core-js/internals/descriptors.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var objectKeys = __webpack_require__(
    /*! ../internals/object-keys */
    "./node_modules/core-js/internals/object-keys.js");

    var getOwnPropertySymbolsModule = __webpack_require__(
    /*! ../internals/object-get-own-property-symbols */
    "./node_modules/core-js/internals/object-get-own-property-symbols.js");

    var propertyIsEnumerableModule = __webpack_require__(
    /*! ../internals/object-property-is-enumerable */
    "./node_modules/core-js/internals/object-property-is-enumerable.js");

    var toObject = __webpack_require__(
    /*! ../internals/to-object */
    "./node_modules/core-js/internals/to-object.js");

    var IndexedObject = __webpack_require__(
    /*! ../internals/indexed-object */
    "./node_modules/core-js/internals/indexed-object.js");

    var nativeAssign = Object.assign;
    var defineProperty = Object.defineProperty; // `Object.assign` method
    // https://tc39.github.io/ecma262/#sec-object.assign

    module.exports = !nativeAssign || fails(function () {
      // should have correct order of operations (Edge bug)
      if (DESCRIPTORS && nativeAssign({
        b: 1
      }, nativeAssign(defineProperty({}, 'a', {
        enumerable: true,
        get: function get() {
          defineProperty(this, 'b', {
            value: 3,
            enumerable: false
          });
        }
      }), {
        b: 2
      })).b !== 1) return true; // should work with symbols and should have deterministic property order (V8 bug)

      var A = {};
      var B = {}; // eslint-disable-next-line no-undef

      var symbol = Symbol();
      var alphabet = 'abcdefghijklmnopqrst';
      A[symbol] = 7;
      alphabet.split('').forEach(function (chr) {
        B[chr] = chr;
      });
      return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
    }) ? function assign(target, source) {
      // eslint-disable-line no-unused-vars
      var T = toObject(target);
      var argumentsLength = arguments.length;
      var index = 1;
      var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
      var propertyIsEnumerable = propertyIsEnumerableModule.f;

      while (argumentsLength > index) {
        var S = IndexedObject(arguments[index++]);
        var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
        var length = keys.length;
        var j = 0;
        var key;

        while (length > j) {
          key = keys[j++];
          if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];
        }
      }

      return T;
    } : nativeAssign;
    /***/
  },

  /***/
  "./node_modules/core-js/internals/object-create.js":
  /*!*********************************************************!*\
    !*** ./node_modules/core-js/internals/object-create.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsObjectCreateJs(module, exports, __webpack_require__) {
    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var defineProperties = __webpack_require__(
    /*! ../internals/object-define-properties */
    "./node_modules/core-js/internals/object-define-properties.js");

    var enumBugKeys = __webpack_require__(
    /*! ../internals/enum-bug-keys */
    "./node_modules/core-js/internals/enum-bug-keys.js");

    var hiddenKeys = __webpack_require__(
    /*! ../internals/hidden-keys */
    "./node_modules/core-js/internals/hidden-keys.js");

    var html = __webpack_require__(
    /*! ../internals/html */
    "./node_modules/core-js/internals/html.js");

    var documentCreateElement = __webpack_require__(
    /*! ../internals/document-create-element */
    "./node_modules/core-js/internals/document-create-element.js");

    var sharedKey = __webpack_require__(
    /*! ../internals/shared-key */
    "./node_modules/core-js/internals/shared-key.js");

    var GT = '>';
    var LT = '<';
    var PROTOTYPE = 'prototype';
    var SCRIPT = 'script';
    var IE_PROTO = sharedKey('IE_PROTO');

    var EmptyConstructor = function EmptyConstructor() {
      /* empty */
    };

    var scriptTag = function scriptTag(content) {
      return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
    }; // Create object with fake `null` prototype: use ActiveX Object with cleared prototype


    var NullProtoObjectViaActiveX = function NullProtoObjectViaActiveX(activeXDocument) {
      activeXDocument.write(scriptTag(''));
      activeXDocument.close();
      var temp = activeXDocument.parentWindow.Object;
      activeXDocument = null; // avoid memory leak

      return temp;
    }; // Create object with fake `null` prototype: use iframe Object with cleared prototype


    var NullProtoObjectViaIFrame = function NullProtoObjectViaIFrame() {
      // Thrash, waste and sodomy: IE GC bug
      var iframe = documentCreateElement('iframe');
      var JS = 'java' + SCRIPT + ':';
      var iframeDocument;
      iframe.style.display = 'none';
      html.appendChild(iframe); // https://github.com/zloirock/core-js/issues/475

      iframe.src = String(JS);
      iframeDocument = iframe.contentWindow.document;
      iframeDocument.open();
      iframeDocument.write(scriptTag('document.F=Object'));
      iframeDocument.close();
      return iframeDocument.F;
    }; // Check for document.domain and active x support
    // No need to use active x approach when document.domain is not set
    // see https://github.com/es-shims/es5-shim/issues/150
    // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
    // avoid IE GC bug


    var activeXDocument;

    var _NullProtoObject = function NullProtoObject() {
      try {
        /* global ActiveXObject */
        activeXDocument = document.domain && new ActiveXObject('htmlfile');
      } catch (error) {
        /* ignore */
      }

      _NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
      var length = enumBugKeys.length;

      while (length--) delete _NullProtoObject[PROTOTYPE][enumBugKeys[length]];

      return _NullProtoObject();
    };

    hiddenKeys[IE_PROTO] = true; // `Object.create` method
    // https://tc39.github.io/ecma262/#sec-object.create

    module.exports = Object.create || function create(O, Properties) {
      var result;

      if (O !== null) {
        EmptyConstructor[PROTOTYPE] = anObject(O);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

        result[IE_PROTO] = O;
      } else result = _NullProtoObject();

      return Properties === undefined ? result : defineProperties(result, Properties);
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/object-define-properties.js":
  /*!********************************************************************!*\
    !*** ./node_modules/core-js/internals/object-define-properties.js ***!
    \********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsObjectDefinePropertiesJs(module, exports, __webpack_require__) {
    var DESCRIPTORS = __webpack_require__(
    /*! ../internals/descriptors */
    "./node_modules/core-js/internals/descriptors.js");

    var definePropertyModule = __webpack_require__(
    /*! ../internals/object-define-property */
    "./node_modules/core-js/internals/object-define-property.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var objectKeys = __webpack_require__(
    /*! ../internals/object-keys */
    "./node_modules/core-js/internals/object-keys.js"); // `Object.defineProperties` method
    // https://tc39.github.io/ecma262/#sec-object.defineproperties


    module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
      anObject(O);
      var keys = objectKeys(Properties);
      var length = keys.length;
      var index = 0;
      var key;

      while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);

      return O;
    };
    /***/
  },

  /***/
  "./node_modules/core-js/internals/object-define-property.js":
  /*!******************************************************************!*\
    !*** ./node_modules/core-js/internals/object-define-property.js ***!
    \******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsObjectDefinePropertyJs(module, exports, __webpack_require__) {
    var DESCRIPTORS = __webpack_require__(
    /*! ../internals/descriptors */
    "./node_modules/core-js/internals/descriptors.js");

    var IE8_DOM_DEFINE = __webpack_require__(
    /*! ../internals/ie8-dom-define */
    "./node_modules/core-js/internals/ie8-dom-define.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var toPrimitive = __webpack_require__(
    /*! ../internals/to-primitive */
    "./node_modules/core-js/internals/to-primitive.js");

    var nativeDefineProperty = Object.defineProperty; // `Object.defineProperty` method
    // https://tc39.github.io/ecma262/#sec-object.defineproperty

    exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
      anObject(O);
      P = toPrimitive(P, true);
      anObject(Attributes);
      if (IE8_DOM_DEFINE) try {
        return nativeDefineProperty(O, P, Attributes);
      } catch (error) {
        /* empty */
      }
      if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
      if ('value' in Attributes) O[P] = Attributes.value;
      return O;
    };
    /***/
  },

  /***/
  "./node_modules/core-js/internals/object-get-own-property-descriptor.js":
  /*!******************************************************************************!*\
    !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!
    \******************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsObjectGetOwnPropertyDescriptorJs(module, exports, __webpack_require__) {
    var DESCRIPTORS = __webpack_require__(
    /*! ../internals/descriptors */
    "./node_modules/core-js/internals/descriptors.js");

    var propertyIsEnumerableModule = __webpack_require__(
    /*! ../internals/object-property-is-enumerable */
    "./node_modules/core-js/internals/object-property-is-enumerable.js");

    var createPropertyDescriptor = __webpack_require__(
    /*! ../internals/create-property-descriptor */
    "./node_modules/core-js/internals/create-property-descriptor.js");

    var toIndexedObject = __webpack_require__(
    /*! ../internals/to-indexed-object */
    "./node_modules/core-js/internals/to-indexed-object.js");

    var toPrimitive = __webpack_require__(
    /*! ../internals/to-primitive */
    "./node_modules/core-js/internals/to-primitive.js");

    var has = __webpack_require__(
    /*! ../internals/has */
    "./node_modules/core-js/internals/has.js");

    var IE8_DOM_DEFINE = __webpack_require__(
    /*! ../internals/ie8-dom-define */
    "./node_modules/core-js/internals/ie8-dom-define.js");

    var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // `Object.getOwnPropertyDescriptor` method
    // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor

    exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
      O = toIndexedObject(O);
      P = toPrimitive(P, true);
      if (IE8_DOM_DEFINE) try {
        return nativeGetOwnPropertyDescriptor(O, P);
      } catch (error) {
        /* empty */
      }
      if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
    };
    /***/
  },

  /***/
  "./node_modules/core-js/internals/object-get-own-property-names-external.js":
  /*!**********************************************************************************!*\
    !*** ./node_modules/core-js/internals/object-get-own-property-names-external.js ***!
    \**********************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsObjectGetOwnPropertyNamesExternalJs(module, exports, __webpack_require__) {
    var toIndexedObject = __webpack_require__(
    /*! ../internals/to-indexed-object */
    "./node_modules/core-js/internals/to-indexed-object.js");

    var nativeGetOwnPropertyNames = __webpack_require__(
    /*! ../internals/object-get-own-property-names */
    "./node_modules/core-js/internals/object-get-own-property-names.js").f;

    var toString = {}.toString;
    var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

    var getWindowNames = function getWindowNames(it) {
      try {
        return nativeGetOwnPropertyNames(it);
      } catch (error) {
        return windowNames.slice();
      }
    }; // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window


    module.exports.f = function getOwnPropertyNames(it) {
      return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : nativeGetOwnPropertyNames(toIndexedObject(it));
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/object-get-own-property-names.js":
  /*!*************************************************************************!*\
    !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!
    \*************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsObjectGetOwnPropertyNamesJs(module, exports, __webpack_require__) {
    var internalObjectKeys = __webpack_require__(
    /*! ../internals/object-keys-internal */
    "./node_modules/core-js/internals/object-keys-internal.js");

    var enumBugKeys = __webpack_require__(
    /*! ../internals/enum-bug-keys */
    "./node_modules/core-js/internals/enum-bug-keys.js");

    var hiddenKeys = enumBugKeys.concat('length', 'prototype'); // `Object.getOwnPropertyNames` method
    // https://tc39.github.io/ecma262/#sec-object.getownpropertynames

    exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
      return internalObjectKeys(O, hiddenKeys);
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/object-get-own-property-symbols.js":
  /*!***************************************************************************!*\
    !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!
    \***************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsObjectGetOwnPropertySymbolsJs(module, exports) {
    exports.f = Object.getOwnPropertySymbols;
    /***/
  },

  /***/
  "./node_modules/core-js/internals/object-get-prototype-of.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/core-js/internals/object-get-prototype-of.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsObjectGetPrototypeOfJs(module, exports, __webpack_require__) {
    var has = __webpack_require__(
    /*! ../internals/has */
    "./node_modules/core-js/internals/has.js");

    var toObject = __webpack_require__(
    /*! ../internals/to-object */
    "./node_modules/core-js/internals/to-object.js");

    var sharedKey = __webpack_require__(
    /*! ../internals/shared-key */
    "./node_modules/core-js/internals/shared-key.js");

    var CORRECT_PROTOTYPE_GETTER = __webpack_require__(
    /*! ../internals/correct-prototype-getter */
    "./node_modules/core-js/internals/correct-prototype-getter.js");

    var IE_PROTO = sharedKey('IE_PROTO');
    var ObjectPrototype = Object.prototype; // `Object.getPrototypeOf` method
    // https://tc39.github.io/ecma262/#sec-object.getprototypeof

    module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
      O = toObject(O);
      if (has(O, IE_PROTO)) return O[IE_PROTO];

      if (typeof O.constructor == 'function' && O instanceof O.constructor) {
        return O.constructor.prototype;
      }

      return O instanceof Object ? ObjectPrototype : null;
    };
    /***/
  },

  /***/
  "./node_modules/core-js/internals/object-keys-internal.js":
  /*!****************************************************************!*\
    !*** ./node_modules/core-js/internals/object-keys-internal.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsObjectKeysInternalJs(module, exports, __webpack_require__) {
    var has = __webpack_require__(
    /*! ../internals/has */
    "./node_modules/core-js/internals/has.js");

    var toIndexedObject = __webpack_require__(
    /*! ../internals/to-indexed-object */
    "./node_modules/core-js/internals/to-indexed-object.js");

    var indexOf = __webpack_require__(
    /*! ../internals/array-includes */
    "./node_modules/core-js/internals/array-includes.js").indexOf;

    var hiddenKeys = __webpack_require__(
    /*! ../internals/hidden-keys */
    "./node_modules/core-js/internals/hidden-keys.js");

    module.exports = function (object, names) {
      var O = toIndexedObject(object);
      var i = 0;
      var result = [];
      var key;

      for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key); // Don't enum bug & hidden keys


      while (names.length > i) if (has(O, key = names[i++])) {
        ~indexOf(result, key) || result.push(key);
      }

      return result;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/object-keys.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/internals/object-keys.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsObjectKeysJs(module, exports, __webpack_require__) {
    var internalObjectKeys = __webpack_require__(
    /*! ../internals/object-keys-internal */
    "./node_modules/core-js/internals/object-keys-internal.js");

    var enumBugKeys = __webpack_require__(
    /*! ../internals/enum-bug-keys */
    "./node_modules/core-js/internals/enum-bug-keys.js"); // `Object.keys` method
    // https://tc39.github.io/ecma262/#sec-object.keys


    module.exports = Object.keys || function keys(O) {
      return internalObjectKeys(O, enumBugKeys);
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/object-property-is-enumerable.js":
  /*!*************************************************************************!*\
    !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!
    \*************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsObjectPropertyIsEnumerableJs(module, exports, __webpack_require__) {
    "use strict";

    var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; // Nashorn ~ JDK8 bug

    var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({
      1: 2
    }, 1); // `Object.prototype.propertyIsEnumerable` method implementation
    // https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable

    exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
      var descriptor = getOwnPropertyDescriptor(this, V);
      return !!descriptor && descriptor.enumerable;
    } : nativePropertyIsEnumerable;
    /***/
  },

  /***/
  "./node_modules/core-js/internals/object-set-prototype-of.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/core-js/internals/object-set-prototype-of.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsObjectSetPrototypeOfJs(module, exports, __webpack_require__) {
    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var aPossiblePrototype = __webpack_require__(
    /*! ../internals/a-possible-prototype */
    "./node_modules/core-js/internals/a-possible-prototype.js"); // `Object.setPrototypeOf` method
    // https://tc39.github.io/ecma262/#sec-object.setprototypeof
    // Works with __proto__ only. Old v8 can't work with null proto objects.

    /* eslint-disable no-proto */


    module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
      var CORRECT_SETTER = false;
      var test = {};
      var setter;

      try {
        setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
        setter.call(test, []);
        CORRECT_SETTER = test instanceof Array;
      } catch (error) {
        /* empty */
      }

      return function setPrototypeOf(O, proto) {
        anObject(O);
        aPossiblePrototype(proto);
        if (CORRECT_SETTER) setter.call(O, proto);else O.__proto__ = proto;
        return O;
      };
    }() : undefined);
    /***/
  },

  /***/
  "./node_modules/core-js/internals/object-to-string.js":
  /*!************************************************************!*\
    !*** ./node_modules/core-js/internals/object-to-string.js ***!
    \************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsObjectToStringJs(module, exports, __webpack_require__) {
    "use strict";

    var TO_STRING_TAG_SUPPORT = __webpack_require__(
    /*! ../internals/to-string-tag-support */
    "./node_modules/core-js/internals/to-string-tag-support.js");

    var classof = __webpack_require__(
    /*! ../internals/classof */
    "./node_modules/core-js/internals/classof.js"); // `Object.prototype.toString` method implementation
    // https://tc39.github.io/ecma262/#sec-object.prototype.tostring


    module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
      return '[object ' + classof(this) + ']';
    };
    /***/
  },

  /***/
  "./node_modules/core-js/internals/own-keys.js":
  /*!****************************************************!*\
    !*** ./node_modules/core-js/internals/own-keys.js ***!
    \****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsOwnKeysJs(module, exports, __webpack_require__) {
    var getBuiltIn = __webpack_require__(
    /*! ../internals/get-built-in */
    "./node_modules/core-js/internals/get-built-in.js");

    var getOwnPropertyNamesModule = __webpack_require__(
    /*! ../internals/object-get-own-property-names */
    "./node_modules/core-js/internals/object-get-own-property-names.js");

    var getOwnPropertySymbolsModule = __webpack_require__(
    /*! ../internals/object-get-own-property-symbols */
    "./node_modules/core-js/internals/object-get-own-property-symbols.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js"); // all object keys, includes non-enumerable and symbols


    module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
      var keys = getOwnPropertyNamesModule.f(anObject(it));
      var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
      return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/path.js":
  /*!************************************************!*\
    !*** ./node_modules/core-js/internals/path.js ***!
    \************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsPathJs(module, exports, __webpack_require__) {
    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    module.exports = global;
    /***/
  },

  /***/
  "./node_modules/core-js/internals/perform.js":
  /*!***************************************************!*\
    !*** ./node_modules/core-js/internals/perform.js ***!
    \***************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsPerformJs(module, exports) {
    module.exports = function (exec) {
      try {
        return {
          error: false,
          value: exec()
        };
      } catch (error) {
        return {
          error: true,
          value: error
        };
      }
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/promise-resolve.js":
  /*!***********************************************************!*\
    !*** ./node_modules/core-js/internals/promise-resolve.js ***!
    \***********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsPromiseResolveJs(module, exports, __webpack_require__) {
    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    var newPromiseCapability = __webpack_require__(
    /*! ../internals/new-promise-capability */
    "./node_modules/core-js/internals/new-promise-capability.js");

    module.exports = function (C, x) {
      anObject(C);
      if (isObject(x) && x.constructor === C) return x;
      var promiseCapability = newPromiseCapability.f(C);
      var resolve = promiseCapability.resolve;
      resolve(x);
      return promiseCapability.promise;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/redefine-all.js":
  /*!********************************************************!*\
    !*** ./node_modules/core-js/internals/redefine-all.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsRedefineAllJs(module, exports, __webpack_require__) {
    var redefine = __webpack_require__(
    /*! ../internals/redefine */
    "./node_modules/core-js/internals/redefine.js");

    module.exports = function (target, src, options) {
      for (var key in src) redefine(target, key, src[key], options);

      return target;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/redefine.js":
  /*!****************************************************!*\
    !*** ./node_modules/core-js/internals/redefine.js ***!
    \****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsRedefineJs(module, exports, __webpack_require__) {
    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    var createNonEnumerableProperty = __webpack_require__(
    /*! ../internals/create-non-enumerable-property */
    "./node_modules/core-js/internals/create-non-enumerable-property.js");

    var has = __webpack_require__(
    /*! ../internals/has */
    "./node_modules/core-js/internals/has.js");

    var setGlobal = __webpack_require__(
    /*! ../internals/set-global */
    "./node_modules/core-js/internals/set-global.js");

    var inspectSource = __webpack_require__(
    /*! ../internals/inspect-source */
    "./node_modules/core-js/internals/inspect-source.js");

    var InternalStateModule = __webpack_require__(
    /*! ../internals/internal-state */
    "./node_modules/core-js/internals/internal-state.js");

    var getInternalState = InternalStateModule.get;
    var enforceInternalState = InternalStateModule.enforce;
    var TEMPLATE = String(String).split('String');
    (module.exports = function (O, key, value, options) {
      var unsafe = options ? !!options.unsafe : false;
      var simple = options ? !!options.enumerable : false;
      var noTargetGet = options ? !!options.noTargetGet : false;

      if (typeof value == 'function') {
        if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
        enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
      }

      if (O === global) {
        if (simple) O[key] = value;else setGlobal(key, value);
        return;
      } else if (!unsafe) {
        delete O[key];
      } else if (!noTargetGet && O[key]) {
        simple = true;
      }

      if (simple) O[key] = value;else createNonEnumerableProperty(O, key, value); // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
    })(Function.prototype, 'toString', function toString() {
      return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
    });
    /***/
  },

  /***/
  "./node_modules/core-js/internals/reflect-metadata.js":
  /*!************************************************************!*\
    !*** ./node_modules/core-js/internals/reflect-metadata.js ***!
    \************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsReflectMetadataJs(module, exports, __webpack_require__) {
    // TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
    var Map = __webpack_require__(
    /*! ../modules/es.map */
    "./node_modules/core-js/modules/es.map.js");

    var WeakMap = __webpack_require__(
    /*! ../modules/es.weak-map */
    "./node_modules/core-js/modules/es.weak-map.js");

    var shared = __webpack_require__(
    /*! ../internals/shared */
    "./node_modules/core-js/internals/shared.js");

    var metadata = shared('metadata');
    var store = metadata.store || (metadata.store = new WeakMap());

    var getOrCreateMetadataMap = function getOrCreateMetadataMap(target, targetKey, create) {
      var targetMetadata = store.get(target);

      if (!targetMetadata) {
        if (!create) return;
        store.set(target, targetMetadata = new Map());
      }

      var keyMetadata = targetMetadata.get(targetKey);

      if (!keyMetadata) {
        if (!create) return;
        targetMetadata.set(targetKey, keyMetadata = new Map());
      }

      return keyMetadata;
    };

    var ordinaryHasOwnMetadata = function ordinaryHasOwnMetadata(MetadataKey, O, P) {
      var metadataMap = getOrCreateMetadataMap(O, P, false);
      return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
    };

    var ordinaryGetOwnMetadata = function ordinaryGetOwnMetadata(MetadataKey, O, P) {
      var metadataMap = getOrCreateMetadataMap(O, P, false);
      return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
    };

    var ordinaryDefineOwnMetadata = function ordinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
      getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
    };

    var ordinaryOwnMetadataKeys = function ordinaryOwnMetadataKeys(target, targetKey) {
      var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
      var keys = [];
      if (metadataMap) metadataMap.forEach(function (_, key) {
        keys.push(key);
      });
      return keys;
    };

    var toMetadataKey = function toMetadataKey(it) {
      return it === undefined || typeof it == 'symbol' ? it : String(it);
    };

    module.exports = {
      store: store,
      getMap: getOrCreateMetadataMap,
      has: ordinaryHasOwnMetadata,
      get: ordinaryGetOwnMetadata,
      set: ordinaryDefineOwnMetadata,
      keys: ordinaryOwnMetadataKeys,
      toKey: toMetadataKey
    };
    /***/
  },

  /***/
  "./node_modules/core-js/internals/regexp-exec-abstract.js":
  /*!****************************************************************!*\
    !*** ./node_modules/core-js/internals/regexp-exec-abstract.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsRegexpExecAbstractJs(module, exports, __webpack_require__) {
    var classof = __webpack_require__(
    /*! ./classof-raw */
    "./node_modules/core-js/internals/classof-raw.js");

    var regexpExec = __webpack_require__(
    /*! ./regexp-exec */
    "./node_modules/core-js/internals/regexp-exec.js"); // `RegExpExec` abstract operation
    // https://tc39.github.io/ecma262/#sec-regexpexec


    module.exports = function (R, S) {
      var exec = R.exec;

      if (typeof exec === 'function') {
        var result = exec.call(R, S);

        if (typeof result !== 'object') {
          throw TypeError('RegExp exec method returned something other than an Object or null');
        }

        return result;
      }

      if (classof(R) !== 'RegExp') {
        throw TypeError('RegExp#exec called on incompatible receiver');
      }

      return regexpExec.call(R, S);
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/regexp-exec.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/internals/regexp-exec.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsRegexpExecJs(module, exports, __webpack_require__) {
    "use strict";

    var regexpFlags = __webpack_require__(
    /*! ./regexp-flags */
    "./node_modules/core-js/internals/regexp-flags.js");

    var stickyHelpers = __webpack_require__(
    /*! ./regexp-sticky-helpers */
    "./node_modules/core-js/internals/regexp-sticky-helpers.js");

    var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the
    // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
    // which loads this file before patching the method.

    var nativeReplace = String.prototype.replace;
    var patchedExec = nativeExec;

    var UPDATES_LAST_INDEX_WRONG = function () {
      var re1 = /a/;
      var re2 = /b*/g;
      nativeExec.call(re1, 'a');
      nativeExec.call(re2, 'a');
      return re1.lastIndex !== 0 || re2.lastIndex !== 0;
    }();

    var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET; // nonparticipating capturing group, copied from es5-shim's String#split patch.

    var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
    var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y;

    if (PATCH) {
      patchedExec = function exec(str) {
        var re = this;
        var lastIndex, reCopy, match, i;
        var sticky = UNSUPPORTED_Y && re.sticky;
        var flags = regexpFlags.call(re);
        var source = re.source;
        var charsAdded = 0;
        var strCopy = str;

        if (sticky) {
          flags = flags.replace('y', '');

          if (flags.indexOf('g') === -1) {
            flags += 'g';
          }

          strCopy = String(str).slice(re.lastIndex); // Support anchored sticky behavior.

          if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\n')) {
            source = '(?: ' + source + ')';
            strCopy = ' ' + strCopy;
            charsAdded++;
          } // ^(? + rx + ) is needed, in combination with some str slicing, to
          // simulate the 'y' flag.


          reCopy = new RegExp('^(?:' + source + ')', flags);
        }

        if (NPCG_INCLUDED) {
          reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
        }

        if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;
        match = nativeExec.call(sticky ? reCopy : re, strCopy);

        if (sticky) {
          if (match) {
            match.input = match.input.slice(charsAdded);
            match[0] = match[0].slice(charsAdded);
            match.index = re.lastIndex;
            re.lastIndex += match[0].length;
          } else re.lastIndex = 0;
        } else if (UPDATES_LAST_INDEX_WRONG && match) {
          re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
        }

        if (NPCG_INCLUDED && match && match.length > 1) {
          // Fix browsers whose `exec` methods don't consistently return `undefined`
          // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
          nativeReplace.call(match[0], reCopy, function () {
            for (i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undefined) match[i] = undefined;
            }
          });
        }

        return match;
      };
    }

    module.exports = patchedExec;
    /***/
  },

  /***/
  "./node_modules/core-js/internals/regexp-flags.js":
  /*!********************************************************!*\
    !*** ./node_modules/core-js/internals/regexp-flags.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsRegexpFlagsJs(module, exports, __webpack_require__) {
    "use strict";

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js"); // `RegExp.prototype.flags` getter implementation
    // https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags


    module.exports = function () {
      var that = anObject(this);
      var result = '';
      if (that.global) result += 'g';
      if (that.ignoreCase) result += 'i';
      if (that.multiline) result += 'm';
      if (that.dotAll) result += 's';
      if (that.unicode) result += 'u';
      if (that.sticky) result += 'y';
      return result;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/regexp-sticky-helpers.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/core-js/internals/regexp-sticky-helpers.js ***!
    \*****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsRegexpStickyHelpersJs(module, exports, __webpack_require__) {
    "use strict";

    var fails = __webpack_require__(
    /*! ./fails */
    "./node_modules/core-js/internals/fails.js"); // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
    // so we use an intermediate function.


    function RE(s, f) {
      return RegExp(s, f);
    }

    exports.UNSUPPORTED_Y = fails(function () {
      // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
      var re = RE('a', 'y');
      re.lastIndex = 2;
      return re.exec('abcd') != null;
    });
    exports.BROKEN_CARET = fails(function () {
      // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
      var re = RE('^r', 'gy');
      re.lastIndex = 2;
      return re.exec('str') != null;
    });
    /***/
  },

  /***/
  "./node_modules/core-js/internals/require-object-coercible.js":
  /*!********************************************************************!*\
    !*** ./node_modules/core-js/internals/require-object-coercible.js ***!
    \********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsRequireObjectCoercibleJs(module, exports) {
    // `RequireObjectCoercible` abstract operation
    // https://tc39.github.io/ecma262/#sec-requireobjectcoercible
    module.exports = function (it) {
      if (it == undefined) throw TypeError("Can't call method on " + it);
      return it;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/same-value.js":
  /*!******************************************************!*\
    !*** ./node_modules/core-js/internals/same-value.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsSameValueJs(module, exports) {
    // `SameValue` abstract operation
    // https://tc39.github.io/ecma262/#sec-samevalue
    module.exports = Object.is || function is(x, y) {
      // eslint-disable-next-line no-self-compare
      return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/set-global.js":
  /*!******************************************************!*\
    !*** ./node_modules/core-js/internals/set-global.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsSetGlobalJs(module, exports, __webpack_require__) {
    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    var createNonEnumerableProperty = __webpack_require__(
    /*! ../internals/create-non-enumerable-property */
    "./node_modules/core-js/internals/create-non-enumerable-property.js");

    module.exports = function (key, value) {
      try {
        createNonEnumerableProperty(global, key, value);
      } catch (error) {
        global[key] = value;
      }

      return value;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/set-species.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/internals/set-species.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsSetSpeciesJs(module, exports, __webpack_require__) {
    "use strict";

    var getBuiltIn = __webpack_require__(
    /*! ../internals/get-built-in */
    "./node_modules/core-js/internals/get-built-in.js");

    var definePropertyModule = __webpack_require__(
    /*! ../internals/object-define-property */
    "./node_modules/core-js/internals/object-define-property.js");

    var wellKnownSymbol = __webpack_require__(
    /*! ../internals/well-known-symbol */
    "./node_modules/core-js/internals/well-known-symbol.js");

    var DESCRIPTORS = __webpack_require__(
    /*! ../internals/descriptors */
    "./node_modules/core-js/internals/descriptors.js");

    var SPECIES = wellKnownSymbol('species');

    module.exports = function (CONSTRUCTOR_NAME) {
      var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
      var defineProperty = definePropertyModule.f;

      if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
        defineProperty(Constructor, SPECIES, {
          configurable: true,
          get: function get() {
            return this;
          }
        });
      }
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/set-to-string-tag.js":
  /*!*************************************************************!*\
    !*** ./node_modules/core-js/internals/set-to-string-tag.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsSetToStringTagJs(module, exports, __webpack_require__) {
    var defineProperty = __webpack_require__(
    /*! ../internals/object-define-property */
    "./node_modules/core-js/internals/object-define-property.js").f;

    var has = __webpack_require__(
    /*! ../internals/has */
    "./node_modules/core-js/internals/has.js");

    var wellKnownSymbol = __webpack_require__(
    /*! ../internals/well-known-symbol */
    "./node_modules/core-js/internals/well-known-symbol.js");

    var TO_STRING_TAG = wellKnownSymbol('toStringTag');

    module.exports = function (it, TAG, STATIC) {
      if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
        defineProperty(it, TO_STRING_TAG, {
          configurable: true,
          value: TAG
        });
      }
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/shared-key.js":
  /*!******************************************************!*\
    !*** ./node_modules/core-js/internals/shared-key.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsSharedKeyJs(module, exports, __webpack_require__) {
    var shared = __webpack_require__(
    /*! ../internals/shared */
    "./node_modules/core-js/internals/shared.js");

    var uid = __webpack_require__(
    /*! ../internals/uid */
    "./node_modules/core-js/internals/uid.js");

    var keys = shared('keys');

    module.exports = function (key) {
      return keys[key] || (keys[key] = uid(key));
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/shared-store.js":
  /*!********************************************************!*\
    !*** ./node_modules/core-js/internals/shared-store.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsSharedStoreJs(module, exports, __webpack_require__) {
    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    var setGlobal = __webpack_require__(
    /*! ../internals/set-global */
    "./node_modules/core-js/internals/set-global.js");

    var SHARED = '__core-js_shared__';
    var store = global[SHARED] || setGlobal(SHARED, {});
    module.exports = store;
    /***/
  },

  /***/
  "./node_modules/core-js/internals/shared.js":
  /*!**************************************************!*\
    !*** ./node_modules/core-js/internals/shared.js ***!
    \**************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsSharedJs(module, exports, __webpack_require__) {
    var IS_PURE = __webpack_require__(
    /*! ../internals/is-pure */
    "./node_modules/core-js/internals/is-pure.js");

    var store = __webpack_require__(
    /*! ../internals/shared-store */
    "./node_modules/core-js/internals/shared-store.js");

    (module.exports = function (key, value) {
      return store[key] || (store[key] = value !== undefined ? value : {});
    })('versions', []).push({
      version: '3.6.4',
      mode: IS_PURE ? 'pure' : 'global',
      copyright: '© 2020 Denis Pushkarev (zloirock.ru)'
    });
    /***/
  },

  /***/
  "./node_modules/core-js/internals/species-constructor.js":
  /*!***************************************************************!*\
    !*** ./node_modules/core-js/internals/species-constructor.js ***!
    \***************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsSpeciesConstructorJs(module, exports, __webpack_require__) {
    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var aFunction = __webpack_require__(
    /*! ../internals/a-function */
    "./node_modules/core-js/internals/a-function.js");

    var wellKnownSymbol = __webpack_require__(
    /*! ../internals/well-known-symbol */
    "./node_modules/core-js/internals/well-known-symbol.js");

    var SPECIES = wellKnownSymbol('species'); // `SpeciesConstructor` abstract operation
    // https://tc39.github.io/ecma262/#sec-speciesconstructor

    module.exports = function (O, defaultConstructor) {
      var C = anObject(O).constructor;
      var S;
      return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/string-html-forced.js":
  /*!**************************************************************!*\
    !*** ./node_modules/core-js/internals/string-html-forced.js ***!
    \**************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsStringHtmlForcedJs(module, exports, __webpack_require__) {
    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js"); // check the existence of a method, lowercase
    // of a tag and escaping quotes in arguments


    module.exports = function (METHOD_NAME) {
      return fails(function () {
        var test = ''[METHOD_NAME]('"');
        return test !== test.toLowerCase() || test.split('"').length > 3;
      });
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/string-multibyte.js":
  /*!************************************************************!*\
    !*** ./node_modules/core-js/internals/string-multibyte.js ***!
    \************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsStringMultibyteJs(module, exports, __webpack_require__) {
    var toInteger = __webpack_require__(
    /*! ../internals/to-integer */
    "./node_modules/core-js/internals/to-integer.js");

    var requireObjectCoercible = __webpack_require__(
    /*! ../internals/require-object-coercible */
    "./node_modules/core-js/internals/require-object-coercible.js"); // `String.prototype.{ codePointAt, at }` methods implementation


    var createMethod = function createMethod(CONVERT_TO_STRING) {
      return function ($this, pos) {
        var S = String(requireObjectCoercible($this));
        var position = toInteger(pos);
        var size = S.length;
        var first, second;
        if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
        first = S.charCodeAt(position);
        return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
      };
    };

    module.exports = {
      // `String.prototype.codePointAt` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
      codeAt: createMethod(false),
      // `String.prototype.at` method
      // https://github.com/mathiasbynens/String.prototype.at
      charAt: createMethod(true)
    };
    /***/
  },

  /***/
  "./node_modules/core-js/internals/string-pad.js":
  /*!******************************************************!*\
    !*** ./node_modules/core-js/internals/string-pad.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsStringPadJs(module, exports, __webpack_require__) {
    // https://github.com/tc39/proposal-string-pad-start-end
    var toLength = __webpack_require__(
    /*! ../internals/to-length */
    "./node_modules/core-js/internals/to-length.js");

    var repeat = __webpack_require__(
    /*! ../internals/string-repeat */
    "./node_modules/core-js/internals/string-repeat.js");

    var requireObjectCoercible = __webpack_require__(
    /*! ../internals/require-object-coercible */
    "./node_modules/core-js/internals/require-object-coercible.js");

    var ceil = Math.ceil; // `String.prototype.{ padStart, padEnd }` methods implementation

    var createMethod = function createMethod(IS_END) {
      return function ($this, maxLength, fillString) {
        var S = String(requireObjectCoercible($this));
        var stringLength = S.length;
        var fillStr = fillString === undefined ? ' ' : String(fillString);
        var intMaxLength = toLength(maxLength);
        var fillLen, stringFiller;
        if (intMaxLength <= stringLength || fillStr == '') return S;
        fillLen = intMaxLength - stringLength;
        stringFiller = repeat.call(fillStr, ceil(fillLen / fillStr.length));
        if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
        return IS_END ? S + stringFiller : stringFiller + S;
      };
    };

    module.exports = {
      // `String.prototype.padStart` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.padstart
      start: createMethod(false),
      // `String.prototype.padEnd` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.padend
      end: createMethod(true)
    };
    /***/
  },

  /***/
  "./node_modules/core-js/internals/string-repeat.js":
  /*!*********************************************************!*\
    !*** ./node_modules/core-js/internals/string-repeat.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsStringRepeatJs(module, exports, __webpack_require__) {
    "use strict";

    var toInteger = __webpack_require__(
    /*! ../internals/to-integer */
    "./node_modules/core-js/internals/to-integer.js");

    var requireObjectCoercible = __webpack_require__(
    /*! ../internals/require-object-coercible */
    "./node_modules/core-js/internals/require-object-coercible.js"); // `String.prototype.repeat` method implementation
    // https://tc39.github.io/ecma262/#sec-string.prototype.repeat


    module.exports = ''.repeat || function repeat(count) {
      var str = String(requireObjectCoercible(this));
      var result = '';
      var n = toInteger(count);
      if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');

      for (; n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;

      return result;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/string-trim-forced.js":
  /*!**************************************************************!*\
    !*** ./node_modules/core-js/internals/string-trim-forced.js ***!
    \**************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsStringTrimForcedJs(module, exports, __webpack_require__) {
    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var whitespaces = __webpack_require__(
    /*! ../internals/whitespaces */
    "./node_modules/core-js/internals/whitespaces.js");

    var non = '\u200B\u0085\u180E'; // check that a method works with the correct list
    // of whitespaces and has a correct name

    module.exports = function (METHOD_NAME) {
      return fails(function () {
        return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
      });
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/string-trim.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/internals/string-trim.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsStringTrimJs(module, exports, __webpack_require__) {
    var requireObjectCoercible = __webpack_require__(
    /*! ../internals/require-object-coercible */
    "./node_modules/core-js/internals/require-object-coercible.js");

    var whitespaces = __webpack_require__(
    /*! ../internals/whitespaces */
    "./node_modules/core-js/internals/whitespaces.js");

    var whitespace = '[' + whitespaces + ']';
    var ltrim = RegExp('^' + whitespace + whitespace + '*');
    var rtrim = RegExp(whitespace + whitespace + '*$'); // `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation

    var createMethod = function createMethod(TYPE) {
      return function ($this) {
        var string = String(requireObjectCoercible($this));
        if (TYPE & 1) string = string.replace(ltrim, '');
        if (TYPE & 2) string = string.replace(rtrim, '');
        return string;
      };
    };

    module.exports = {
      // `String.prototype.{ trimLeft, trimStart }` methods
      // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
      start: createMethod(1),
      // `String.prototype.{ trimRight, trimEnd }` methods
      // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
      end: createMethod(2),
      // `String.prototype.trim` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.trim
      trim: createMethod(3)
    };
    /***/
  },

  /***/
  "./node_modules/core-js/internals/task.js":
  /*!************************************************!*\
    !*** ./node_modules/core-js/internals/task.js ***!
    \************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsTaskJs(module, exports, __webpack_require__) {
    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var classof = __webpack_require__(
    /*! ../internals/classof-raw */
    "./node_modules/core-js/internals/classof-raw.js");

    var bind = __webpack_require__(
    /*! ../internals/function-bind-context */
    "./node_modules/core-js/internals/function-bind-context.js");

    var html = __webpack_require__(
    /*! ../internals/html */
    "./node_modules/core-js/internals/html.js");

    var createElement = __webpack_require__(
    /*! ../internals/document-create-element */
    "./node_modules/core-js/internals/document-create-element.js");

    var IS_IOS = __webpack_require__(
    /*! ../internals/engine-is-ios */
    "./node_modules/core-js/internals/engine-is-ios.js");

    var location = global.location;
    var set = global.setImmediate;
    var clear = global.clearImmediate;
    var process = global.process;
    var MessageChannel = global.MessageChannel;
    var Dispatch = global.Dispatch;
    var counter = 0;
    var queue = {};
    var ONREADYSTATECHANGE = 'onreadystatechange';
    var defer, channel, port;

    var run = function run(id) {
      // eslint-disable-next-line no-prototype-builtins
      if (queue.hasOwnProperty(id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
      }
    };

    var runner = function runner(id) {
      return function () {
        run(id);
      };
    };

    var listener = function listener(event) {
      run(event.data);
    };

    var post = function post(id) {
      // old engines have not location.origin
      global.postMessage(id + '', location.protocol + '//' + location.host);
    }; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


    if (!set || !clear) {
      set = function setImmediate(fn) {
        var args = [];
        var i = 1;

        while (arguments.length > i) args.push(arguments[i++]);

        queue[++counter] = function () {
          // eslint-disable-next-line no-new-func
          (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
        };

        defer(counter);
        return counter;
      };

      clear = function clearImmediate(id) {
        delete queue[id];
      }; // Node.js 0.8-


      if (classof(process) == 'process') {
        defer = function defer(id) {
          process.nextTick(runner(id));
        }; // Sphere (JS game engine) Dispatch API

      } else if (Dispatch && Dispatch.now) {
        defer = function defer(id) {
          Dispatch.now(runner(id));
        }; // Browsers with MessageChannel, includes WebWorkers
        // except iOS - https://github.com/zloirock/core-js/issues/624

      } else if (MessageChannel && !IS_IOS) {
        channel = new MessageChannel();
        port = channel.port2;
        channel.port1.onmessage = listener;
        defer = bind(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers
        // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
      } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts && !fails(post)) {
        defer = post;
        global.addEventListener('message', listener, false); // IE8-
      } else if (ONREADYSTATECHANGE in createElement('script')) {
        defer = function defer(id) {
          html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
            html.removeChild(this);
            run(id);
          };
        }; // Rest old browsers

      } else {
        defer = function defer(id) {
          setTimeout(runner(id), 0);
        };
      }
    }

    module.exports = {
      set: set,
      clear: clear
    };
    /***/
  },

  /***/
  "./node_modules/core-js/internals/this-number-value.js":
  /*!*************************************************************!*\
    !*** ./node_modules/core-js/internals/this-number-value.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsThisNumberValueJs(module, exports, __webpack_require__) {
    var classof = __webpack_require__(
    /*! ../internals/classof-raw */
    "./node_modules/core-js/internals/classof-raw.js"); // `thisNumberValue` abstract operation
    // https://tc39.github.io/ecma262/#sec-thisnumbervalue


    module.exports = function (value) {
      if (typeof value != 'number' && classof(value) != 'Number') {
        throw TypeError('Incorrect invocation');
      }

      return +value;
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/to-absolute-index.js":
  /*!*************************************************************!*\
    !*** ./node_modules/core-js/internals/to-absolute-index.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsToAbsoluteIndexJs(module, exports, __webpack_require__) {
    var toInteger = __webpack_require__(
    /*! ../internals/to-integer */
    "./node_modules/core-js/internals/to-integer.js");

    var max = Math.max;
    var min = Math.min; // Helper for a popular repeating case of the spec:
    // Let integer be ? ToInteger(index).
    // If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).

    module.exports = function (index, length) {
      var integer = toInteger(index);
      return integer < 0 ? max(integer + length, 0) : min(integer, length);
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/to-indexed-object.js":
  /*!*************************************************************!*\
    !*** ./node_modules/core-js/internals/to-indexed-object.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsToIndexedObjectJs(module, exports, __webpack_require__) {
    // toObject with fallback for non-array-like ES3 strings
    var IndexedObject = __webpack_require__(
    /*! ../internals/indexed-object */
    "./node_modules/core-js/internals/indexed-object.js");

    var requireObjectCoercible = __webpack_require__(
    /*! ../internals/require-object-coercible */
    "./node_modules/core-js/internals/require-object-coercible.js");

    module.exports = function (it) {
      return IndexedObject(requireObjectCoercible(it));
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/to-integer.js":
  /*!******************************************************!*\
    !*** ./node_modules/core-js/internals/to-integer.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsToIntegerJs(module, exports) {
    var ceil = Math.ceil;
    var floor = Math.floor; // `ToInteger` abstract operation
    // https://tc39.github.io/ecma262/#sec-tointeger

    module.exports = function (argument) {
      return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/to-length.js":
  /*!*****************************************************!*\
    !*** ./node_modules/core-js/internals/to-length.js ***!
    \*****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsToLengthJs(module, exports, __webpack_require__) {
    var toInteger = __webpack_require__(
    /*! ../internals/to-integer */
    "./node_modules/core-js/internals/to-integer.js");

    var min = Math.min; // `ToLength` abstract operation
    // https://tc39.github.io/ecma262/#sec-tolength

    module.exports = function (argument) {
      return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/to-object.js":
  /*!*****************************************************!*\
    !*** ./node_modules/core-js/internals/to-object.js ***!
    \*****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsToObjectJs(module, exports, __webpack_require__) {
    var requireObjectCoercible = __webpack_require__(
    /*! ../internals/require-object-coercible */
    "./node_modules/core-js/internals/require-object-coercible.js"); // `ToObject` abstract operation
    // https://tc39.github.io/ecma262/#sec-toobject


    module.exports = function (argument) {
      return Object(requireObjectCoercible(argument));
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/to-primitive.js":
  /*!********************************************************!*\
    !*** ./node_modules/core-js/internals/to-primitive.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsToPrimitiveJs(module, exports, __webpack_require__) {
    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js"); // `ToPrimitive` abstract operation
    // https://tc39.github.io/ecma262/#sec-toprimitive
    // instead of the ES6 spec version, we didn't implement @@toPrimitive case
    // and the second argument - flag - preferred type is a string


    module.exports = function (input, PREFERRED_STRING) {
      if (!isObject(input)) return input;
      var fn, val;
      if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
      if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
      if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
      throw TypeError("Can't convert object to primitive value");
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/to-string-tag-support.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/core-js/internals/to-string-tag-support.js ***!
    \*****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsToStringTagSupportJs(module, exports, __webpack_require__) {
    var wellKnownSymbol = __webpack_require__(
    /*! ../internals/well-known-symbol */
    "./node_modules/core-js/internals/well-known-symbol.js");

    var TO_STRING_TAG = wellKnownSymbol('toStringTag');
    var test = {};
    test[TO_STRING_TAG] = 'z';
    module.exports = String(test) === '[object z]';
    /***/
  },

  /***/
  "./node_modules/core-js/internals/uid.js":
  /*!***********************************************!*\
    !*** ./node_modules/core-js/internals/uid.js ***!
    \***********************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsUidJs(module, exports) {
    var id = 0;
    var postfix = Math.random();

    module.exports = function (key) {
      return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/use-symbol-as-uid.js":
  /*!*************************************************************!*\
    !*** ./node_modules/core-js/internals/use-symbol-as-uid.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsUseSymbolAsUidJs(module, exports, __webpack_require__) {
    var NATIVE_SYMBOL = __webpack_require__(
    /*! ../internals/native-symbol */
    "./node_modules/core-js/internals/native-symbol.js");

    module.exports = NATIVE_SYMBOL // eslint-disable-next-line no-undef
    && !Symbol.sham // eslint-disable-next-line no-undef
    && typeof Symbol.iterator == 'symbol';
    /***/
  },

  /***/
  "./node_modules/core-js/internals/well-known-symbol-wrapped.js":
  /*!*********************************************************************!*\
    !*** ./node_modules/core-js/internals/well-known-symbol-wrapped.js ***!
    \*********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsWellKnownSymbolWrappedJs(module, exports, __webpack_require__) {
    var wellKnownSymbol = __webpack_require__(
    /*! ../internals/well-known-symbol */
    "./node_modules/core-js/internals/well-known-symbol.js");

    exports.f = wellKnownSymbol;
    /***/
  },

  /***/
  "./node_modules/core-js/internals/well-known-symbol.js":
  /*!*************************************************************!*\
    !*** ./node_modules/core-js/internals/well-known-symbol.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsWellKnownSymbolJs(module, exports, __webpack_require__) {
    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    var shared = __webpack_require__(
    /*! ../internals/shared */
    "./node_modules/core-js/internals/shared.js");

    var has = __webpack_require__(
    /*! ../internals/has */
    "./node_modules/core-js/internals/has.js");

    var uid = __webpack_require__(
    /*! ../internals/uid */
    "./node_modules/core-js/internals/uid.js");

    var NATIVE_SYMBOL = __webpack_require__(
    /*! ../internals/native-symbol */
    "./node_modules/core-js/internals/native-symbol.js");

    var USE_SYMBOL_AS_UID = __webpack_require__(
    /*! ../internals/use-symbol-as-uid */
    "./node_modules/core-js/internals/use-symbol-as-uid.js");

    var WellKnownSymbolsStore = shared('wks');
    var Symbol = global.Symbol;
    var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

    module.exports = function (name) {
      if (!has(WellKnownSymbolsStore, name)) {
        if (NATIVE_SYMBOL && has(Symbol, name)) WellKnownSymbolsStore[name] = Symbol[name];else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
      }

      return WellKnownSymbolsStore[name];
    };
    /***/

  },

  /***/
  "./node_modules/core-js/internals/whitespaces.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/internals/whitespaces.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsInternalsWhitespacesJs(module, exports) {
    // a string of all valid unicode whitespaces
    // eslint-disable-next-line max-len
    module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.array.concat.js":
  /*!*********************************************************!*\
    !*** ./node_modules/core-js/modules/es.array.concat.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsArrayConcatJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var isArray = __webpack_require__(
    /*! ../internals/is-array */
    "./node_modules/core-js/internals/is-array.js");

    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    var toObject = __webpack_require__(
    /*! ../internals/to-object */
    "./node_modules/core-js/internals/to-object.js");

    var toLength = __webpack_require__(
    /*! ../internals/to-length */
    "./node_modules/core-js/internals/to-length.js");

    var createProperty = __webpack_require__(
    /*! ../internals/create-property */
    "./node_modules/core-js/internals/create-property.js");

    var arraySpeciesCreate = __webpack_require__(
    /*! ../internals/array-species-create */
    "./node_modules/core-js/internals/array-species-create.js");

    var arrayMethodHasSpeciesSupport = __webpack_require__(
    /*! ../internals/array-method-has-species-support */
    "./node_modules/core-js/internals/array-method-has-species-support.js");

    var wellKnownSymbol = __webpack_require__(
    /*! ../internals/well-known-symbol */
    "./node_modules/core-js/internals/well-known-symbol.js");

    var V8_VERSION = __webpack_require__(
    /*! ../internals/engine-v8-version */
    "./node_modules/core-js/internals/engine-v8-version.js");

    var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
    var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
    var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded'; // We can't use this feature detection in V8 since it causes
    // deoptimization and serious performance degradation
    // https://github.com/zloirock/core-js/issues/679

    var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
      var array = [];
      array[IS_CONCAT_SPREADABLE] = false;
      return array.concat()[0] !== array;
    });
    var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

    var isConcatSpreadable = function isConcatSpreadable(O) {
      if (!isObject(O)) return false;
      var spreadable = O[IS_CONCAT_SPREADABLE];
      return spreadable !== undefined ? !!spreadable : isArray(O);
    };

    var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT; // `Array.prototype.concat` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.concat
    // with adding support of @@isConcatSpreadable and @@species

    $({
      target: 'Array',
      proto: true,
      forced: FORCED
    }, {
      concat: function concat(arg) {
        // eslint-disable-line no-unused-vars
        var O = toObject(this);
        var A = arraySpeciesCreate(O, 0);
        var n = 0;
        var i, k, length, len, E;

        for (i = -1, length = arguments.length; i < length; i++) {
          E = i === -1 ? O : arguments[i];

          if (isConcatSpreadable(E)) {
            len = toLength(E.length);
            if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);

            for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
          } else {
            if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
            createProperty(A, n++, E);
          }
        }

        A.length = n;
        return A;
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.array.copy-within.js":
  /*!**************************************************************!*\
    !*** ./node_modules/core-js/modules/es.array.copy-within.js ***!
    \**************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsArrayCopyWithinJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var copyWithin = __webpack_require__(
    /*! ../internals/array-copy-within */
    "./node_modules/core-js/internals/array-copy-within.js");

    var addToUnscopables = __webpack_require__(
    /*! ../internals/add-to-unscopables */
    "./node_modules/core-js/internals/add-to-unscopables.js"); // `Array.prototype.copyWithin` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.copywithin


    $({
      target: 'Array',
      proto: true
    }, {
      copyWithin: copyWithin
    }); // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

    addToUnscopables('copyWithin');
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.array.every.js":
  /*!********************************************************!*\
    !*** ./node_modules/core-js/modules/es.array.every.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsArrayEveryJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var $every = __webpack_require__(
    /*! ../internals/array-iteration */
    "./node_modules/core-js/internals/array-iteration.js").every;

    var arrayMethodIsStrict = __webpack_require__(
    /*! ../internals/array-method-is-strict */
    "./node_modules/core-js/internals/array-method-is-strict.js");

    var arrayMethodUsesToLength = __webpack_require__(
    /*! ../internals/array-method-uses-to-length */
    "./node_modules/core-js/internals/array-method-uses-to-length.js");

    var STRICT_METHOD = arrayMethodIsStrict('every');
    var USES_TO_LENGTH = arrayMethodUsesToLength('every'); // `Array.prototype.every` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.every

    $({
      target: 'Array',
      proto: true,
      forced: !STRICT_METHOD || !USES_TO_LENGTH
    }, {
      every: function every(callbackfn
      /* , thisArg */
      ) {
        return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.array.fill.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/modules/es.array.fill.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsArrayFillJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var fill = __webpack_require__(
    /*! ../internals/array-fill */
    "./node_modules/core-js/internals/array-fill.js");

    var addToUnscopables = __webpack_require__(
    /*! ../internals/add-to-unscopables */
    "./node_modules/core-js/internals/add-to-unscopables.js"); // `Array.prototype.fill` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.fill


    $({
      target: 'Array',
      proto: true
    }, {
      fill: fill
    }); // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

    addToUnscopables('fill');
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.array.filter.js":
  /*!*********************************************************!*\
    !*** ./node_modules/core-js/modules/es.array.filter.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsArrayFilterJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var $filter = __webpack_require__(
    /*! ../internals/array-iteration */
    "./node_modules/core-js/internals/array-iteration.js").filter;

    var arrayMethodHasSpeciesSupport = __webpack_require__(
    /*! ../internals/array-method-has-species-support */
    "./node_modules/core-js/internals/array-method-has-species-support.js");

    var arrayMethodUsesToLength = __webpack_require__(
    /*! ../internals/array-method-uses-to-length */
    "./node_modules/core-js/internals/array-method-uses-to-length.js");

    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter'); // Edge 14- issue

    var USES_TO_LENGTH = arrayMethodUsesToLength('filter'); // `Array.prototype.filter` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.filter
    // with adding support of @@species

    $({
      target: 'Array',
      proto: true,
      forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH
    }, {
      filter: function filter(callbackfn
      /* , thisArg */
      ) {
        return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.array.find-index.js":
  /*!*************************************************************!*\
    !*** ./node_modules/core-js/modules/es.array.find-index.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsArrayFindIndexJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var $findIndex = __webpack_require__(
    /*! ../internals/array-iteration */
    "./node_modules/core-js/internals/array-iteration.js").findIndex;

    var addToUnscopables = __webpack_require__(
    /*! ../internals/add-to-unscopables */
    "./node_modules/core-js/internals/add-to-unscopables.js");

    var arrayMethodUsesToLength = __webpack_require__(
    /*! ../internals/array-method-uses-to-length */
    "./node_modules/core-js/internals/array-method-uses-to-length.js");

    var FIND_INDEX = 'findIndex';
    var SKIPS_HOLES = true;
    var USES_TO_LENGTH = arrayMethodUsesToLength(FIND_INDEX); // Shouldn't skip holes

    if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () {
      SKIPS_HOLES = false;
    }); // `Array.prototype.findIndex` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.findindex

    $({
      target: 'Array',
      proto: true,
      forced: SKIPS_HOLES || !USES_TO_LENGTH
    }, {
      findIndex: function findIndex(callbackfn
      /* , that = undefined */
      ) {
        return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      }
    }); // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

    addToUnscopables(FIND_INDEX);
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.array.find.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/modules/es.array.find.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsArrayFindJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var $find = __webpack_require__(
    /*! ../internals/array-iteration */
    "./node_modules/core-js/internals/array-iteration.js").find;

    var addToUnscopables = __webpack_require__(
    /*! ../internals/add-to-unscopables */
    "./node_modules/core-js/internals/add-to-unscopables.js");

    var arrayMethodUsesToLength = __webpack_require__(
    /*! ../internals/array-method-uses-to-length */
    "./node_modules/core-js/internals/array-method-uses-to-length.js");

    var FIND = 'find';
    var SKIPS_HOLES = true;
    var USES_TO_LENGTH = arrayMethodUsesToLength(FIND); // Shouldn't skip holes

    if (FIND in []) Array(1)[FIND](function () {
      SKIPS_HOLES = false;
    }); // `Array.prototype.find` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.find

    $({
      target: 'Array',
      proto: true,
      forced: SKIPS_HOLES || !USES_TO_LENGTH
    }, {
      find: function find(callbackfn
      /* , that = undefined */
      ) {
        return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      }
    }); // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

    addToUnscopables(FIND);
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.array.for-each.js":
  /*!***********************************************************!*\
    !*** ./node_modules/core-js/modules/es.array.for-each.js ***!
    \***********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsArrayForEachJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var forEach = __webpack_require__(
    /*! ../internals/array-for-each */
    "./node_modules/core-js/internals/array-for-each.js"); // `Array.prototype.forEach` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.foreach


    $({
      target: 'Array',
      proto: true,
      forced: [].forEach != forEach
    }, {
      forEach: forEach
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.array.from.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/modules/es.array.from.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsArrayFromJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var from = __webpack_require__(
    /*! ../internals/array-from */
    "./node_modules/core-js/internals/array-from.js");

    var checkCorrectnessOfIteration = __webpack_require__(
    /*! ../internals/check-correctness-of-iteration */
    "./node_modules/core-js/internals/check-correctness-of-iteration.js");

    var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
      Array.from(iterable);
    }); // `Array.from` method
    // https://tc39.github.io/ecma262/#sec-array.from

    $({
      target: 'Array',
      stat: true,
      forced: INCORRECT_ITERATION
    }, {
      from: from
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.array.index-of.js":
  /*!***********************************************************!*\
    !*** ./node_modules/core-js/modules/es.array.index-of.js ***!
    \***********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsArrayIndexOfJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var $indexOf = __webpack_require__(
    /*! ../internals/array-includes */
    "./node_modules/core-js/internals/array-includes.js").indexOf;

    var arrayMethodIsStrict = __webpack_require__(
    /*! ../internals/array-method-is-strict */
    "./node_modules/core-js/internals/array-method-is-strict.js");

    var arrayMethodUsesToLength = __webpack_require__(
    /*! ../internals/array-method-uses-to-length */
    "./node_modules/core-js/internals/array-method-uses-to-length.js");

    var nativeIndexOf = [].indexOf;
    var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
    var STRICT_METHOD = arrayMethodIsStrict('indexOf');
    var USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', {
      ACCESSORS: true,
      1: 0
    }); // `Array.prototype.indexOf` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.indexof

    $({
      target: 'Array',
      proto: true,
      forced: NEGATIVE_ZERO || !STRICT_METHOD || !USES_TO_LENGTH
    }, {
      indexOf: function indexOf(searchElement
      /* , fromIndex = 0 */
      ) {
        return NEGATIVE_ZERO // convert -0 to +0
        ? nativeIndexOf.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.array.is-array.js":
  /*!***********************************************************!*\
    !*** ./node_modules/core-js/modules/es.array.is-array.js ***!
    \***********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsArrayIsArrayJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var isArray = __webpack_require__(
    /*! ../internals/is-array */
    "./node_modules/core-js/internals/is-array.js"); // `Array.isArray` method
    // https://tc39.github.io/ecma262/#sec-array.isarray


    $({
      target: 'Array',
      stat: true
    }, {
      isArray: isArray
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.array.iterator.js":
  /*!***********************************************************!*\
    !*** ./node_modules/core-js/modules/es.array.iterator.js ***!
    \***********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsArrayIteratorJs(module, exports, __webpack_require__) {
    "use strict";

    var toIndexedObject = __webpack_require__(
    /*! ../internals/to-indexed-object */
    "./node_modules/core-js/internals/to-indexed-object.js");

    var addToUnscopables = __webpack_require__(
    /*! ../internals/add-to-unscopables */
    "./node_modules/core-js/internals/add-to-unscopables.js");

    var Iterators = __webpack_require__(
    /*! ../internals/iterators */
    "./node_modules/core-js/internals/iterators.js");

    var InternalStateModule = __webpack_require__(
    /*! ../internals/internal-state */
    "./node_modules/core-js/internals/internal-state.js");

    var defineIterator = __webpack_require__(
    /*! ../internals/define-iterator */
    "./node_modules/core-js/internals/define-iterator.js");

    var ARRAY_ITERATOR = 'Array Iterator';
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR); // `Array.prototype.entries` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.entries
    // `Array.prototype.keys` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.keys
    // `Array.prototype.values` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.values
    // `Array.prototype[@@iterator]` method
    // https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
    // `CreateArrayIterator` internal method
    // https://tc39.github.io/ecma262/#sec-createarrayiterator

    module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
      setInternalState(this, {
        type: ARRAY_ITERATOR,
        target: toIndexedObject(iterated),
        // target
        index: 0,
        // next index
        kind: kind // kind

      }); // `%ArrayIteratorPrototype%.next` method
      // https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
    }, function () {
      var state = getInternalState(this);
      var target = state.target;
      var kind = state.kind;
      var index = state.index++;

      if (!target || index >= target.length) {
        state.target = undefined;
        return {
          value: undefined,
          done: true
        };
      }

      if (kind == 'keys') return {
        value: index,
        done: false
      };
      if (kind == 'values') return {
        value: target[index],
        done: false
      };
      return {
        value: [index, target[index]],
        done: false
      };
    }, 'values'); // argumentsList[@@iterator] is %ArrayProto_values%
    // https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
    // https://tc39.github.io/ecma262/#sec-createmappedargumentsobject

    Iterators.Arguments = Iterators.Array; // https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables

    addToUnscopables('keys');
    addToUnscopables('values');
    addToUnscopables('entries');
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.array.join.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/modules/es.array.join.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsArrayJoinJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var IndexedObject = __webpack_require__(
    /*! ../internals/indexed-object */
    "./node_modules/core-js/internals/indexed-object.js");

    var toIndexedObject = __webpack_require__(
    /*! ../internals/to-indexed-object */
    "./node_modules/core-js/internals/to-indexed-object.js");

    var arrayMethodIsStrict = __webpack_require__(
    /*! ../internals/array-method-is-strict */
    "./node_modules/core-js/internals/array-method-is-strict.js");

    var nativeJoin = [].join;
    var ES3_STRINGS = IndexedObject != Object;
    var STRICT_METHOD = arrayMethodIsStrict('join', ','); // `Array.prototype.join` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.join

    $({
      target: 'Array',
      proto: true,
      forced: ES3_STRINGS || !STRICT_METHOD
    }, {
      join: function join(separator) {
        return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.array.last-index-of.js":
  /*!****************************************************************!*\
    !*** ./node_modules/core-js/modules/es.array.last-index-of.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsArrayLastIndexOfJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var lastIndexOf = __webpack_require__(
    /*! ../internals/array-last-index-of */
    "./node_modules/core-js/internals/array-last-index-of.js"); // `Array.prototype.lastIndexOf` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof


    $({
      target: 'Array',
      proto: true,
      forced: lastIndexOf !== [].lastIndexOf
    }, {
      lastIndexOf: lastIndexOf
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.array.map.js":
  /*!******************************************************!*\
    !*** ./node_modules/core-js/modules/es.array.map.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsArrayMapJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var $map = __webpack_require__(
    /*! ../internals/array-iteration */
    "./node_modules/core-js/internals/array-iteration.js").map;

    var arrayMethodHasSpeciesSupport = __webpack_require__(
    /*! ../internals/array-method-has-species-support */
    "./node_modules/core-js/internals/array-method-has-species-support.js");

    var arrayMethodUsesToLength = __webpack_require__(
    /*! ../internals/array-method-uses-to-length */
    "./node_modules/core-js/internals/array-method-uses-to-length.js");

    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map'); // FF49- issue

    var USES_TO_LENGTH = arrayMethodUsesToLength('map'); // `Array.prototype.map` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.map
    // with adding support of @@species

    $({
      target: 'Array',
      proto: true,
      forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH
    }, {
      map: function map(callbackfn
      /* , thisArg */
      ) {
        return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.array.of.js":
  /*!*****************************************************!*\
    !*** ./node_modules/core-js/modules/es.array.of.js ***!
    \*****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsArrayOfJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var createProperty = __webpack_require__(
    /*! ../internals/create-property */
    "./node_modules/core-js/internals/create-property.js");

    var ISNT_GENERIC = fails(function () {
      function F() {
        /* empty */
      }

      return !(Array.of.call(F) instanceof F);
    }); // `Array.of` method
    // https://tc39.github.io/ecma262/#sec-array.of
    // WebKit Array.of isn't generic

    $({
      target: 'Array',
      stat: true,
      forced: ISNT_GENERIC
    }, {
      of: function of()
      /* ...args */
      {
        var index = 0;
        var argumentsLength = arguments.length;
        var result = new (typeof this == 'function' ? this : Array)(argumentsLength);

        while (argumentsLength > index) createProperty(result, index, arguments[index++]);

        result.length = argumentsLength;
        return result;
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.array.reduce-right.js":
  /*!***************************************************************!*\
    !*** ./node_modules/core-js/modules/es.array.reduce-right.js ***!
    \***************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsArrayReduceRightJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var $reduceRight = __webpack_require__(
    /*! ../internals/array-reduce */
    "./node_modules/core-js/internals/array-reduce.js").right;

    var arrayMethodIsStrict = __webpack_require__(
    /*! ../internals/array-method-is-strict */
    "./node_modules/core-js/internals/array-method-is-strict.js");

    var arrayMethodUsesToLength = __webpack_require__(
    /*! ../internals/array-method-uses-to-length */
    "./node_modules/core-js/internals/array-method-uses-to-length.js");

    var STRICT_METHOD = arrayMethodIsStrict('reduceRight'); // For preventing possible almost infinite loop in non-standard implementations, test the forward version of the method

    var USES_TO_LENGTH = arrayMethodUsesToLength('reduce', {
      1: 0
    }); // `Array.prototype.reduceRight` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright

    $({
      target: 'Array',
      proto: true,
      forced: !STRICT_METHOD || !USES_TO_LENGTH
    }, {
      reduceRight: function reduceRight(callbackfn
      /* , initialValue */
      ) {
        return $reduceRight(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.array.reduce.js":
  /*!*********************************************************!*\
    !*** ./node_modules/core-js/modules/es.array.reduce.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsArrayReduceJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var $reduce = __webpack_require__(
    /*! ../internals/array-reduce */
    "./node_modules/core-js/internals/array-reduce.js").left;

    var arrayMethodIsStrict = __webpack_require__(
    /*! ../internals/array-method-is-strict */
    "./node_modules/core-js/internals/array-method-is-strict.js");

    var arrayMethodUsesToLength = __webpack_require__(
    /*! ../internals/array-method-uses-to-length */
    "./node_modules/core-js/internals/array-method-uses-to-length.js");

    var STRICT_METHOD = arrayMethodIsStrict('reduce');
    var USES_TO_LENGTH = arrayMethodUsesToLength('reduce', {
      1: 0
    }); // `Array.prototype.reduce` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.reduce

    $({
      target: 'Array',
      proto: true,
      forced: !STRICT_METHOD || !USES_TO_LENGTH
    }, {
      reduce: function reduce(callbackfn
      /* , initialValue */
      ) {
        return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.array.slice.js":
  /*!********************************************************!*\
    !*** ./node_modules/core-js/modules/es.array.slice.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsArraySliceJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    var isArray = __webpack_require__(
    /*! ../internals/is-array */
    "./node_modules/core-js/internals/is-array.js");

    var toAbsoluteIndex = __webpack_require__(
    /*! ../internals/to-absolute-index */
    "./node_modules/core-js/internals/to-absolute-index.js");

    var toLength = __webpack_require__(
    /*! ../internals/to-length */
    "./node_modules/core-js/internals/to-length.js");

    var toIndexedObject = __webpack_require__(
    /*! ../internals/to-indexed-object */
    "./node_modules/core-js/internals/to-indexed-object.js");

    var createProperty = __webpack_require__(
    /*! ../internals/create-property */
    "./node_modules/core-js/internals/create-property.js");

    var wellKnownSymbol = __webpack_require__(
    /*! ../internals/well-known-symbol */
    "./node_modules/core-js/internals/well-known-symbol.js");

    var arrayMethodHasSpeciesSupport = __webpack_require__(
    /*! ../internals/array-method-has-species-support */
    "./node_modules/core-js/internals/array-method-has-species-support.js");

    var arrayMethodUsesToLength = __webpack_require__(
    /*! ../internals/array-method-uses-to-length */
    "./node_modules/core-js/internals/array-method-uses-to-length.js");

    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');
    var USES_TO_LENGTH = arrayMethodUsesToLength('slice', {
      ACCESSORS: true,
      0: 0,
      1: 2
    });
    var SPECIES = wellKnownSymbol('species');
    var nativeSlice = [].slice;
    var max = Math.max; // `Array.prototype.slice` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.slice
    // fallback for not array-like ES3 strings and DOM objects

    $({
      target: 'Array',
      proto: true,
      forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH
    }, {
      slice: function slice(start, end) {
        var O = toIndexedObject(this);
        var length = toLength(O.length);
        var k = toAbsoluteIndex(start, length);
        var fin = toAbsoluteIndex(end === undefined ? length : end, length); // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible

        var Constructor, result, n;

        if (isArray(O)) {
          Constructor = O.constructor; // cross-realm fallback

          if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
            Constructor = undefined;
          } else if (isObject(Constructor)) {
            Constructor = Constructor[SPECIES];
            if (Constructor === null) Constructor = undefined;
          }

          if (Constructor === Array || Constructor === undefined) {
            return nativeSlice.call(O, k, fin);
          }
        }

        result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));

        for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);

        result.length = n;
        return result;
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.array.some.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/modules/es.array.some.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsArraySomeJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var $some = __webpack_require__(
    /*! ../internals/array-iteration */
    "./node_modules/core-js/internals/array-iteration.js").some;

    var arrayMethodIsStrict = __webpack_require__(
    /*! ../internals/array-method-is-strict */
    "./node_modules/core-js/internals/array-method-is-strict.js");

    var arrayMethodUsesToLength = __webpack_require__(
    /*! ../internals/array-method-uses-to-length */
    "./node_modules/core-js/internals/array-method-uses-to-length.js");

    var STRICT_METHOD = arrayMethodIsStrict('some');
    var USES_TO_LENGTH = arrayMethodUsesToLength('some'); // `Array.prototype.some` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.some

    $({
      target: 'Array',
      proto: true,
      forced: !STRICT_METHOD || !USES_TO_LENGTH
    }, {
      some: function some(callbackfn
      /* , thisArg */
      ) {
        return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.array.sort.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/modules/es.array.sort.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsArraySortJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var aFunction = __webpack_require__(
    /*! ../internals/a-function */
    "./node_modules/core-js/internals/a-function.js");

    var toObject = __webpack_require__(
    /*! ../internals/to-object */
    "./node_modules/core-js/internals/to-object.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var arrayMethodIsStrict = __webpack_require__(
    /*! ../internals/array-method-is-strict */
    "./node_modules/core-js/internals/array-method-is-strict.js");

    var test = [];
    var nativeSort = test.sort; // IE8-

    var FAILS_ON_UNDEFINED = fails(function () {
      test.sort(undefined);
    }); // V8 bug

    var FAILS_ON_NULL = fails(function () {
      test.sort(null);
    }); // Old WebKit

    var STRICT_METHOD = arrayMethodIsStrict('sort');
    var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD; // `Array.prototype.sort` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.sort

    $({
      target: 'Array',
      proto: true,
      forced: FORCED
    }, {
      sort: function sort(comparefn) {
        return comparefn === undefined ? nativeSort.call(toObject(this)) : nativeSort.call(toObject(this), aFunction(comparefn));
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.array.splice.js":
  /*!*********************************************************!*\
    !*** ./node_modules/core-js/modules/es.array.splice.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsArraySpliceJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var toAbsoluteIndex = __webpack_require__(
    /*! ../internals/to-absolute-index */
    "./node_modules/core-js/internals/to-absolute-index.js");

    var toInteger = __webpack_require__(
    /*! ../internals/to-integer */
    "./node_modules/core-js/internals/to-integer.js");

    var toLength = __webpack_require__(
    /*! ../internals/to-length */
    "./node_modules/core-js/internals/to-length.js");

    var toObject = __webpack_require__(
    /*! ../internals/to-object */
    "./node_modules/core-js/internals/to-object.js");

    var arraySpeciesCreate = __webpack_require__(
    /*! ../internals/array-species-create */
    "./node_modules/core-js/internals/array-species-create.js");

    var createProperty = __webpack_require__(
    /*! ../internals/create-property */
    "./node_modules/core-js/internals/create-property.js");

    var arrayMethodHasSpeciesSupport = __webpack_require__(
    /*! ../internals/array-method-has-species-support */
    "./node_modules/core-js/internals/array-method-has-species-support.js");

    var arrayMethodUsesToLength = __webpack_require__(
    /*! ../internals/array-method-uses-to-length */
    "./node_modules/core-js/internals/array-method-uses-to-length.js");

    var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');
    var USES_TO_LENGTH = arrayMethodUsesToLength('splice', {
      ACCESSORS: true,
      0: 0,
      1: 2
    });
    var max = Math.max;
    var min = Math.min;
    var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
    var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded'; // `Array.prototype.splice` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.splice
    // with adding support of @@species

    $({
      target: 'Array',
      proto: true,
      forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH
    }, {
      splice: function splice(start, deleteCount
      /* , ...items */
      ) {
        var O = toObject(this);
        var len = toLength(O.length);
        var actualStart = toAbsoluteIndex(start, len);
        var argumentsLength = arguments.length;
        var insertCount, actualDeleteCount, A, k, from, to;

        if (argumentsLength === 0) {
          insertCount = actualDeleteCount = 0;
        } else if (argumentsLength === 1) {
          insertCount = 0;
          actualDeleteCount = len - actualStart;
        } else {
          insertCount = argumentsLength - 2;
          actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);
        }

        if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
          throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
        }

        A = arraySpeciesCreate(O, actualDeleteCount);

        for (k = 0; k < actualDeleteCount; k++) {
          from = actualStart + k;
          if (from in O) createProperty(A, k, O[from]);
        }

        A.length = actualDeleteCount;

        if (insertCount < actualDeleteCount) {
          for (k = actualStart; k < len - actualDeleteCount; k++) {
            from = k + actualDeleteCount;
            to = k + insertCount;
            if (from in O) O[to] = O[from];else delete O[to];
          }

          for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
        } else if (insertCount > actualDeleteCount) {
          for (k = len - actualDeleteCount; k > actualStart; k--) {
            from = k + actualDeleteCount - 1;
            to = k + insertCount - 1;
            if (from in O) O[to] = O[from];else delete O[to];
          }
        }

        for (k = 0; k < insertCount; k++) {
          O[k + actualStart] = arguments[k + 2];
        }

        O.length = len - actualDeleteCount + insertCount;
        return A;
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.date.now.js":
  /*!*****************************************************!*\
    !*** ./node_modules/core-js/modules/es.date.now.js ***!
    \*****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsDateNowJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js"); // `Date.now` method
    // https://tc39.github.io/ecma262/#sec-date.now


    $({
      target: 'Date',
      stat: true
    }, {
      now: function now() {
        return new Date().getTime();
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.date.to-iso-string.js":
  /*!***************************************************************!*\
    !*** ./node_modules/core-js/modules/es.date.to-iso-string.js ***!
    \***************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsDateToIsoStringJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var toISOString = __webpack_require__(
    /*! ../internals/date-to-iso-string */
    "./node_modules/core-js/internals/date-to-iso-string.js"); // `Date.prototype.toISOString` method
    // https://tc39.github.io/ecma262/#sec-date.prototype.toisostring
    // PhantomJS / old WebKit has a broken implementations


    $({
      target: 'Date',
      proto: true,
      forced: Date.prototype.toISOString !== toISOString
    }, {
      toISOString: toISOString
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.date.to-json.js":
  /*!*********************************************************!*\
    !*** ./node_modules/core-js/modules/es.date.to-json.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsDateToJsonJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var toObject = __webpack_require__(
    /*! ../internals/to-object */
    "./node_modules/core-js/internals/to-object.js");

    var toPrimitive = __webpack_require__(
    /*! ../internals/to-primitive */
    "./node_modules/core-js/internals/to-primitive.js");

    var FORCED = fails(function () {
      return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({
        toISOString: function toISOString() {
          return 1;
        }
      }) !== 1;
    }); // `Date.prototype.toJSON` method
    // https://tc39.github.io/ecma262/#sec-date.prototype.tojson

    $({
      target: 'Date',
      proto: true,
      forced: FORCED
    }, {
      // eslint-disable-next-line no-unused-vars
      toJSON: function toJSON(key) {
        var O = toObject(this);
        var pv = toPrimitive(O);
        return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.date.to-primitive.js":
  /*!**************************************************************!*\
    !*** ./node_modules/core-js/modules/es.date.to-primitive.js ***!
    \**************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsDateToPrimitiveJs(module, exports, __webpack_require__) {
    var createNonEnumerableProperty = __webpack_require__(
    /*! ../internals/create-non-enumerable-property */
    "./node_modules/core-js/internals/create-non-enumerable-property.js");

    var dateToPrimitive = __webpack_require__(
    /*! ../internals/date-to-primitive */
    "./node_modules/core-js/internals/date-to-primitive.js");

    var wellKnownSymbol = __webpack_require__(
    /*! ../internals/well-known-symbol */
    "./node_modules/core-js/internals/well-known-symbol.js");

    var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
    var DatePrototype = Date.prototype; // `Date.prototype[@@toPrimitive]` method
    // https://tc39.github.io/ecma262/#sec-date.prototype-@@toprimitive

    if (!(TO_PRIMITIVE in DatePrototype)) {
      createNonEnumerableProperty(DatePrototype, TO_PRIMITIVE, dateToPrimitive);
    }
    /***/

  },

  /***/
  "./node_modules/core-js/modules/es.date.to-string.js":
  /*!***********************************************************!*\
    !*** ./node_modules/core-js/modules/es.date.to-string.js ***!
    \***********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsDateToStringJs(module, exports, __webpack_require__) {
    var redefine = __webpack_require__(
    /*! ../internals/redefine */
    "./node_modules/core-js/internals/redefine.js");

    var DatePrototype = Date.prototype;
    var INVALID_DATE = 'Invalid Date';
    var TO_STRING = 'toString';
    var nativeDateToString = DatePrototype[TO_STRING];
    var getTime = DatePrototype.getTime; // `Date.prototype.toString` method
    // https://tc39.github.io/ecma262/#sec-date.prototype.tostring

    if (new Date(NaN) + '' != INVALID_DATE) {
      redefine(DatePrototype, TO_STRING, function toString() {
        var value = getTime.call(this); // eslint-disable-next-line no-self-compare

        return value === value ? nativeDateToString.call(this) : INVALID_DATE;
      });
    }
    /***/

  },

  /***/
  "./node_modules/core-js/modules/es.function.bind.js":
  /*!**********************************************************!*\
    !*** ./node_modules/core-js/modules/es.function.bind.js ***!
    \**********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsFunctionBindJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var bind = __webpack_require__(
    /*! ../internals/function-bind */
    "./node_modules/core-js/internals/function-bind.js"); // `Function.prototype.bind` method
    // https://tc39.github.io/ecma262/#sec-function.prototype.bind


    $({
      target: 'Function',
      proto: true
    }, {
      bind: bind
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.function.has-instance.js":
  /*!******************************************************************!*\
    !*** ./node_modules/core-js/modules/es.function.has-instance.js ***!
    \******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsFunctionHasInstanceJs(module, exports, __webpack_require__) {
    "use strict";

    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    var definePropertyModule = __webpack_require__(
    /*! ../internals/object-define-property */
    "./node_modules/core-js/internals/object-define-property.js");

    var getPrototypeOf = __webpack_require__(
    /*! ../internals/object-get-prototype-of */
    "./node_modules/core-js/internals/object-get-prototype-of.js");

    var wellKnownSymbol = __webpack_require__(
    /*! ../internals/well-known-symbol */
    "./node_modules/core-js/internals/well-known-symbol.js");

    var HAS_INSTANCE = wellKnownSymbol('hasInstance');
    var FunctionPrototype = Function.prototype; // `Function.prototype[@@hasInstance]` method
    // https://tc39.github.io/ecma262/#sec-function.prototype-@@hasinstance

    if (!(HAS_INSTANCE in FunctionPrototype)) {
      definePropertyModule.f(FunctionPrototype, HAS_INSTANCE, {
        value: function value(O) {
          if (typeof this != 'function' || !isObject(O)) return false;
          if (!isObject(this.prototype)) return O instanceof this; // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:

          while (O = getPrototypeOf(O)) if (this.prototype === O) return true;

          return false;
        }
      });
    }
    /***/

  },

  /***/
  "./node_modules/core-js/modules/es.function.name.js":
  /*!**********************************************************!*\
    !*** ./node_modules/core-js/modules/es.function.name.js ***!
    \**********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsFunctionNameJs(module, exports, __webpack_require__) {
    var DESCRIPTORS = __webpack_require__(
    /*! ../internals/descriptors */
    "./node_modules/core-js/internals/descriptors.js");

    var defineProperty = __webpack_require__(
    /*! ../internals/object-define-property */
    "./node_modules/core-js/internals/object-define-property.js").f;

    var FunctionPrototype = Function.prototype;
    var FunctionPrototypeToString = FunctionPrototype.toString;
    var nameRE = /^\s*function ([^ (]*)/;
    var NAME = 'name'; // Function instances `.name` property
    // https://tc39.github.io/ecma262/#sec-function-instances-name

    if (DESCRIPTORS && !(NAME in FunctionPrototype)) {
      defineProperty(FunctionPrototype, NAME, {
        configurable: true,
        get: function get() {
          try {
            return FunctionPrototypeToString.call(this).match(nameRE)[1];
          } catch (error) {
            return '';
          }
        }
      });
    }
    /***/

  },

  /***/
  "./node_modules/core-js/modules/es.json.to-string-tag.js":
  /*!***************************************************************!*\
    !*** ./node_modules/core-js/modules/es.json.to-string-tag.js ***!
    \***************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsJsonToStringTagJs(module, exports, __webpack_require__) {
    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    var setToStringTag = __webpack_require__(
    /*! ../internals/set-to-string-tag */
    "./node_modules/core-js/internals/set-to-string-tag.js"); // JSON[@@toStringTag] property
    // https://tc39.github.io/ecma262/#sec-json-@@tostringtag


    setToStringTag(global.JSON, 'JSON', true);
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.map.js":
  /*!************************************************!*\
    !*** ./node_modules/core-js/modules/es.map.js ***!
    \************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsMapJs(module, exports, __webpack_require__) {
    "use strict";

    var collection = __webpack_require__(
    /*! ../internals/collection */
    "./node_modules/core-js/internals/collection.js");

    var collectionStrong = __webpack_require__(
    /*! ../internals/collection-strong */
    "./node_modules/core-js/internals/collection-strong.js"); // `Map` constructor
    // https://tc39.github.io/ecma262/#sec-map-objects


    module.exports = collection('Map', function (init) {
      return function Map() {
        return init(this, arguments.length ? arguments[0] : undefined);
      };
    }, collectionStrong);
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.math.acosh.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/modules/es.math.acosh.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsMathAcoshJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var log1p = __webpack_require__(
    /*! ../internals/math-log1p */
    "./node_modules/core-js/internals/math-log1p.js");

    var nativeAcosh = Math.acosh;
    var log = Math.log;
    var sqrt = Math.sqrt;
    var LN2 = Math.LN2;
    var FORCED = !nativeAcosh // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
    || Math.floor(nativeAcosh(Number.MAX_VALUE)) != 710 // Tor Browser bug: Math.acosh(Infinity) -> NaN
    || nativeAcosh(Infinity) != Infinity; // `Math.acosh` method
    // https://tc39.github.io/ecma262/#sec-math.acosh

    $({
      target: 'Math',
      stat: true,
      forced: FORCED
    }, {
      acosh: function acosh(x) {
        return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? log(x) + LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.math.asinh.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/modules/es.math.asinh.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsMathAsinhJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var nativeAsinh = Math.asinh;
    var log = Math.log;
    var sqrt = Math.sqrt;

    function asinh(x) {
      return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log(x + sqrt(x * x + 1));
    } // `Math.asinh` method
    // https://tc39.github.io/ecma262/#sec-math.asinh
    // Tor Browser bug: Math.asinh(0) -> -0


    $({
      target: 'Math',
      stat: true,
      forced: !(nativeAsinh && 1 / nativeAsinh(0) > 0)
    }, {
      asinh: asinh
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.math.atanh.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/modules/es.math.atanh.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsMathAtanhJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var nativeAtanh = Math.atanh;
    var log = Math.log; // `Math.atanh` method
    // https://tc39.github.io/ecma262/#sec-math.atanh
    // Tor Browser bug: Math.atanh(-0) -> 0

    $({
      target: 'Math',
      stat: true,
      forced: !(nativeAtanh && 1 / nativeAtanh(-0) < 0)
    }, {
      atanh: function atanh(x) {
        return (x = +x) == 0 ? x : log((1 + x) / (1 - x)) / 2;
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.math.cbrt.js":
  /*!******************************************************!*\
    !*** ./node_modules/core-js/modules/es.math.cbrt.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsMathCbrtJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var sign = __webpack_require__(
    /*! ../internals/math-sign */
    "./node_modules/core-js/internals/math-sign.js");

    var abs = Math.abs;
    var pow = Math.pow; // `Math.cbrt` method
    // https://tc39.github.io/ecma262/#sec-math.cbrt

    $({
      target: 'Math',
      stat: true
    }, {
      cbrt: function cbrt(x) {
        return sign(x = +x) * pow(abs(x), 1 / 3);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.math.clz32.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/modules/es.math.clz32.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsMathClz32Js(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var floor = Math.floor;
    var log = Math.log;
    var LOG2E = Math.LOG2E; // `Math.clz32` method
    // https://tc39.github.io/ecma262/#sec-math.clz32

    $({
      target: 'Math',
      stat: true
    }, {
      clz32: function clz32(x) {
        return (x >>>= 0) ? 31 - floor(log(x + 0.5) * LOG2E) : 32;
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.math.cosh.js":
  /*!******************************************************!*\
    !*** ./node_modules/core-js/modules/es.math.cosh.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsMathCoshJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var expm1 = __webpack_require__(
    /*! ../internals/math-expm1 */
    "./node_modules/core-js/internals/math-expm1.js");

    var nativeCosh = Math.cosh;
    var abs = Math.abs;
    var E = Math.E; // `Math.cosh` method
    // https://tc39.github.io/ecma262/#sec-math.cosh

    $({
      target: 'Math',
      stat: true,
      forced: !nativeCosh || nativeCosh(710) === Infinity
    }, {
      cosh: function cosh(x) {
        var t = expm1(abs(x) - 1) + 1;
        return (t + 1 / (t * E * E)) * (E / 2);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.math.expm1.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/modules/es.math.expm1.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsMathExpm1Js(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var expm1 = __webpack_require__(
    /*! ../internals/math-expm1 */
    "./node_modules/core-js/internals/math-expm1.js"); // `Math.expm1` method
    // https://tc39.github.io/ecma262/#sec-math.expm1


    $({
      target: 'Math',
      stat: true,
      forced: expm1 != Math.expm1
    }, {
      expm1: expm1
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.math.fround.js":
  /*!********************************************************!*\
    !*** ./node_modules/core-js/modules/es.math.fround.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsMathFroundJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var fround = __webpack_require__(
    /*! ../internals/math-fround */
    "./node_modules/core-js/internals/math-fround.js"); // `Math.fround` method
    // https://tc39.github.io/ecma262/#sec-math.fround


    $({
      target: 'Math',
      stat: true
    }, {
      fround: fround
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.math.hypot.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/modules/es.math.hypot.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsMathHypotJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var $hypot = Math.hypot;
    var abs = Math.abs;
    var sqrt = Math.sqrt; // Chrome 77 bug
    // https://bugs.chromium.org/p/v8/issues/detail?id=9546

    var BUGGY = !!$hypot && $hypot(Infinity, NaN) !== Infinity; // `Math.hypot` method
    // https://tc39.github.io/ecma262/#sec-math.hypot

    $({
      target: 'Math',
      stat: true,
      forced: BUGGY
    }, {
      hypot: function hypot(value1, value2) {
        // eslint-disable-line no-unused-vars
        var sum = 0;
        var i = 0;
        var aLen = arguments.length;
        var larg = 0;
        var arg, div;

        while (i < aLen) {
          arg = abs(arguments[i++]);

          if (larg < arg) {
            div = larg / arg;
            sum = sum * div * div + 1;
            larg = arg;
          } else if (arg > 0) {
            div = arg / larg;
            sum += div * div;
          } else sum += arg;
        }

        return larg === Infinity ? Infinity : larg * sqrt(sum);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.math.imul.js":
  /*!******************************************************!*\
    !*** ./node_modules/core-js/modules/es.math.imul.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsMathImulJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var nativeImul = Math.imul;
    var FORCED = fails(function () {
      return nativeImul(0xFFFFFFFF, 5) != -5 || nativeImul.length != 2;
    }); // `Math.imul` method
    // https://tc39.github.io/ecma262/#sec-math.imul
    // some WebKit versions fails with big numbers, some has wrong arity

    $({
      target: 'Math',
      stat: true,
      forced: FORCED
    }, {
      imul: function imul(x, y) {
        var UINT16 = 0xFFFF;
        var xn = +x;
        var yn = +y;
        var xl = UINT16 & xn;
        var yl = UINT16 & yn;
        return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.math.log10.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/modules/es.math.log10.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsMathLog10Js(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var log = Math.log;
    var LOG10E = Math.LOG10E; // `Math.log10` method
    // https://tc39.github.io/ecma262/#sec-math.log10

    $({
      target: 'Math',
      stat: true
    }, {
      log10: function log10(x) {
        return log(x) * LOG10E;
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.math.log1p.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/modules/es.math.log1p.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsMathLog1pJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var log1p = __webpack_require__(
    /*! ../internals/math-log1p */
    "./node_modules/core-js/internals/math-log1p.js"); // `Math.log1p` method
    // https://tc39.github.io/ecma262/#sec-math.log1p


    $({
      target: 'Math',
      stat: true
    }, {
      log1p: log1p
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.math.log2.js":
  /*!******************************************************!*\
    !*** ./node_modules/core-js/modules/es.math.log2.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsMathLog2Js(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var log = Math.log;
    var LN2 = Math.LN2; // `Math.log2` method
    // https://tc39.github.io/ecma262/#sec-math.log2

    $({
      target: 'Math',
      stat: true
    }, {
      log2: function log2(x) {
        return log(x) / LN2;
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.math.sign.js":
  /*!******************************************************!*\
    !*** ./node_modules/core-js/modules/es.math.sign.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsMathSignJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var sign = __webpack_require__(
    /*! ../internals/math-sign */
    "./node_modules/core-js/internals/math-sign.js"); // `Math.sign` method
    // https://tc39.github.io/ecma262/#sec-math.sign


    $({
      target: 'Math',
      stat: true
    }, {
      sign: sign
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.math.sinh.js":
  /*!******************************************************!*\
    !*** ./node_modules/core-js/modules/es.math.sinh.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsMathSinhJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var expm1 = __webpack_require__(
    /*! ../internals/math-expm1 */
    "./node_modules/core-js/internals/math-expm1.js");

    var abs = Math.abs;
    var exp = Math.exp;
    var E = Math.E;
    var FORCED = fails(function () {
      return Math.sinh(-2e-17) != -2e-17;
    }); // `Math.sinh` method
    // https://tc39.github.io/ecma262/#sec-math.sinh
    // V8 near Chromium 38 has a problem with very small numbers

    $({
      target: 'Math',
      stat: true,
      forced: FORCED
    }, {
      sinh: function sinh(x) {
        return abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (E / 2);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.math.tanh.js":
  /*!******************************************************!*\
    !*** ./node_modules/core-js/modules/es.math.tanh.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsMathTanhJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var expm1 = __webpack_require__(
    /*! ../internals/math-expm1 */
    "./node_modules/core-js/internals/math-expm1.js");

    var exp = Math.exp; // `Math.tanh` method
    // https://tc39.github.io/ecma262/#sec-math.tanh

    $({
      target: 'Math',
      stat: true
    }, {
      tanh: function tanh(x) {
        var a = expm1(x = +x);
        var b = expm1(-x);
        return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.math.to-string-tag.js":
  /*!***************************************************************!*\
    !*** ./node_modules/core-js/modules/es.math.to-string-tag.js ***!
    \***************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsMathToStringTagJs(module, exports, __webpack_require__) {
    var setToStringTag = __webpack_require__(
    /*! ../internals/set-to-string-tag */
    "./node_modules/core-js/internals/set-to-string-tag.js"); // Math[@@toStringTag] property
    // https://tc39.github.io/ecma262/#sec-math-@@tostringtag


    setToStringTag(Math, 'Math', true);
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.math.trunc.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/modules/es.math.trunc.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsMathTruncJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var ceil = Math.ceil;
    var floor = Math.floor; // `Math.trunc` method
    // https://tc39.github.io/ecma262/#sec-math.trunc

    $({
      target: 'Math',
      stat: true
    }, {
      trunc: function trunc(it) {
        return (it > 0 ? floor : ceil)(it);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.number.constructor.js":
  /*!***************************************************************!*\
    !*** ./node_modules/core-js/modules/es.number.constructor.js ***!
    \***************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsNumberConstructorJs(module, exports, __webpack_require__) {
    "use strict";

    var DESCRIPTORS = __webpack_require__(
    /*! ../internals/descriptors */
    "./node_modules/core-js/internals/descriptors.js");

    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    var isForced = __webpack_require__(
    /*! ../internals/is-forced */
    "./node_modules/core-js/internals/is-forced.js");

    var redefine = __webpack_require__(
    /*! ../internals/redefine */
    "./node_modules/core-js/internals/redefine.js");

    var has = __webpack_require__(
    /*! ../internals/has */
    "./node_modules/core-js/internals/has.js");

    var classof = __webpack_require__(
    /*! ../internals/classof-raw */
    "./node_modules/core-js/internals/classof-raw.js");

    var inheritIfRequired = __webpack_require__(
    /*! ../internals/inherit-if-required */
    "./node_modules/core-js/internals/inherit-if-required.js");

    var toPrimitive = __webpack_require__(
    /*! ../internals/to-primitive */
    "./node_modules/core-js/internals/to-primitive.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var create = __webpack_require__(
    /*! ../internals/object-create */
    "./node_modules/core-js/internals/object-create.js");

    var getOwnPropertyNames = __webpack_require__(
    /*! ../internals/object-get-own-property-names */
    "./node_modules/core-js/internals/object-get-own-property-names.js").f;

    var getOwnPropertyDescriptor = __webpack_require__(
    /*! ../internals/object-get-own-property-descriptor */
    "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;

    var defineProperty = __webpack_require__(
    /*! ../internals/object-define-property */
    "./node_modules/core-js/internals/object-define-property.js").f;

    var trim = __webpack_require__(
    /*! ../internals/string-trim */
    "./node_modules/core-js/internals/string-trim.js").trim;

    var NUMBER = 'Number';
    var NativeNumber = global[NUMBER];
    var NumberPrototype = NativeNumber.prototype; // Opera ~12 has broken Object#toString

    var BROKEN_CLASSOF = classof(create(NumberPrototype)) == NUMBER; // `ToNumber` abstract operation
    // https://tc39.github.io/ecma262/#sec-tonumber

    var toNumber = function toNumber(argument) {
      var it = toPrimitive(argument, false);
      var first, third, radix, maxCode, digits, length, index, code;

      if (typeof it == 'string' && it.length > 2) {
        it = trim(it);
        first = it.charCodeAt(0);

        if (first === 43 || first === 45) {
          third = it.charCodeAt(2);
          if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
        } else if (first === 48) {
          switch (it.charCodeAt(1)) {
            case 66:
            case 98:
              radix = 2;
              maxCode = 49;
              break;
            // fast equal of /^0b[01]+$/i

            case 79:
            case 111:
              radix = 8;
              maxCode = 55;
              break;
            // fast equal of /^0o[0-7]+$/i

            default:
              return +it;
          }

          digits = it.slice(2);
          length = digits.length;

          for (index = 0; index < length; index++) {
            code = digits.charCodeAt(index); // parseInt parses a string to a first unavailable symbol
            // but ToNumber should return NaN if a string contains unavailable symbols

            if (code < 48 || code > maxCode) return NaN;
          }

          return parseInt(digits, radix);
        }
      }

      return +it;
    }; // `Number` constructor
    // https://tc39.github.io/ecma262/#sec-number-constructor


    if (isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
      var NumberWrapper = function Number(value) {
        var it = arguments.length < 1 ? 0 : value;
        var dummy = this;
        return dummy instanceof NumberWrapper // check on 1..constructor(foo) case
        && (BROKEN_CLASSOF ? fails(function () {
          NumberPrototype.valueOf.call(dummy);
        }) : classof(dummy) != NUMBER) ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
      };

      for (var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : ( // ES3:
      'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES2015 (in case, if modules with ES2015 Number statics required before):
      'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j = 0, key; keys.length > j; j++) {
        if (has(NativeNumber, key = keys[j]) && !has(NumberWrapper, key)) {
          defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));
        }
      }

      NumberWrapper.prototype = NumberPrototype;
      NumberPrototype.constructor = NumberWrapper;
      redefine(global, NUMBER, NumberWrapper);
    }
    /***/

  },

  /***/
  "./node_modules/core-js/modules/es.number.epsilon.js":
  /*!***********************************************************!*\
    !*** ./node_modules/core-js/modules/es.number.epsilon.js ***!
    \***********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsNumberEpsilonJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js"); // `Number.EPSILON` constant
    // https://tc39.github.io/ecma262/#sec-number.epsilon


    $({
      target: 'Number',
      stat: true
    }, {
      EPSILON: Math.pow(2, -52)
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.number.is-finite.js":
  /*!*************************************************************!*\
    !*** ./node_modules/core-js/modules/es.number.is-finite.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsNumberIsFiniteJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var numberIsFinite = __webpack_require__(
    /*! ../internals/number-is-finite */
    "./node_modules/core-js/internals/number-is-finite.js"); // `Number.isFinite` method
    // https://tc39.github.io/ecma262/#sec-number.isfinite


    $({
      target: 'Number',
      stat: true
    }, {
      isFinite: numberIsFinite
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.number.is-integer.js":
  /*!**************************************************************!*\
    !*** ./node_modules/core-js/modules/es.number.is-integer.js ***!
    \**************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsNumberIsIntegerJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var isInteger = __webpack_require__(
    /*! ../internals/is-integer */
    "./node_modules/core-js/internals/is-integer.js"); // `Number.isInteger` method
    // https://tc39.github.io/ecma262/#sec-number.isinteger


    $({
      target: 'Number',
      stat: true
    }, {
      isInteger: isInteger
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.number.is-nan.js":
  /*!**********************************************************!*\
    !*** ./node_modules/core-js/modules/es.number.is-nan.js ***!
    \**********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsNumberIsNanJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js"); // `Number.isNaN` method
    // https://tc39.github.io/ecma262/#sec-number.isnan


    $({
      target: 'Number',
      stat: true
    }, {
      isNaN: function isNaN(number) {
        // eslint-disable-next-line no-self-compare
        return number != number;
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.number.is-safe-integer.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/core-js/modules/es.number.is-safe-integer.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsNumberIsSafeIntegerJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var isInteger = __webpack_require__(
    /*! ../internals/is-integer */
    "./node_modules/core-js/internals/is-integer.js");

    var abs = Math.abs; // `Number.isSafeInteger` method
    // https://tc39.github.io/ecma262/#sec-number.issafeinteger

    $({
      target: 'Number',
      stat: true
    }, {
      isSafeInteger: function isSafeInteger(number) {
        return isInteger(number) && abs(number) <= 0x1FFFFFFFFFFFFF;
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.number.max-safe-integer.js":
  /*!********************************************************************!*\
    !*** ./node_modules/core-js/modules/es.number.max-safe-integer.js ***!
    \********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsNumberMaxSafeIntegerJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js"); // `Number.MAX_SAFE_INTEGER` constant
    // https://tc39.github.io/ecma262/#sec-number.max_safe_integer


    $({
      target: 'Number',
      stat: true
    }, {
      MAX_SAFE_INTEGER: 0x1FFFFFFFFFFFFF
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.number.min-safe-integer.js":
  /*!********************************************************************!*\
    !*** ./node_modules/core-js/modules/es.number.min-safe-integer.js ***!
    \********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsNumberMinSafeIntegerJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js"); // `Number.MIN_SAFE_INTEGER` constant
    // https://tc39.github.io/ecma262/#sec-number.min_safe_integer


    $({
      target: 'Number',
      stat: true
    }, {
      MIN_SAFE_INTEGER: -0x1FFFFFFFFFFFFF
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.number.parse-float.js":
  /*!***************************************************************!*\
    !*** ./node_modules/core-js/modules/es.number.parse-float.js ***!
    \***************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsNumberParseFloatJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var parseFloat = __webpack_require__(
    /*! ../internals/number-parse-float */
    "./node_modules/core-js/internals/number-parse-float.js"); // `Number.parseFloat` method
    // https://tc39.github.io/ecma262/#sec-number.parseFloat


    $({
      target: 'Number',
      stat: true,
      forced: Number.parseFloat != parseFloat
    }, {
      parseFloat: parseFloat
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.number.parse-int.js":
  /*!*************************************************************!*\
    !*** ./node_modules/core-js/modules/es.number.parse-int.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsNumberParseIntJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var parseInt = __webpack_require__(
    /*! ../internals/number-parse-int */
    "./node_modules/core-js/internals/number-parse-int.js"); // `Number.parseInt` method
    // https://tc39.github.io/ecma262/#sec-number.parseint


    $({
      target: 'Number',
      stat: true,
      forced: Number.parseInt != parseInt
    }, {
      parseInt: parseInt
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.number.to-fixed.js":
  /*!************************************************************!*\
    !*** ./node_modules/core-js/modules/es.number.to-fixed.js ***!
    \************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsNumberToFixedJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var toInteger = __webpack_require__(
    /*! ../internals/to-integer */
    "./node_modules/core-js/internals/to-integer.js");

    var thisNumberValue = __webpack_require__(
    /*! ../internals/this-number-value */
    "./node_modules/core-js/internals/this-number-value.js");

    var repeat = __webpack_require__(
    /*! ../internals/string-repeat */
    "./node_modules/core-js/internals/string-repeat.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var nativeToFixed = 1.0.toFixed;
    var floor = Math.floor;

    var pow = function pow(x, n, acc) {
      return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
    };

    var log = function log(x) {
      var n = 0;
      var x2 = x;

      while (x2 >= 4096) {
        n += 12;
        x2 /= 4096;
      }

      while (x2 >= 2) {
        n += 1;
        x2 /= 2;
      }

      return n;
    };

    var FORCED = nativeToFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128') || !fails(function () {
      // V8 ~ Android 4.3-
      nativeToFixed.call({});
    }); // `Number.prototype.toFixed` method
    // https://tc39.github.io/ecma262/#sec-number.prototype.tofixed

    $({
      target: 'Number',
      proto: true,
      forced: FORCED
    }, {
      // eslint-disable-next-line max-statements
      toFixed: function toFixed(fractionDigits) {
        var number = thisNumberValue(this);
        var fractDigits = toInteger(fractionDigits);
        var data = [0, 0, 0, 0, 0, 0];
        var sign = '';
        var result = '0';
        var e, z, j, k;

        var multiply = function multiply(n, c) {
          var index = -1;
          var c2 = c;

          while (++index < 6) {
            c2 += n * data[index];
            data[index] = c2 % 1e7;
            c2 = floor(c2 / 1e7);
          }
        };

        var divide = function divide(n) {
          var index = 6;
          var c = 0;

          while (--index >= 0) {
            c += data[index];
            data[index] = floor(c / n);
            c = c % n * 1e7;
          }
        };

        var dataToString = function dataToString() {
          var index = 6;
          var s = '';

          while (--index >= 0) {
            if (s !== '' || index === 0 || data[index] !== 0) {
              var t = String(data[index]);
              s = s === '' ? t : s + repeat.call('0', 7 - t.length) + t;
            }
          }

          return s;
        };

        if (fractDigits < 0 || fractDigits > 20) throw RangeError('Incorrect fraction digits'); // eslint-disable-next-line no-self-compare

        if (number != number) return 'NaN';
        if (number <= -1e21 || number >= 1e21) return String(number);

        if (number < 0) {
          sign = '-';
          number = -number;
        }

        if (number > 1e-21) {
          e = log(number * pow(2, 69, 1)) - 69;
          z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);
          z *= 0x10000000000000;
          e = 52 - e;

          if (e > 0) {
            multiply(0, z);
            j = fractDigits;

            while (j >= 7) {
              multiply(1e7, 0);
              j -= 7;
            }

            multiply(pow(10, j, 1), 0);
            j = e - 1;

            while (j >= 23) {
              divide(1 << 23);
              j -= 23;
            }

            divide(1 << j);
            multiply(1, 1);
            divide(2);
            result = dataToString();
          } else {
            multiply(0, z);
            multiply(1 << -e, 0);
            result = dataToString() + repeat.call('0', fractDigits);
          }
        }

        if (fractDigits > 0) {
          k = result.length;
          result = sign + (k <= fractDigits ? '0.' + repeat.call('0', fractDigits - k) + result : result.slice(0, k - fractDigits) + '.' + result.slice(k - fractDigits));
        } else {
          result = sign + result;
        }

        return result;
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.number.to-precision.js":
  /*!****************************************************************!*\
    !*** ./node_modules/core-js/modules/es.number.to-precision.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsNumberToPrecisionJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var thisNumberValue = __webpack_require__(
    /*! ../internals/this-number-value */
    "./node_modules/core-js/internals/this-number-value.js");

    var nativeToPrecision = 1.0.toPrecision;
    var FORCED = fails(function () {
      // IE7-
      return nativeToPrecision.call(1, undefined) !== '1';
    }) || !fails(function () {
      // V8 ~ Android 4.3-
      nativeToPrecision.call({});
    }); // `Number.prototype.toPrecision` method
    // https://tc39.github.io/ecma262/#sec-number.prototype.toprecision

    $({
      target: 'Number',
      proto: true,
      forced: FORCED
    }, {
      toPrecision: function toPrecision(precision) {
        return precision === undefined ? nativeToPrecision.call(thisNumberValue(this)) : nativeToPrecision.call(thisNumberValue(this), precision);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.object.assign.js":
  /*!**********************************************************!*\
    !*** ./node_modules/core-js/modules/es.object.assign.js ***!
    \**********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsObjectAssignJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var assign = __webpack_require__(
    /*! ../internals/object-assign */
    "./node_modules/core-js/internals/object-assign.js"); // `Object.assign` method
    // https://tc39.github.io/ecma262/#sec-object.assign


    $({
      target: 'Object',
      stat: true,
      forced: Object.assign !== assign
    }, {
      assign: assign
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.object.create.js":
  /*!**********************************************************!*\
    !*** ./node_modules/core-js/modules/es.object.create.js ***!
    \**********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsObjectCreateJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var DESCRIPTORS = __webpack_require__(
    /*! ../internals/descriptors */
    "./node_modules/core-js/internals/descriptors.js");

    var create = __webpack_require__(
    /*! ../internals/object-create */
    "./node_modules/core-js/internals/object-create.js"); // `Object.create` method
    // https://tc39.github.io/ecma262/#sec-object.create


    $({
      target: 'Object',
      stat: true,
      sham: !DESCRIPTORS
    }, {
      create: create
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.object.define-properties.js":
  /*!*********************************************************************!*\
    !*** ./node_modules/core-js/modules/es.object.define-properties.js ***!
    \*********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsObjectDefinePropertiesJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var DESCRIPTORS = __webpack_require__(
    /*! ../internals/descriptors */
    "./node_modules/core-js/internals/descriptors.js");

    var defineProperties = __webpack_require__(
    /*! ../internals/object-define-properties */
    "./node_modules/core-js/internals/object-define-properties.js"); // `Object.defineProperties` method
    // https://tc39.github.io/ecma262/#sec-object.defineproperties


    $({
      target: 'Object',
      stat: true,
      forced: !DESCRIPTORS,
      sham: !DESCRIPTORS
    }, {
      defineProperties: defineProperties
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.object.define-property.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/core-js/modules/es.object.define-property.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsObjectDefinePropertyJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var DESCRIPTORS = __webpack_require__(
    /*! ../internals/descriptors */
    "./node_modules/core-js/internals/descriptors.js");

    var objectDefinePropertyModile = __webpack_require__(
    /*! ../internals/object-define-property */
    "./node_modules/core-js/internals/object-define-property.js"); // `Object.defineProperty` method
    // https://tc39.github.io/ecma262/#sec-object.defineproperty


    $({
      target: 'Object',
      stat: true,
      forced: !DESCRIPTORS,
      sham: !DESCRIPTORS
    }, {
      defineProperty: objectDefinePropertyModile.f
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.object.freeze.js":
  /*!**********************************************************!*\
    !*** ./node_modules/core-js/modules/es.object.freeze.js ***!
    \**********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsObjectFreezeJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var FREEZING = __webpack_require__(
    /*! ../internals/freezing */
    "./node_modules/core-js/internals/freezing.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    var onFreeze = __webpack_require__(
    /*! ../internals/internal-metadata */
    "./node_modules/core-js/internals/internal-metadata.js").onFreeze;

    var nativeFreeze = Object.freeze;
    var FAILS_ON_PRIMITIVES = fails(function () {
      nativeFreeze(1);
    }); // `Object.freeze` method
    // https://tc39.github.io/ecma262/#sec-object.freeze

    $({
      target: 'Object',
      stat: true,
      forced: FAILS_ON_PRIMITIVES,
      sham: !FREEZING
    }, {
      freeze: function freeze(it) {
        return nativeFreeze && isObject(it) ? nativeFreeze(onFreeze(it)) : it;
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.object.get-own-property-descriptor.js":
  /*!*******************************************************************************!*\
    !*** ./node_modules/core-js/modules/es.object.get-own-property-descriptor.js ***!
    \*******************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsObjectGetOwnPropertyDescriptorJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var toIndexedObject = __webpack_require__(
    /*! ../internals/to-indexed-object */
    "./node_modules/core-js/internals/to-indexed-object.js");

    var nativeGetOwnPropertyDescriptor = __webpack_require__(
    /*! ../internals/object-get-own-property-descriptor */
    "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;

    var DESCRIPTORS = __webpack_require__(
    /*! ../internals/descriptors */
    "./node_modules/core-js/internals/descriptors.js");

    var FAILS_ON_PRIMITIVES = fails(function () {
      nativeGetOwnPropertyDescriptor(1);
    });
    var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES; // `Object.getOwnPropertyDescriptor` method
    // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor

    $({
      target: 'Object',
      stat: true,
      forced: FORCED,
      sham: !DESCRIPTORS
    }, {
      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
        return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.object.get-own-property-names.js":
  /*!**************************************************************************!*\
    !*** ./node_modules/core-js/modules/es.object.get-own-property-names.js ***!
    \**************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsObjectGetOwnPropertyNamesJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var nativeGetOwnPropertyNames = __webpack_require__(
    /*! ../internals/object-get-own-property-names-external */
    "./node_modules/core-js/internals/object-get-own-property-names-external.js").f;

    var FAILS_ON_PRIMITIVES = fails(function () {
      return !Object.getOwnPropertyNames(1);
    }); // `Object.getOwnPropertyNames` method
    // https://tc39.github.io/ecma262/#sec-object.getownpropertynames

    $({
      target: 'Object',
      stat: true,
      forced: FAILS_ON_PRIMITIVES
    }, {
      getOwnPropertyNames: nativeGetOwnPropertyNames
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.object.get-prototype-of.js":
  /*!********************************************************************!*\
    !*** ./node_modules/core-js/modules/es.object.get-prototype-of.js ***!
    \********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsObjectGetPrototypeOfJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var toObject = __webpack_require__(
    /*! ../internals/to-object */
    "./node_modules/core-js/internals/to-object.js");

    var nativeGetPrototypeOf = __webpack_require__(
    /*! ../internals/object-get-prototype-of */
    "./node_modules/core-js/internals/object-get-prototype-of.js");

    var CORRECT_PROTOTYPE_GETTER = __webpack_require__(
    /*! ../internals/correct-prototype-getter */
    "./node_modules/core-js/internals/correct-prototype-getter.js");

    var FAILS_ON_PRIMITIVES = fails(function () {
      nativeGetPrototypeOf(1);
    }); // `Object.getPrototypeOf` method
    // https://tc39.github.io/ecma262/#sec-object.getprototypeof

    $({
      target: 'Object',
      stat: true,
      forced: FAILS_ON_PRIMITIVES,
      sham: !CORRECT_PROTOTYPE_GETTER
    }, {
      getPrototypeOf: function getPrototypeOf(it) {
        return nativeGetPrototypeOf(toObject(it));
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.object.is-extensible.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/core-js/modules/es.object.is-extensible.js ***!
    \*****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsObjectIsExtensibleJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    var nativeIsExtensible = Object.isExtensible;
    var FAILS_ON_PRIMITIVES = fails(function () {
      nativeIsExtensible(1);
    }); // `Object.isExtensible` method
    // https://tc39.github.io/ecma262/#sec-object.isextensible

    $({
      target: 'Object',
      stat: true,
      forced: FAILS_ON_PRIMITIVES
    }, {
      isExtensible: function isExtensible(it) {
        return isObject(it) ? nativeIsExtensible ? nativeIsExtensible(it) : true : false;
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.object.is-frozen.js":
  /*!*************************************************************!*\
    !*** ./node_modules/core-js/modules/es.object.is-frozen.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsObjectIsFrozenJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    var nativeIsFrozen = Object.isFrozen;
    var FAILS_ON_PRIMITIVES = fails(function () {
      nativeIsFrozen(1);
    }); // `Object.isFrozen` method
    // https://tc39.github.io/ecma262/#sec-object.isfrozen

    $({
      target: 'Object',
      stat: true,
      forced: FAILS_ON_PRIMITIVES
    }, {
      isFrozen: function isFrozen(it) {
        return isObject(it) ? nativeIsFrozen ? nativeIsFrozen(it) : false : true;
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.object.is-sealed.js":
  /*!*************************************************************!*\
    !*** ./node_modules/core-js/modules/es.object.is-sealed.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsObjectIsSealedJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    var nativeIsSealed = Object.isSealed;
    var FAILS_ON_PRIMITIVES = fails(function () {
      nativeIsSealed(1);
    }); // `Object.isSealed` method
    // https://tc39.github.io/ecma262/#sec-object.issealed

    $({
      target: 'Object',
      stat: true,
      forced: FAILS_ON_PRIMITIVES
    }, {
      isSealed: function isSealed(it) {
        return isObject(it) ? nativeIsSealed ? nativeIsSealed(it) : false : true;
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.object.is.js":
  /*!******************************************************!*\
    !*** ./node_modules/core-js/modules/es.object.is.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsObjectIsJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var is = __webpack_require__(
    /*! ../internals/same-value */
    "./node_modules/core-js/internals/same-value.js"); // `Object.is` method
    // https://tc39.github.io/ecma262/#sec-object.is


    $({
      target: 'Object',
      stat: true
    }, {
      is: is
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.object.keys.js":
  /*!********************************************************!*\
    !*** ./node_modules/core-js/modules/es.object.keys.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsObjectKeysJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var toObject = __webpack_require__(
    /*! ../internals/to-object */
    "./node_modules/core-js/internals/to-object.js");

    var nativeKeys = __webpack_require__(
    /*! ../internals/object-keys */
    "./node_modules/core-js/internals/object-keys.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var FAILS_ON_PRIMITIVES = fails(function () {
      nativeKeys(1);
    }); // `Object.keys` method
    // https://tc39.github.io/ecma262/#sec-object.keys

    $({
      target: 'Object',
      stat: true,
      forced: FAILS_ON_PRIMITIVES
    }, {
      keys: function keys(it) {
        return nativeKeys(toObject(it));
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.object.prevent-extensions.js":
  /*!**********************************************************************!*\
    !*** ./node_modules/core-js/modules/es.object.prevent-extensions.js ***!
    \**********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsObjectPreventExtensionsJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    var onFreeze = __webpack_require__(
    /*! ../internals/internal-metadata */
    "./node_modules/core-js/internals/internal-metadata.js").onFreeze;

    var FREEZING = __webpack_require__(
    /*! ../internals/freezing */
    "./node_modules/core-js/internals/freezing.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var nativePreventExtensions = Object.preventExtensions;
    var FAILS_ON_PRIMITIVES = fails(function () {
      nativePreventExtensions(1);
    }); // `Object.preventExtensions` method
    // https://tc39.github.io/ecma262/#sec-object.preventextensions

    $({
      target: 'Object',
      stat: true,
      forced: FAILS_ON_PRIMITIVES,
      sham: !FREEZING
    }, {
      preventExtensions: function preventExtensions(it) {
        return nativePreventExtensions && isObject(it) ? nativePreventExtensions(onFreeze(it)) : it;
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.object.seal.js":
  /*!********************************************************!*\
    !*** ./node_modules/core-js/modules/es.object.seal.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsObjectSealJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    var onFreeze = __webpack_require__(
    /*! ../internals/internal-metadata */
    "./node_modules/core-js/internals/internal-metadata.js").onFreeze;

    var FREEZING = __webpack_require__(
    /*! ../internals/freezing */
    "./node_modules/core-js/internals/freezing.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var nativeSeal = Object.seal;
    var FAILS_ON_PRIMITIVES = fails(function () {
      nativeSeal(1);
    }); // `Object.seal` method
    // https://tc39.github.io/ecma262/#sec-object.seal

    $({
      target: 'Object',
      stat: true,
      forced: FAILS_ON_PRIMITIVES,
      sham: !FREEZING
    }, {
      seal: function seal(it) {
        return nativeSeal && isObject(it) ? nativeSeal(onFreeze(it)) : it;
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.object.set-prototype-of.js":
  /*!********************************************************************!*\
    !*** ./node_modules/core-js/modules/es.object.set-prototype-of.js ***!
    \********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsObjectSetPrototypeOfJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var setPrototypeOf = __webpack_require__(
    /*! ../internals/object-set-prototype-of */
    "./node_modules/core-js/internals/object-set-prototype-of.js"); // `Object.setPrototypeOf` method
    // https://tc39.github.io/ecma262/#sec-object.setprototypeof


    $({
      target: 'Object',
      stat: true
    }, {
      setPrototypeOf: setPrototypeOf
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.object.to-string.js":
  /*!*************************************************************!*\
    !*** ./node_modules/core-js/modules/es.object.to-string.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsObjectToStringJs(module, exports, __webpack_require__) {
    var TO_STRING_TAG_SUPPORT = __webpack_require__(
    /*! ../internals/to-string-tag-support */
    "./node_modules/core-js/internals/to-string-tag-support.js");

    var redefine = __webpack_require__(
    /*! ../internals/redefine */
    "./node_modules/core-js/internals/redefine.js");

    var toString = __webpack_require__(
    /*! ../internals/object-to-string */
    "./node_modules/core-js/internals/object-to-string.js"); // `Object.prototype.toString` method
    // https://tc39.github.io/ecma262/#sec-object.prototype.tostring


    if (!TO_STRING_TAG_SUPPORT) {
      redefine(Object.prototype, 'toString', toString, {
        unsafe: true
      });
    }
    /***/

  },

  /***/
  "./node_modules/core-js/modules/es.parse-float.js":
  /*!********************************************************!*\
    !*** ./node_modules/core-js/modules/es.parse-float.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsParseFloatJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var parseFloatImplementation = __webpack_require__(
    /*! ../internals/number-parse-float */
    "./node_modules/core-js/internals/number-parse-float.js"); // `parseFloat` method
    // https://tc39.github.io/ecma262/#sec-parsefloat-string


    $({
      global: true,
      forced: parseFloat != parseFloatImplementation
    }, {
      parseFloat: parseFloatImplementation
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.parse-int.js":
  /*!******************************************************!*\
    !*** ./node_modules/core-js/modules/es.parse-int.js ***!
    \******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsParseIntJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var parseIntImplementation = __webpack_require__(
    /*! ../internals/number-parse-int */
    "./node_modules/core-js/internals/number-parse-int.js"); // `parseInt` method
    // https://tc39.github.io/ecma262/#sec-parseint-string-radix


    $({
      global: true,
      forced: parseInt != parseIntImplementation
    }, {
      parseInt: parseIntImplementation
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.promise.js":
  /*!****************************************************!*\
    !*** ./node_modules/core-js/modules/es.promise.js ***!
    \****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsPromiseJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var IS_PURE = __webpack_require__(
    /*! ../internals/is-pure */
    "./node_modules/core-js/internals/is-pure.js");

    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    var getBuiltIn = __webpack_require__(
    /*! ../internals/get-built-in */
    "./node_modules/core-js/internals/get-built-in.js");

    var NativePromise = __webpack_require__(
    /*! ../internals/native-promise-constructor */
    "./node_modules/core-js/internals/native-promise-constructor.js");

    var redefine = __webpack_require__(
    /*! ../internals/redefine */
    "./node_modules/core-js/internals/redefine.js");

    var redefineAll = __webpack_require__(
    /*! ../internals/redefine-all */
    "./node_modules/core-js/internals/redefine-all.js");

    var setToStringTag = __webpack_require__(
    /*! ../internals/set-to-string-tag */
    "./node_modules/core-js/internals/set-to-string-tag.js");

    var setSpecies = __webpack_require__(
    /*! ../internals/set-species */
    "./node_modules/core-js/internals/set-species.js");

    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    var aFunction = __webpack_require__(
    /*! ../internals/a-function */
    "./node_modules/core-js/internals/a-function.js");

    var anInstance = __webpack_require__(
    /*! ../internals/an-instance */
    "./node_modules/core-js/internals/an-instance.js");

    var classof = __webpack_require__(
    /*! ../internals/classof-raw */
    "./node_modules/core-js/internals/classof-raw.js");

    var inspectSource = __webpack_require__(
    /*! ../internals/inspect-source */
    "./node_modules/core-js/internals/inspect-source.js");

    var iterate = __webpack_require__(
    /*! ../internals/iterate */
    "./node_modules/core-js/internals/iterate.js");

    var checkCorrectnessOfIteration = __webpack_require__(
    /*! ../internals/check-correctness-of-iteration */
    "./node_modules/core-js/internals/check-correctness-of-iteration.js");

    var speciesConstructor = __webpack_require__(
    /*! ../internals/species-constructor */
    "./node_modules/core-js/internals/species-constructor.js");

    var task = __webpack_require__(
    /*! ../internals/task */
    "./node_modules/core-js/internals/task.js").set;

    var microtask = __webpack_require__(
    /*! ../internals/microtask */
    "./node_modules/core-js/internals/microtask.js");

    var promiseResolve = __webpack_require__(
    /*! ../internals/promise-resolve */
    "./node_modules/core-js/internals/promise-resolve.js");

    var hostReportErrors = __webpack_require__(
    /*! ../internals/host-report-errors */
    "./node_modules/core-js/internals/host-report-errors.js");

    var newPromiseCapabilityModule = __webpack_require__(
    /*! ../internals/new-promise-capability */
    "./node_modules/core-js/internals/new-promise-capability.js");

    var perform = __webpack_require__(
    /*! ../internals/perform */
    "./node_modules/core-js/internals/perform.js");

    var InternalStateModule = __webpack_require__(
    /*! ../internals/internal-state */
    "./node_modules/core-js/internals/internal-state.js");

    var isForced = __webpack_require__(
    /*! ../internals/is-forced */
    "./node_modules/core-js/internals/is-forced.js");

    var wellKnownSymbol = __webpack_require__(
    /*! ../internals/well-known-symbol */
    "./node_modules/core-js/internals/well-known-symbol.js");

    var V8_VERSION = __webpack_require__(
    /*! ../internals/engine-v8-version */
    "./node_modules/core-js/internals/engine-v8-version.js");

    var SPECIES = wellKnownSymbol('species');
    var PROMISE = 'Promise';
    var getInternalState = InternalStateModule.get;
    var setInternalState = InternalStateModule.set;
    var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
    var PromiseConstructor = NativePromise;
    var TypeError = global.TypeError;
    var document = global.document;
    var process = global.process;
    var $fetch = getBuiltIn('fetch');
    var newPromiseCapability = newPromiseCapabilityModule.f;
    var newGenericPromiseCapability = newPromiseCapability;
    var IS_NODE = classof(process) == 'process';
    var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
    var UNHANDLED_REJECTION = 'unhandledrejection';
    var REJECTION_HANDLED = 'rejectionhandled';
    var PENDING = 0;
    var FULFILLED = 1;
    var REJECTED = 2;
    var HANDLED = 1;
    var UNHANDLED = 2;
    var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
    var FORCED = isForced(PROMISE, function () {
      var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);

      if (!GLOBAL_CORE_JS_PROMISE) {
        // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
        // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
        // We can't detect it synchronously, so just check versions
        if (V8_VERSION === 66) return true; // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test

        if (!IS_NODE && typeof PromiseRejectionEvent != 'function') return true;
      } // We need Promise#finally in the pure version for preventing prototype pollution


      if (IS_PURE && !PromiseConstructor.prototype['finally']) return true; // We can't use @@species feature detection in V8 since it causes
      // deoptimization and performance degradation
      // https://github.com/zloirock/core-js/issues/679

      if (V8_VERSION >= 51 && /native code/.test(PromiseConstructor)) return false; // Detect correctness of subclassing with @@species support

      var promise = PromiseConstructor.resolve(1);

      var FakePromise = function FakePromise(exec) {
        exec(function () {
          /* empty */
        }, function () {
          /* empty */
        });
      };

      var constructor = promise.constructor = {};
      constructor[SPECIES] = FakePromise;
      return !(promise.then(function () {
        /* empty */
      }) instanceof FakePromise);
    });
    var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {
      PromiseConstructor.all(iterable)['catch'](function () {
        /* empty */
      });
    }); // helpers

    var isThenable = function isThenable(it) {
      var then;
      return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
    };

    var notify = function notify(promise, state, isReject) {
      if (state.notified) return;
      state.notified = true;
      var chain = state.reactions;
      microtask(function () {
        var value = state.value;
        var ok = state.state == FULFILLED;
        var index = 0; // variable length - can't use forEach

        while (chain.length > index) {
          var reaction = chain[index++];
          var handler = ok ? reaction.ok : reaction.fail;
          var resolve = reaction.resolve;
          var reject = reaction.reject;
          var domain = reaction.domain;
          var result, then, exited;

          try {
            if (handler) {
              if (!ok) {
                if (state.rejection === UNHANDLED) onHandleUnhandled(promise, state);
                state.rejection = HANDLED;
              }

              if (handler === true) result = value;else {
                if (domain) domain.enter();
                result = handler(value); // can throw

                if (domain) {
                  domain.exit();
                  exited = true;
                }
              }

              if (result === reaction.promise) {
                reject(TypeError('Promise-chain cycle'));
              } else if (then = isThenable(result)) {
                then.call(result, resolve, reject);
              } else resolve(result);
            } else reject(value);
          } catch (error) {
            if (domain && !exited) domain.exit();
            reject(error);
          }
        }

        state.reactions = [];
        state.notified = false;
        if (isReject && !state.rejection) onUnhandled(promise, state);
      });
    };

    var dispatchEvent = function dispatchEvent(name, promise, reason) {
      var event, handler;

      if (DISPATCH_EVENT) {
        event = document.createEvent('Event');
        event.promise = promise;
        event.reason = reason;
        event.initEvent(name, false, true);
        global.dispatchEvent(event);
      } else event = {
        promise: promise,
        reason: reason
      };

      if (handler = global['on' + name]) handler(event);else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
    };

    var onUnhandled = function onUnhandled(promise, state) {
      task.call(global, function () {
        var value = state.value;
        var IS_UNHANDLED = isUnhandled(state);
        var result;

        if (IS_UNHANDLED) {
          result = perform(function () {
            if (IS_NODE) {
              process.emit('unhandledRejection', value, promise);
            } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
          }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should

          state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
          if (result.error) throw result.value;
        }
      });
    };

    var isUnhandled = function isUnhandled(state) {
      return state.rejection !== HANDLED && !state.parent;
    };

    var onHandleUnhandled = function onHandleUnhandled(promise, state) {
      task.call(global, function () {
        if (IS_NODE) {
          process.emit('rejectionHandled', promise);
        } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
      });
    };

    var bind = function bind(fn, promise, state, unwrap) {
      return function (value) {
        fn(promise, state, value, unwrap);
      };
    };

    var internalReject = function internalReject(promise, state, value, unwrap) {
      if (state.done) return;
      state.done = true;
      if (unwrap) state = unwrap;
      state.value = value;
      state.state = REJECTED;
      notify(promise, state, true);
    };

    var internalResolve = function internalResolve(promise, state, value, unwrap) {
      if (state.done) return;
      state.done = true;
      if (unwrap) state = unwrap;

      try {
        if (promise === value) throw TypeError("Promise can't be resolved itself");
        var then = isThenable(value);

        if (then) {
          microtask(function () {
            var wrapper = {
              done: false
            };

            try {
              then.call(value, bind(internalResolve, promise, wrapper, state), bind(internalReject, promise, wrapper, state));
            } catch (error) {
              internalReject(promise, wrapper, error, state);
            }
          });
        } else {
          state.value = value;
          state.state = FULFILLED;
          notify(promise, state, false);
        }
      } catch (error) {
        internalReject(promise, {
          done: false
        }, error, state);
      }
    }; // constructor polyfill


    if (FORCED) {
      // 25.4.3.1 Promise(executor)
      PromiseConstructor = function Promise(executor) {
        anInstance(this, PromiseConstructor, PROMISE);
        aFunction(executor);
        Internal.call(this);
        var state = getInternalState(this);

        try {
          executor(bind(internalResolve, this, state), bind(internalReject, this, state));
        } catch (error) {
          internalReject(this, state, error);
        }
      }; // eslint-disable-next-line no-unused-vars


      Internal = function Promise(executor) {
        setInternalState(this, {
          type: PROMISE,
          done: false,
          notified: false,
          parent: false,
          reactions: [],
          rejection: false,
          state: PENDING,
          value: undefined
        });
      };

      Internal.prototype = redefineAll(PromiseConstructor.prototype, {
        // `Promise.prototype.then` method
        // https://tc39.github.io/ecma262/#sec-promise.prototype.then
        then: function then(onFulfilled, onRejected) {
          var state = getInternalPromiseState(this);
          var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
          reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
          reaction.fail = typeof onRejected == 'function' && onRejected;
          reaction.domain = IS_NODE ? process.domain : undefined;
          state.parent = true;
          state.reactions.push(reaction);
          if (state.state != PENDING) notify(this, state, false);
          return reaction.promise;
        },
        // `Promise.prototype.catch` method
        // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
        'catch': function _catch(onRejected) {
          return this.then(undefined, onRejected);
        }
      });

      OwnPromiseCapability = function OwnPromiseCapability() {
        var promise = new Internal();
        var state = getInternalState(promise);
        this.promise = promise;
        this.resolve = bind(internalResolve, promise, state);
        this.reject = bind(internalReject, promise, state);
      };

      newPromiseCapabilityModule.f = newPromiseCapability = function newPromiseCapability(C) {
        return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
      };

      if (!IS_PURE && typeof NativePromise == 'function') {
        nativeThen = NativePromise.prototype.then; // wrap native Promise#then for native async functions

        redefine(NativePromise.prototype, 'then', function then(onFulfilled, onRejected) {
          var that = this;
          return new PromiseConstructor(function (resolve, reject) {
            nativeThen.call(that, resolve, reject);
          }).then(onFulfilled, onRejected); // https://github.com/zloirock/core-js/issues/640
        }, {
          unsafe: true
        }); // wrap fetch result

        if (typeof $fetch == 'function') $({
          global: true,
          enumerable: true,
          forced: true
        }, {
          // eslint-disable-next-line no-unused-vars
          fetch: function fetch(input
          /* , init */
          ) {
            return promiseResolve(PromiseConstructor, $fetch.apply(global, arguments));
          }
        });
      }
    }

    $({
      global: true,
      wrap: true,
      forced: FORCED
    }, {
      Promise: PromiseConstructor
    });
    setToStringTag(PromiseConstructor, PROMISE, false, true);
    setSpecies(PROMISE);
    PromiseWrapper = getBuiltIn(PROMISE); // statics

    $({
      target: PROMISE,
      stat: true,
      forced: FORCED
    }, {
      // `Promise.reject` method
      // https://tc39.github.io/ecma262/#sec-promise.reject
      reject: function reject(r) {
        var capability = newPromiseCapability(this);
        capability.reject.call(undefined, r);
        return capability.promise;
      }
    });
    $({
      target: PROMISE,
      stat: true,
      forced: IS_PURE || FORCED
    }, {
      // `Promise.resolve` method
      // https://tc39.github.io/ecma262/#sec-promise.resolve
      resolve: function resolve(x) {
        return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
      }
    });
    $({
      target: PROMISE,
      stat: true,
      forced: INCORRECT_ITERATION
    }, {
      // `Promise.all` method
      // https://tc39.github.io/ecma262/#sec-promise.all
      all: function all(iterable) {
        var C = this;
        var capability = newPromiseCapability(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function () {
          var $promiseResolve = aFunction(C.resolve);
          var values = [];
          var counter = 0;
          var remaining = 1;
          iterate(iterable, function (promise) {
            var index = counter++;
            var alreadyCalled = false;
            values.push(undefined);
            remaining++;
            $promiseResolve.call(C, promise).then(function (value) {
              if (alreadyCalled) return;
              alreadyCalled = true;
              values[index] = value;
              --remaining || resolve(values);
            }, reject);
          });
          --remaining || resolve(values);
        });
        if (result.error) reject(result.value);
        return capability.promise;
      },
      // `Promise.race` method
      // https://tc39.github.io/ecma262/#sec-promise.race
      race: function race(iterable) {
        var C = this;
        var capability = newPromiseCapability(C);
        var reject = capability.reject;
        var result = perform(function () {
          var $promiseResolve = aFunction(C.resolve);
          iterate(iterable, function (promise) {
            $promiseResolve.call(C, promise).then(capability.resolve, reject);
          });
        });
        if (result.error) reject(result.value);
        return capability.promise;
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.reflect.apply.js":
  /*!**********************************************************!*\
    !*** ./node_modules/core-js/modules/es.reflect.apply.js ***!
    \**********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsReflectApplyJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var getBuiltIn = __webpack_require__(
    /*! ../internals/get-built-in */
    "./node_modules/core-js/internals/get-built-in.js");

    var aFunction = __webpack_require__(
    /*! ../internals/a-function */
    "./node_modules/core-js/internals/a-function.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var nativeApply = getBuiltIn('Reflect', 'apply');
    var functionApply = Function.apply; // MS Edge argumentsList argument is optional

    var OPTIONAL_ARGUMENTS_LIST = !fails(function () {
      nativeApply(function () {
        /* empty */
      });
    }); // `Reflect.apply` method
    // https://tc39.github.io/ecma262/#sec-reflect.apply

    $({
      target: 'Reflect',
      stat: true,
      forced: OPTIONAL_ARGUMENTS_LIST
    }, {
      apply: function apply(target, thisArgument, argumentsList) {
        aFunction(target);
        anObject(argumentsList);
        return nativeApply ? nativeApply(target, thisArgument, argumentsList) : functionApply.call(target, thisArgument, argumentsList);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.reflect.construct.js":
  /*!**************************************************************!*\
    !*** ./node_modules/core-js/modules/es.reflect.construct.js ***!
    \**************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsReflectConstructJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var getBuiltIn = __webpack_require__(
    /*! ../internals/get-built-in */
    "./node_modules/core-js/internals/get-built-in.js");

    var aFunction = __webpack_require__(
    /*! ../internals/a-function */
    "./node_modules/core-js/internals/a-function.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    var create = __webpack_require__(
    /*! ../internals/object-create */
    "./node_modules/core-js/internals/object-create.js");

    var bind = __webpack_require__(
    /*! ../internals/function-bind */
    "./node_modules/core-js/internals/function-bind.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var nativeConstruct = getBuiltIn('Reflect', 'construct'); // `Reflect.construct` method
    // https://tc39.github.io/ecma262/#sec-reflect.construct
    // MS Edge supports only 2 arguments and argumentsList argument is optional
    // FF Nightly sets third argument as `new.target`, but does not create `this` from it

    var NEW_TARGET_BUG = fails(function () {
      function F() {
        /* empty */
      }

      return !(nativeConstruct(function () {
        /* empty */
      }, [], F) instanceof F);
    });
    var ARGS_BUG = !fails(function () {
      nativeConstruct(function () {
        /* empty */
      });
    });
    var FORCED = NEW_TARGET_BUG || ARGS_BUG;
    $({
      target: 'Reflect',
      stat: true,
      forced: FORCED,
      sham: FORCED
    }, {
      construct: function construct(Target, args
      /* , newTarget */
      ) {
        aFunction(Target);
        anObject(args);
        var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
        if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);

        if (Target == newTarget) {
          // w/o altered newTarget, optimization for 0-4 arguments
          switch (args.length) {
            case 0:
              return new Target();

            case 1:
              return new Target(args[0]);

            case 2:
              return new Target(args[0], args[1]);

            case 3:
              return new Target(args[0], args[1], args[2]);

            case 4:
              return new Target(args[0], args[1], args[2], args[3]);
          } // w/o altered newTarget, lot of arguments case


          var $args = [null];
          $args.push.apply($args, args);
          return new (bind.apply(Target, $args))();
        } // with altered newTarget, not support built-in constructors


        var proto = newTarget.prototype;
        var instance = create(isObject(proto) ? proto : Object.prototype);
        var result = Function.apply.call(Target, instance, args);
        return isObject(result) ? result : instance;
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.reflect.define-property.js":
  /*!********************************************************************!*\
    !*** ./node_modules/core-js/modules/es.reflect.define-property.js ***!
    \********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsReflectDefinePropertyJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var DESCRIPTORS = __webpack_require__(
    /*! ../internals/descriptors */
    "./node_modules/core-js/internals/descriptors.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var toPrimitive = __webpack_require__(
    /*! ../internals/to-primitive */
    "./node_modules/core-js/internals/to-primitive.js");

    var definePropertyModule = __webpack_require__(
    /*! ../internals/object-define-property */
    "./node_modules/core-js/internals/object-define-property.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js"); // MS Edge has broken Reflect.defineProperty - throwing instead of returning false


    var ERROR_INSTEAD_OF_FALSE = fails(function () {
      // eslint-disable-next-line no-undef
      Reflect.defineProperty(definePropertyModule.f({}, 1, {
        value: 1
      }), 1, {
        value: 2
      });
    }); // `Reflect.defineProperty` method
    // https://tc39.github.io/ecma262/#sec-reflect.defineproperty

    $({
      target: 'Reflect',
      stat: true,
      forced: ERROR_INSTEAD_OF_FALSE,
      sham: !DESCRIPTORS
    }, {
      defineProperty: function defineProperty(target, propertyKey, attributes) {
        anObject(target);
        var key = toPrimitive(propertyKey, true);
        anObject(attributes);

        try {
          definePropertyModule.f(target, key, attributes);
          return true;
        } catch (error) {
          return false;
        }
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.reflect.delete-property.js":
  /*!********************************************************************!*\
    !*** ./node_modules/core-js/modules/es.reflect.delete-property.js ***!
    \********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsReflectDeletePropertyJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var getOwnPropertyDescriptor = __webpack_require__(
    /*! ../internals/object-get-own-property-descriptor */
    "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f; // `Reflect.deleteProperty` method
    // https://tc39.github.io/ecma262/#sec-reflect.deleteproperty


    $({
      target: 'Reflect',
      stat: true
    }, {
      deleteProperty: function deleteProperty(target, propertyKey) {
        var descriptor = getOwnPropertyDescriptor(anObject(target), propertyKey);
        return descriptor && !descriptor.configurable ? false : delete target[propertyKey];
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.reflect.get-own-property-descriptor.js":
  /*!********************************************************************************!*\
    !*** ./node_modules/core-js/modules/es.reflect.get-own-property-descriptor.js ***!
    \********************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsReflectGetOwnPropertyDescriptorJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var DESCRIPTORS = __webpack_require__(
    /*! ../internals/descriptors */
    "./node_modules/core-js/internals/descriptors.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var getOwnPropertyDescriptorModule = __webpack_require__(
    /*! ../internals/object-get-own-property-descriptor */
    "./node_modules/core-js/internals/object-get-own-property-descriptor.js"); // `Reflect.getOwnPropertyDescriptor` method
    // https://tc39.github.io/ecma262/#sec-reflect.getownpropertydescriptor


    $({
      target: 'Reflect',
      stat: true,
      sham: !DESCRIPTORS
    }, {
      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
        return getOwnPropertyDescriptorModule.f(anObject(target), propertyKey);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.reflect.get-prototype-of.js":
  /*!*********************************************************************!*\
    !*** ./node_modules/core-js/modules/es.reflect.get-prototype-of.js ***!
    \*********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsReflectGetPrototypeOfJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var objectGetPrototypeOf = __webpack_require__(
    /*! ../internals/object-get-prototype-of */
    "./node_modules/core-js/internals/object-get-prototype-of.js");

    var CORRECT_PROTOTYPE_GETTER = __webpack_require__(
    /*! ../internals/correct-prototype-getter */
    "./node_modules/core-js/internals/correct-prototype-getter.js"); // `Reflect.getPrototypeOf` method
    // https://tc39.github.io/ecma262/#sec-reflect.getprototypeof


    $({
      target: 'Reflect',
      stat: true,
      sham: !CORRECT_PROTOTYPE_GETTER
    }, {
      getPrototypeOf: function getPrototypeOf(target) {
        return objectGetPrototypeOf(anObject(target));
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.reflect.get.js":
  /*!********************************************************!*\
    !*** ./node_modules/core-js/modules/es.reflect.get.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsReflectGetJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var has = __webpack_require__(
    /*! ../internals/has */
    "./node_modules/core-js/internals/has.js");

    var getOwnPropertyDescriptorModule = __webpack_require__(
    /*! ../internals/object-get-own-property-descriptor */
    "./node_modules/core-js/internals/object-get-own-property-descriptor.js");

    var getPrototypeOf = __webpack_require__(
    /*! ../internals/object-get-prototype-of */
    "./node_modules/core-js/internals/object-get-prototype-of.js"); // `Reflect.get` method
    // https://tc39.github.io/ecma262/#sec-reflect.get


    function get(target, propertyKey
    /* , receiver */
    ) {
      var receiver = arguments.length < 3 ? target : arguments[2];
      var descriptor, prototype;
      if (anObject(target) === receiver) return target[propertyKey];
      if (descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey)) return has(descriptor, 'value') ? descriptor.value : descriptor.get === undefined ? undefined : descriptor.get.call(receiver);
      if (isObject(prototype = getPrototypeOf(target))) return get(prototype, propertyKey, receiver);
    }

    $({
      target: 'Reflect',
      stat: true
    }, {
      get: get
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.reflect.has.js":
  /*!********************************************************!*\
    !*** ./node_modules/core-js/modules/es.reflect.has.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsReflectHasJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js"); // `Reflect.has` method
    // https://tc39.github.io/ecma262/#sec-reflect.has


    $({
      target: 'Reflect',
      stat: true
    }, {
      has: function has(target, propertyKey) {
        return propertyKey in target;
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.reflect.is-extensible.js":
  /*!******************************************************************!*\
    !*** ./node_modules/core-js/modules/es.reflect.is-extensible.js ***!
    \******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsReflectIsExtensibleJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var objectIsExtensible = Object.isExtensible; // `Reflect.isExtensible` method
    // https://tc39.github.io/ecma262/#sec-reflect.isextensible

    $({
      target: 'Reflect',
      stat: true
    }, {
      isExtensible: function isExtensible(target) {
        anObject(target);
        return objectIsExtensible ? objectIsExtensible(target) : true;
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.reflect.own-keys.js":
  /*!*************************************************************!*\
    !*** ./node_modules/core-js/modules/es.reflect.own-keys.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsReflectOwnKeysJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var ownKeys = __webpack_require__(
    /*! ../internals/own-keys */
    "./node_modules/core-js/internals/own-keys.js"); // `Reflect.ownKeys` method
    // https://tc39.github.io/ecma262/#sec-reflect.ownkeys


    $({
      target: 'Reflect',
      stat: true
    }, {
      ownKeys: ownKeys
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.reflect.prevent-extensions.js":
  /*!***********************************************************************!*\
    !*** ./node_modules/core-js/modules/es.reflect.prevent-extensions.js ***!
    \***********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsReflectPreventExtensionsJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var getBuiltIn = __webpack_require__(
    /*! ../internals/get-built-in */
    "./node_modules/core-js/internals/get-built-in.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var FREEZING = __webpack_require__(
    /*! ../internals/freezing */
    "./node_modules/core-js/internals/freezing.js"); // `Reflect.preventExtensions` method
    // https://tc39.github.io/ecma262/#sec-reflect.preventextensions


    $({
      target: 'Reflect',
      stat: true,
      sham: !FREEZING
    }, {
      preventExtensions: function preventExtensions(target) {
        anObject(target);

        try {
          var objectPreventExtensions = getBuiltIn('Object', 'preventExtensions');
          if (objectPreventExtensions) objectPreventExtensions(target);
          return true;
        } catch (error) {
          return false;
        }
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.reflect.set-prototype-of.js":
  /*!*********************************************************************!*\
    !*** ./node_modules/core-js/modules/es.reflect.set-prototype-of.js ***!
    \*********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsReflectSetPrototypeOfJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var aPossiblePrototype = __webpack_require__(
    /*! ../internals/a-possible-prototype */
    "./node_modules/core-js/internals/a-possible-prototype.js");

    var objectSetPrototypeOf = __webpack_require__(
    /*! ../internals/object-set-prototype-of */
    "./node_modules/core-js/internals/object-set-prototype-of.js"); // `Reflect.setPrototypeOf` method
    // https://tc39.github.io/ecma262/#sec-reflect.setprototypeof


    if (objectSetPrototypeOf) $({
      target: 'Reflect',
      stat: true
    }, {
      setPrototypeOf: function setPrototypeOf(target, proto) {
        anObject(target);
        aPossiblePrototype(proto);

        try {
          objectSetPrototypeOf(target, proto);
          return true;
        } catch (error) {
          return false;
        }
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.reflect.set.js":
  /*!********************************************************!*\
    !*** ./node_modules/core-js/modules/es.reflect.set.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsReflectSetJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    var has = __webpack_require__(
    /*! ../internals/has */
    "./node_modules/core-js/internals/has.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var definePropertyModule = __webpack_require__(
    /*! ../internals/object-define-property */
    "./node_modules/core-js/internals/object-define-property.js");

    var getOwnPropertyDescriptorModule = __webpack_require__(
    /*! ../internals/object-get-own-property-descriptor */
    "./node_modules/core-js/internals/object-get-own-property-descriptor.js");

    var getPrototypeOf = __webpack_require__(
    /*! ../internals/object-get-prototype-of */
    "./node_modules/core-js/internals/object-get-prototype-of.js");

    var createPropertyDescriptor = __webpack_require__(
    /*! ../internals/create-property-descriptor */
    "./node_modules/core-js/internals/create-property-descriptor.js"); // `Reflect.set` method
    // https://tc39.github.io/ecma262/#sec-reflect.set


    function set(target, propertyKey, V
    /* , receiver */
    ) {
      var receiver = arguments.length < 4 ? target : arguments[3];
      var ownDescriptor = getOwnPropertyDescriptorModule.f(anObject(target), propertyKey);
      var existingDescriptor, prototype;

      if (!ownDescriptor) {
        if (isObject(prototype = getPrototypeOf(target))) {
          return set(prototype, propertyKey, V, receiver);
        }

        ownDescriptor = createPropertyDescriptor(0);
      }

      if (has(ownDescriptor, 'value')) {
        if (ownDescriptor.writable === false || !isObject(receiver)) return false;

        if (existingDescriptor = getOwnPropertyDescriptorModule.f(receiver, propertyKey)) {
          if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
          existingDescriptor.value = V;
          definePropertyModule.f(receiver, propertyKey, existingDescriptor);
        } else definePropertyModule.f(receiver, propertyKey, createPropertyDescriptor(0, V));

        return true;
      }

      return ownDescriptor.set === undefined ? false : (ownDescriptor.set.call(receiver, V), true);
    } // MS Edge 17-18 Reflect.set allows setting the property to object
    // with non-writable property on the prototype


    var MS_EDGE_BUG = fails(function () {
      var object = definePropertyModule.f({}, 'a', {
        configurable: true
      }); // eslint-disable-next-line no-undef

      return Reflect.set(getPrototypeOf(object), 'a', 1, object) !== false;
    });
    $({
      target: 'Reflect',
      stat: true,
      forced: MS_EDGE_BUG
    }, {
      set: set
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.regexp.constructor.js":
  /*!***************************************************************!*\
    !*** ./node_modules/core-js/modules/es.regexp.constructor.js ***!
    \***************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsRegexpConstructorJs(module, exports, __webpack_require__) {
    var DESCRIPTORS = __webpack_require__(
    /*! ../internals/descriptors */
    "./node_modules/core-js/internals/descriptors.js");

    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    var isForced = __webpack_require__(
    /*! ../internals/is-forced */
    "./node_modules/core-js/internals/is-forced.js");

    var inheritIfRequired = __webpack_require__(
    /*! ../internals/inherit-if-required */
    "./node_modules/core-js/internals/inherit-if-required.js");

    var defineProperty = __webpack_require__(
    /*! ../internals/object-define-property */
    "./node_modules/core-js/internals/object-define-property.js").f;

    var getOwnPropertyNames = __webpack_require__(
    /*! ../internals/object-get-own-property-names */
    "./node_modules/core-js/internals/object-get-own-property-names.js").f;

    var isRegExp = __webpack_require__(
    /*! ../internals/is-regexp */
    "./node_modules/core-js/internals/is-regexp.js");

    var getFlags = __webpack_require__(
    /*! ../internals/regexp-flags */
    "./node_modules/core-js/internals/regexp-flags.js");

    var stickyHelpers = __webpack_require__(
    /*! ../internals/regexp-sticky-helpers */
    "./node_modules/core-js/internals/regexp-sticky-helpers.js");

    var redefine = __webpack_require__(
    /*! ../internals/redefine */
    "./node_modules/core-js/internals/redefine.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var setInternalState = __webpack_require__(
    /*! ../internals/internal-state */
    "./node_modules/core-js/internals/internal-state.js").set;

    var setSpecies = __webpack_require__(
    /*! ../internals/set-species */
    "./node_modules/core-js/internals/set-species.js");

    var wellKnownSymbol = __webpack_require__(
    /*! ../internals/well-known-symbol */
    "./node_modules/core-js/internals/well-known-symbol.js");

    var MATCH = wellKnownSymbol('match');
    var NativeRegExp = global.RegExp;
    var RegExpPrototype = NativeRegExp.prototype;
    var re1 = /a/g;
    var re2 = /a/g; // "new" should create a new object, old webkit bug

    var CORRECT_NEW = new NativeRegExp(re1) !== re1;
    var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
    var FORCED = DESCRIPTORS && isForced('RegExp', !CORRECT_NEW || UNSUPPORTED_Y || fails(function () {
      re2[MATCH] = false; // RegExp constructor can alter flags and IsRegExp works correct with @@match

      return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
    })); // `RegExp` constructor
    // https://tc39.github.io/ecma262/#sec-regexp-constructor

    if (FORCED) {
      var RegExpWrapper = function RegExp(pattern, flags) {
        var thisIsRegExp = this instanceof RegExpWrapper;
        var patternIsRegExp = isRegExp(pattern);
        var flagsAreUndefined = flags === undefined;
        var sticky;

        if (!thisIsRegExp && patternIsRegExp && pattern.constructor === RegExpWrapper && flagsAreUndefined) {
          return pattern;
        }

        if (CORRECT_NEW) {
          if (patternIsRegExp && !flagsAreUndefined) pattern = pattern.source;
        } else if (pattern instanceof RegExpWrapper) {
          if (flagsAreUndefined) flags = getFlags.call(pattern);
          pattern = pattern.source;
        }

        if (UNSUPPORTED_Y) {
          sticky = !!flags && flags.indexOf('y') > -1;
          if (sticky) flags = flags.replace(/y/g, '');
        }

        var result = inheritIfRequired(CORRECT_NEW ? new NativeRegExp(pattern, flags) : NativeRegExp(pattern, flags), thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);
        if (UNSUPPORTED_Y && sticky) setInternalState(result, {
          sticky: sticky
        });
        return result;
      };

      var proxy = function proxy(key) {
        key in RegExpWrapper || defineProperty(RegExpWrapper, key, {
          configurable: true,
          get: function get() {
            return NativeRegExp[key];
          },
          set: function set(it) {
            NativeRegExp[key] = it;
          }
        });
      };

      var keys = getOwnPropertyNames(NativeRegExp);
      var index = 0;

      while (keys.length > index) proxy(keys[index++]);

      RegExpPrototype.constructor = RegExpWrapper;
      RegExpWrapper.prototype = RegExpPrototype;
      redefine(global, 'RegExp', RegExpWrapper);
    } // https://tc39.github.io/ecma262/#sec-get-regexp-@@species


    setSpecies('RegExp');
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.regexp.exec.js":
  /*!********************************************************!*\
    !*** ./node_modules/core-js/modules/es.regexp.exec.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsRegexpExecJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var exec = __webpack_require__(
    /*! ../internals/regexp-exec */
    "./node_modules/core-js/internals/regexp-exec.js");

    $({
      target: 'RegExp',
      proto: true,
      forced: /./.exec !== exec
    }, {
      exec: exec
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.regexp.flags.js":
  /*!*********************************************************!*\
    !*** ./node_modules/core-js/modules/es.regexp.flags.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsRegexpFlagsJs(module, exports, __webpack_require__) {
    var DESCRIPTORS = __webpack_require__(
    /*! ../internals/descriptors */
    "./node_modules/core-js/internals/descriptors.js");

    var objectDefinePropertyModule = __webpack_require__(
    /*! ../internals/object-define-property */
    "./node_modules/core-js/internals/object-define-property.js");

    var regExpFlags = __webpack_require__(
    /*! ../internals/regexp-flags */
    "./node_modules/core-js/internals/regexp-flags.js");

    var UNSUPPORTED_Y = __webpack_require__(
    /*! ../internals/regexp-sticky-helpers */
    "./node_modules/core-js/internals/regexp-sticky-helpers.js").UNSUPPORTED_Y; // `RegExp.prototype.flags` getter
    // https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags


    if (DESCRIPTORS && (/./g.flags != 'g' || UNSUPPORTED_Y)) {
      objectDefinePropertyModule.f(RegExp.prototype, 'flags', {
        configurable: true,
        get: regExpFlags
      });
    }
    /***/

  },

  /***/
  "./node_modules/core-js/modules/es.regexp.to-string.js":
  /*!*************************************************************!*\
    !*** ./node_modules/core-js/modules/es.regexp.to-string.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsRegexpToStringJs(module, exports, __webpack_require__) {
    "use strict";

    var redefine = __webpack_require__(
    /*! ../internals/redefine */
    "./node_modules/core-js/internals/redefine.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var flags = __webpack_require__(
    /*! ../internals/regexp-flags */
    "./node_modules/core-js/internals/regexp-flags.js");

    var TO_STRING = 'toString';
    var RegExpPrototype = RegExp.prototype;
    var nativeToString = RegExpPrototype[TO_STRING];
    var NOT_GENERIC = fails(function () {
      return nativeToString.call({
        source: 'a',
        flags: 'b'
      }) != '/a/b';
    }); // FF44- RegExp#toString has a wrong name

    var INCORRECT_NAME = nativeToString.name != TO_STRING; // `RegExp.prototype.toString` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring

    if (NOT_GENERIC || INCORRECT_NAME) {
      redefine(RegExp.prototype, TO_STRING, function toString() {
        var R = anObject(this);
        var p = String(R.source);
        var rf = R.flags;
        var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? flags.call(R) : rf);
        return '/' + p + '/' + f;
      }, {
        unsafe: true
      });
    }
    /***/

  },

  /***/
  "./node_modules/core-js/modules/es.set.js":
  /*!************************************************!*\
    !*** ./node_modules/core-js/modules/es.set.js ***!
    \************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsSetJs(module, exports, __webpack_require__) {
    "use strict";

    var collection = __webpack_require__(
    /*! ../internals/collection */
    "./node_modules/core-js/internals/collection.js");

    var collectionStrong = __webpack_require__(
    /*! ../internals/collection-strong */
    "./node_modules/core-js/internals/collection-strong.js"); // `Set` constructor
    // https://tc39.github.io/ecma262/#sec-set-objects


    module.exports = collection('Set', function (init) {
      return function Set() {
        return init(this, arguments.length ? arguments[0] : undefined);
      };
    }, collectionStrong);
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.string.anchor.js":
  /*!**********************************************************!*\
    !*** ./node_modules/core-js/modules/es.string.anchor.js ***!
    \**********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsStringAnchorJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var createHTML = __webpack_require__(
    /*! ../internals/create-html */
    "./node_modules/core-js/internals/create-html.js");

    var forcedStringHTMLMethod = __webpack_require__(
    /*! ../internals/string-html-forced */
    "./node_modules/core-js/internals/string-html-forced.js"); // `String.prototype.anchor` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.anchor


    $({
      target: 'String',
      proto: true,
      forced: forcedStringHTMLMethod('anchor')
    }, {
      anchor: function anchor(name) {
        return createHTML(this, 'a', 'name', name);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.string.big.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/modules/es.string.big.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsStringBigJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var createHTML = __webpack_require__(
    /*! ../internals/create-html */
    "./node_modules/core-js/internals/create-html.js");

    var forcedStringHTMLMethod = __webpack_require__(
    /*! ../internals/string-html-forced */
    "./node_modules/core-js/internals/string-html-forced.js"); // `String.prototype.big` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.big


    $({
      target: 'String',
      proto: true,
      forced: forcedStringHTMLMethod('big')
    }, {
      big: function big() {
        return createHTML(this, 'big', '', '');
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.string.blink.js":
  /*!*********************************************************!*\
    !*** ./node_modules/core-js/modules/es.string.blink.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsStringBlinkJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var createHTML = __webpack_require__(
    /*! ../internals/create-html */
    "./node_modules/core-js/internals/create-html.js");

    var forcedStringHTMLMethod = __webpack_require__(
    /*! ../internals/string-html-forced */
    "./node_modules/core-js/internals/string-html-forced.js"); // `String.prototype.blink` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.blink


    $({
      target: 'String',
      proto: true,
      forced: forcedStringHTMLMethod('blink')
    }, {
      blink: function blink() {
        return createHTML(this, 'blink', '', '');
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.string.bold.js":
  /*!********************************************************!*\
    !*** ./node_modules/core-js/modules/es.string.bold.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsStringBoldJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var createHTML = __webpack_require__(
    /*! ../internals/create-html */
    "./node_modules/core-js/internals/create-html.js");

    var forcedStringHTMLMethod = __webpack_require__(
    /*! ../internals/string-html-forced */
    "./node_modules/core-js/internals/string-html-forced.js"); // `String.prototype.bold` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.bold


    $({
      target: 'String',
      proto: true,
      forced: forcedStringHTMLMethod('bold')
    }, {
      bold: function bold() {
        return createHTML(this, 'b', '', '');
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.string.code-point-at.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/core-js/modules/es.string.code-point-at.js ***!
    \*****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsStringCodePointAtJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var codeAt = __webpack_require__(
    /*! ../internals/string-multibyte */
    "./node_modules/core-js/internals/string-multibyte.js").codeAt; // `String.prototype.codePointAt` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat


    $({
      target: 'String',
      proto: true
    }, {
      codePointAt: function codePointAt(pos) {
        return codeAt(this, pos);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.string.ends-with.js":
  /*!*************************************************************!*\
    !*** ./node_modules/core-js/modules/es.string.ends-with.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsStringEndsWithJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var getOwnPropertyDescriptor = __webpack_require__(
    /*! ../internals/object-get-own-property-descriptor */
    "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;

    var toLength = __webpack_require__(
    /*! ../internals/to-length */
    "./node_modules/core-js/internals/to-length.js");

    var notARegExp = __webpack_require__(
    /*! ../internals/not-a-regexp */
    "./node_modules/core-js/internals/not-a-regexp.js");

    var requireObjectCoercible = __webpack_require__(
    /*! ../internals/require-object-coercible */
    "./node_modules/core-js/internals/require-object-coercible.js");

    var correctIsRegExpLogic = __webpack_require__(
    /*! ../internals/correct-is-regexp-logic */
    "./node_modules/core-js/internals/correct-is-regexp-logic.js");

    var IS_PURE = __webpack_require__(
    /*! ../internals/is-pure */
    "./node_modules/core-js/internals/is-pure.js");

    var nativeEndsWith = ''.endsWith;
    var min = Math.min;
    var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('endsWith'); // https://github.com/zloirock/core-js/pull/702

    var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function () {
      var descriptor = getOwnPropertyDescriptor(String.prototype, 'endsWith');
      return descriptor && !descriptor.writable;
    }(); // `String.prototype.endsWith` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.endswith

    $({
      target: 'String',
      proto: true,
      forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC
    }, {
      endsWith: function endsWith(searchString
      /* , endPosition = @length */
      ) {
        var that = String(requireObjectCoercible(this));
        notARegExp(searchString);
        var endPosition = arguments.length > 1 ? arguments[1] : undefined;
        var len = toLength(that.length);
        var end = endPosition === undefined ? len : min(toLength(endPosition), len);
        var search = String(searchString);
        return nativeEndsWith ? nativeEndsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.string.fixed.js":
  /*!*********************************************************!*\
    !*** ./node_modules/core-js/modules/es.string.fixed.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsStringFixedJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var createHTML = __webpack_require__(
    /*! ../internals/create-html */
    "./node_modules/core-js/internals/create-html.js");

    var forcedStringHTMLMethod = __webpack_require__(
    /*! ../internals/string-html-forced */
    "./node_modules/core-js/internals/string-html-forced.js"); // `String.prototype.fixed` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.fixed


    $({
      target: 'String',
      proto: true,
      forced: forcedStringHTMLMethod('fixed')
    }, {
      fixed: function fixed() {
        return createHTML(this, 'tt', '', '');
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.string.fontcolor.js":
  /*!*************************************************************!*\
    !*** ./node_modules/core-js/modules/es.string.fontcolor.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsStringFontcolorJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var createHTML = __webpack_require__(
    /*! ../internals/create-html */
    "./node_modules/core-js/internals/create-html.js");

    var forcedStringHTMLMethod = __webpack_require__(
    /*! ../internals/string-html-forced */
    "./node_modules/core-js/internals/string-html-forced.js"); // `String.prototype.fontcolor` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.fontcolor


    $({
      target: 'String',
      proto: true,
      forced: forcedStringHTMLMethod('fontcolor')
    }, {
      fontcolor: function fontcolor(color) {
        return createHTML(this, 'font', 'color', color);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.string.fontsize.js":
  /*!************************************************************!*\
    !*** ./node_modules/core-js/modules/es.string.fontsize.js ***!
    \************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsStringFontsizeJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var createHTML = __webpack_require__(
    /*! ../internals/create-html */
    "./node_modules/core-js/internals/create-html.js");

    var forcedStringHTMLMethod = __webpack_require__(
    /*! ../internals/string-html-forced */
    "./node_modules/core-js/internals/string-html-forced.js"); // `String.prototype.fontsize` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.fontsize


    $({
      target: 'String',
      proto: true,
      forced: forcedStringHTMLMethod('fontsize')
    }, {
      fontsize: function fontsize(size) {
        return createHTML(this, 'font', 'size', size);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.string.from-code-point.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/core-js/modules/es.string.from-code-point.js ***!
    \*******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsStringFromCodePointJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var toAbsoluteIndex = __webpack_require__(
    /*! ../internals/to-absolute-index */
    "./node_modules/core-js/internals/to-absolute-index.js");

    var fromCharCode = String.fromCharCode;
    var nativeFromCodePoint = String.fromCodePoint; // length should be 1, old FF problem

    var INCORRECT_LENGTH = !!nativeFromCodePoint && nativeFromCodePoint.length != 1; // `String.fromCodePoint` method
    // https://tc39.github.io/ecma262/#sec-string.fromcodepoint

    $({
      target: 'String',
      stat: true,
      forced: INCORRECT_LENGTH
    }, {
      fromCodePoint: function fromCodePoint(x) {
        // eslint-disable-line no-unused-vars
        var elements = [];
        var length = arguments.length;
        var i = 0;
        var code;

        while (length > i) {
          code = +arguments[i++];
          if (toAbsoluteIndex(code, 0x10FFFF) !== code) throw RangeError(code + ' is not a valid code point');
          elements.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xD800, code % 0x400 + 0xDC00));
        }

        return elements.join('');
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.string.includes.js":
  /*!************************************************************!*\
    !*** ./node_modules/core-js/modules/es.string.includes.js ***!
    \************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsStringIncludesJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var notARegExp = __webpack_require__(
    /*! ../internals/not-a-regexp */
    "./node_modules/core-js/internals/not-a-regexp.js");

    var requireObjectCoercible = __webpack_require__(
    /*! ../internals/require-object-coercible */
    "./node_modules/core-js/internals/require-object-coercible.js");

    var correctIsRegExpLogic = __webpack_require__(
    /*! ../internals/correct-is-regexp-logic */
    "./node_modules/core-js/internals/correct-is-regexp-logic.js"); // `String.prototype.includes` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.includes


    $({
      target: 'String',
      proto: true,
      forced: !correctIsRegExpLogic('includes')
    }, {
      includes: function includes(searchString
      /* , position = 0 */
      ) {
        return !!~String(requireObjectCoercible(this)).indexOf(notARegExp(searchString), arguments.length > 1 ? arguments[1] : undefined);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.string.italics.js":
  /*!***********************************************************!*\
    !*** ./node_modules/core-js/modules/es.string.italics.js ***!
    \***********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsStringItalicsJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var createHTML = __webpack_require__(
    /*! ../internals/create-html */
    "./node_modules/core-js/internals/create-html.js");

    var forcedStringHTMLMethod = __webpack_require__(
    /*! ../internals/string-html-forced */
    "./node_modules/core-js/internals/string-html-forced.js"); // `String.prototype.italics` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.italics


    $({
      target: 'String',
      proto: true,
      forced: forcedStringHTMLMethod('italics')
    }, {
      italics: function italics() {
        return createHTML(this, 'i', '', '');
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.string.iterator.js":
  /*!************************************************************!*\
    !*** ./node_modules/core-js/modules/es.string.iterator.js ***!
    \************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsStringIteratorJs(module, exports, __webpack_require__) {
    "use strict";

    var charAt = __webpack_require__(
    /*! ../internals/string-multibyte */
    "./node_modules/core-js/internals/string-multibyte.js").charAt;

    var InternalStateModule = __webpack_require__(
    /*! ../internals/internal-state */
    "./node_modules/core-js/internals/internal-state.js");

    var defineIterator = __webpack_require__(
    /*! ../internals/define-iterator */
    "./node_modules/core-js/internals/define-iterator.js");

    var STRING_ITERATOR = 'String Iterator';
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR); // `String.prototype[@@iterator]` method
    // https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator

    defineIterator(String, 'String', function (iterated) {
      setInternalState(this, {
        type: STRING_ITERATOR,
        string: String(iterated),
        index: 0
      }); // `%StringIteratorPrototype%.next` method
      // https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
    }, function next() {
      var state = getInternalState(this);
      var string = state.string;
      var index = state.index;
      var point;
      if (index >= string.length) return {
        value: undefined,
        done: true
      };
      point = charAt(string, index);
      state.index += point.length;
      return {
        value: point,
        done: false
      };
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.string.link.js":
  /*!********************************************************!*\
    !*** ./node_modules/core-js/modules/es.string.link.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsStringLinkJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var createHTML = __webpack_require__(
    /*! ../internals/create-html */
    "./node_modules/core-js/internals/create-html.js");

    var forcedStringHTMLMethod = __webpack_require__(
    /*! ../internals/string-html-forced */
    "./node_modules/core-js/internals/string-html-forced.js"); // `String.prototype.link` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.link


    $({
      target: 'String',
      proto: true,
      forced: forcedStringHTMLMethod('link')
    }, {
      link: function link(url) {
        return createHTML(this, 'a', 'href', url);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.string.match.js":
  /*!*********************************************************!*\
    !*** ./node_modules/core-js/modules/es.string.match.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsStringMatchJs(module, exports, __webpack_require__) {
    "use strict";

    var fixRegExpWellKnownSymbolLogic = __webpack_require__(
    /*! ../internals/fix-regexp-well-known-symbol-logic */
    "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var toLength = __webpack_require__(
    /*! ../internals/to-length */
    "./node_modules/core-js/internals/to-length.js");

    var requireObjectCoercible = __webpack_require__(
    /*! ../internals/require-object-coercible */
    "./node_modules/core-js/internals/require-object-coercible.js");

    var advanceStringIndex = __webpack_require__(
    /*! ../internals/advance-string-index */
    "./node_modules/core-js/internals/advance-string-index.js");

    var regExpExec = __webpack_require__(
    /*! ../internals/regexp-exec-abstract */
    "./node_modules/core-js/internals/regexp-exec-abstract.js"); // @@match logic


    fixRegExpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {
      return [// `String.prototype.match` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.match
      function match(regexp) {
        var O = requireObjectCoercible(this);
        var matcher = regexp == undefined ? undefined : regexp[MATCH];
        return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
      }, // `RegExp.prototype[@@match]` method
      // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
      function (regexp) {
        var res = maybeCallNative(nativeMatch, regexp, this);
        if (res.done) return res.value;
        var rx = anObject(regexp);
        var S = String(this);
        if (!rx.global) return regExpExec(rx, S);
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
        var A = [];
        var n = 0;
        var result;

        while ((result = regExpExec(rx, S)) !== null) {
          var matchStr = String(result[0]);
          A[n] = matchStr;
          if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
          n++;
        }

        return n === 0 ? null : A;
      }];
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.string.raw.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/modules/es.string.raw.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsStringRawJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var toIndexedObject = __webpack_require__(
    /*! ../internals/to-indexed-object */
    "./node_modules/core-js/internals/to-indexed-object.js");

    var toLength = __webpack_require__(
    /*! ../internals/to-length */
    "./node_modules/core-js/internals/to-length.js"); // `String.raw` method
    // https://tc39.github.io/ecma262/#sec-string.raw


    $({
      target: 'String',
      stat: true
    }, {
      raw: function raw(template) {
        var rawTemplate = toIndexedObject(template.raw);
        var literalSegments = toLength(rawTemplate.length);
        var argumentsLength = arguments.length;
        var elements = [];
        var i = 0;

        while (literalSegments > i) {
          elements.push(String(rawTemplate[i++]));
          if (i < argumentsLength) elements.push(String(arguments[i]));
        }

        return elements.join('');
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.string.repeat.js":
  /*!**********************************************************!*\
    !*** ./node_modules/core-js/modules/es.string.repeat.js ***!
    \**********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsStringRepeatJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var repeat = __webpack_require__(
    /*! ../internals/string-repeat */
    "./node_modules/core-js/internals/string-repeat.js"); // `String.prototype.repeat` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.repeat


    $({
      target: 'String',
      proto: true
    }, {
      repeat: repeat
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.string.replace.js":
  /*!***********************************************************!*\
    !*** ./node_modules/core-js/modules/es.string.replace.js ***!
    \***********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsStringReplaceJs(module, exports, __webpack_require__) {
    "use strict";

    var fixRegExpWellKnownSymbolLogic = __webpack_require__(
    /*! ../internals/fix-regexp-well-known-symbol-logic */
    "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var toObject = __webpack_require__(
    /*! ../internals/to-object */
    "./node_modules/core-js/internals/to-object.js");

    var toLength = __webpack_require__(
    /*! ../internals/to-length */
    "./node_modules/core-js/internals/to-length.js");

    var toInteger = __webpack_require__(
    /*! ../internals/to-integer */
    "./node_modules/core-js/internals/to-integer.js");

    var requireObjectCoercible = __webpack_require__(
    /*! ../internals/require-object-coercible */
    "./node_modules/core-js/internals/require-object-coercible.js");

    var advanceStringIndex = __webpack_require__(
    /*! ../internals/advance-string-index */
    "./node_modules/core-js/internals/advance-string-index.js");

    var regExpExec = __webpack_require__(
    /*! ../internals/regexp-exec-abstract */
    "./node_modules/core-js/internals/regexp-exec-abstract.js");

    var max = Math.max;
    var min = Math.min;
    var floor = Math.floor;
    var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
    var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;

    var maybeToString = function maybeToString(it) {
      return it === undefined ? it : String(it);
    }; // @@replace logic


    fixRegExpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative, reason) {
      var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
      var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
      var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';
      return [// `String.prototype.replace` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.replace
      function replace(searchValue, replaceValue) {
        var O = requireObjectCoercible(this);
        var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
        return replacer !== undefined ? replacer.call(searchValue, O, replaceValue) : nativeReplace.call(String(O), searchValue, replaceValue);
      }, // `RegExp.prototype[@@replace]` method
      // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
      function (regexp, replaceValue) {
        if (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0 || typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1) {
          var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
          if (res.done) return res.value;
        }

        var rx = anObject(regexp);
        var S = String(this);
        var functionalReplace = typeof replaceValue === 'function';
        if (!functionalReplace) replaceValue = String(replaceValue);
        var global = rx.global;

        if (global) {
          var fullUnicode = rx.unicode;
          rx.lastIndex = 0;
        }

        var results = [];

        while (true) {
          var result = regExpExec(rx, S);
          if (result === null) break;
          results.push(result);
          if (!global) break;
          var matchStr = String(result[0]);
          if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        }

        var accumulatedResult = '';
        var nextSourcePosition = 0;

        for (var i = 0; i < results.length; i++) {
          result = results[i];
          var matched = String(result[0]);
          var position = max(min(toInteger(result.index), S.length), 0);
          var captures = []; // NOTE: This is equivalent to
          //   captures = result.slice(1).map(maybeToString)
          // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
          // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
          // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.

          for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));

          var namedCaptures = result.groups;

          if (functionalReplace) {
            var replacerArgs = [matched].concat(captures, position, S);
            if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
            var replacement = String(replaceValue.apply(undefined, replacerArgs));
          } else {
            replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
          }

          if (position >= nextSourcePosition) {
            accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
            nextSourcePosition = position + matched.length;
          }
        }

        return accumulatedResult + S.slice(nextSourcePosition);
      }]; // https://tc39.github.io/ecma262/#sec-getsubstitution

      function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
        var tailPos = position + matched.length;
        var m = captures.length;
        var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;

        if (namedCaptures !== undefined) {
          namedCaptures = toObject(namedCaptures);
          symbols = SUBSTITUTION_SYMBOLS;
        }

        return nativeReplace.call(replacement, symbols, function (match, ch) {
          var capture;

          switch (ch.charAt(0)) {
            case '$':
              return '$';

            case '&':
              return matched;

            case '`':
              return str.slice(0, position);

            case "'":
              return str.slice(tailPos);

            case '<':
              capture = namedCaptures[ch.slice(1, -1)];
              break;

            default:
              // \d\d?
              var n = +ch;
              if (n === 0) return match;

              if (n > m) {
                var f = floor(n / 10);
                if (f === 0) return match;
                if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
                return match;
              }

              capture = captures[n - 1];
          }

          return capture === undefined ? '' : capture;
        });
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.string.search.js":
  /*!**********************************************************!*\
    !*** ./node_modules/core-js/modules/es.string.search.js ***!
    \**********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsStringSearchJs(module, exports, __webpack_require__) {
    "use strict";

    var fixRegExpWellKnownSymbolLogic = __webpack_require__(
    /*! ../internals/fix-regexp-well-known-symbol-logic */
    "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var requireObjectCoercible = __webpack_require__(
    /*! ../internals/require-object-coercible */
    "./node_modules/core-js/internals/require-object-coercible.js");

    var sameValue = __webpack_require__(
    /*! ../internals/same-value */
    "./node_modules/core-js/internals/same-value.js");

    var regExpExec = __webpack_require__(
    /*! ../internals/regexp-exec-abstract */
    "./node_modules/core-js/internals/regexp-exec-abstract.js"); // @@search logic


    fixRegExpWellKnownSymbolLogic('search', 1, function (SEARCH, nativeSearch, maybeCallNative) {
      return [// `String.prototype.search` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.search
      function search(regexp) {
        var O = requireObjectCoercible(this);
        var searcher = regexp == undefined ? undefined : regexp[SEARCH];
        return searcher !== undefined ? searcher.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
      }, // `RegExp.prototype[@@search]` method
      // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
      function (regexp) {
        var res = maybeCallNative(nativeSearch, regexp, this);
        if (res.done) return res.value;
        var rx = anObject(regexp);
        var S = String(this);
        var previousLastIndex = rx.lastIndex;
        if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
        var result = regExpExec(rx, S);
        if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
        return result === null ? -1 : result.index;
      }];
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.string.small.js":
  /*!*********************************************************!*\
    !*** ./node_modules/core-js/modules/es.string.small.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsStringSmallJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var createHTML = __webpack_require__(
    /*! ../internals/create-html */
    "./node_modules/core-js/internals/create-html.js");

    var forcedStringHTMLMethod = __webpack_require__(
    /*! ../internals/string-html-forced */
    "./node_modules/core-js/internals/string-html-forced.js"); // `String.prototype.small` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.small


    $({
      target: 'String',
      proto: true,
      forced: forcedStringHTMLMethod('small')
    }, {
      small: function small() {
        return createHTML(this, 'small', '', '');
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.string.split.js":
  /*!*********************************************************!*\
    !*** ./node_modules/core-js/modules/es.string.split.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsStringSplitJs(module, exports, __webpack_require__) {
    "use strict";

    var fixRegExpWellKnownSymbolLogic = __webpack_require__(
    /*! ../internals/fix-regexp-well-known-symbol-logic */
    "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js");

    var isRegExp = __webpack_require__(
    /*! ../internals/is-regexp */
    "./node_modules/core-js/internals/is-regexp.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var requireObjectCoercible = __webpack_require__(
    /*! ../internals/require-object-coercible */
    "./node_modules/core-js/internals/require-object-coercible.js");

    var speciesConstructor = __webpack_require__(
    /*! ../internals/species-constructor */
    "./node_modules/core-js/internals/species-constructor.js");

    var advanceStringIndex = __webpack_require__(
    /*! ../internals/advance-string-index */
    "./node_modules/core-js/internals/advance-string-index.js");

    var toLength = __webpack_require__(
    /*! ../internals/to-length */
    "./node_modules/core-js/internals/to-length.js");

    var callRegExpExec = __webpack_require__(
    /*! ../internals/regexp-exec-abstract */
    "./node_modules/core-js/internals/regexp-exec-abstract.js");

    var regexpExec = __webpack_require__(
    /*! ../internals/regexp-exec */
    "./node_modules/core-js/internals/regexp-exec.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var arrayPush = [].push;
    var min = Math.min;
    var MAX_UINT32 = 0xFFFFFFFF; // babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError

    var SUPPORTS_Y = !fails(function () {
      return !RegExp(MAX_UINT32, 'y');
    }); // @@split logic

    fixRegExpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {
      var internalSplit;

      if ('abbc'.split(/(b)*/)[1] == 'c' || 'test'.split(/(?:)/, -1).length != 4 || 'ab'.split(/(?:ab)*/).length != 2 || '.'.split(/(.?)(.?)/).length != 4 || '.'.split(/()()/).length > 1 || ''.split(/.?/).length) {
        // based on es5-shim implementation, need to rework it
        internalSplit = function internalSplit(separator, limit) {
          var string = String(requireObjectCoercible(this));
          var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
          if (lim === 0) return [];
          if (separator === undefined) return [string]; // If `separator` is not a regex, use native split

          if (!isRegExp(separator)) {
            return nativeSplit.call(string, separator, lim);
          }

          var output = [];
          var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
          var lastLastIndex = 0; // Make `global` and avoid `lastIndex` issues by working with a copy

          var separatorCopy = new RegExp(separator.source, flags + 'g');
          var match, lastIndex, lastLength;

          while (match = regexpExec.call(separatorCopy, string)) {
            lastIndex = separatorCopy.lastIndex;

            if (lastIndex > lastLastIndex) {
              output.push(string.slice(lastLastIndex, match.index));
              if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
              lastLength = match[0].length;
              lastLastIndex = lastIndex;
              if (output.length >= lim) break;
            }

            if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
          }

          if (lastLastIndex === string.length) {
            if (lastLength || !separatorCopy.test('')) output.push('');
          } else output.push(string.slice(lastLastIndex));

          return output.length > lim ? output.slice(0, lim) : output;
        }; // Chakra, V8

      } else if ('0'.split(undefined, 0).length) {
        internalSplit = function internalSplit(separator, limit) {
          return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
        };
      } else internalSplit = nativeSplit;

      return [// `String.prototype.split` method
      // https://tc39.github.io/ecma262/#sec-string.prototype.split
      function split(separator, limit) {
        var O = requireObjectCoercible(this);
        var splitter = separator == undefined ? undefined : separator[SPLIT];
        return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
      }, // `RegExp.prototype[@@split]` method
      // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
      //
      // NOTE: This cannot be properly polyfilled in engines that don't support
      // the 'y' flag.
      function (regexp, limit) {
        var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
        if (res.done) return res.value;
        var rx = anObject(regexp);
        var S = String(this);
        var C = speciesConstructor(rx, RegExp);
        var unicodeMatching = rx.unicode;
        var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (SUPPORTS_Y ? 'y' : 'g'); // ^(? + rx + ) is needed, in combination with some S slicing, to
        // simulate the 'y' flag.

        var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
        var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
        if (lim === 0) return [];
        if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
        var p = 0;
        var q = 0;
        var A = [];

        while (q < S.length) {
          splitter.lastIndex = SUPPORTS_Y ? q : 0;
          var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
          var e;

          if (z === null || (e = min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) {
            q = advanceStringIndex(S, q, unicodeMatching);
          } else {
            A.push(S.slice(p, q));
            if (A.length === lim) return A;

            for (var i = 1; i <= z.length - 1; i++) {
              A.push(z[i]);
              if (A.length === lim) return A;
            }

            q = p = e;
          }
        }

        A.push(S.slice(p));
        return A;
      }];
    }, !SUPPORTS_Y);
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.string.starts-with.js":
  /*!***************************************************************!*\
    !*** ./node_modules/core-js/modules/es.string.starts-with.js ***!
    \***************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsStringStartsWithJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var getOwnPropertyDescriptor = __webpack_require__(
    /*! ../internals/object-get-own-property-descriptor */
    "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;

    var toLength = __webpack_require__(
    /*! ../internals/to-length */
    "./node_modules/core-js/internals/to-length.js");

    var notARegExp = __webpack_require__(
    /*! ../internals/not-a-regexp */
    "./node_modules/core-js/internals/not-a-regexp.js");

    var requireObjectCoercible = __webpack_require__(
    /*! ../internals/require-object-coercible */
    "./node_modules/core-js/internals/require-object-coercible.js");

    var correctIsRegExpLogic = __webpack_require__(
    /*! ../internals/correct-is-regexp-logic */
    "./node_modules/core-js/internals/correct-is-regexp-logic.js");

    var IS_PURE = __webpack_require__(
    /*! ../internals/is-pure */
    "./node_modules/core-js/internals/is-pure.js");

    var nativeStartsWith = ''.startsWith;
    var min = Math.min;
    var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('startsWith'); // https://github.com/zloirock/core-js/pull/702

    var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function () {
      var descriptor = getOwnPropertyDescriptor(String.prototype, 'startsWith');
      return descriptor && !descriptor.writable;
    }(); // `String.prototype.startsWith` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.startswith

    $({
      target: 'String',
      proto: true,
      forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC
    }, {
      startsWith: function startsWith(searchString
      /* , position = 0 */
      ) {
        var that = String(requireObjectCoercible(this));
        notARegExp(searchString);
        var index = toLength(min(arguments.length > 1 ? arguments[1] : undefined, that.length));
        var search = String(searchString);
        return nativeStartsWith ? nativeStartsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.string.strike.js":
  /*!**********************************************************!*\
    !*** ./node_modules/core-js/modules/es.string.strike.js ***!
    \**********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsStringStrikeJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var createHTML = __webpack_require__(
    /*! ../internals/create-html */
    "./node_modules/core-js/internals/create-html.js");

    var forcedStringHTMLMethod = __webpack_require__(
    /*! ../internals/string-html-forced */
    "./node_modules/core-js/internals/string-html-forced.js"); // `String.prototype.strike` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.strike


    $({
      target: 'String',
      proto: true,
      forced: forcedStringHTMLMethod('strike')
    }, {
      strike: function strike() {
        return createHTML(this, 'strike', '', '');
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.string.sub.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/modules/es.string.sub.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsStringSubJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var createHTML = __webpack_require__(
    /*! ../internals/create-html */
    "./node_modules/core-js/internals/create-html.js");

    var forcedStringHTMLMethod = __webpack_require__(
    /*! ../internals/string-html-forced */
    "./node_modules/core-js/internals/string-html-forced.js"); // `String.prototype.sub` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.sub


    $({
      target: 'String',
      proto: true,
      forced: forcedStringHTMLMethod('sub')
    }, {
      sub: function sub() {
        return createHTML(this, 'sub', '', '');
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.string.sup.js":
  /*!*******************************************************!*\
    !*** ./node_modules/core-js/modules/es.string.sup.js ***!
    \*******************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsStringSupJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var createHTML = __webpack_require__(
    /*! ../internals/create-html */
    "./node_modules/core-js/internals/create-html.js");

    var forcedStringHTMLMethod = __webpack_require__(
    /*! ../internals/string-html-forced */
    "./node_modules/core-js/internals/string-html-forced.js"); // `String.prototype.sup` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.sup


    $({
      target: 'String',
      proto: true,
      forced: forcedStringHTMLMethod('sup')
    }, {
      sup: function sup() {
        return createHTML(this, 'sup', '', '');
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.string.trim.js":
  /*!********************************************************!*\
    !*** ./node_modules/core-js/modules/es.string.trim.js ***!
    \********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsStringTrimJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var $trim = __webpack_require__(
    /*! ../internals/string-trim */
    "./node_modules/core-js/internals/string-trim.js").trim;

    var forcedStringTrimMethod = __webpack_require__(
    /*! ../internals/string-trim-forced */
    "./node_modules/core-js/internals/string-trim-forced.js"); // `String.prototype.trim` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.trim


    $({
      target: 'String',
      proto: true,
      forced: forcedStringTrimMethod('trim')
    }, {
      trim: function trim() {
        return $trim(this);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.symbol.async-iterator.js":
  /*!******************************************************************!*\
    !*** ./node_modules/core-js/modules/es.symbol.async-iterator.js ***!
    \******************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsSymbolAsyncIteratorJs(module, exports, __webpack_require__) {
    var defineWellKnownSymbol = __webpack_require__(
    /*! ../internals/define-well-known-symbol */
    "./node_modules/core-js/internals/define-well-known-symbol.js"); // `Symbol.asyncIterator` well-known symbol
    // https://tc39.github.io/ecma262/#sec-symbol.asynciterator


    defineWellKnownSymbol('asyncIterator');
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.symbol.description.js":
  /*!***************************************************************!*\
    !*** ./node_modules/core-js/modules/es.symbol.description.js ***!
    \***************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsSymbolDescriptionJs(module, exports, __webpack_require__) {
    "use strict"; // `Symbol.prototype.description` getter
    // https://tc39.github.io/ecma262/#sec-symbol.prototype.description

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var DESCRIPTORS = __webpack_require__(
    /*! ../internals/descriptors */
    "./node_modules/core-js/internals/descriptors.js");

    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    var has = __webpack_require__(
    /*! ../internals/has */
    "./node_modules/core-js/internals/has.js");

    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    var defineProperty = __webpack_require__(
    /*! ../internals/object-define-property */
    "./node_modules/core-js/internals/object-define-property.js").f;

    var copyConstructorProperties = __webpack_require__(
    /*! ../internals/copy-constructor-properties */
    "./node_modules/core-js/internals/copy-constructor-properties.js");

    var NativeSymbol = global.Symbol;

    if (DESCRIPTORS && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) || // Safari 12 bug
    NativeSymbol().description !== undefined)) {
      var EmptyStringDescriptionStore = {}; // wrap Symbol constructor for correct work with undefined description

      var SymbolWrapper = function Symbol() {
        var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
        var result = this instanceof SymbolWrapper ? new NativeSymbol(description) // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
        : description === undefined ? NativeSymbol() : NativeSymbol(description);
        if (description === '') EmptyStringDescriptionStore[result] = true;
        return result;
      };

      copyConstructorProperties(SymbolWrapper, NativeSymbol);
      var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
      symbolPrototype.constructor = SymbolWrapper;
      var symbolToString = symbolPrototype.toString;
      var native = String(NativeSymbol('test')) == 'Symbol(test)';
      var regexp = /^Symbol\((.*)\)[^)]+$/;
      defineProperty(symbolPrototype, 'description', {
        configurable: true,
        get: function description() {
          var symbol = isObject(this) ? this.valueOf() : this;
          var string = symbolToString.call(symbol);
          if (has(EmptyStringDescriptionStore, symbol)) return '';
          var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
          return desc === '' ? undefined : desc;
        }
      });
      $({
        global: true,
        forced: true
      }, {
        Symbol: SymbolWrapper
      });
    }
    /***/

  },

  /***/
  "./node_modules/core-js/modules/es.symbol.has-instance.js":
  /*!****************************************************************!*\
    !*** ./node_modules/core-js/modules/es.symbol.has-instance.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsSymbolHasInstanceJs(module, exports, __webpack_require__) {
    var defineWellKnownSymbol = __webpack_require__(
    /*! ../internals/define-well-known-symbol */
    "./node_modules/core-js/internals/define-well-known-symbol.js"); // `Symbol.hasInstance` well-known symbol
    // https://tc39.github.io/ecma262/#sec-symbol.hasinstance


    defineWellKnownSymbol('hasInstance');
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.symbol.is-concat-spreadable.js":
  /*!************************************************************************!*\
    !*** ./node_modules/core-js/modules/es.symbol.is-concat-spreadable.js ***!
    \************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsSymbolIsConcatSpreadableJs(module, exports, __webpack_require__) {
    var defineWellKnownSymbol = __webpack_require__(
    /*! ../internals/define-well-known-symbol */
    "./node_modules/core-js/internals/define-well-known-symbol.js"); // `Symbol.isConcatSpreadable` well-known symbol
    // https://tc39.github.io/ecma262/#sec-symbol.isconcatspreadable


    defineWellKnownSymbol('isConcatSpreadable');
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.symbol.iterator.js":
  /*!************************************************************!*\
    !*** ./node_modules/core-js/modules/es.symbol.iterator.js ***!
    \************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsSymbolIteratorJs(module, exports, __webpack_require__) {
    var defineWellKnownSymbol = __webpack_require__(
    /*! ../internals/define-well-known-symbol */
    "./node_modules/core-js/internals/define-well-known-symbol.js"); // `Symbol.iterator` well-known symbol
    // https://tc39.github.io/ecma262/#sec-symbol.iterator


    defineWellKnownSymbol('iterator');
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.symbol.js":
  /*!***************************************************!*\
    !*** ./node_modules/core-js/modules/es.symbol.js ***!
    \***************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsSymbolJs(module, exports, __webpack_require__) {
    "use strict";

    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    var getBuiltIn = __webpack_require__(
    /*! ../internals/get-built-in */
    "./node_modules/core-js/internals/get-built-in.js");

    var IS_PURE = __webpack_require__(
    /*! ../internals/is-pure */
    "./node_modules/core-js/internals/is-pure.js");

    var DESCRIPTORS = __webpack_require__(
    /*! ../internals/descriptors */
    "./node_modules/core-js/internals/descriptors.js");

    var NATIVE_SYMBOL = __webpack_require__(
    /*! ../internals/native-symbol */
    "./node_modules/core-js/internals/native-symbol.js");

    var USE_SYMBOL_AS_UID = __webpack_require__(
    /*! ../internals/use-symbol-as-uid */
    "./node_modules/core-js/internals/use-symbol-as-uid.js");

    var fails = __webpack_require__(
    /*! ../internals/fails */
    "./node_modules/core-js/internals/fails.js");

    var has = __webpack_require__(
    /*! ../internals/has */
    "./node_modules/core-js/internals/has.js");

    var isArray = __webpack_require__(
    /*! ../internals/is-array */
    "./node_modules/core-js/internals/is-array.js");

    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var toObject = __webpack_require__(
    /*! ../internals/to-object */
    "./node_modules/core-js/internals/to-object.js");

    var toIndexedObject = __webpack_require__(
    /*! ../internals/to-indexed-object */
    "./node_modules/core-js/internals/to-indexed-object.js");

    var toPrimitive = __webpack_require__(
    /*! ../internals/to-primitive */
    "./node_modules/core-js/internals/to-primitive.js");

    var createPropertyDescriptor = __webpack_require__(
    /*! ../internals/create-property-descriptor */
    "./node_modules/core-js/internals/create-property-descriptor.js");

    var nativeObjectCreate = __webpack_require__(
    /*! ../internals/object-create */
    "./node_modules/core-js/internals/object-create.js");

    var objectKeys = __webpack_require__(
    /*! ../internals/object-keys */
    "./node_modules/core-js/internals/object-keys.js");

    var getOwnPropertyNamesModule = __webpack_require__(
    /*! ../internals/object-get-own-property-names */
    "./node_modules/core-js/internals/object-get-own-property-names.js");

    var getOwnPropertyNamesExternal = __webpack_require__(
    /*! ../internals/object-get-own-property-names-external */
    "./node_modules/core-js/internals/object-get-own-property-names-external.js");

    var getOwnPropertySymbolsModule = __webpack_require__(
    /*! ../internals/object-get-own-property-symbols */
    "./node_modules/core-js/internals/object-get-own-property-symbols.js");

    var getOwnPropertyDescriptorModule = __webpack_require__(
    /*! ../internals/object-get-own-property-descriptor */
    "./node_modules/core-js/internals/object-get-own-property-descriptor.js");

    var definePropertyModule = __webpack_require__(
    /*! ../internals/object-define-property */
    "./node_modules/core-js/internals/object-define-property.js");

    var propertyIsEnumerableModule = __webpack_require__(
    /*! ../internals/object-property-is-enumerable */
    "./node_modules/core-js/internals/object-property-is-enumerable.js");

    var createNonEnumerableProperty = __webpack_require__(
    /*! ../internals/create-non-enumerable-property */
    "./node_modules/core-js/internals/create-non-enumerable-property.js");

    var redefine = __webpack_require__(
    /*! ../internals/redefine */
    "./node_modules/core-js/internals/redefine.js");

    var shared = __webpack_require__(
    /*! ../internals/shared */
    "./node_modules/core-js/internals/shared.js");

    var sharedKey = __webpack_require__(
    /*! ../internals/shared-key */
    "./node_modules/core-js/internals/shared-key.js");

    var hiddenKeys = __webpack_require__(
    /*! ../internals/hidden-keys */
    "./node_modules/core-js/internals/hidden-keys.js");

    var uid = __webpack_require__(
    /*! ../internals/uid */
    "./node_modules/core-js/internals/uid.js");

    var wellKnownSymbol = __webpack_require__(
    /*! ../internals/well-known-symbol */
    "./node_modules/core-js/internals/well-known-symbol.js");

    var wrappedWellKnownSymbolModule = __webpack_require__(
    /*! ../internals/well-known-symbol-wrapped */
    "./node_modules/core-js/internals/well-known-symbol-wrapped.js");

    var defineWellKnownSymbol = __webpack_require__(
    /*! ../internals/define-well-known-symbol */
    "./node_modules/core-js/internals/define-well-known-symbol.js");

    var setToStringTag = __webpack_require__(
    /*! ../internals/set-to-string-tag */
    "./node_modules/core-js/internals/set-to-string-tag.js");

    var InternalStateModule = __webpack_require__(
    /*! ../internals/internal-state */
    "./node_modules/core-js/internals/internal-state.js");

    var $forEach = __webpack_require__(
    /*! ../internals/array-iteration */
    "./node_modules/core-js/internals/array-iteration.js").forEach;

    var HIDDEN = sharedKey('hidden');
    var SYMBOL = 'Symbol';
    var PROTOTYPE = 'prototype';
    var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
    var setInternalState = InternalStateModule.set;
    var getInternalState = InternalStateModule.getterFor(SYMBOL);
    var ObjectPrototype = Object[PROTOTYPE];
    var $Symbol = global.Symbol;
    var $stringify = getBuiltIn('JSON', 'stringify');
    var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    var nativeDefineProperty = definePropertyModule.f;
    var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
    var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
    var AllSymbols = shared('symbols');
    var ObjectPrototypeSymbols = shared('op-symbols');
    var StringToSymbolRegistry = shared('string-to-symbol-registry');
    var SymbolToStringRegistry = shared('symbol-to-string-registry');
    var WellKnownSymbolsStore = shared('wks');
    var QObject = global.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

    var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

    var setSymbolDescriptor = DESCRIPTORS && fails(function () {
      return nativeObjectCreate(nativeDefineProperty({}, 'a', {
        get: function get() {
          return nativeDefineProperty(this, 'a', {
            value: 7
          }).a;
        }
      })).a != 7;
    }) ? function (O, P, Attributes) {
      var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
      if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
      nativeDefineProperty(O, P, Attributes);

      if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
        nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
      }
    } : nativeDefineProperty;

    var wrap = function wrap(tag, description) {
      var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
      setInternalState(symbol, {
        type: SYMBOL,
        tag: tag,
        description: description
      });
      if (!DESCRIPTORS) symbol.description = description;
      return symbol;
    };

    var isSymbol = USE_SYMBOL_AS_UID ? function (it) {
      return typeof it == 'symbol';
    } : function (it) {
      return Object(it) instanceof $Symbol;
    };

    var $defineProperty = function defineProperty(O, P, Attributes) {
      if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
      anObject(O);
      var key = toPrimitive(P, true);
      anObject(Attributes);

      if (has(AllSymbols, key)) {
        if (!Attributes.enumerable) {
          if (!has(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
          O[HIDDEN][key] = true;
        } else {
          if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
          Attributes = nativeObjectCreate(Attributes, {
            enumerable: createPropertyDescriptor(0, false)
          });
        }

        return setSymbolDescriptor(O, key, Attributes);
      }

      return nativeDefineProperty(O, key, Attributes);
    };

    var $defineProperties = function defineProperties(O, Properties) {
      anObject(O);
      var properties = toIndexedObject(Properties);
      var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
      $forEach(keys, function (key) {
        if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
      });
      return O;
    };

    var $create = function create(O, Properties) {
      return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
    };

    var $propertyIsEnumerable = function propertyIsEnumerable(V) {
      var P = toPrimitive(V, true);
      var enumerable = nativePropertyIsEnumerable.call(this, P);
      if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
      return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
    };

    var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
      var it = toIndexedObject(O);
      var key = toPrimitive(P, true);
      if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
      var descriptor = nativeGetOwnPropertyDescriptor(it, key);

      if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
        descriptor.enumerable = true;
      }

      return descriptor;
    };

    var $getOwnPropertyNames = function getOwnPropertyNames(O) {
      var names = nativeGetOwnPropertyNames(toIndexedObject(O));
      var result = [];
      $forEach(names, function (key) {
        if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
      });
      return result;
    };

    var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
      var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
      var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
      var result = [];
      $forEach(names, function (key) {
        if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
          result.push(AllSymbols[key]);
        }
      });
      return result;
    }; // `Symbol` constructor
    // https://tc39.github.io/ecma262/#sec-symbol-constructor


    if (!NATIVE_SYMBOL) {
      $Symbol = function Symbol() {
        if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
        var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
        var tag = uid(description);

        var setter = function setter(value) {
          if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
          if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
          setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
        };

        if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, {
          configurable: true,
          set: setter
        });
        return wrap(tag, description);
      };

      redefine($Symbol[PROTOTYPE], 'toString', function toString() {
        return getInternalState(this).tag;
      });
      redefine($Symbol, 'withoutSetter', function (description) {
        return wrap(uid(description), description);
      });
      propertyIsEnumerableModule.f = $propertyIsEnumerable;
      definePropertyModule.f = $defineProperty;
      getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
      getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
      getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;

      wrappedWellKnownSymbolModule.f = function (name) {
        return wrap(wellKnownSymbol(name), name);
      };

      if (DESCRIPTORS) {
        // https://github.com/tc39/proposal-Symbol-description
        nativeDefineProperty($Symbol[PROTOTYPE], 'description', {
          configurable: true,
          get: function description() {
            return getInternalState(this).description;
          }
        });

        if (!IS_PURE) {
          redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, {
            unsafe: true
          });
        }
      }
    }

    $({
      global: true,
      wrap: true,
      forced: !NATIVE_SYMBOL,
      sham: !NATIVE_SYMBOL
    }, {
      Symbol: $Symbol
    });
    $forEach(objectKeys(WellKnownSymbolsStore), function (name) {
      defineWellKnownSymbol(name);
    });
    $({
      target: SYMBOL,
      stat: true,
      forced: !NATIVE_SYMBOL
    }, {
      // `Symbol.for` method
      // https://tc39.github.io/ecma262/#sec-symbol.for
      'for': function _for(key) {
        var string = String(key);
        if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
        var symbol = $Symbol(string);
        StringToSymbolRegistry[string] = symbol;
        SymbolToStringRegistry[symbol] = string;
        return symbol;
      },
      // `Symbol.keyFor` method
      // https://tc39.github.io/ecma262/#sec-symbol.keyfor
      keyFor: function keyFor(sym) {
        if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
        if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
      },
      useSetter: function useSetter() {
        USE_SETTER = true;
      },
      useSimple: function useSimple() {
        USE_SETTER = false;
      }
    });
    $({
      target: 'Object',
      stat: true,
      forced: !NATIVE_SYMBOL,
      sham: !DESCRIPTORS
    }, {
      // `Object.create` method
      // https://tc39.github.io/ecma262/#sec-object.create
      create: $create,
      // `Object.defineProperty` method
      // https://tc39.github.io/ecma262/#sec-object.defineproperty
      defineProperty: $defineProperty,
      // `Object.defineProperties` method
      // https://tc39.github.io/ecma262/#sec-object.defineproperties
      defineProperties: $defineProperties,
      // `Object.getOwnPropertyDescriptor` method
      // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
      getOwnPropertyDescriptor: $getOwnPropertyDescriptor
    });
    $({
      target: 'Object',
      stat: true,
      forced: !NATIVE_SYMBOL
    }, {
      // `Object.getOwnPropertyNames` method
      // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
      getOwnPropertyNames: $getOwnPropertyNames,
      // `Object.getOwnPropertySymbols` method
      // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
      getOwnPropertySymbols: $getOwnPropertySymbols
    }); // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
    // https://bugs.chromium.org/p/v8/issues/detail?id=3443

    $({
      target: 'Object',
      stat: true,
      forced: fails(function () {
        getOwnPropertySymbolsModule.f(1);
      })
    }, {
      getOwnPropertySymbols: function getOwnPropertySymbols(it) {
        return getOwnPropertySymbolsModule.f(toObject(it));
      }
    }); // `JSON.stringify` method behavior with symbols
    // https://tc39.github.io/ecma262/#sec-json.stringify

    if ($stringify) {
      var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function () {
        var symbol = $Symbol(); // MS Edge converts symbol values to JSON as {}

        return $stringify([symbol]) != '[null]' // WebKit converts symbol values to JSON as null
        || $stringify({
          a: symbol
        }) != '{}' // V8 throws on boxed symbols
        || $stringify(Object(symbol)) != '{}';
      });
      $({
        target: 'JSON',
        stat: true,
        forced: FORCED_JSON_STRINGIFY
      }, {
        // eslint-disable-next-line no-unused-vars
        stringify: function stringify(it, replacer, space) {
          var args = [it];
          var index = 1;
          var $replacer;

          while (arguments.length > index) args.push(arguments[index++]);

          $replacer = replacer;
          if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

          if (!isArray(replacer)) replacer = function replacer(key, value) {
            if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
            if (!isSymbol(value)) return value;
          };
          args[1] = replacer;
          return $stringify.apply(null, args);
        }
      });
    } // `Symbol.prototype[@@toPrimitive]` method
    // https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive


    if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {
      createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
    } // `Symbol.prototype[@@toStringTag]` property
    // https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag


    setToStringTag($Symbol, SYMBOL);
    hiddenKeys[HIDDEN] = true;
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.symbol.match-all.js":
  /*!*************************************************************!*\
    !*** ./node_modules/core-js/modules/es.symbol.match-all.js ***!
    \*************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsSymbolMatchAllJs(module, exports, __webpack_require__) {
    var defineWellKnownSymbol = __webpack_require__(
    /*! ../internals/define-well-known-symbol */
    "./node_modules/core-js/internals/define-well-known-symbol.js"); // `Symbol.matchAll` well-known symbol


    defineWellKnownSymbol('matchAll');
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.symbol.match.js":
  /*!*********************************************************!*\
    !*** ./node_modules/core-js/modules/es.symbol.match.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsSymbolMatchJs(module, exports, __webpack_require__) {
    var defineWellKnownSymbol = __webpack_require__(
    /*! ../internals/define-well-known-symbol */
    "./node_modules/core-js/internals/define-well-known-symbol.js"); // `Symbol.match` well-known symbol
    // https://tc39.github.io/ecma262/#sec-symbol.match


    defineWellKnownSymbol('match');
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.symbol.replace.js":
  /*!***********************************************************!*\
    !*** ./node_modules/core-js/modules/es.symbol.replace.js ***!
    \***********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsSymbolReplaceJs(module, exports, __webpack_require__) {
    var defineWellKnownSymbol = __webpack_require__(
    /*! ../internals/define-well-known-symbol */
    "./node_modules/core-js/internals/define-well-known-symbol.js"); // `Symbol.replace` well-known symbol
    // https://tc39.github.io/ecma262/#sec-symbol.replace


    defineWellKnownSymbol('replace');
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.symbol.search.js":
  /*!**********************************************************!*\
    !*** ./node_modules/core-js/modules/es.symbol.search.js ***!
    \**********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsSymbolSearchJs(module, exports, __webpack_require__) {
    var defineWellKnownSymbol = __webpack_require__(
    /*! ../internals/define-well-known-symbol */
    "./node_modules/core-js/internals/define-well-known-symbol.js"); // `Symbol.search` well-known symbol
    // https://tc39.github.io/ecma262/#sec-symbol.search


    defineWellKnownSymbol('search');
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.symbol.species.js":
  /*!***********************************************************!*\
    !*** ./node_modules/core-js/modules/es.symbol.species.js ***!
    \***********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsSymbolSpeciesJs(module, exports, __webpack_require__) {
    var defineWellKnownSymbol = __webpack_require__(
    /*! ../internals/define-well-known-symbol */
    "./node_modules/core-js/internals/define-well-known-symbol.js"); // `Symbol.species` well-known symbol
    // https://tc39.github.io/ecma262/#sec-symbol.species


    defineWellKnownSymbol('species');
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.symbol.split.js":
  /*!*********************************************************!*\
    !*** ./node_modules/core-js/modules/es.symbol.split.js ***!
    \*********************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsSymbolSplitJs(module, exports, __webpack_require__) {
    var defineWellKnownSymbol = __webpack_require__(
    /*! ../internals/define-well-known-symbol */
    "./node_modules/core-js/internals/define-well-known-symbol.js"); // `Symbol.split` well-known symbol
    // https://tc39.github.io/ecma262/#sec-symbol.split


    defineWellKnownSymbol('split');
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.symbol.to-primitive.js":
  /*!****************************************************************!*\
    !*** ./node_modules/core-js/modules/es.symbol.to-primitive.js ***!
    \****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsSymbolToPrimitiveJs(module, exports, __webpack_require__) {
    var defineWellKnownSymbol = __webpack_require__(
    /*! ../internals/define-well-known-symbol */
    "./node_modules/core-js/internals/define-well-known-symbol.js"); // `Symbol.toPrimitive` well-known symbol
    // https://tc39.github.io/ecma262/#sec-symbol.toprimitive


    defineWellKnownSymbol('toPrimitive');
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.symbol.to-string-tag.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/core-js/modules/es.symbol.to-string-tag.js ***!
    \*****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsSymbolToStringTagJs(module, exports, __webpack_require__) {
    var defineWellKnownSymbol = __webpack_require__(
    /*! ../internals/define-well-known-symbol */
    "./node_modules/core-js/internals/define-well-known-symbol.js"); // `Symbol.toStringTag` well-known symbol
    // https://tc39.github.io/ecma262/#sec-symbol.tostringtag


    defineWellKnownSymbol('toStringTag');
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.symbol.unscopables.js":
  /*!***************************************************************!*\
    !*** ./node_modules/core-js/modules/es.symbol.unscopables.js ***!
    \***************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsSymbolUnscopablesJs(module, exports, __webpack_require__) {
    var defineWellKnownSymbol = __webpack_require__(
    /*! ../internals/define-well-known-symbol */
    "./node_modules/core-js/internals/define-well-known-symbol.js"); // `Symbol.unscopables` well-known symbol
    // https://tc39.github.io/ecma262/#sec-symbol.unscopables


    defineWellKnownSymbol('unscopables');
    /***/
  },

  /***/
  "./node_modules/core-js/modules/es.weak-map.js":
  /*!*****************************************************!*\
    !*** ./node_modules/core-js/modules/es.weak-map.js ***!
    \*****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsWeakMapJs(module, exports, __webpack_require__) {
    "use strict";

    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    var redefineAll = __webpack_require__(
    /*! ../internals/redefine-all */
    "./node_modules/core-js/internals/redefine-all.js");

    var InternalMetadataModule = __webpack_require__(
    /*! ../internals/internal-metadata */
    "./node_modules/core-js/internals/internal-metadata.js");

    var collection = __webpack_require__(
    /*! ../internals/collection */
    "./node_modules/core-js/internals/collection.js");

    var collectionWeak = __webpack_require__(
    /*! ../internals/collection-weak */
    "./node_modules/core-js/internals/collection-weak.js");

    var isObject = __webpack_require__(
    /*! ../internals/is-object */
    "./node_modules/core-js/internals/is-object.js");

    var enforceIternalState = __webpack_require__(
    /*! ../internals/internal-state */
    "./node_modules/core-js/internals/internal-state.js").enforce;

    var NATIVE_WEAK_MAP = __webpack_require__(
    /*! ../internals/native-weak-map */
    "./node_modules/core-js/internals/native-weak-map.js");

    var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
    var isExtensible = Object.isExtensible;
    var InternalWeakMap;

    var wrapper = function wrapper(init) {
      return function WeakMap() {
        return init(this, arguments.length ? arguments[0] : undefined);
      };
    }; // `WeakMap` constructor
    // https://tc39.github.io/ecma262/#sec-weakmap-constructor


    var $WeakMap = module.exports = collection('WeakMap', wrapper, collectionWeak); // IE11 WeakMap frozen keys fix
    // We can't use feature detection because it crash some old IE builds
    // https://github.com/zloirock/core-js/issues/485

    if (NATIVE_WEAK_MAP && IS_IE11) {
      InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);
      InternalMetadataModule.REQUIRED = true;
      var WeakMapPrototype = $WeakMap.prototype;
      var nativeDelete = WeakMapPrototype['delete'];
      var nativeHas = WeakMapPrototype.has;
      var nativeGet = WeakMapPrototype.get;
      var nativeSet = WeakMapPrototype.set;
      redefineAll(WeakMapPrototype, {
        'delete': function _delete(key) {
          if (isObject(key) && !isExtensible(key)) {
            var state = enforceIternalState(this);
            if (!state.frozen) state.frozen = new InternalWeakMap();
            return nativeDelete.call(this, key) || state.frozen['delete'](key);
          }

          return nativeDelete.call(this, key);
        },
        has: function has(key) {
          if (isObject(key) && !isExtensible(key)) {
            var state = enforceIternalState(this);
            if (!state.frozen) state.frozen = new InternalWeakMap();
            return nativeHas.call(this, key) || state.frozen.has(key);
          }

          return nativeHas.call(this, key);
        },
        get: function get(key) {
          if (isObject(key) && !isExtensible(key)) {
            var state = enforceIternalState(this);
            if (!state.frozen) state.frozen = new InternalWeakMap();
            return nativeHas.call(this, key) ? nativeGet.call(this, key) : state.frozen.get(key);
          }

          return nativeGet.call(this, key);
        },
        set: function set(key, value) {
          if (isObject(key) && !isExtensible(key)) {
            var state = enforceIternalState(this);
            if (!state.frozen) state.frozen = new InternalWeakMap();
            nativeHas.call(this, key) ? nativeSet.call(this, key, value) : state.frozen.set(key, value);
          } else nativeSet.call(this, key, value);

          return this;
        }
      });
    }
    /***/

  },

  /***/
  "./node_modules/core-js/modules/esnext.reflect.define-metadata.js":
  /*!************************************************************************!*\
    !*** ./node_modules/core-js/modules/esnext.reflect.define-metadata.js ***!
    \************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsnextReflectDefineMetadataJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var ReflectMetadataModule = __webpack_require__(
    /*! ../internals/reflect-metadata */
    "./node_modules/core-js/internals/reflect-metadata.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var toMetadataKey = ReflectMetadataModule.toKey;
    var ordinaryDefineOwnMetadata = ReflectMetadataModule.set; // `Reflect.defineMetadata` method
    // https://github.com/rbuckton/reflect-metadata

    $({
      target: 'Reflect',
      stat: true
    }, {
      defineMetadata: function defineMetadata(metadataKey, metadataValue, target
      /* , targetKey */
      ) {
        var targetKey = arguments.length < 4 ? undefined : toMetadataKey(arguments[3]);
        ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), targetKey);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/esnext.reflect.delete-metadata.js":
  /*!************************************************************************!*\
    !*** ./node_modules/core-js/modules/esnext.reflect.delete-metadata.js ***!
    \************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsnextReflectDeleteMetadataJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var ReflectMetadataModule = __webpack_require__(
    /*! ../internals/reflect-metadata */
    "./node_modules/core-js/internals/reflect-metadata.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var toMetadataKey = ReflectMetadataModule.toKey;
    var getOrCreateMetadataMap = ReflectMetadataModule.getMap;
    var store = ReflectMetadataModule.store; // `Reflect.deleteMetadata` method
    // https://github.com/rbuckton/reflect-metadata

    $({
      target: 'Reflect',
      stat: true
    }, {
      deleteMetadata: function deleteMetadata(metadataKey, target
      /* , targetKey */
      ) {
        var targetKey = arguments.length < 3 ? undefined : toMetadataKey(arguments[2]);
        var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
        if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
        if (metadataMap.size) return true;
        var targetMetadata = store.get(target);
        targetMetadata['delete'](targetKey);
        return !!targetMetadata.size || store['delete'](target);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/esnext.reflect.get-metadata-keys.js":
  /*!**************************************************************************!*\
    !*** ./node_modules/core-js/modules/esnext.reflect.get-metadata-keys.js ***!
    \**************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsnextReflectGetMetadataKeysJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js"); // TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`


    var Set = __webpack_require__(
    /*! ../modules/es.set */
    "./node_modules/core-js/modules/es.set.js");

    var ReflectMetadataModule = __webpack_require__(
    /*! ../internals/reflect-metadata */
    "./node_modules/core-js/internals/reflect-metadata.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var getPrototypeOf = __webpack_require__(
    /*! ../internals/object-get-prototype-of */
    "./node_modules/core-js/internals/object-get-prototype-of.js");

    var iterate = __webpack_require__(
    /*! ../internals/iterate */
    "./node_modules/core-js/internals/iterate.js");

    var ordinaryOwnMetadataKeys = ReflectMetadataModule.keys;
    var toMetadataKey = ReflectMetadataModule.toKey;

    var from = function from(iter) {
      var result = [];
      iterate(iter, result.push, result);
      return result;
    };

    var ordinaryMetadataKeys = function ordinaryMetadataKeys(O, P) {
      var oKeys = ordinaryOwnMetadataKeys(O, P);
      var parent = getPrototypeOf(O);
      if (parent === null) return oKeys;
      var pKeys = ordinaryMetadataKeys(parent, P);
      return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
    }; // `Reflect.getMetadataKeys` method
    // https://github.com/rbuckton/reflect-metadata


    $({
      target: 'Reflect',
      stat: true
    }, {
      getMetadataKeys: function getMetadataKeys(target
      /* , targetKey */
      ) {
        var targetKey = arguments.length < 2 ? undefined : toMetadataKey(arguments[1]);
        return ordinaryMetadataKeys(anObject(target), targetKey);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/esnext.reflect.get-metadata.js":
  /*!*********************************************************************!*\
    !*** ./node_modules/core-js/modules/esnext.reflect.get-metadata.js ***!
    \*********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsnextReflectGetMetadataJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var ReflectMetadataModule = __webpack_require__(
    /*! ../internals/reflect-metadata */
    "./node_modules/core-js/internals/reflect-metadata.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var getPrototypeOf = __webpack_require__(
    /*! ../internals/object-get-prototype-of */
    "./node_modules/core-js/internals/object-get-prototype-of.js");

    var ordinaryHasOwnMetadata = ReflectMetadataModule.has;
    var ordinaryGetOwnMetadata = ReflectMetadataModule.get;
    var toMetadataKey = ReflectMetadataModule.toKey;

    var ordinaryGetMetadata = function ordinaryGetMetadata(MetadataKey, O, P) {
      var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
      var parent = getPrototypeOf(O);
      return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
    }; // `Reflect.getMetadata` method
    // https://github.com/rbuckton/reflect-metadata


    $({
      target: 'Reflect',
      stat: true
    }, {
      getMetadata: function getMetadata(metadataKey, target
      /* , targetKey */
      ) {
        var targetKey = arguments.length < 3 ? undefined : toMetadataKey(arguments[2]);
        return ordinaryGetMetadata(metadataKey, anObject(target), targetKey);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/esnext.reflect.get-own-metadata-keys.js":
  /*!******************************************************************************!*\
    !*** ./node_modules/core-js/modules/esnext.reflect.get-own-metadata-keys.js ***!
    \******************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsnextReflectGetOwnMetadataKeysJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var ReflectMetadataModule = __webpack_require__(
    /*! ../internals/reflect-metadata */
    "./node_modules/core-js/internals/reflect-metadata.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var ordinaryOwnMetadataKeys = ReflectMetadataModule.keys;
    var toMetadataKey = ReflectMetadataModule.toKey; // `Reflect.getOwnMetadataKeys` method
    // https://github.com/rbuckton/reflect-metadata

    $({
      target: 'Reflect',
      stat: true
    }, {
      getOwnMetadataKeys: function getOwnMetadataKeys(target
      /* , targetKey */
      ) {
        var targetKey = arguments.length < 2 ? undefined : toMetadataKey(arguments[1]);
        return ordinaryOwnMetadataKeys(anObject(target), targetKey);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/esnext.reflect.get-own-metadata.js":
  /*!*************************************************************************!*\
    !*** ./node_modules/core-js/modules/esnext.reflect.get-own-metadata.js ***!
    \*************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsnextReflectGetOwnMetadataJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var ReflectMetadataModule = __webpack_require__(
    /*! ../internals/reflect-metadata */
    "./node_modules/core-js/internals/reflect-metadata.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var ordinaryGetOwnMetadata = ReflectMetadataModule.get;
    var toMetadataKey = ReflectMetadataModule.toKey; // `Reflect.getOwnMetadata` method
    // https://github.com/rbuckton/reflect-metadata

    $({
      target: 'Reflect',
      stat: true
    }, {
      getOwnMetadata: function getOwnMetadata(metadataKey, target
      /* , targetKey */
      ) {
        var targetKey = arguments.length < 3 ? undefined : toMetadataKey(arguments[2]);
        return ordinaryGetOwnMetadata(metadataKey, anObject(target), targetKey);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/esnext.reflect.has-metadata.js":
  /*!*********************************************************************!*\
    !*** ./node_modules/core-js/modules/esnext.reflect.has-metadata.js ***!
    \*********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsnextReflectHasMetadataJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var ReflectMetadataModule = __webpack_require__(
    /*! ../internals/reflect-metadata */
    "./node_modules/core-js/internals/reflect-metadata.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var getPrototypeOf = __webpack_require__(
    /*! ../internals/object-get-prototype-of */
    "./node_modules/core-js/internals/object-get-prototype-of.js");

    var ordinaryHasOwnMetadata = ReflectMetadataModule.has;
    var toMetadataKey = ReflectMetadataModule.toKey;

    var ordinaryHasMetadata = function ordinaryHasMetadata(MetadataKey, O, P) {
      var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
      if (hasOwn) return true;
      var parent = getPrototypeOf(O);
      return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
    }; // `Reflect.hasMetadata` method
    // https://github.com/rbuckton/reflect-metadata


    $({
      target: 'Reflect',
      stat: true
    }, {
      hasMetadata: function hasMetadata(metadataKey, target
      /* , targetKey */
      ) {
        var targetKey = arguments.length < 3 ? undefined : toMetadataKey(arguments[2]);
        return ordinaryHasMetadata(metadataKey, anObject(target), targetKey);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/esnext.reflect.has-own-metadata.js":
  /*!*************************************************************************!*\
    !*** ./node_modules/core-js/modules/esnext.reflect.has-own-metadata.js ***!
    \*************************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsnextReflectHasOwnMetadataJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var ReflectMetadataModule = __webpack_require__(
    /*! ../internals/reflect-metadata */
    "./node_modules/core-js/internals/reflect-metadata.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var ordinaryHasOwnMetadata = ReflectMetadataModule.has;
    var toMetadataKey = ReflectMetadataModule.toKey; // `Reflect.hasOwnMetadata` method
    // https://github.com/rbuckton/reflect-metadata

    $({
      target: 'Reflect',
      stat: true
    }, {
      hasOwnMetadata: function hasOwnMetadata(metadataKey, target
      /* , targetKey */
      ) {
        var targetKey = arguments.length < 3 ? undefined : toMetadataKey(arguments[2]);
        return ordinaryHasOwnMetadata(metadataKey, anObject(target), targetKey);
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/esnext.reflect.metadata.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/core-js/modules/esnext.reflect.metadata.js ***!
    \*****************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesEsnextReflectMetadataJs(module, exports, __webpack_require__) {
    var $ = __webpack_require__(
    /*! ../internals/export */
    "./node_modules/core-js/internals/export.js");

    var ReflectMetadataModule = __webpack_require__(
    /*! ../internals/reflect-metadata */
    "./node_modules/core-js/internals/reflect-metadata.js");

    var anObject = __webpack_require__(
    /*! ../internals/an-object */
    "./node_modules/core-js/internals/an-object.js");

    var toMetadataKey = ReflectMetadataModule.toKey;
    var ordinaryDefineOwnMetadata = ReflectMetadataModule.set; // `Reflect.metadata` method
    // https://github.com/rbuckton/reflect-metadata

    $({
      target: 'Reflect',
      stat: true
    }, {
      metadata: function metadata(metadataKey, metadataValue) {
        return function decorator(target, key) {
          ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetadataKey(key));
        };
      }
    });
    /***/
  },

  /***/
  "./node_modules/core-js/modules/web.dom-collections.for-each.js":
  /*!**********************************************************************!*\
    !*** ./node_modules/core-js/modules/web.dom-collections.for-each.js ***!
    \**********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesWebDomCollectionsForEachJs(module, exports, __webpack_require__) {
    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    var DOMIterables = __webpack_require__(
    /*! ../internals/dom-iterables */
    "./node_modules/core-js/internals/dom-iterables.js");

    var forEach = __webpack_require__(
    /*! ../internals/array-for-each */
    "./node_modules/core-js/internals/array-for-each.js");

    var createNonEnumerableProperty = __webpack_require__(
    /*! ../internals/create-non-enumerable-property */
    "./node_modules/core-js/internals/create-non-enumerable-property.js");

    for (var COLLECTION_NAME in DOMIterables) {
      var Collection = global[COLLECTION_NAME];
      var CollectionPrototype = Collection && Collection.prototype; // some Chrome versions have non-configurable methods on DOMTokenList

      if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
        createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);
      } catch (error) {
        CollectionPrototype.forEach = forEach;
      }
    }
    /***/

  },

  /***/
  "./node_modules/core-js/modules/web.dom-collections.iterator.js":
  /*!**********************************************************************!*\
    !*** ./node_modules/core-js/modules/web.dom-collections.iterator.js ***!
    \**********************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsModulesWebDomCollectionsIteratorJs(module, exports, __webpack_require__) {
    var global = __webpack_require__(
    /*! ../internals/global */
    "./node_modules/core-js/internals/global.js");

    var DOMIterables = __webpack_require__(
    /*! ../internals/dom-iterables */
    "./node_modules/core-js/internals/dom-iterables.js");

    var ArrayIteratorMethods = __webpack_require__(
    /*! ../modules/es.array.iterator */
    "./node_modules/core-js/modules/es.array.iterator.js");

    var createNonEnumerableProperty = __webpack_require__(
    /*! ../internals/create-non-enumerable-property */
    "./node_modules/core-js/internals/create-non-enumerable-property.js");

    var wellKnownSymbol = __webpack_require__(
    /*! ../internals/well-known-symbol */
    "./node_modules/core-js/internals/well-known-symbol.js");

    var ITERATOR = wellKnownSymbol('iterator');
    var TO_STRING_TAG = wellKnownSymbol('toStringTag');
    var ArrayValues = ArrayIteratorMethods.values;

    for (var COLLECTION_NAME in DOMIterables) {
      var Collection = global[COLLECTION_NAME];
      var CollectionPrototype = Collection && Collection.prototype;

      if (CollectionPrototype) {
        // some Chrome versions have non-configurable methods on DOMTokenList
        if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
          createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
        } catch (error) {
          CollectionPrototype[ITERATOR] = ArrayValues;
        }

        if (!CollectionPrototype[TO_STRING_TAG]) {
          createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
        }

        if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
          // some Chrome versions have non-configurable methods on DOMTokenList
          if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
            createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
          } catch (error) {
            CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
          }
        }
      }
    }
    /***/

  },

  /***/
  "./node_modules/core-js/proposals/reflect-metadata.js":
  /*!************************************************************!*\
    !*** ./node_modules/core-js/proposals/reflect-metadata.js ***!
    \************************************************************/

  /*! no static exports found */

  /***/
  function node_modulesCoreJsProposalsReflectMetadataJs(module, exports, __webpack_require__) {
    __webpack_require__(
    /*! ../modules/esnext.reflect.define-metadata */
    "./node_modules/core-js/modules/esnext.reflect.define-metadata.js");

    __webpack_require__(
    /*! ../modules/esnext.reflect.delete-metadata */
    "./node_modules/core-js/modules/esnext.reflect.delete-metadata.js");

    __webpack_require__(
    /*! ../modules/esnext.reflect.get-metadata */
    "./node_modules/core-js/modules/esnext.reflect.get-metadata.js");

    __webpack_require__(
    /*! ../modules/esnext.reflect.get-metadata-keys */
    "./node_modules/core-js/modules/esnext.reflect.get-metadata-keys.js");

    __webpack_require__(
    /*! ../modules/esnext.reflect.get-own-metadata */
    "./node_modules/core-js/modules/esnext.reflect.get-own-metadata.js");

    __webpack_require__(
    /*! ../modules/esnext.reflect.get-own-metadata-keys */
    "./node_modules/core-js/modules/esnext.reflect.get-own-metadata-keys.js");

    __webpack_require__(
    /*! ../modules/esnext.reflect.has-metadata */
    "./node_modules/core-js/modules/esnext.reflect.has-metadata.js");

    __webpack_require__(
    /*! ../modules/esnext.reflect.has-own-metadata */
    "./node_modules/core-js/modules/esnext.reflect.has-own-metadata.js");

    __webpack_require__(
    /*! ../modules/esnext.reflect.metadata */
    "./node_modules/core-js/modules/esnext.reflect.metadata.js");
    /***/

  },

  /***/
  "./node_modules/jquery/dist/jquery.js":
  /*!********************************************!*\
    !*** ./node_modules/jquery/dist/jquery.js ***!
    \********************************************/

  /*! no static exports found */

  /***/
  function node_modulesJqueryDistJqueryJs(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    /*!
    * jQuery JavaScript Library v3.4.1
    * https://jquery.com/
    *
    * Includes Sizzle.js
    * https://sizzlejs.com/
    *
    * Copyright JS Foundation and other contributors
    * Released under the MIT license
    * https://jquery.org/license
    *
    * Date: 2019-05-01T21:04Z
    */


    (function (global, factory) {
      "use strict";

      if (true && typeof module.exports === "object") {
        // For CommonJS and CommonJS-like environments where a proper `window`
        // is present, execute the factory and get jQuery.
        // For environments that do not have a `window` with a `document`
        // (such as Node.js), expose a factory as module.exports.
        // This accentuates the need for the creation of a real `window`.
        // e.g. var jQuery = require("jquery")(window);
        // See ticket #14549 for more info.
        module.exports = global.document ? factory(global, true) : function (w) {
          if (!w.document) {
            throw new Error("jQuery requires a window with a document");
          }

          return factory(w);
        };
      } else {
        factory(global);
      } // Pass this if window is not defined yet

    })(typeof window !== "undefined" ? window : this, function (window, noGlobal) {
      // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
      // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
      // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
      // enough that all such attempts are guarded in a try block.
      "use strict";

      var arr = [];
      var document = window.document;
      var getProto = Object.getPrototypeOf;
      var _slice = arr.slice;
      var concat = arr.concat;
      var push = arr.push;
      var indexOf = arr.indexOf;
      var class2type = {};
      var toString = class2type.toString;
      var hasOwn = class2type.hasOwnProperty;
      var fnToString = hasOwn.toString;
      var ObjectFunctionString = fnToString.call(Object);
      var support = {};

      var isFunction = function isFunction(obj) {
        // Support: Chrome <=57, Firefox <=52
        // In some browsers, typeof returns "function" for HTML <object> elements
        // (i.e., `typeof document.createElement( "object" ) === "function"`).
        // We don't want to classify *any* DOM node as a function.
        return typeof obj === "function" && typeof obj.nodeType !== "number";
      };

      var isWindow = function isWindow(obj) {
        return obj != null && obj === obj.window;
      };

      var preservedScriptAttributes = {
        type: true,
        src: true,
        nonce: true,
        noModule: true
      };

      function DOMEval(code, node, doc) {
        doc = doc || document;
        var i,
            val,
            script = doc.createElement("script");
        script.text = code;

        if (node) {
          for (i in preservedScriptAttributes) {
            // Support: Firefox 64+, Edge 18+
            // Some browsers don't support the "nonce" property on scripts.
            // On the other hand, just using `getAttribute` is not enough as
            // the `nonce` attribute is reset to an empty string whenever it
            // becomes browsing-context connected.
            // See https://github.com/whatwg/html/issues/2369
            // See https://html.spec.whatwg.org/#nonce-attributes
            // The `node.getAttribute` check was added for the sake of
            // `jQuery.globalEval` so that it can fake a nonce-containing node
            // via an object.
            val = node[i] || node.getAttribute && node.getAttribute(i);

            if (val) {
              script.setAttribute(i, val);
            }
          }
        }

        doc.head.appendChild(script).parentNode.removeChild(script);
      }

      function toType(obj) {
        if (obj == null) {
          return obj + "";
        } // Support: Android <=2.3 only (functionish RegExp)


        return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
      }
      /* global Symbol */
      // Defining this global in .eslintrc.json would create a danger of using the global
      // unguarded in another place, it seems safer to define global only for this module


      var version = "3.4.1",
          // Define a local copy of jQuery
      jQuery = function jQuery(selector, context) {
        // The jQuery object is actually just the init constructor 'enhanced'
        // Need init if jQuery is called (just allow error to be thrown if not included)
        return new jQuery.fn.init(selector, context);
      },
          // Support: Android <=4.0 only
      // Make sure we trim BOM and NBSP
      rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

      jQuery.fn = jQuery.prototype = {
        // The current version of jQuery being used
        jquery: version,
        constructor: jQuery,
        // The default length of a jQuery object is 0
        length: 0,
        toArray: function toArray() {
          return _slice.call(this);
        },
        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function get(num) {
          // Return all the elements in a clean array
          if (num == null) {
            return _slice.call(this);
          } // Return just the one element from the set


          return num < 0 ? this[num + this.length] : this[num];
        },
        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function pushStack(elems) {
          // Build a new jQuery matched element set
          var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference)

          ret.prevObject = this; // Return the newly-formed element set

          return ret;
        },
        // Execute a callback for every element in the matched set.
        each: function each(callback) {
          return jQuery.each(this, callback);
        },
        map: function map(callback) {
          return this.pushStack(jQuery.map(this, function (elem, i) {
            return callback.call(elem, i, elem);
          }));
        },
        slice: function slice() {
          return this.pushStack(_slice.apply(this, arguments));
        },
        first: function first() {
          return this.eq(0);
        },
        last: function last() {
          return this.eq(-1);
        },
        eq: function eq(i) {
          var len = this.length,
              j = +i + (i < 0 ? len : 0);
          return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
        },
        end: function end() {
          return this.prevObject || this.constructor();
        },
        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push,
        sort: arr.sort,
        splice: arr.splice
      };

      jQuery.extend = jQuery.fn.extend = function () {
        var options,
            name,
            src,
            copy,
            copyIsArray,
            clone,
            target = arguments[0] || {},
            i = 1,
            length = arguments.length,
            deep = false; // Handle a deep copy situation

        if (typeof target === "boolean") {
          deep = target; // Skip the boolean and the target

          target = arguments[i] || {};
          i++;
        } // Handle case when target is a string or something (possible in deep copy)


        if (typeof target !== "object" && !isFunction(target)) {
          target = {};
        } // Extend jQuery itself if only one argument is passed


        if (i === length) {
          target = this;
          i--;
        }

        for (; i < length; i++) {
          // Only deal with non-null/undefined values
          if ((options = arguments[i]) != null) {
            // Extend the base object
            for (name in options) {
              copy = options[name]; // Prevent Object.prototype pollution
              // Prevent never-ending loop

              if (name === "__proto__" || target === copy) {
                continue;
              } // Recurse if we're merging plain objects or arrays


              if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                src = target[name]; // Ensure proper type for the source value

                if (copyIsArray && !Array.isArray(src)) {
                  clone = [];
                } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
                  clone = {};
                } else {
                  clone = src;
                }

                copyIsArray = false; // Never move original objects, clone them

                target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values
              } else if (copy !== undefined) {
                target[name] = copy;
              }
            }
          }
        } // Return the modified object


        return target;
      };

      jQuery.extend({
        // Unique for each copy of jQuery on the page
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
        // Assume jQuery is ready without the ready module
        isReady: true,
        error: function error(msg) {
          throw new Error(msg);
        },
        noop: function noop() {},
        isPlainObject: function isPlainObject(obj) {
          var proto, Ctor; // Detect obvious negatives
          // Use toString instead of jQuery.type to catch host objects

          if (!obj || toString.call(obj) !== "[object Object]") {
            return false;
          }

          proto = getProto(obj); // Objects with no prototype (e.g., `Object.create( null )`) are plain

          if (!proto) {
            return true;
          } // Objects with prototype are plain iff they were constructed by a global Object function


          Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
          return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
        },
        isEmptyObject: function isEmptyObject(obj) {
          var name;

          for (name in obj) {
            return false;
          }

          return true;
        },
        // Evaluates a script in a global context
        globalEval: function globalEval(code, options) {
          DOMEval(code, {
            nonce: options && options.nonce
          });
        },
        each: function each(obj, callback) {
          var length,
              i = 0;

          if (isArrayLike(obj)) {
            length = obj.length;

            for (; i < length; i++) {
              if (callback.call(obj[i], i, obj[i]) === false) {
                break;
              }
            }
          } else {
            for (i in obj) {
              if (callback.call(obj[i], i, obj[i]) === false) {
                break;
              }
            }
          }

          return obj;
        },
        // Support: Android <=4.0 only
        trim: function trim(text) {
          return text == null ? "" : (text + "").replace(rtrim, "");
        },
        // results is for internal usage only
        makeArray: function makeArray(arr, results) {
          var ret = results || [];

          if (arr != null) {
            if (isArrayLike(Object(arr))) {
              jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
            } else {
              push.call(ret, arr);
            }
          }

          return ret;
        },
        inArray: function inArray(elem, arr, i) {
          return arr == null ? -1 : indexOf.call(arr, elem, i);
        },
        // Support: Android <=4.0 only, PhantomJS 1 only
        // push.apply(_, arraylike) throws on ancient WebKit
        merge: function merge(first, second) {
          var len = +second.length,
              j = 0,
              i = first.length;

          for (; j < len; j++) {
            first[i++] = second[j];
          }

          first.length = i;
          return first;
        },
        grep: function grep(elems, callback, invert) {
          var callbackInverse,
              matches = [],
              i = 0,
              length = elems.length,
              callbackExpect = !invert; // Go through the array, only saving the items
          // that pass the validator function

          for (; i < length; i++) {
            callbackInverse = !callback(elems[i], i);

            if (callbackInverse !== callbackExpect) {
              matches.push(elems[i]);
            }
          }

          return matches;
        },
        // arg is for internal usage only
        map: function map(elems, callback, arg) {
          var length,
              value,
              i = 0,
              ret = []; // Go through the array, translating each of the items to their new values

          if (isArrayLike(elems)) {
            length = elems.length;

            for (; i < length; i++) {
              value = callback(elems[i], i, arg);

              if (value != null) {
                ret.push(value);
              }
            } // Go through every key on the object,

          } else {
            for (i in elems) {
              value = callback(elems[i], i, arg);

              if (value != null) {
                ret.push(value);
              }
            }
          } // Flatten any nested arrays


          return concat.apply([], ret);
        },
        // A global GUID counter for objects
        guid: 1,
        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support: support
      });

      if (typeof Symbol === "function") {
        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
      } // Populate the class2type map


      jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
      });

      function isArrayLike(obj) {
        // Support: real iOS 8.2 only (not reproducible in simulator)
        // `in` check used to prevent JIT error (gh-2145)
        // hasOwn isn't used here due to false negatives
        // regarding Nodelist length in IE
        var length = !!obj && "length" in obj && obj.length,
            type = toType(obj);

        if (isFunction(obj) || isWindow(obj)) {
          return false;
        }

        return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
      }

      var Sizzle =
      /*!
       * Sizzle CSS Selector Engine v2.3.4
       * https://sizzlejs.com/
       *
       * Copyright JS Foundation and other contributors
       * Released under the MIT license
       * https://js.foundation/
       *
       * Date: 2019-04-08
       */
      function (window) {
        var i,
            support,
            Expr,
            getText,
            isXML,
            tokenize,
            compile,
            select,
            outermostContext,
            sortInput,
            hasDuplicate,
            // Local document vars
        setDocument,
            document,
            docElem,
            documentIsHTML,
            rbuggyQSA,
            rbuggyMatches,
            matches,
            contains,
            // Instance-specific data
        expando = "sizzle" + 1 * new Date(),
            preferredDoc = window.document,
            dirruns = 0,
            done = 0,
            classCache = createCache(),
            tokenCache = createCache(),
            compilerCache = createCache(),
            nonnativeSelectorCache = createCache(),
            sortOrder = function sortOrder(a, b) {
          if (a === b) {
            hasDuplicate = true;
          }

          return 0;
        },
            // Instance methods
        hasOwn = {}.hasOwnProperty,
            arr = [],
            pop = arr.pop,
            push_native = arr.push,
            push = arr.push,
            slice = arr.slice,
            // Use a stripped-down indexOf as it's faster than native
        // https://jsperf.com/thor-indexof-vs-for/5
        indexOf = function indexOf(list, elem) {
          var i = 0,
              len = list.length;

          for (; i < len; i++) {
            if (list[i] === elem) {
              return i;
            }
          }

          return -1;
        },
            booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
            // Regular expressions
        // http://www.w3.org/TR/css3-selectors/#whitespace
        whitespace = "[\\x20\\t\\r\\n\\f]",
            // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
        identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
            // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
        attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
        "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
        "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
            pseudos = ":(" + identifier + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
        // 1. quoted (capture 3; capture 4 or capture 5)
        "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
        "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + // 3. anything else (capture 2)
        ".*" + ")\\)|)",
            // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
        rwhitespace = new RegExp(whitespace + "+", "g"),
            rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
            rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
            rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
            rdescend = new RegExp(whitespace + "|>"),
            rpseudo = new RegExp(pseudos),
            ridentifier = new RegExp("^" + identifier + "$"),
            matchExpr = {
          "ID": new RegExp("^#(" + identifier + ")"),
          "CLASS": new RegExp("^\\.(" + identifier + ")"),
          "TAG": new RegExp("^(" + identifier + "|[*])"),
          "ATTR": new RegExp("^" + attributes),
          "PSEUDO": new RegExp("^" + pseudos),
          "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
          "bool": new RegExp("^(?:" + booleans + ")$", "i"),
          // For use in libraries implementing .is()
          // We use this for POS matching in `select`
          "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        },
            rhtml = /HTML$/i,
            rinputs = /^(?:input|select|textarea|button)$/i,
            rheader = /^h\d$/i,
            rnative = /^[^{]+\{\s*\[native \w/,
            // Easily-parseable/retrievable ID or TAG or CLASS selectors
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
            rsibling = /[+~]/,
            // CSS escapes
        // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
            funescape = function funescape(_, escaped, escapedWhitespace) {
          var high = "0x" + escaped - 0x10000; // NaN means non-codepoint
          // Support: Firefox<24
          // Workaround erroneous numeric interpretation of +"0x"

          return high !== high || escapedWhitespace ? escaped : high < 0 ? // BMP codepoint
          String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)
          String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
        },
            // CSS string/identifier serialization
        // https://drafts.csswg.org/cssom/#common-serializing-idioms
        rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
            fcssescape = function fcssescape(ch, asCodePoint) {
          if (asCodePoint) {
            // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
            if (ch === "\0") {
              return "\uFFFD";
            } // Control characters and (dependent upon position) numbers get escaped as code points


            return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
          } // Other potentially-special ASCII characters get backslash-escaped


          return "\\" + ch;
        },
            // Used for iframes
        // See setDocument()
        // Removing the function wrapper causes a "Permission Denied"
        // error in IE
        unloadHandler = function unloadHandler() {
          setDocument();
        },
            inDisabledFieldset = addCombinator(function (elem) {
          return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
        }, {
          dir: "parentNode",
          next: "legend"
        }); // Optimize for push.apply( _, NodeList )


        try {
          push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0
          // Detect silently failing push.apply

          arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
          push = {
            apply: arr.length ? // Leverage slice if possible
            function (target, els) {
              push_native.apply(target, slice.call(els));
            } : // Support: IE<9
            // Otherwise append directly
            function (target, els) {
              var j = target.length,
                  i = 0; // Can't trust NodeList.length

              while (target[j++] = els[i++]) {}

              target.length = j - 1;
            }
          };
        }

        function Sizzle(selector, context, results, seed) {
          var m,
              i,
              elem,
              nid,
              match,
              groups,
              newSelector,
              newContext = context && context.ownerDocument,
              // nodeType defaults to 9, since context defaults to document
          nodeType = context ? context.nodeType : 9;
          results = results || []; // Return early from calls with invalid selector or context

          if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
            return results;
          } // Try to shortcut find operations (as opposed to filters) in HTML documents


          if (!seed) {
            if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
              setDocument(context);
            }

            context = context || document;

            if (documentIsHTML) {
              // If the selector is sufficiently simple, try using a "get*By*" DOM method
              // (excepting DocumentFragment context, where the methods don't exist)
              if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                // ID selector
                if (m = match[1]) {
                  // Document context
                  if (nodeType === 9) {
                    if (elem = context.getElementById(m)) {
                      // Support: IE, Opera, Webkit
                      // TODO: identify versions
                      // getElementById can match elements by name instead of ID
                      if (elem.id === m) {
                        results.push(elem);
                        return results;
                      }
                    } else {
                      return results;
                    } // Element context

                  } else {
                    // Support: IE, Opera, Webkit
                    // TODO: identify versions
                    // getElementById can match elements by name instead of ID
                    if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                      results.push(elem);
                      return results;
                    }
                  } // Type selector

                } else if (match[2]) {
                  push.apply(results, context.getElementsByTagName(selector));
                  return results; // Class selector
                } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                  push.apply(results, context.getElementsByClassName(m));
                  return results;
                }
              } // Take advantage of querySelectorAll


              if (support.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && ( // Support: IE 8 only
              // Exclude object elements
              nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
                newSelector = selector;
                newContext = context; // qSA considers elements outside a scoping root when evaluating child or
                // descendant combinators, which is not what we want.
                // In such cases, we work around the behavior by prefixing every selector in the
                // list with an ID selector referencing the scope context.
                // Thanks to Andrew Dupont for this technique.

                if (nodeType === 1 && rdescend.test(selector)) {
                  // Capture the context ID, setting it first if necessary
                  if (nid = context.getAttribute("id")) {
                    nid = nid.replace(rcssescape, fcssescape);
                  } else {
                    context.setAttribute("id", nid = expando);
                  } // Prefix every selector in the list


                  groups = tokenize(selector);
                  i = groups.length;

                  while (i--) {
                    groups[i] = "#" + nid + " " + toSelector(groups[i]);
                  }

                  newSelector = groups.join(","); // Expand context for sibling selectors

                  newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                }

                try {
                  push.apply(results, newContext.querySelectorAll(newSelector));
                  return results;
                } catch (qsaError) {
                  nonnativeSelectorCache(selector, true);
                } finally {
                  if (nid === expando) {
                    context.removeAttribute("id");
                  }
                }
              }
            }
          } // All others


          return select(selector.replace(rtrim, "$1"), context, results, seed);
        }
        /**
         * Create key-value caches of limited size
         * @returns {function(string, object)} Returns the Object data after storing it on itself with
         *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
         *	deleting the oldest entry
         */


        function createCache() {
          var keys = [];

          function cache(key, value) {
            // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
            if (keys.push(key + " ") > Expr.cacheLength) {
              // Only keep the most recent entries
              delete cache[keys.shift()];
            }

            return cache[key + " "] = value;
          }

          return cache;
        }
        /**
         * Mark a function for special use by Sizzle
         * @param {Function} fn The function to mark
         */


        function markFunction(fn) {
          fn[expando] = true;
          return fn;
        }
        /**
         * Support testing using an element
         * @param {Function} fn Passed the created element and returns a boolean result
         */


        function assert(fn) {
          var el = document.createElement("fieldset");

          try {
            return !!fn(el);
          } catch (e) {
            return false;
          } finally {
            // Remove from its parent by default
            if (el.parentNode) {
              el.parentNode.removeChild(el);
            } // release memory in IE


            el = null;
          }
        }
        /**
         * Adds the same handler for all of the specified attrs
         * @param {String} attrs Pipe-separated list of attributes
         * @param {Function} handler The method that will be applied
         */


        function addHandle(attrs, handler) {
          var arr = attrs.split("|"),
              i = arr.length;

          while (i--) {
            Expr.attrHandle[arr[i]] = handler;
          }
        }
        /**
         * Checks document order of two siblings
         * @param {Element} a
         * @param {Element} b
         * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
         */


        function siblingCheck(a, b) {
          var cur = b && a,
              diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex; // Use IE sourceIndex if available on both nodes

          if (diff) {
            return diff;
          } // Check if b follows a


          if (cur) {
            while (cur = cur.nextSibling) {
              if (cur === b) {
                return -1;
              }
            }
          }

          return a ? 1 : -1;
        }
        /**
         * Returns a function to use in pseudos for input types
         * @param {String} type
         */


        function createInputPseudo(type) {
          return function (elem) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === type;
          };
        }
        /**
         * Returns a function to use in pseudos for buttons
         * @param {String} type
         */


        function createButtonPseudo(type) {
          return function (elem) {
            var name = elem.nodeName.toLowerCase();
            return (name === "input" || name === "button") && elem.type === type;
          };
        }
        /**
         * Returns a function to use in pseudos for :enabled/:disabled
         * @param {Boolean} disabled true for :disabled; false for :enabled
         */


        function createDisabledPseudo(disabled) {
          // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
          return function (elem) {
            // Only certain elements can match :enabled or :disabled
            // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
            // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
            if ("form" in elem) {
              // Check for inherited disabledness on relevant non-disabled elements:
              // * listed form-associated elements in a disabled fieldset
              //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
              //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
              // * option elements in a disabled optgroup
              //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
              // All such elements have a "form" property.
              if (elem.parentNode && elem.disabled === false) {
                // Option elements defer to a parent optgroup if present
                if ("label" in elem) {
                  if ("label" in elem.parentNode) {
                    return elem.parentNode.disabled === disabled;
                  } else {
                    return elem.disabled === disabled;
                  }
                } // Support: IE 6 - 11
                // Use the isDisabled shortcut property to check for disabled fieldset ancestors


                return elem.isDisabled === disabled || // Where there is no isDisabled, check manually

                /* jshint -W018 */
                elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
              }

              return elem.disabled === disabled; // Try to winnow out elements that can't be disabled before trusting the disabled property.
              // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
              // even exist on them, let alone have a boolean value.
            } else if ("label" in elem) {
              return elem.disabled === disabled;
            } // Remaining elements are neither :enabled nor :disabled


            return false;
          };
        }
        /**
         * Returns a function to use in pseudos for positionals
         * @param {Function} fn
         */


        function createPositionalPseudo(fn) {
          return markFunction(function (argument) {
            argument = +argument;
            return markFunction(function (seed, matches) {
              var j,
                  matchIndexes = fn([], seed.length, argument),
                  i = matchIndexes.length; // Match elements found at the specified indexes

              while (i--) {
                if (seed[j = matchIndexes[i]]) {
                  seed[j] = !(matches[j] = seed[j]);
                }
              }
            });
          });
        }
        /**
         * Checks a node for validity as a Sizzle context
         * @param {Element|Object=} context
         * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
         */


        function testContext(context) {
          return context && typeof context.getElementsByTagName !== "undefined" && context;
        } // Expose support vars for convenience


        support = Sizzle.support = {};
        /**
         * Detects XML nodes
         * @param {Element|Object} elem An element or a document
         * @returns {Boolean} True iff elem is a non-HTML XML node
         */

        isXML = Sizzle.isXML = function (elem) {
          var namespace = elem.namespaceURI,
              docElem = (elem.ownerDocument || elem).documentElement; // Support: IE <=8
          // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
          // https://bugs.jquery.com/ticket/4833

          return !rhtml.test(namespace || docElem && docElem.nodeName || "HTML");
        };
        /**
         * Sets document-related variables once based on the current document
         * @param {Element|Object} [doc] An element or document object to use to set the document
         * @returns {Object} Returns the current document
         */


        setDocument = Sizzle.setDocument = function (node) {
          var hasCompare,
              subWindow,
              doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected

          if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
            return document;
          } // Update global variables


          document = doc;
          docElem = document.documentElement;
          documentIsHTML = !isXML(document); // Support: IE 9-11, Edge
          // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)

          if (preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
            // Support: IE 11, Edge
            if (subWindow.addEventListener) {
              subWindow.addEventListener("unload", unloadHandler, false); // Support: IE 9 - 10 only
            } else if (subWindow.attachEvent) {
              subWindow.attachEvent("onunload", unloadHandler);
            }
          }
          /* Attributes
          ---------------------------------------------------------------------- */
          // Support: IE<8
          // Verify that getAttribute really returns attributes and not properties
          // (excepting IE8 booleans)


          support.attributes = assert(function (el) {
            el.className = "i";
            return !el.getAttribute("className");
          });
          /* getElement(s)By*
          ---------------------------------------------------------------------- */
          // Check if getElementsByTagName("*") returns only elements

          support.getElementsByTagName = assert(function (el) {
            el.appendChild(document.createComment(""));
            return !el.getElementsByTagName("*").length;
          }); // Support: IE<9

          support.getElementsByClassName = rnative.test(document.getElementsByClassName); // Support: IE<10
          // Check if getElementById returns elements by name
          // The broken getElementById methods don't pick up programmatically-set names,
          // so use a roundabout getElementsByName test

          support.getById = assert(function (el) {
            docElem.appendChild(el).id = expando;
            return !document.getElementsByName || !document.getElementsByName(expando).length;
          }); // ID filter and find

          if (support.getById) {
            Expr.filter["ID"] = function (id) {
              var attrId = id.replace(runescape, funescape);
              return function (elem) {
                return elem.getAttribute("id") === attrId;
              };
            };

            Expr.find["ID"] = function (id, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var elem = context.getElementById(id);
                return elem ? [elem] : [];
              }
            };
          } else {
            Expr.filter["ID"] = function (id) {
              var attrId = id.replace(runescape, funescape);
              return function (elem) {
                var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                return node && node.value === attrId;
              };
            }; // Support: IE 6 - 7 only
            // getElementById is not reliable as a find shortcut


            Expr.find["ID"] = function (id, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var node,
                    i,
                    elems,
                    elem = context.getElementById(id);

                if (elem) {
                  // Verify the id attribute
                  node = elem.getAttributeNode("id");

                  if (node && node.value === id) {
                    return [elem];
                  } // Fall back on getElementsByName


                  elems = context.getElementsByName(id);
                  i = 0;

                  while (elem = elems[i++]) {
                    node = elem.getAttributeNode("id");

                    if (node && node.value === id) {
                      return [elem];
                    }
                  }
                }

                return [];
              }
            };
          } // Tag


          Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
            if (typeof context.getElementsByTagName !== "undefined") {
              return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN
            } else if (support.qsa) {
              return context.querySelectorAll(tag);
            }
          } : function (tag, context) {
            var elem,
                tmp = [],
                i = 0,
                // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
            results = context.getElementsByTagName(tag); // Filter out possible comments

            if (tag === "*") {
              while (elem = results[i++]) {
                if (elem.nodeType === 1) {
                  tmp.push(elem);
                }
              }

              return tmp;
            }

            return results;
          }; // Class

          Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
            if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
              return context.getElementsByClassName(className);
            }
          };
          /* QSA/matchesSelector
          ---------------------------------------------------------------------- */
          // QSA and matchesSelector support
          // matchesSelector(:active) reports false when true (IE9/Opera 11.5)


          rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)
          // We allow this because of a bug in IE8/9 that throws an error
          // whenever `document.activeElement` is accessed on an iframe
          // So, we allow :focus to pass through QSA all the time to avoid the IE error
          // See https://bugs.jquery.com/ticket/13378

          rbuggyQSA = [];

          if (support.qsa = rnative.test(document.querySelectorAll)) {
            // Build QSA regex
            // Regex strategy adopted from Diego Perini
            assert(function (el) {
              // Select is set to empty string on purpose
              // This is to test IE's treatment of not explicitly
              // setting a boolean content attribute,
              // since its presence should be enough
              // https://bugs.jquery.com/ticket/12359
              docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>"; // Support: IE8, Opera 11-12.16
              // Nothing should be selected when empty strings follow ^= or $= or *=
              // The test attribute must be unknown in Opera but "safe" for WinRT
              // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section

              if (el.querySelectorAll("[msallowcapture^='']").length) {
                rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
              } // Support: IE8
              // Boolean attributes and "value" are not treated correctly


              if (!el.querySelectorAll("[selected]").length) {
                rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
              } // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+


              if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
                rbuggyQSA.push("~=");
              } // Webkit/Opera - :checked should return selected option elements
              // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
              // IE8 throws error here and will not see later tests


              if (!el.querySelectorAll(":checked").length) {
                rbuggyQSA.push(":checked");
              } // Support: Safari 8+, iOS 8+
              // https://bugs.webkit.org/show_bug.cgi?id=136851
              // In-page `selector#id sibling-combinator selector` fails


              if (!el.querySelectorAll("a#" + expando + "+*").length) {
                rbuggyQSA.push(".#.+[+~]");
              }
            });
            assert(function (el) {
              el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>"; // Support: Windows 8 Native Apps
              // The type and name attributes are restricted during .innerHTML assignment

              var input = document.createElement("input");
              input.setAttribute("type", "hidden");
              el.appendChild(input).setAttribute("name", "D"); // Support: IE8
              // Enforce case-sensitivity of name attribute

              if (el.querySelectorAll("[name=d]").length) {
                rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
              } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
              // IE8 throws error here and will not see later tests


              if (el.querySelectorAll(":enabled").length !== 2) {
                rbuggyQSA.push(":enabled", ":disabled");
              } // Support: IE9-11+
              // IE's :disabled selector does not pick up the children of disabled fieldsets


              docElem.appendChild(el).disabled = true;

              if (el.querySelectorAll(":disabled").length !== 2) {
                rbuggyQSA.push(":enabled", ":disabled");
              } // Opera 10-11 does not throw on post-comma invalid pseudos


              el.querySelectorAll("*,:x");
              rbuggyQSA.push(",.*:");
            });
          }

          if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
            assert(function (el) {
              // Check to see if it's possible to do matchesSelector
              // on a disconnected node (IE 9)
              support.disconnectedMatch = matches.call(el, "*"); // This should fail with an exception
              // Gecko does not error, returns false instead

              matches.call(el, "[s!='']:x");
              rbuggyMatches.push("!=", pseudos);
            });
          }

          rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
          rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
          /* Contains
          ---------------------------------------------------------------------- */

          hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another
          // Purposefully self-exclusive
          // As in, an element does not contain itself

          contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
            var adown = a.nodeType === 9 ? a.documentElement : a,
                bup = b && b.parentNode;
            return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
          } : function (a, b) {
            if (b) {
              while (b = b.parentNode) {
                if (b === a) {
                  return true;
                }
              }
            }

            return false;
          };
          /* Sorting
          ---------------------------------------------------------------------- */
          // Document order sorting

          sortOrder = hasCompare ? function (a, b) {
            // Flag for duplicate removal
            if (a === b) {
              hasDuplicate = true;
              return 0;
            } // Sort on method existence if only one input has compareDocumentPosition


            var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;

            if (compare) {
              return compare;
            } // Calculate position if both inputs belong to the same document


            compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected
            1; // Disconnected nodes

            if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
              // Choose the first element that is related to our preferred document
              if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                return -1;
              }

              if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                return 1;
              } // Maintain original order


              return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
            }

            return compare & 4 ? -1 : 1;
          } : function (a, b) {
            // Exit early if the nodes are identical
            if (a === b) {
              hasDuplicate = true;
              return 0;
            }

            var cur,
                i = 0,
                aup = a.parentNode,
                bup = b.parentNode,
                ap = [a],
                bp = [b]; // Parentless nodes are either documents or disconnected

            if (!aup || !bup) {
              return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check
            } else if (aup === bup) {
              return siblingCheck(a, b);
            } // Otherwise we need full lists of their ancestors for comparison


            cur = a;

            while (cur = cur.parentNode) {
              ap.unshift(cur);
            }

            cur = b;

            while (cur = cur.parentNode) {
              bp.unshift(cur);
            } // Walk down the tree looking for a discrepancy


            while (ap[i] === bp[i]) {
              i++;
            }

            return i ? // Do a sibling check if the nodes have a common ancestor
            siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first
            ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
          };
          return document;
        };

        Sizzle.matches = function (expr, elements) {
          return Sizzle(expr, null, null, elements);
        };

        Sizzle.matchesSelector = function (elem, expr) {
          // Set document vars if needed
          if ((elem.ownerDocument || elem) !== document) {
            setDocument(elem);
          }

          if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
            try {
              var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes

              if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
              // fragment in IE 9
              elem.document && elem.document.nodeType !== 11) {
                return ret;
              }
            } catch (e) {
              nonnativeSelectorCache(expr, true);
            }
          }

          return Sizzle(expr, document, null, [elem]).length > 0;
        };

        Sizzle.contains = function (context, elem) {
          // Set document vars if needed
          if ((context.ownerDocument || context) !== document) {
            setDocument(context);
          }

          return contains(context, elem);
        };

        Sizzle.attr = function (elem, name) {
          // Set document vars if needed
          if ((elem.ownerDocument || elem) !== document) {
            setDocument(elem);
          }

          var fn = Expr.attrHandle[name.toLowerCase()],
              // Don't get fooled by Object.prototype properties (jQuery #13807)
          val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
          return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };

        Sizzle.escape = function (sel) {
          return (sel + "").replace(rcssescape, fcssescape);
        };

        Sizzle.error = function (msg) {
          throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        /**
         * Document sorting and removing duplicates
         * @param {ArrayLike} results
         */


        Sizzle.uniqueSort = function (results) {
          var elem,
              duplicates = [],
              j = 0,
              i = 0; // Unless we *know* we can detect duplicates, assume their presence

          hasDuplicate = !support.detectDuplicates;
          sortInput = !support.sortStable && results.slice(0);
          results.sort(sortOrder);

          if (hasDuplicate) {
            while (elem = results[i++]) {
              if (elem === results[i]) {
                j = duplicates.push(i);
              }
            }

            while (j--) {
              results.splice(duplicates[j], 1);
            }
          } // Clear input after sorting to release objects
          // See https://github.com/jquery/sizzle/pull/225


          sortInput = null;
          return results;
        };
        /**
         * Utility function for retrieving the text value of an array of DOM nodes
         * @param {Array|Element} elem
         */


        getText = Sizzle.getText = function (elem) {
          var node,
              ret = "",
              i = 0,
              nodeType = elem.nodeType;

          if (!nodeType) {
            // If no nodeType, this is expected to be an array
            while (node = elem[i++]) {
              // Do not traverse comment nodes
              ret += getText(node);
            }
          } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
            // Use textContent for elements
            // innerText usage removed for consistency of new lines (jQuery #11153)
            if (typeof elem.textContent === "string") {
              return elem.textContent;
            } else {
              // Traverse its children
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                ret += getText(elem);
              }
            }
          } else if (nodeType === 3 || nodeType === 4) {
            return elem.nodeValue;
          } // Do not include comment or processing instruction nodes


          return ret;
        };

        Expr = Sizzle.selectors = {
          // Can be adjusted by the user
          cacheLength: 50,
          createPseudo: markFunction,
          match: matchExpr,
          attrHandle: {},
          find: {},
          relative: {
            ">": {
              dir: "parentNode",
              first: true
            },
            " ": {
              dir: "parentNode"
            },
            "+": {
              dir: "previousSibling",
              first: true
            },
            "~": {
              dir: "previousSibling"
            }
          },
          preFilter: {
            "ATTR": function ATTR(match) {
              match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted

              match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

              if (match[2] === "~=") {
                match[3] = " " + match[3] + " ";
              }

              return match.slice(0, 4);
            },
            "CHILD": function CHILD(match) {
              /* matches from matchExpr["CHILD"]
              	1 type (only|nth|...)
              	2 what (child|of-type)
              	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
              	4 xn-component of xn+y argument ([+-]?\d*n|)
              	5 sign of xn-component
              	6 x of xn-component
              	7 sign of y-component
              	8 y of y-component
              */
              match[1] = match[1].toLowerCase();

              if (match[1].slice(0, 3) === "nth") {
                // nth-* requires argument
                if (!match[3]) {
                  Sizzle.error(match[0]);
                } // numeric x and y parameters for Expr.filter.CHILD
                // remember that false/true cast respectively to 0/1


                match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                match[5] = +(match[7] + match[8] || match[3] === "odd"); // other types prohibit arguments
              } else if (match[3]) {
                Sizzle.error(match[0]);
              }

              return match;
            },
            "PSEUDO": function PSEUDO(match) {
              var excess,
                  unquoted = !match[6] && match[2];

              if (matchExpr["CHILD"].test(match[0])) {
                return null;
              } // Accept quoted arguments as-is


              if (match[3]) {
                match[2] = match[4] || match[5] || ""; // Strip excess characters from unquoted arguments
              } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)
              excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis
              excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                // excess is a negative index
                match[0] = match[0].slice(0, excess);
                match[2] = unquoted.slice(0, excess);
              } // Return only captures needed by the pseudo filter method (type and argument)


              return match.slice(0, 3);
            }
          },
          filter: {
            "TAG": function TAG(nodeNameSelector) {
              var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
              return nodeNameSelector === "*" ? function () {
                return true;
              } : function (elem) {
                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
              };
            },
            "CLASS": function CLASS(className) {
              var pattern = classCache[className + " "];
              return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
                return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
              });
            },
            "ATTR": function ATTR(name, operator, check) {
              return function (elem) {
                var result = Sizzle.attr(elem, name);

                if (result == null) {
                  return operator === "!=";
                }

                if (!operator) {
                  return true;
                }

                result += "";
                return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
              };
            },
            "CHILD": function CHILD(type, what, argument, first, last) {
              var simple = type.slice(0, 3) !== "nth",
                  forward = type.slice(-4) !== "last",
                  ofType = what === "of-type";
              return first === 1 && last === 0 ? // Shortcut for :nth-*(n)
              function (elem) {
                return !!elem.parentNode;
              } : function (elem, context, xml) {
                var cache,
                    uniqueCache,
                    outerCache,
                    node,
                    nodeIndex,
                    start,
                    dir = simple !== forward ? "nextSibling" : "previousSibling",
                    parent = elem.parentNode,
                    name = ofType && elem.nodeName.toLowerCase(),
                    useCache = !xml && !ofType,
                    diff = false;

                if (parent) {
                  // :(first|last|only)-(child|of-type)
                  if (simple) {
                    while (dir) {
                      node = elem;

                      while (node = node[dir]) {
                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                          return false;
                        }
                      } // Reverse direction for :only-* (if we haven't yet done so)


                      start = dir = type === "only" && !start && "nextSibling";
                    }

                    return true;
                  }

                  start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`

                  if (forward && useCache) {
                    // Seek `elem` from a previously-cached index
                    // ...in a gzip-friendly way
                    node = parent;
                    outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                    // Defend against cloned attroperties (jQuery gh-1709)

                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                    cache = uniqueCache[type] || [];
                    nodeIndex = cache[0] === dirruns && cache[1];
                    diff = nodeIndex && cache[2];
                    node = nodeIndex && parent.childNodes[nodeIndex];

                    while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start
                    diff = nodeIndex = 0) || start.pop()) {
                      // When found, cache indexes on `parent` and break
                      if (node.nodeType === 1 && ++diff && node === elem) {
                        uniqueCache[type] = [dirruns, nodeIndex, diff];
                        break;
                      }
                    }
                  } else {
                    // Use previously-cached element index if available
                    if (useCache) {
                      // ...in a gzip-friendly way
                      node = elem;
                      outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                      // Defend against cloned attroperties (jQuery gh-1709)

                      uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                      cache = uniqueCache[type] || [];
                      nodeIndex = cache[0] === dirruns && cache[1];
                      diff = nodeIndex;
                    } // xml :nth-child(...)
                    // or :nth-last-child(...) or :nth(-last)?-of-type(...)


                    if (diff === false) {
                      // Use the same loop as above to seek `elem` from the start
                      while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                        if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                          // Cache the index of each encountered element
                          if (useCache) {
                            outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                            // Defend against cloned attroperties (jQuery gh-1709)

                            uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                            uniqueCache[type] = [dirruns, diff];
                          }

                          if (node === elem) {
                            break;
                          }
                        }
                      }
                    }
                  } // Incorporate the offset, then check against cycle size


                  diff -= last;
                  return diff === first || diff % first === 0 && diff / first >= 0;
                }
              };
            },
            "PSEUDO": function PSEUDO(pseudo, argument) {
              // pseudo-class names are case-insensitive
              // http://www.w3.org/TR/selectors/#pseudo-classes
              // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
              // Remember that setFilters inherits from pseudos
              var args,
                  fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo); // The user may use createPseudo to indicate that
              // arguments are needed to create the filter function
              // just as Sizzle does

              if (fn[expando]) {
                return fn(argument);
              } // But maintain support for old signatures


              if (fn.length > 1) {
                args = [pseudo, pseudo, "", argument];
                return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                  var idx,
                      matched = fn(seed, argument),
                      i = matched.length;

                  while (i--) {
                    idx = indexOf(seed, matched[i]);
                    seed[idx] = !(matches[idx] = matched[i]);
                  }
                }) : function (elem) {
                  return fn(elem, 0, args);
                };
              }

              return fn;
            }
          },
          pseudos: {
            // Potentially complex pseudos
            "not": markFunction(function (selector) {
              // Trim the selector passed to compile
              // to avoid treating leading and trailing
              // spaces as combinators
              var input = [],
                  results = [],
                  matcher = compile(selector.replace(rtrim, "$1"));
              return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
                var elem,
                    unmatched = matcher(seed, null, xml, []),
                    i = seed.length; // Match elements unmatched by `matcher`

                while (i--) {
                  if (elem = unmatched[i]) {
                    seed[i] = !(matches[i] = elem);
                  }
                }
              }) : function (elem, context, xml) {
                input[0] = elem;
                matcher(input, null, xml, results); // Don't keep the element (issue #299)

                input[0] = null;
                return !results.pop();
              };
            }),
            "has": markFunction(function (selector) {
              return function (elem) {
                return Sizzle(selector, elem).length > 0;
              };
            }),
            "contains": markFunction(function (text) {
              text = text.replace(runescape, funescape);
              return function (elem) {
                return (elem.textContent || getText(elem)).indexOf(text) > -1;
              };
            }),
            // "Whether an element is represented by a :lang() selector
            // is based solely on the element's language value
            // being equal to the identifier C,
            // or beginning with the identifier C immediately followed by "-".
            // The matching of C against the element's language value is performed case-insensitively.
            // The identifier C does not have to be a valid language name."
            // http://www.w3.org/TR/selectors/#lang-pseudo
            "lang": markFunction(function (lang) {
              // lang value must be a valid identifier
              if (!ridentifier.test(lang || "")) {
                Sizzle.error("unsupported lang: " + lang);
              }

              lang = lang.replace(runescape, funescape).toLowerCase();
              return function (elem) {
                var elemLang;

                do {
                  if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                    elemLang = elemLang.toLowerCase();
                    return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                  }
                } while ((elem = elem.parentNode) && elem.nodeType === 1);

                return false;
              };
            }),
            // Miscellaneous
            "target": function target(elem) {
              var hash = window.location && window.location.hash;
              return hash && hash.slice(1) === elem.id;
            },
            "root": function root(elem) {
              return elem === docElem;
            },
            "focus": function focus(elem) {
              return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
            },
            // Boolean properties
            "enabled": createDisabledPseudo(false),
            "disabled": createDisabledPseudo(true),
            "checked": function checked(elem) {
              // In CSS3, :checked should return both checked and selected elements
              // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
              var nodeName = elem.nodeName.toLowerCase();
              return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
            },
            "selected": function selected(elem) {
              // Accessing this property makes selected-by-default
              // options in Safari work properly
              if (elem.parentNode) {
                elem.parentNode.selectedIndex;
              }

              return elem.selected === true;
            },
            // Contents
            "empty": function empty(elem) {
              // http://www.w3.org/TR/selectors/#empty-pseudo
              // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
              //   but not by others (comment: 8; processing instruction: 7; etc.)
              // nodeType < 6 works because attributes (2) do not appear as children
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                if (elem.nodeType < 6) {
                  return false;
                }
              }

              return true;
            },
            "parent": function parent(elem) {
              return !Expr.pseudos["empty"](elem);
            },
            // Element/input types
            "header": function header(elem) {
              return rheader.test(elem.nodeName);
            },
            "input": function input(elem) {
              return rinputs.test(elem.nodeName);
            },
            "button": function button(elem) {
              var name = elem.nodeName.toLowerCase();
              return name === "input" && elem.type === "button" || name === "button";
            },
            "text": function text(elem) {
              var attr;
              return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ( // Support: IE<8
              // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
              (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
            },
            // Position-in-collection
            "first": createPositionalPseudo(function () {
              return [0];
            }),
            "last": createPositionalPseudo(function (matchIndexes, length) {
              return [length - 1];
            }),
            "eq": createPositionalPseudo(function (matchIndexes, length, argument) {
              return [argument < 0 ? argument + length : argument];
            }),
            "even": createPositionalPseudo(function (matchIndexes, length) {
              var i = 0;

              for (; i < length; i += 2) {
                matchIndexes.push(i);
              }

              return matchIndexes;
            }),
            "odd": createPositionalPseudo(function (matchIndexes, length) {
              var i = 1;

              for (; i < length; i += 2) {
                matchIndexes.push(i);
              }

              return matchIndexes;
            }),
            "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
              var i = argument < 0 ? argument + length : argument > length ? length : argument;

              for (; --i >= 0;) {
                matchIndexes.push(i);
              }

              return matchIndexes;
            }),
            "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
              var i = argument < 0 ? argument + length : argument;

              for (; ++i < length;) {
                matchIndexes.push(i);
              }

              return matchIndexes;
            })
          }
        };
        Expr.pseudos["nth"] = Expr.pseudos["eq"]; // Add button/input type pseudos

        for (i in {
          radio: true,
          checkbox: true,
          file: true,
          password: true,
          image: true
        }) {
          Expr.pseudos[i] = createInputPseudo(i);
        }

        for (i in {
          submit: true,
          reset: true
        }) {
          Expr.pseudos[i] = createButtonPseudo(i);
        } // Easy API for creating new setFilters


        function setFilters() {}

        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();

        tokenize = Sizzle.tokenize = function (selector, parseOnly) {
          var matched,
              match,
              tokens,
              type,
              soFar,
              groups,
              preFilters,
              cached = tokenCache[selector + " "];

          if (cached) {
            return parseOnly ? 0 : cached.slice(0);
          }

          soFar = selector;
          groups = [];
          preFilters = Expr.preFilter;

          while (soFar) {
            // Comma and first run
            if (!matched || (match = rcomma.exec(soFar))) {
              if (match) {
                // Don't consume trailing commas as valid
                soFar = soFar.slice(match[0].length) || soFar;
              }

              groups.push(tokens = []);
            }

            matched = false; // Combinators

            if (match = rcombinators.exec(soFar)) {
              matched = match.shift();
              tokens.push({
                value: matched,
                // Cast descendant combinators to space
                type: match[0].replace(rtrim, " ")
              });
              soFar = soFar.slice(matched.length);
            } // Filters


            for (type in Expr.filter) {
              if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                matched = match.shift();
                tokens.push({
                  value: matched,
                  type: type,
                  matches: match
                });
                soFar = soFar.slice(matched.length);
              }
            }

            if (!matched) {
              break;
            }
          } // Return the length of the invalid excess
          // if we're just parsing
          // Otherwise, throw an error or return tokens


          return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens
          tokenCache(selector, groups).slice(0);
        };

        function toSelector(tokens) {
          var i = 0,
              len = tokens.length,
              selector = "";

          for (; i < len; i++) {
            selector += tokens[i].value;
          }

          return selector;
        }

        function addCombinator(matcher, combinator, base) {
          var dir = combinator.dir,
              skip = combinator.next,
              key = skip || dir,
              checkNonElements = base && key === "parentNode",
              doneName = done++;
          return combinator.first ? // Check against closest ancestor/preceding element
          function (elem, context, xml) {
            while (elem = elem[dir]) {
              if (elem.nodeType === 1 || checkNonElements) {
                return matcher(elem, context, xml);
              }
            }

            return false;
          } : // Check against all ancestor/preceding elements
          function (elem, context, xml) {
            var oldCache,
                uniqueCache,
                outerCache,
                newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching

            if (xml) {
              while (elem = elem[dir]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  if (matcher(elem, context, xml)) {
                    return true;
                  }
                }
              }
            } else {
              while (elem = elem[dir]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  outerCache = elem[expando] || (elem[expando] = {}); // Support: IE <9 only
                  // Defend against cloned attroperties (jQuery gh-1709)

                  uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

                  if (skip && skip === elem.nodeName.toLowerCase()) {
                    elem = elem[dir] || elem;
                  } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                    // Assign to newCache so results back-propagate to previous elements
                    return newCache[2] = oldCache[2];
                  } else {
                    // Reuse newcache so results back-propagate to previous elements
                    uniqueCache[key] = newCache; // A match means we're done; a fail means we have to keep checking

                    if (newCache[2] = matcher(elem, context, xml)) {
                      return true;
                    }
                  }
                }
              }
            }

            return false;
          };
        }

        function elementMatcher(matchers) {
          return matchers.length > 1 ? function (elem, context, xml) {
            var i = matchers.length;

            while (i--) {
              if (!matchers[i](elem, context, xml)) {
                return false;
              }
            }

            return true;
          } : matchers[0];
        }

        function multipleContexts(selector, contexts, results) {
          var i = 0,
              len = contexts.length;

          for (; i < len; i++) {
            Sizzle(selector, contexts[i], results);
          }

          return results;
        }

        function condense(unmatched, map, filter, context, xml) {
          var elem,
              newUnmatched = [],
              i = 0,
              len = unmatched.length,
              mapped = map != null;

          for (; i < len; i++) {
            if (elem = unmatched[i]) {
              if (!filter || filter(elem, context, xml)) {
                newUnmatched.push(elem);

                if (mapped) {
                  map.push(i);
                }
              }
            }
          }

          return newUnmatched;
        }

        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
          if (postFilter && !postFilter[expando]) {
            postFilter = setMatcher(postFilter);
          }

          if (postFinder && !postFinder[expando]) {
            postFinder = setMatcher(postFinder, postSelector);
          }

          return markFunction(function (seed, results, context, xml) {
            var temp,
                i,
                elem,
                preMap = [],
                postMap = [],
                preexisting = results.length,
                // Get initial elements from seed or context
            elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
                // Prefilter to get matcher input, preserving a map for seed-results synchronization
            matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
                matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
            postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
            [] : // ...otherwise use results directly
            results : matcherIn; // Find primary matches

            if (matcher) {
              matcher(matcherIn, matcherOut, context, xml);
            } // Apply postFilter


            if (postFilter) {
              temp = condense(matcherOut, postMap);
              postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn

              i = temp.length;

              while (i--) {
                if (elem = temp[i]) {
                  matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                }
              }
            }

            if (seed) {
              if (postFinder || preFilter) {
                if (postFinder) {
                  // Get the final matcherOut by condensing this intermediate into postFinder contexts
                  temp = [];
                  i = matcherOut.length;

                  while (i--) {
                    if (elem = matcherOut[i]) {
                      // Restore matcherIn since elem is not yet a final match
                      temp.push(matcherIn[i] = elem);
                    }
                  }

                  postFinder(null, matcherOut = [], temp, xml);
                } // Move matched elements from seed to results to keep them synchronized


                i = matcherOut.length;

                while (i--) {
                  if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                    seed[temp] = !(results[temp] = elem);
                  }
                }
              } // Add elements to results, through postFinder if defined

            } else {
              matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);

              if (postFinder) {
                postFinder(null, results, matcherOut, xml);
              } else {
                push.apply(results, matcherOut);
              }
            }
          });
        }

        function matcherFromTokens(tokens) {
          var checkContext,
              matcher,
              j,
              len = tokens.length,
              leadingRelative = Expr.relative[tokens[0].type],
              implicitRelative = leadingRelative || Expr.relative[" "],
              i = leadingRelative ? 1 : 0,
              // The foundational matcher ensures that elements are reachable from top-level context(s)
          matchContext = addCombinator(function (elem) {
            return elem === checkContext;
          }, implicitRelative, true),
              matchAnyContext = addCombinator(function (elem) {
            return indexOf(checkContext, elem) > -1;
          }, implicitRelative, true),
              matchers = [function (elem, context, xml) {
            var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)

            checkContext = null;
            return ret;
          }];

          for (; i < len; i++) {
            if (matcher = Expr.relative[tokens[i].type]) {
              matchers = [addCombinator(elementMatcher(matchers), matcher)];
            } else {
              matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher

              if (matcher[expando]) {
                // Find the next relative operator (if any) for proper handling
                j = ++i;

                for (; j < len; j++) {
                  if (Expr.relative[tokens[j].type]) {
                    break;
                  }
                }

                return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                tokens.slice(0, i - 1).concat({
                  value: tokens[i - 2].type === " " ? "*" : ""
                })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
              }

              matchers.push(matcher);
            }
          }

          return elementMatcher(matchers);
        }

        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
          var bySet = setMatchers.length > 0,
              byElement = elementMatchers.length > 0,
              superMatcher = function superMatcher(seed, context, xml, results, outermost) {
            var elem,
                j,
                matcher,
                matchedCount = 0,
                i = "0",
                unmatched = seed && [],
                setMatched = [],
                contextBackup = outermostContext,
                // We must always have either seed elements or outermost context
            elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                // Use integer dirruns iff this is the outermost matcher
            dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
                len = elems.length;

            if (outermost) {
              outermostContext = context === document || context || outermost;
            } // Add elements passing elementMatchers directly to results
            // Support: IE<9, Safari
            // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id


            for (; i !== len && (elem = elems[i]) != null; i++) {
              if (byElement && elem) {
                j = 0;

                if (!context && elem.ownerDocument !== document) {
                  setDocument(elem);
                  xml = !documentIsHTML;
                }

                while (matcher = elementMatchers[j++]) {
                  if (matcher(elem, context || document, xml)) {
                    results.push(elem);
                    break;
                  }
                }

                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              } // Track unmatched elements for set filters


              if (bySet) {
                // They will have gone through all possible matchers
                if (elem = !matcher && elem) {
                  matchedCount--;
                } // Lengthen the array for every element, matched or not


                if (seed) {
                  unmatched.push(elem);
                }
              }
            } // `i` is now the count of elements visited above, and adding it to `matchedCount`
            // makes the latter nonnegative.


            matchedCount += i; // Apply set filters to unmatched elements
            // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
            // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
            // no element matchers and no seed.
            // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
            // case, which will result in a "00" `matchedCount` that differs from `i` but is also
            // numerically zero.

            if (bySet && i !== matchedCount) {
              j = 0;

              while (matcher = setMatchers[j++]) {
                matcher(unmatched, setMatched, context, xml);
              }

              if (seed) {
                // Reintegrate element matches to eliminate the need for sorting
                if (matchedCount > 0) {
                  while (i--) {
                    if (!(unmatched[i] || setMatched[i])) {
                      setMatched[i] = pop.call(results);
                    }
                  }
                } // Discard index placeholder values to get only actual matches


                setMatched = condense(setMatched);
              } // Add matches to results


              push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting

              if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                Sizzle.uniqueSort(results);
              }
            } // Override manipulation of globals by nested matchers


            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }

            return unmatched;
          };

          return bySet ? markFunction(superMatcher) : superMatcher;
        }

        compile = Sizzle.compile = function (selector, match
        /* Internal Use Only */
        ) {
          var i,
              setMatchers = [],
              elementMatchers = [],
              cached = compilerCache[selector + " "];

          if (!cached) {
            // Generate a function of recursive functions that can be used to check each element
            if (!match) {
              match = tokenize(selector);
            }

            i = match.length;

            while (i--) {
              cached = matcherFromTokens(match[i]);

              if (cached[expando]) {
                setMatchers.push(cached);
              } else {
                elementMatchers.push(cached);
              }
            } // Cache the compiled function


            cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization

            cached.selector = selector;
          }

          return cached;
        };
        /**
         * A low-level selection function that works with Sizzle's compiled
         *  selector functions
         * @param {String|Function} selector A selector or a pre-compiled
         *  selector function built with Sizzle.compile
         * @param {Element} context
         * @param {Array} [results]
         * @param {Array} [seed] A set of elements to match against
         */


        select = Sizzle.select = function (selector, context, results, seed) {
          var i,
              tokens,
              token,
              type,
              find,
              compiled = typeof selector === "function" && selector,
              match = !seed && tokenize(selector = compiled.selector || selector);
          results = results || []; // Try to minimize operations if there is only one selector in the list and no seed
          // (the latter of which guarantees us context)

          if (match.length === 1) {
            // Reduce context if the leading compound selector is an ID
            tokens = match[0] = match[0].slice(0);

            if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
              context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];

              if (!context) {
                return results; // Precompiled matchers will still verify ancestry, so step up a level
              } else if (compiled) {
                context = context.parentNode;
              }

              selector = selector.slice(tokens.shift().value.length);
            } // Fetch a seed set for right-to-left matching


            i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;

            while (i--) {
              token = tokens[i]; // Abort if we hit a combinator

              if (Expr.relative[type = token.type]) {
                break;
              }

              if (find = Expr.find[type]) {
                // Search, expanding context for leading sibling combinators
                if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                  // If seed is empty or no tokens remain, we can return early
                  tokens.splice(i, 1);
                  selector = seed.length && toSelector(tokens);

                  if (!selector) {
                    push.apply(results, seed);
                    return results;
                  }

                  break;
                }
              }
            }
          } // Compile and execute a filtering function if one is not provided
          // Provide `match` to avoid retokenization if we modified the selector above


          (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
          return results;
        }; // One-time assignments
        // Sort stability


        support.sortStable = expando.split("").sort(sortOrder).join("") === expando; // Support: Chrome 14-35+
        // Always assume duplicates if they aren't passed to the comparison function

        support.detectDuplicates = !!hasDuplicate; // Initialize against the default document

        setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
        // Detached nodes confoundingly follow *each other*

        support.sortDetached = assert(function (el) {
          // Should return 1, but returns 4 (following)
          return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
        }); // Support: IE<8
        // Prevent attribute/property "interpolation"
        // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx

        if (!assert(function (el) {
          el.innerHTML = "<a href='#'></a>";
          return el.firstChild.getAttribute("href") === "#";
        })) {
          addHandle("type|href|height|width", function (elem, name, isXML) {
            if (!isXML) {
              return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
            }
          });
        } // Support: IE<9
        // Use defaultValue in place of getAttribute("value")


        if (!support.attributes || !assert(function (el) {
          el.innerHTML = "<input/>";
          el.firstChild.setAttribute("value", "");
          return el.firstChild.getAttribute("value") === "";
        })) {
          addHandle("value", function (elem, name, isXML) {
            if (!isXML && elem.nodeName.toLowerCase() === "input") {
              return elem.defaultValue;
            }
          });
        } // Support: IE<9
        // Use getAttributeNode to fetch booleans when getAttribute lies


        if (!assert(function (el) {
          return el.getAttribute("disabled") == null;
        })) {
          addHandle(booleans, function (elem, name, isXML) {
            var val;

            if (!isXML) {
              return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
            }
          });
        }

        return Sizzle;
      }(window);

      jQuery.find = Sizzle;
      jQuery.expr = Sizzle.selectors; // Deprecated

      jQuery.expr[":"] = jQuery.expr.pseudos;
      jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
      jQuery.text = Sizzle.getText;
      jQuery.isXMLDoc = Sizzle.isXML;
      jQuery.contains = Sizzle.contains;
      jQuery.escapeSelector = Sizzle.escape;

      var dir = function dir(elem, _dir, until) {
        var matched = [],
            truncate = until !== undefined;

        while ((elem = elem[_dir]) && elem.nodeType !== 9) {
          if (elem.nodeType === 1) {
            if (truncate && jQuery(elem).is(until)) {
              break;
            }

            matched.push(elem);
          }
        }

        return matched;
      };

      var _siblings = function siblings(n, elem) {
        var matched = [];

        for (; n; n = n.nextSibling) {
          if (n.nodeType === 1 && n !== elem) {
            matched.push(n);
          }
        }

        return matched;
      };

      var rneedsContext = jQuery.expr.match.needsContext;

      function nodeName(elem, name) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
      }

      ;
      var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; // Implement the identical functionality for filter and not

      function winnow(elements, qualifier, not) {
        if (isFunction(qualifier)) {
          return jQuery.grep(elements, function (elem, i) {
            return !!qualifier.call(elem, i, elem) !== not;
          });
        } // Single element


        if (qualifier.nodeType) {
          return jQuery.grep(elements, function (elem) {
            return elem === qualifier !== not;
          });
        } // Arraylike of elements (jQuery, arguments, Array)


        if (typeof qualifier !== "string") {
          return jQuery.grep(elements, function (elem) {
            return indexOf.call(qualifier, elem) > -1 !== not;
          });
        } // Filtered directly for both simple and complex selectors


        return jQuery.filter(qualifier, elements, not);
      }

      jQuery.filter = function (expr, elems, not) {
        var elem = elems[0];

        if (not) {
          expr = ":not(" + expr + ")";
        }

        if (elems.length === 1 && elem.nodeType === 1) {
          return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
        }

        return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
          return elem.nodeType === 1;
        }));
      };

      jQuery.fn.extend({
        find: function find(selector) {
          var i,
              ret,
              len = this.length,
              self = this;

          if (typeof selector !== "string") {
            return this.pushStack(jQuery(selector).filter(function () {
              for (i = 0; i < len; i++) {
                if (jQuery.contains(self[i], this)) {
                  return true;
                }
              }
            }));
          }

          ret = this.pushStack([]);

          for (i = 0; i < len; i++) {
            jQuery.find(selector, self[i], ret);
          }

          return len > 1 ? jQuery.uniqueSort(ret) : ret;
        },
        filter: function filter(selector) {
          return this.pushStack(winnow(this, selector || [], false));
        },
        not: function not(selector) {
          return this.pushStack(winnow(this, selector || [], true));
        },
        is: function is(selector) {
          return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set
          // so $("p:first").is("p:last") won't return true for a doc with two "p".
          typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
      }); // Initialize a jQuery object
      // A central reference to the root jQuery(document)

      var rootjQuery,
          // A simple way to check for HTML strings
      // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
      // Strict HTML recognition (#11290: must start with <)
      // Shortcut simple #id case for speed
      rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
          init = jQuery.fn.init = function (selector, context, root) {
        var match, elem; // HANDLE: $(""), $(null), $(undefined), $(false)

        if (!selector) {
          return this;
        } // Method init() accepts an alternate rootjQuery
        // so migrate can support jQuery.sub (gh-2101)


        root = root || rootjQuery; // Handle HTML strings

        if (typeof selector === "string") {
          if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
            // Assume that strings that start and end with <> are HTML and skip the regex check
            match = [null, selector, null];
          } else {
            match = rquickExpr.exec(selector);
          } // Match html or make sure no context is specified for #id


          if (match && (match[1] || !context)) {
            // HANDLE: $(html) -> $(array)
            if (match[1]) {
              context = context instanceof jQuery ? context[0] : context; // Option to run scripts is true for back-compat
              // Intentionally let the error be thrown if parseHTML is not present

              jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true)); // HANDLE: $(html, props)

              if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                for (match in context) {
                  // Properties of context are called as methods if possible
                  if (isFunction(this[match])) {
                    this[match](context[match]); // ...and otherwise set as attributes
                  } else {
                    this.attr(match, context[match]);
                  }
                }
              }

              return this; // HANDLE: $(#id)
            } else {
              elem = document.getElementById(match[2]);

              if (elem) {
                // Inject the element directly into the jQuery object
                this[0] = elem;
                this.length = 1;
              }

              return this;
            } // HANDLE: $(expr, $(...))

          } else if (!context || context.jquery) {
            return (context || root).find(selector); // HANDLE: $(expr, context)
            // (which is just equivalent to: $(context).find(expr)
          } else {
            return this.constructor(context).find(selector);
          } // HANDLE: $(DOMElement)

        } else if (selector.nodeType) {
          this[0] = selector;
          this.length = 1;
          return this; // HANDLE: $(function)
          // Shortcut for document ready
        } else if (isFunction(selector)) {
          return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present
          selector(jQuery);
        }

        return jQuery.makeArray(selector, this);
      }; // Give the init function the jQuery prototype for later instantiation


      init.prototype = jQuery.fn; // Initialize central reference

      rootjQuery = jQuery(document);
      var rparentsprev = /^(?:parents|prev(?:Until|All))/,
          // Methods guaranteed to produce a unique set when starting from a unique set
      guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
      };
      jQuery.fn.extend({
        has: function has(target) {
          var targets = jQuery(target, this),
              l = targets.length;
          return this.filter(function () {
            var i = 0;

            for (; i < l; i++) {
              if (jQuery.contains(this, targets[i])) {
                return true;
              }
            }
          });
        },
        closest: function closest(selectors, context) {
          var cur,
              i = 0,
              l = this.length,
              matched = [],
              targets = typeof selectors !== "string" && jQuery(selectors); // Positional selectors never match, since there's no _selection_ context

          if (!rneedsContext.test(selectors)) {
            for (; i < l; i++) {
              for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                // Always skip document fragments
                if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to Sizzle
                cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                  matched.push(cur);
                  break;
                }
              }
            }
          }

          return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },
        // Determine the position of an element within the set
        index: function index(elem) {
          // No argument, return index in parent
          if (!elem) {
            return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
          } // Index in selector


          if (typeof elem === "string") {
            return indexOf.call(jQuery(elem), this[0]);
          } // Locate the position of the desired element


          return indexOf.call(this, // If it receives a jQuery object, the first element is used
          elem.jquery ? elem[0] : elem);
        },
        add: function add(selector, context) {
          return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function addBack(selector) {
          return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
      });

      function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1) {}

        return cur;
      }

      jQuery.each({
        parent: function parent(elem) {
          var parent = elem.parentNode;
          return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function parents(elem) {
          return dir(elem, "parentNode");
        },
        parentsUntil: function parentsUntil(elem, i, until) {
          return dir(elem, "parentNode", until);
        },
        next: function next(elem) {
          return sibling(elem, "nextSibling");
        },
        prev: function prev(elem) {
          return sibling(elem, "previousSibling");
        },
        nextAll: function nextAll(elem) {
          return dir(elem, "nextSibling");
        },
        prevAll: function prevAll(elem) {
          return dir(elem, "previousSibling");
        },
        nextUntil: function nextUntil(elem, i, until) {
          return dir(elem, "nextSibling", until);
        },
        prevUntil: function prevUntil(elem, i, until) {
          return dir(elem, "previousSibling", until);
        },
        siblings: function siblings(elem) {
          return _siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function children(elem) {
          return _siblings(elem.firstChild);
        },
        contents: function contents(elem) {
          if (typeof elem.contentDocument !== "undefined") {
            return elem.contentDocument;
          } // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
          // Treat the template element as a regular one in browsers that
          // don't support it.


          if (nodeName(elem, "template")) {
            elem = elem.content || elem;
          }

          return jQuery.merge([], elem.childNodes);
        }
      }, function (name, fn) {
        jQuery.fn[name] = function (until, selector) {
          var matched = jQuery.map(this, fn, until);

          if (name.slice(-5) !== "Until") {
            selector = until;
          }

          if (selector && typeof selector === "string") {
            matched = jQuery.filter(selector, matched);
          }

          if (this.length > 1) {
            // Remove duplicates
            if (!guaranteedUnique[name]) {
              jQuery.uniqueSort(matched);
            } // Reverse order for parents* and prev-derivatives


            if (rparentsprev.test(name)) {
              matched.reverse();
            }
          }

          return this.pushStack(matched);
        };
      });
      var rnothtmlwhite = /[^\x20\t\r\n\f]+/g; // Convert String-formatted options into Object-formatted ones

      function createOptions(options) {
        var object = {};
        jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
          object[flag] = true;
        });
        return object;
      }
      /*
       * Create a callback list using the following parameters:
       *
       *	options: an optional list of space-separated options that will change how
       *			the callback list behaves or a more traditional option object
       *
       * By default a callback list will act like an event callback list and can be
       * "fired" multiple times.
       *
       * Possible options:
       *
       *	once:			will ensure the callback list can only be fired once (like a Deferred)
       *
       *	memory:			will keep track of previous values and will call any callback added
       *					after the list has been fired right away with the latest "memorized"
       *					values (like a Deferred)
       *
       *	unique:			will ensure a callback can only be added once (no duplicate in the list)
       *
       *	stopOnFalse:	interrupt callings when a callback returns false
       *
       */


      jQuery.Callbacks = function (options) {
        // Convert options from String-formatted to Object-formatted if needed
        // (we check in cache first)
        options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);

        var // Flag to know if list is currently firing
        firing,
            // Last fire value for non-forgettable lists
        memory,
            // Flag to know if list was already fired
        _fired,
            // Flag to prevent firing
        _locked,
            // Actual callback list
        list = [],
            // Queue of execution data for repeatable lists
        queue = [],
            // Index of currently firing callback (modified by add/remove as needed)
        firingIndex = -1,
            // Fire callbacks
        fire = function fire() {
          // Enforce single-firing
          _locked = _locked || options.once; // Execute callbacks for all pending executions,
          // respecting firingIndex overrides and runtime changes

          _fired = firing = true;

          for (; queue.length; firingIndex = -1) {
            memory = queue.shift();

            while (++firingIndex < list.length) {
              // Run callback and check for early termination
              if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                // Jump to end and forget the data so .add doesn't re-fire
                firingIndex = list.length;
                memory = false;
              }
            }
          } // Forget the data if we're done with it


          if (!options.memory) {
            memory = false;
          }

          firing = false; // Clean up if we're done firing for good

          if (_locked) {
            // Keep an empty list if we have data for future add calls
            if (memory) {
              list = []; // Otherwise, this object is spent
            } else {
              list = "";
            }
          }
        },
            // Actual Callbacks object
        self = {
          // Add a callback or a collection of callbacks to the list
          add: function add() {
            if (list) {
              // If we have memory from a past run, we should fire after adding
              if (memory && !firing) {
                firingIndex = list.length - 1;
                queue.push(memory);
              }

              (function add(args) {
                jQuery.each(args, function (_, arg) {
                  if (isFunction(arg)) {
                    if (!options.unique || !self.has(arg)) {
                      list.push(arg);
                    }
                  } else if (arg && arg.length && toType(arg) !== "string") {
                    // Inspect recursively
                    add(arg);
                  }
                });
              })(arguments);

              if (memory && !firing) {
                fire();
              }
            }

            return this;
          },
          // Remove a callback from the list
          remove: function remove() {
            jQuery.each(arguments, function (_, arg) {
              var index;

              while ((index = jQuery.inArray(arg, list, index)) > -1) {
                list.splice(index, 1); // Handle firing indexes

                if (index <= firingIndex) {
                  firingIndex--;
                }
              }
            });
            return this;
          },
          // Check if a given callback is in the list.
          // If no argument is given, return whether or not list has callbacks attached.
          has: function has(fn) {
            return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
          },
          // Remove all callbacks from the list
          empty: function empty() {
            if (list) {
              list = [];
            }

            return this;
          },
          // Disable .fire and .add
          // Abort any current/pending executions
          // Clear all callbacks and values
          disable: function disable() {
            _locked = queue = [];
            list = memory = "";
            return this;
          },
          disabled: function disabled() {
            return !list;
          },
          // Disable .fire
          // Also disable .add unless we have memory (since it would have no effect)
          // Abort any pending executions
          lock: function lock() {
            _locked = queue = [];

            if (!memory && !firing) {
              list = memory = "";
            }

            return this;
          },
          locked: function locked() {
            return !!_locked;
          },
          // Call all callbacks with the given context and arguments
          fireWith: function fireWith(context, args) {
            if (!_locked) {
              args = args || [];
              args = [context, args.slice ? args.slice() : args];
              queue.push(args);

              if (!firing) {
                fire();
              }
            }

            return this;
          },
          // Call all the callbacks with the given arguments
          fire: function fire() {
            self.fireWith(this, arguments);
            return this;
          },
          // To know if the callbacks have already been called at least once
          fired: function fired() {
            return !!_fired;
          }
        };

        return self;
      };

      function Identity(v) {
        return v;
      }

      function Thrower(ex) {
        throw ex;
      }

      function adoptValue(value, resolve, reject, noValue) {
        var method;

        try {
          // Check for promise aspect first to privilege synchronous behavior
          if (value && isFunction(method = value.promise)) {
            method.call(value).done(resolve).fail(reject); // Other thenables
          } else if (value && isFunction(method = value.then)) {
            method.call(value, resolve, reject); // Other non-thenables
          } else {
            // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
            // * false: [ value ].slice( 0 ) => resolve( value )
            // * true: [ value ].slice( 1 ) => resolve()
            resolve.apply(undefined, [value].slice(noValue));
          } // For Promises/A+, convert exceptions into rejections
          // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
          // Deferred#then to conditionally suppress rejection.

        } catch (value) {
          // Support: Android 4.0 only
          // Strict mode functions invoked without .call/.apply get global-object context
          reject.apply(undefined, [value]);
        }
      }

      jQuery.extend({
        Deferred: function Deferred(func) {
          var tuples = [// action, add listener, callbacks,
          // ... .then handlers, argument index, [final state]
          ["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]],
              _state = "pending",
              _promise = {
            state: function state() {
              return _state;
            },
            always: function always() {
              deferred.done(arguments).fail(arguments);
              return this;
            },
            "catch": function _catch(fn) {
              return _promise.then(null, fn);
            },
            // Keep pipe for back-compat
            pipe: function pipe()
            /* fnDone, fnFail, fnProgress */
            {
              var fns = arguments;
              return jQuery.Deferred(function (newDefer) {
                jQuery.each(tuples, function (i, tuple) {
                  // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                  var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]]; // deferred.progress(function() { bind to newDefer or newDefer.notify })
                  // deferred.done(function() { bind to newDefer or newDefer.resolve })
                  // deferred.fail(function() { bind to newDefer or newDefer.reject })

                  deferred[tuple[1]](function () {
                    var returned = fn && fn.apply(this, arguments);

                    if (returned && isFunction(returned.promise)) {
                      returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                    } else {
                      newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
                    }
                  });
                });
                fns = null;
              }).promise();
            },
            then: function then(onFulfilled, onRejected, onProgress) {
              var maxDepth = 0;

              function resolve(depth, deferred, handler, special) {
                return function () {
                  var that = this,
                      args = arguments,
                      mightThrow = function mightThrow() {
                    var returned, then; // Support: Promises/A+ section 2.3.3.3.3
                    // https://promisesaplus.com/#point-59
                    // Ignore double-resolution attempts

                    if (depth < maxDepth) {
                      return;
                    }

                    returned = handler.apply(that, args); // Support: Promises/A+ section 2.3.1
                    // https://promisesaplus.com/#point-48

                    if (returned === deferred.promise()) {
                      throw new TypeError("Thenable self-resolution");
                    } // Support: Promises/A+ sections 2.3.3.1, 3.5
                    // https://promisesaplus.com/#point-54
                    // https://promisesaplus.com/#point-75
                    // Retrieve `then` only once


                    then = returned && ( // Support: Promises/A+ section 2.3.4
                    // https://promisesaplus.com/#point-64
                    // Only check objects and functions for thenability
                    typeof returned === "object" || typeof returned === "function") && returned.then; // Handle a returned thenable

                    if (isFunction(then)) {
                      // Special processors (notify) just wait for resolution
                      if (special) {
                        then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)); // Normal processors (resolve) also hook into progress
                      } else {
                        // ...and disregard older resolution values
                        maxDepth++;
                        then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                      } // Handle all other returned values

                    } else {
                      // Only substitute handlers pass on context
                      // and multiple values (non-spec behavior)
                      if (handler !== Identity) {
                        that = undefined;
                        args = [returned];
                      } // Process the value(s)
                      // Default process is resolve


                      (special || deferred.resolveWith)(that, args);
                    }
                  },
                      // Only normal processors (resolve) catch and reject exceptions
                  process = special ? mightThrow : function () {
                    try {
                      mightThrow();
                    } catch (e) {
                      if (jQuery.Deferred.exceptionHook) {
                        jQuery.Deferred.exceptionHook(e, process.stackTrace);
                      } // Support: Promises/A+ section 2.3.3.3.4.1
                      // https://promisesaplus.com/#point-61
                      // Ignore post-resolution exceptions


                      if (depth + 1 >= maxDepth) {
                        // Only substitute handlers pass on context
                        // and multiple values (non-spec behavior)
                        if (handler !== Thrower) {
                          that = undefined;
                          args = [e];
                        }

                        deferred.rejectWith(that, args);
                      }
                    }
                  }; // Support: Promises/A+ section 2.3.3.3.1
                  // https://promisesaplus.com/#point-57
                  // Re-resolve promises immediately to dodge false rejection from
                  // subsequent errors


                  if (depth) {
                    process();
                  } else {
                    // Call an optional hook to record the stack, in case of exception
                    // since it's otherwise lost when execution goes async
                    if (jQuery.Deferred.getStackHook) {
                      process.stackTrace = jQuery.Deferred.getStackHook();
                    }

                    window.setTimeout(process);
                  }
                };
              }

              return jQuery.Deferred(function (newDefer) {
                // progress_handlers.add( ... )
                tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)); // fulfilled_handlers.add( ... )

                tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity)); // rejected_handlers.add( ... )

                tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
              }).promise();
            },
            // Get a promise for this deferred
            // If obj is provided, the promise aspect is added to the object
            promise: function promise(obj) {
              return obj != null ? jQuery.extend(obj, _promise) : _promise;
            }
          },
              deferred = {}; // Add list-specific methods

          jQuery.each(tuples, function (i, tuple) {
            var list = tuple[2],
                stateString = tuple[5]; // promise.progress = list.add
            // promise.done = list.add
            // promise.fail = list.add

            _promise[tuple[1]] = list.add; // Handle state

            if (stateString) {
              list.add(function () {
                // state = "resolved" (i.e., fulfilled)
                // state = "rejected"
                _state = stateString;
              }, // rejected_callbacks.disable
              // fulfilled_callbacks.disable
              tuples[3 - i][2].disable, // rejected_handlers.disable
              // fulfilled_handlers.disable
              tuples[3 - i][3].disable, // progress_callbacks.lock
              tuples[0][2].lock, // progress_handlers.lock
              tuples[0][3].lock);
            } // progress_handlers.fire
            // fulfilled_handlers.fire
            // rejected_handlers.fire


            list.add(tuple[3].fire); // deferred.notify = function() { deferred.notifyWith(...) }
            // deferred.resolve = function() { deferred.resolveWith(...) }
            // deferred.reject = function() { deferred.rejectWith(...) }

            deferred[tuple[0]] = function () {
              deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
              return this;
            }; // deferred.notifyWith = list.fireWith
            // deferred.resolveWith = list.fireWith
            // deferred.rejectWith = list.fireWith


            deferred[tuple[0] + "With"] = list.fireWith;
          }); // Make the deferred a promise

          _promise.promise(deferred); // Call given func if any


          if (func) {
            func.call(deferred, deferred);
          } // All done!


          return deferred;
        },
        // Deferred helper
        when: function when(singleValue) {
          var // count of uncompleted subordinates
          remaining = arguments.length,
              // count of unprocessed arguments
          i = remaining,
              // subordinate fulfillment data
          resolveContexts = Array(i),
              resolveValues = _slice.call(arguments),
              // the master Deferred
          master = jQuery.Deferred(),
              // subordinate callback factory
          updateFunc = function updateFunc(i) {
            return function (value) {
              resolveContexts[i] = this;
              resolveValues[i] = arguments.length > 1 ? _slice.call(arguments) : value;

              if (! --remaining) {
                master.resolveWith(resolveContexts, resolveValues);
              }
            };
          }; // Single- and empty arguments are adopted like Promise.resolve


          if (remaining <= 1) {
            adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining); // Use .then() to unwrap secondary thenables (cf. gh-3000)

            if (master.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
              return master.then();
            }
          } // Multiple arguments are aggregated like Promise.all array elements


          while (i--) {
            adoptValue(resolveValues[i], updateFunc(i), master.reject);
          }

          return master.promise();
        }
      }); // These usually indicate a programmer mistake during development,
      // warn about them ASAP rather than swallowing them by default.

      var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

      jQuery.Deferred.exceptionHook = function (error, stack) {
        // Support: IE 8 - 9 only
        // Console exists when dev tools are open, which can happen at any time
        if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
          window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
        }
      };

      jQuery.readyException = function (error) {
        window.setTimeout(function () {
          throw error;
        });
      }; // The deferred used on DOM ready


      var readyList = jQuery.Deferred();

      jQuery.fn.ready = function (fn) {
        readyList.then(fn) // Wrap jQuery.readyException in a function so that the lookup
        // happens at the time of error handling instead of callback
        // registration.
        .catch(function (error) {
          jQuery.readyException(error);
        });
        return this;
      };

      jQuery.extend({
        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,
        // A counter to track how many items to wait for before
        // the ready event fires. See #6781
        readyWait: 1,
        // Handle when the DOM is ready
        ready: function ready(wait) {
          // Abort if there are pending holds or we're already ready
          if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
            return;
          } // Remember that the DOM is ready


          jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be

          if (wait !== true && --jQuery.readyWait > 0) {
            return;
          } // If there are functions bound, to execute


          readyList.resolveWith(document, [jQuery]);
        }
      });
      jQuery.ready.then = readyList.then; // The ready event handler and self cleanup method

      function completed() {
        document.removeEventListener("DOMContentLoaded", completed);
        window.removeEventListener("load", completed);
        jQuery.ready();
      } // Catch cases where $(document).ready() is called
      // after the browser event has already occurred.
      // Support: IE <=9 - 10 only
      // Older IE sometimes signals "interactive" too soon


      if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {
        // Handle it asynchronously to allow scripts the opportunity to delay ready
        window.setTimeout(jQuery.ready);
      } else {
        // Use the handy event callback
        document.addEventListener("DOMContentLoaded", completed); // A fallback to window.onload, that will always work

        window.addEventListener("load", completed);
      } // Multifunctional method to get and set values of a collection
      // The value/s can optionally be executed if it's a function


      var access = function access(elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0,
            len = elems.length,
            bulk = key == null; // Sets many values

        if (toType(key) === "object") {
          chainable = true;

          for (i in key) {
            access(elems, fn, i, key[i], true, emptyGet, raw);
          } // Sets one value

        } else if (value !== undefined) {
          chainable = true;

          if (!isFunction(value)) {
            raw = true;
          }

          if (bulk) {
            // Bulk operations run against the entire set
            if (raw) {
              fn.call(elems, value);
              fn = null; // ...except when executing function values
            } else {
              bulk = fn;

              fn = function fn(elem, key, value) {
                return bulk.call(jQuery(elem), value);
              };
            }
          }

          if (fn) {
            for (; i < len; i++) {
              fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
            }
          }
        }

        if (chainable) {
          return elems;
        } // Gets


        if (bulk) {
          return fn.call(elems);
        }

        return len ? fn(elems[0], key) : emptyGet;
      }; // Matches dashed string for camelizing


      var rmsPrefix = /^-ms-/,
          rdashAlpha = /-([a-z])/g; // Used by camelCase as callback to replace()

      function fcamelCase(all, letter) {
        return letter.toUpperCase();
      } // Convert dashed to camelCase; used by the css and data modules
      // Support: IE <=9 - 11, Edge 12 - 15
      // Microsoft forgot to hump their vendor prefix (#9572)


      function camelCase(string) {
        return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
      }

      var acceptData = function acceptData(owner) {
        // Accepts only:
        //  - Node
        //    - Node.ELEMENT_NODE
        //    - Node.DOCUMENT_NODE
        //  - Object
        //    - Any
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
      };

      function Data() {
        this.expando = jQuery.expando + Data.uid++;
      }

      Data.uid = 1;
      Data.prototype = {
        cache: function cache(owner) {
          // Check if the owner object already has a cache
          var value = owner[this.expando]; // If not, create one

          if (!value) {
            value = {}; // We can accept data for non-element nodes in modern browsers,
            // but we should not, see #8335.
            // Always return an empty object.

            if (acceptData(owner)) {
              // If it is a node unlikely to be stringify-ed or looped over
              // use plain assignment
              if (owner.nodeType) {
                owner[this.expando] = value; // Otherwise secure it in a non-enumerable property
                // configurable must be true to allow the property to be
                // deleted when data is removed
              } else {
                Object.defineProperty(owner, this.expando, {
                  value: value,
                  configurable: true
                });
              }
            }
          }

          return value;
        },
        set: function set(owner, data, value) {
          var prop,
              cache = this.cache(owner); // Handle: [ owner, key, value ] args
          // Always use camelCase key (gh-2257)

          if (typeof data === "string") {
            cache[camelCase(data)] = value; // Handle: [ owner, { properties } ] args
          } else {
            // Copy the properties one-by-one to the cache object
            for (prop in data) {
              cache[camelCase(prop)] = data[prop];
            }
          }

          return cache;
        },
        get: function get(owner, key) {
          return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)
          owner[this.expando] && owner[this.expando][camelCase(key)];
        },
        access: function access(owner, key, value) {
          // In cases where either:
          //
          //   1. No key was specified
          //   2. A string key was specified, but no value provided
          //
          // Take the "read" path and allow the get method to determine
          // which value to return, respectively either:
          //
          //   1. The entire cache object
          //   2. The data stored at the key
          //
          if (key === undefined || key && typeof key === "string" && value === undefined) {
            return this.get(owner, key);
          } // When the key is not a string, or both a key and value
          // are specified, set or extend (existing objects) with either:
          //
          //   1. An object of properties
          //   2. A key and value
          //


          this.set(owner, key, value); // Since the "set" path can have two possible entry points
          // return the expected data based on which path was taken[*]

          return value !== undefined ? value : key;
        },
        remove: function remove(owner, key) {
          var i,
              cache = owner[this.expando];

          if (cache === undefined) {
            return;
          }

          if (key !== undefined) {
            // Support array or space separated string of keys
            if (Array.isArray(key)) {
              // If key is an array of keys...
              // We always set camelCase keys, so remove that.
              key = key.map(camelCase);
            } else {
              key = camelCase(key); // If a key with the spaces exists, use it.
              // Otherwise, create an array by matching non-whitespace

              key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
            }

            i = key.length;

            while (i--) {
              delete cache[key[i]];
            }
          } // Remove the expando if there's no more data


          if (key === undefined || jQuery.isEmptyObject(cache)) {
            // Support: Chrome <=35 - 45
            // Webkit & Blink performance suffers when deleting properties
            // from DOM nodes, so set to undefined instead
            // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
            if (owner.nodeType) {
              owner[this.expando] = undefined;
            } else {
              delete owner[this.expando];
            }
          }
        },
        hasData: function hasData(owner) {
          var cache = owner[this.expando];
          return cache !== undefined && !jQuery.isEmptyObject(cache);
        }
      };
      var dataPriv = new Data();
      var dataUser = new Data(); //	Implementation Summary
      //
      //	1. Enforce API surface and semantic compatibility with 1.9.x branch
      //	2. Improve the module's maintainability by reducing the storage
      //		paths to a single mechanism.
      //	3. Use the same single mechanism to support "private" and "user" data.
      //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
      //	5. Avoid exposing implementation details on user objects (eg. expando properties)
      //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

      var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
          rmultiDash = /[A-Z]/g;

      function getData(data) {
        if (data === "true") {
          return true;
        }

        if (data === "false") {
          return false;
        }

        if (data === "null") {
          return null;
        } // Only convert to a number if it doesn't change the string


        if (data === +data + "") {
          return +data;
        }

        if (rbrace.test(data)) {
          return JSON.parse(data);
        }

        return data;
      }

      function dataAttr(elem, key, data) {
        var name; // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute

        if (data === undefined && elem.nodeType === 1) {
          name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
          data = elem.getAttribute(name);

          if (typeof data === "string") {
            try {
              data = getData(data);
            } catch (e) {} // Make sure we set the data so it isn't changed later


            dataUser.set(elem, key, data);
          } else {
            data = undefined;
          }
        }

        return data;
      }

      jQuery.extend({
        hasData: function hasData(elem) {
          return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },
        data: function data(elem, name, _data2) {
          return dataUser.access(elem, name, _data2);
        },
        removeData: function removeData(elem, name) {
          dataUser.remove(elem, name);
        },
        // TODO: Now that all calls to _data and _removeData have been replaced
        // with direct calls to dataPriv methods, these can be deprecated.
        _data: function _data(elem, name, data) {
          return dataPriv.access(elem, name, data);
        },
        _removeData: function _removeData(elem, name) {
          dataPriv.remove(elem, name);
        }
      });
      jQuery.fn.extend({
        data: function data(key, value) {
          var i,
              name,
              data,
              elem = this[0],
              attrs = elem && elem.attributes; // Gets all values

          if (key === undefined) {
            if (this.length) {
              data = dataUser.get(elem);

              if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                i = attrs.length;

                while (i--) {
                  // Support: IE 11 only
                  // The attrs elements can be null (#14894)
                  if (attrs[i]) {
                    name = attrs[i].name;

                    if (name.indexOf("data-") === 0) {
                      name = camelCase(name.slice(5));
                      dataAttr(elem, name, data[name]);
                    }
                  }
                }

                dataPriv.set(elem, "hasDataAttrs", true);
              }
            }

            return data;
          } // Sets multiple values


          if (typeof key === "object") {
            return this.each(function () {
              dataUser.set(this, key);
            });
          }

          return access(this, function (value) {
            var data; // The calling jQuery object (element matches) is not empty
            // (and therefore has an element appears at this[ 0 ]) and the
            // `value` parameter was not undefined. An empty jQuery object
            // will result in `undefined` for elem = this[ 0 ] which will
            // throw an exception if an attempt to read a data cache is made.

            if (elem && value === undefined) {
              // Attempt to get data from the cache
              // The key will always be camelCased in Data
              data = dataUser.get(elem, key);

              if (data !== undefined) {
                return data;
              } // Attempt to "discover" the data in
              // HTML5 custom data-* attrs


              data = dataAttr(elem, key);

              if (data !== undefined) {
                return data;
              } // We tried really hard, but the data doesn't exist.


              return;
            } // Set the data...


            this.each(function () {
              // We always store the camelCased key
              dataUser.set(this, key, value);
            });
          }, null, value, arguments.length > 1, null, true);
        },
        removeData: function removeData(key) {
          return this.each(function () {
            dataUser.remove(this, key);
          });
        }
      });
      jQuery.extend({
        queue: function queue(elem, type, data) {
          var queue;

          if (elem) {
            type = (type || "fx") + "queue";
            queue = dataPriv.get(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup

            if (data) {
              if (!queue || Array.isArray(data)) {
                queue = dataPriv.access(elem, type, jQuery.makeArray(data));
              } else {
                queue.push(data);
              }
            }

            return queue || [];
          }
        },
        dequeue: function dequeue(elem, type) {
          type = type || "fx";

          var queue = jQuery.queue(elem, type),
              startLength = queue.length,
              fn = queue.shift(),
              hooks = jQuery._queueHooks(elem, type),
              next = function next() {
            jQuery.dequeue(elem, type);
          }; // If the fx queue is dequeued, always remove the progress sentinel


          if (fn === "inprogress") {
            fn = queue.shift();
            startLength--;
          }

          if (fn) {
            // Add a progress sentinel to prevent the fx queue from being
            // automatically dequeued
            if (type === "fx") {
              queue.unshift("inprogress");
            } // Clear up the last queue stop function


            delete hooks.stop;
            fn.call(elem, next, hooks);
          }

          if (!startLength && hooks) {
            hooks.empty.fire();
          }
        },
        // Not public - generate a queueHooks object, or return the current one
        _queueHooks: function _queueHooks(elem, type) {
          var key = type + "queueHooks";
          return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
            empty: jQuery.Callbacks("once memory").add(function () {
              dataPriv.remove(elem, [type + "queue", key]);
            })
          });
        }
      });
      jQuery.fn.extend({
        queue: function queue(type, data) {
          var setter = 2;

          if (typeof type !== "string") {
            data = type;
            type = "fx";
            setter--;
          }

          if (arguments.length < setter) {
            return jQuery.queue(this[0], type);
          }

          return data === undefined ? this : this.each(function () {
            var queue = jQuery.queue(this, type, data); // Ensure a hooks for this queue

            jQuery._queueHooks(this, type);

            if (type === "fx" && queue[0] !== "inprogress") {
              jQuery.dequeue(this, type);
            }
          });
        },
        dequeue: function dequeue(type) {
          return this.each(function () {
            jQuery.dequeue(this, type);
          });
        },
        clearQueue: function clearQueue(type) {
          return this.queue(type || "fx", []);
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function promise(type, obj) {
          var tmp,
              count = 1,
              defer = jQuery.Deferred(),
              elements = this,
              i = this.length,
              resolve = function resolve() {
            if (! --count) {
              defer.resolveWith(elements, [elements]);
            }
          };

          if (typeof type !== "string") {
            obj = type;
            type = undefined;
          }

          type = type || "fx";

          while (i--) {
            tmp = dataPriv.get(elements[i], type + "queueHooks");

            if (tmp && tmp.empty) {
              count++;
              tmp.empty.add(resolve);
            }
          }

          resolve();
          return defer.promise(obj);
        }
      });
      var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
      var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
      var cssExpand = ["Top", "Right", "Bottom", "Left"];
      var documentElement = document.documentElement;

      var isAttached = function isAttached(elem) {
        return jQuery.contains(elem.ownerDocument, elem);
      },
          composed = {
        composed: true
      }; // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
      // Check attachment across shadow DOM boundaries when possible (gh-3504)
      // Support: iOS 10.0-10.2 only
      // Early iOS 10 versions support `attachShadow` but not `getRootNode`,
      // leading to errors. We need to check for `getRootNode`.


      if (documentElement.getRootNode) {
        isAttached = function isAttached(elem) {
          return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
        };
      }

      var isHiddenWithinTree = function isHiddenWithinTree(elem, el) {
        // isHiddenWithinTree might be called from jQuery#filter function;
        // in that case, element will be second argument
        elem = el || elem; // Inline style trumps all

        return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
        // Support: Firefox <=43 - 45
        // Disconnected elements can have computed display: none, so first confirm that elem is
        // in the document.
        isAttached(elem) && jQuery.css(elem, "display") === "none";
      };

      var swap = function swap(elem, options, callback, args) {
        var ret,
            name,
            old = {}; // Remember the old values, and insert the new ones

        for (name in options) {
          old[name] = elem.style[name];
          elem.style[name] = options[name];
        }

        ret = callback.apply(elem, args || []); // Revert the old values

        for (name in options) {
          elem.style[name] = old[name];
        }

        return ret;
      };

      function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted,
            scale,
            maxIterations = 20,
            currentValue = tween ? function () {
          return tween.cur();
        } : function () {
          return jQuery.css(elem, prop, "");
        },
            initial = currentValue(),
            unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
            // Starting value computation is required for potential unit mismatches
        initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));

        if (initialInUnit && initialInUnit[3] !== unit) {
          // Support: Firefox <=54
          // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
          initial = initial / 2; // Trust units reported by jQuery.css

          unit = unit || initialInUnit[3]; // Iteratively approximate from a nonzero starting point

          initialInUnit = +initial || 1;

          while (maxIterations--) {
            // Evaluate and update our best guess (doubling guesses that zero out).
            // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
            jQuery.style(elem, prop, initialInUnit + unit);

            if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
              maxIterations = 0;
            }

            initialInUnit = initialInUnit / scale;
          }

          initialInUnit = initialInUnit * 2;
          jQuery.style(elem, prop, initialInUnit + unit); // Make sure we update the tween properties later on

          valueParts = valueParts || [];
        }

        if (valueParts) {
          initialInUnit = +initialInUnit || +initial || 0; // Apply relative offset (+=/-=) if specified

          adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];

          if (tween) {
            tween.unit = unit;
            tween.start = initialInUnit;
            tween.end = adjusted;
          }
        }

        return adjusted;
      }

      var defaultDisplayMap = {};

      function getDefaultDisplay(elem) {
        var temp,
            doc = elem.ownerDocument,
            nodeName = elem.nodeName,
            display = defaultDisplayMap[nodeName];

        if (display) {
          return display;
        }

        temp = doc.body.appendChild(doc.createElement(nodeName));
        display = jQuery.css(temp, "display");
        temp.parentNode.removeChild(temp);

        if (display === "none") {
          display = "block";
        }

        defaultDisplayMap[nodeName] = display;
        return display;
      }

      function showHide(elements, show) {
        var display,
            elem,
            values = [],
            index = 0,
            length = elements.length; // Determine new display value for elements that need to change

        for (; index < length; index++) {
          elem = elements[index];

          if (!elem.style) {
            continue;
          }

          display = elem.style.display;

          if (show) {
            // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
            // check is required in this first loop unless we have a nonempty display value (either
            // inline or about-to-be-restored)
            if (display === "none") {
              values[index] = dataPriv.get(elem, "display") || null;

              if (!values[index]) {
                elem.style.display = "";
              }
            }

            if (elem.style.display === "" && isHiddenWithinTree(elem)) {
              values[index] = getDefaultDisplay(elem);
            }
          } else {
            if (display !== "none") {
              values[index] = "none"; // Remember what we're overwriting

              dataPriv.set(elem, "display", display);
            }
          }
        } // Set the display of the elements in a second loop to avoid constant reflow


        for (index = 0; index < length; index++) {
          if (values[index] != null) {
            elements[index].style.display = values[index];
          }
        }

        return elements;
      }

      jQuery.fn.extend({
        show: function show() {
          return showHide(this, true);
        },
        hide: function hide() {
          return showHide(this);
        },
        toggle: function toggle(state) {
          if (typeof state === "boolean") {
            return state ? this.show() : this.hide();
          }

          return this.each(function () {
            if (isHiddenWithinTree(this)) {
              jQuery(this).show();
            } else {
              jQuery(this).hide();
            }
          });
        }
      });
      var rcheckableType = /^(?:checkbox|radio)$/i;
      var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
      var rscriptType = /^$|^module$|\/(?:java|ecma)script/i; // We have to close these tags to support XHTML (#13200)

      var wrapMap = {
        // Support: IE <=9 only
        option: [1, "<select multiple='multiple'>", "</select>"],
        // XHTML parsers do not magically insert elements in the
        // same way that tag soup parsers do. So we cannot shorten
        // this by omitting <tbody> or other required elements.
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: [0, "", ""]
      }; // Support: IE <=9 only

      wrapMap.optgroup = wrapMap.option;
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;

      function getAll(context, tag) {
        // Support: IE <=9 - 11 only
        // Use typeof to avoid zero-argument method invocation on host objects (#15151)
        var ret;

        if (typeof context.getElementsByTagName !== "undefined") {
          ret = context.getElementsByTagName(tag || "*");
        } else if (typeof context.querySelectorAll !== "undefined") {
          ret = context.querySelectorAll(tag || "*");
        } else {
          ret = [];
        }

        if (tag === undefined || tag && nodeName(context, tag)) {
          return jQuery.merge([context], ret);
        }

        return ret;
      } // Mark scripts as having already been evaluated


      function setGlobalEval(elems, refElements) {
        var i = 0,
            l = elems.length;

        for (; i < l; i++) {
          dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
        }
      }

      var rhtml = /<|&#?\w+;/;

      function buildFragment(elems, context, scripts, selection, ignored) {
        var elem,
            tmp,
            tag,
            wrap,
            attached,
            j,
            fragment = context.createDocumentFragment(),
            nodes = [],
            i = 0,
            l = elems.length;

        for (; i < l; i++) {
          elem = elems[i];

          if (elem || elem === 0) {
            // Add nodes directly
            if (toType(elem) === "object") {
              // Support: Android <=4.0 only, PhantomJS 1 only
              // push.apply(_, arraylike) throws on ancient WebKit
              jQuery.merge(nodes, elem.nodeType ? [elem] : elem); // Convert non-html into a text node
            } else if (!rhtml.test(elem)) {
              nodes.push(context.createTextNode(elem)); // Convert html into DOM nodes
            } else {
              tmp = tmp || fragment.appendChild(context.createElement("div")); // Deserialize a standard representation

              tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
              wrap = wrapMap[tag] || wrapMap._default;
              tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]; // Descend through wrappers to the right content

              j = wrap[0];

              while (j--) {
                tmp = tmp.lastChild;
              } // Support: Android <=4.0 only, PhantomJS 1 only
              // push.apply(_, arraylike) throws on ancient WebKit


              jQuery.merge(nodes, tmp.childNodes); // Remember the top-level container

              tmp = fragment.firstChild; // Ensure the created nodes are orphaned (#12392)

              tmp.textContent = "";
            }
          }
        } // Remove wrapper from fragment


        fragment.textContent = "";
        i = 0;

        while (elem = nodes[i++]) {
          // Skip elements already in the context collection (trac-4087)
          if (selection && jQuery.inArray(elem, selection) > -1) {
            if (ignored) {
              ignored.push(elem);
            }

            continue;
          }

          attached = isAttached(elem); // Append to fragment

          tmp = getAll(fragment.appendChild(elem), "script"); // Preserve script evaluation history

          if (attached) {
            setGlobalEval(tmp);
          } // Capture executables


          if (scripts) {
            j = 0;

            while (elem = tmp[j++]) {
              if (rscriptType.test(elem.type || "")) {
                scripts.push(elem);
              }
            }
          }
        }

        return fragment;
      }

      (function () {
        var fragment = document.createDocumentFragment(),
            div = fragment.appendChild(document.createElement("div")),
            input = document.createElement("input"); // Support: Android 4.0 - 4.3 only
        // Check state lost if the name is set (#11217)
        // Support: Windows Web Apps (WWA)
        // `name` and `type` must use .setAttribute for WWA (#14901)

        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");
        div.appendChild(input); // Support: Android <=4.1 only
        // Older WebKit doesn't clone checked state correctly in fragments

        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked; // Support: IE <=11 only
        // Make sure textarea (and checkbox) defaultValue is properly cloned

        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
      })();

      var rkeyEvent = /^key/,
          rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
          rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

      function returnTrue() {
        return true;
      }

      function returnFalse() {
        return false;
      } // Support: IE <=9 - 11+
      // focus() and blur() are asynchronous, except when they are no-op.
      // So expect focus to be synchronous when the element is already active,
      // and blur to be synchronous when the element is not already active.
      // (focus and blur are always synchronous in other supported browsers,
      // this just defines when we can count on it).


      function expectSync(elem, type) {
        return elem === safeActiveElement() === (type === "focus");
      } // Support: IE <=9 only
      // Accessing document.activeElement can throw unexpectedly
      // https://bugs.jquery.com/ticket/13393


      function safeActiveElement() {
        try {
          return document.activeElement;
        } catch (err) {}
      }

      function _on(elem, types, selector, data, fn, one) {
        var origFn, type; // Types can be a map of types/handlers

        if (typeof types === "object") {
          // ( types-Object, selector, data )
          if (typeof selector !== "string") {
            // ( types-Object, data )
            data = data || selector;
            selector = undefined;
          }

          for (type in types) {
            _on(elem, type, selector, data, types[type], one);
          }

          return elem;
        }

        if (data == null && fn == null) {
          // ( types, fn )
          fn = selector;
          data = selector = undefined;
        } else if (fn == null) {
          if (typeof selector === "string") {
            // ( types, selector, fn )
            fn = data;
            data = undefined;
          } else {
            // ( types, data, fn )
            fn = data;
            data = selector;
            selector = undefined;
          }
        }

        if (fn === false) {
          fn = returnFalse;
        } else if (!fn) {
          return elem;
        }

        if (one === 1) {
          origFn = fn;

          fn = function fn(event) {
            // Can use an empty set, since event contains the info
            jQuery().off(event);
            return origFn.apply(this, arguments);
          }; // Use same guid so caller can remove using origFn


          fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
        }

        return elem.each(function () {
          jQuery.event.add(this, types, fn, data, selector);
        });
      }
      /*
       * Helper functions for managing events -- not part of the public interface.
       * Props to Dean Edwards' addEvent library for many of the ideas.
       */


      jQuery.event = {
        global: {},
        add: function add(elem, types, handler, data, selector) {
          var handleObjIn,
              eventHandle,
              tmp,
              events,
              t,
              handleObj,
              special,
              handlers,
              type,
              namespaces,
              origType,
              elemData = dataPriv.get(elem); // Don't attach events to noData or text/comment nodes (but allow plain objects)

          if (!elemData) {
            return;
          } // Caller can pass in an object of custom data in lieu of the handler


          if (handler.handler) {
            handleObjIn = handler;
            handler = handleObjIn.handler;
            selector = handleObjIn.selector;
          } // Ensure that invalid selectors throw exceptions at attach time
          // Evaluate against documentElement in case elem is a non-element node (e.g., document)


          if (selector) {
            jQuery.find.matchesSelector(documentElement, selector);
          } // Make sure that the handler has a unique ID, used to find/remove it later


          if (!handler.guid) {
            handler.guid = jQuery.guid++;
          } // Init the element's event structure and main handler, if this is the first


          if (!(events = elemData.events)) {
            events = elemData.events = {};
          }

          if (!(eventHandle = elemData.handle)) {
            eventHandle = elemData.handle = function (e) {
              // Discard the second event of a jQuery.event.trigger() and
              // when an event is called after a page has unloaded
              return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
            };
          } // Handle multiple events separated by a space


          types = (types || "").match(rnothtmlwhite) || [""];
          t = types.length;

          while (t--) {
            tmp = rtypenamespace.exec(types[t]) || [];
            type = origType = tmp[1];
            namespaces = (tmp[2] || "").split(".").sort(); // There *must* be a type, no attaching namespace-only handlers

            if (!type) {
              continue;
            } // If event changes its type, use the special event handlers for the changed type


            special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type

            type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type

            special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers

            handleObj = jQuery.extend({
              type: type,
              origType: origType,
              data: data,
              handler: handler,
              guid: handler.guid,
              selector: selector,
              needsContext: selector && jQuery.expr.match.needsContext.test(selector),
              namespace: namespaces.join(".")
            }, handleObjIn); // Init the event handler queue if we're the first

            if (!(handlers = events[type])) {
              handlers = events[type] = [];
              handlers.delegateCount = 0; // Only use addEventListener if the special events handler returns false

              if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                if (elem.addEventListener) {
                  elem.addEventListener(type, eventHandle);
                }
              }
            }

            if (special.add) {
              special.add.call(elem, handleObj);

              if (!handleObj.handler.guid) {
                handleObj.handler.guid = handler.guid;
              }
            } // Add to the element's handler list, delegates in front


            if (selector) {
              handlers.splice(handlers.delegateCount++, 0, handleObj);
            } else {
              handlers.push(handleObj);
            } // Keep track of which events have ever been used, for event optimization


            jQuery.event.global[type] = true;
          }
        },
        // Detach an event or set of events from an element
        remove: function remove(elem, types, handler, selector, mappedTypes) {
          var j,
              origCount,
              tmp,
              events,
              t,
              handleObj,
              special,
              handlers,
              type,
              namespaces,
              origType,
              elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

          if (!elemData || !(events = elemData.events)) {
            return;
          } // Once for each type.namespace in types; type may be omitted


          types = (types || "").match(rnothtmlwhite) || [""];
          t = types.length;

          while (t--) {
            tmp = rtypenamespace.exec(types[t]) || [];
            type = origType = tmp[1];
            namespaces = (tmp[2] || "").split(".").sort(); // Unbind all events (on this namespace, if provided) for the element

            if (!type) {
              for (type in events) {
                jQuery.event.remove(elem, type + types[t], handler, selector, true);
              }

              continue;
            }

            special = jQuery.event.special[type] || {};
            type = (selector ? special.delegateType : special.bindType) || type;
            handlers = events[type] || [];
            tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"); // Remove matching events

            origCount = j = handlers.length;

            while (j--) {
              handleObj = handlers[j];

              if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                handlers.splice(j, 1);

                if (handleObj.selector) {
                  handlers.delegateCount--;
                }

                if (special.remove) {
                  special.remove.call(elem, handleObj);
                }
              }
            } // Remove generic event handler if we removed something and no more handlers exist
            // (avoids potential for endless recursion during removal of special event handlers)


            if (origCount && !handlers.length) {
              if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                jQuery.removeEvent(elem, type, elemData.handle);
              }

              delete events[type];
            }
          } // Remove data and the expando if it's no longer used


          if (jQuery.isEmptyObject(events)) {
            dataPriv.remove(elem, "handle events");
          }
        },
        dispatch: function dispatch(nativeEvent) {
          // Make a writable jQuery.Event from the native event object
          var event = jQuery.event.fix(nativeEvent);
          var i,
              j,
              ret,
              matched,
              handleObj,
              handlerQueue,
              args = new Array(arguments.length),
              handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
              special = jQuery.event.special[event.type] || {}; // Use the fix-ed jQuery.Event rather than the (read-only) native event

          args[0] = event;

          for (i = 1; i < arguments.length; i++) {
            args[i] = arguments[i];
          }

          event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired

          if (special.preDispatch && special.preDispatch.call(this, event) === false) {
            return;
          } // Determine handlers


          handlerQueue = jQuery.event.handlers.call(this, event, handlers); // Run delegates first; they may want to stop propagation beneath us

          i = 0;

          while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
            event.currentTarget = matched.elem;
            j = 0;

            while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
              // If the event is namespaced, then each handler is only invoked if it is
              // specially universal or its namespaces are a superset of the event's.
              if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
                event.handleObj = handleObj;
                event.data = handleObj.data;
                ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

                if (ret !== undefined) {
                  if ((event.result = ret) === false) {
                    event.preventDefault();
                    event.stopPropagation();
                  }
                }
              }
            }
          } // Call the postDispatch hook for the mapped type


          if (special.postDispatch) {
            special.postDispatch.call(this, event);
          }

          return event.result;
        },
        handlers: function handlers(event, _handlers) {
          var i,
              handleObj,
              sel,
              matchedHandlers,
              matchedSelectors,
              handlerQueue = [],
              delegateCount = _handlers.delegateCount,
              cur = event.target; // Find delegate handlers

          if (delegateCount && // Support: IE <=9
          // Black-hole SVG <use> instance trees (trac-13180)
          cur.nodeType && // Support: Firefox <=42
          // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
          // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
          // Support: IE 11 only
          // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
          !(event.type === "click" && event.button >= 1)) {
            for (; cur !== this; cur = cur.parentNode || this) {
              // Don't check non-elements (#13208)
              // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
              if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                matchedHandlers = [];
                matchedSelectors = {};

                for (i = 0; i < delegateCount; i++) {
                  handleObj = _handlers[i]; // Don't conflict with Object.prototype properties (#13203)

                  sel = handleObj.selector + " ";

                  if (matchedSelectors[sel] === undefined) {
                    matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                  }

                  if (matchedSelectors[sel]) {
                    matchedHandlers.push(handleObj);
                  }
                }

                if (matchedHandlers.length) {
                  handlerQueue.push({
                    elem: cur,
                    handlers: matchedHandlers
                  });
                }
              }
            }
          } // Add the remaining (directly-bound) handlers


          cur = this;

          if (delegateCount < _handlers.length) {
            handlerQueue.push({
              elem: cur,
              handlers: _handlers.slice(delegateCount)
            });
          }

          return handlerQueue;
        },
        addProp: function addProp(name, hook) {
          Object.defineProperty(jQuery.Event.prototype, name, {
            enumerable: true,
            configurable: true,
            get: isFunction(hook) ? function () {
              if (this.originalEvent) {
                return hook(this.originalEvent);
              }
            } : function () {
              if (this.originalEvent) {
                return this.originalEvent[name];
              }
            },
            set: function set(value) {
              Object.defineProperty(this, name, {
                enumerable: true,
                configurable: true,
                writable: true,
                value: value
              });
            }
          });
        },
        fix: function fix(originalEvent) {
          return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
        },
        special: {
          load: {
            // Prevent triggered image.load events from bubbling to window.load
            noBubble: true
          },
          click: {
            // Utilize native event to ensure correct state for checkable inputs
            setup: function setup(data) {
              // For mutual compressibility with _default, replace `this` access with a local var.
              // `|| data` is dead code meant only to preserve the variable through minification.
              var el = this || data; // Claim the first handler

              if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                // dataPriv.set( el, "click", ... )
                leverageNative(el, "click", returnTrue);
              } // Return false to allow normal processing in the caller


              return false;
            },
            trigger: function trigger(data) {
              // For mutual compressibility with _default, replace `this` access with a local var.
              // `|| data` is dead code meant only to preserve the variable through minification.
              var el = this || data; // Force setup before triggering a click

              if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                leverageNative(el, "click");
              } // Return non-false to allow normal event-path propagation


              return true;
            },
            // For cross-browser consistency, suppress native .click() on links
            // Also prevent it if we're currently inside a leveraged native-event stack
            _default: function _default(event) {
              var target = event.target;
              return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
            }
          },
          beforeunload: {
            postDispatch: function postDispatch(event) {
              // Support: Firefox 20+
              // Firefox doesn't alert if the returnValue field is not set.
              if (event.result !== undefined && event.originalEvent) {
                event.originalEvent.returnValue = event.result;
              }
            }
          }
        }
      }; // Ensure the presence of an event listener that handles manually-triggered
      // synthetic events by interrupting progress until reinvoked in response to
      // *native* events that it fires directly, ensuring that state changes have
      // already occurred before other listeners are invoked.

      function leverageNative(el, type, expectSync) {
        // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
        if (!expectSync) {
          if (dataPriv.get(el, type) === undefined) {
            jQuery.event.add(el, type, returnTrue);
          }

          return;
        } // Register the controller as a special universal handler for all event namespaces


        dataPriv.set(el, type, false);
        jQuery.event.add(el, type, {
          namespace: false,
          handler: function handler(event) {
            var notAsync,
                result,
                saved = dataPriv.get(this, type);

            if (event.isTrigger & 1 && this[type]) {
              // Interrupt processing of the outer synthetic .trigger()ed event
              // Saved data should be false in such cases, but might be a leftover capture object
              // from an async native handler (gh-4350)
              if (!saved.length) {
                // Store arguments for use when handling the inner native event
                // There will always be at least one argument (an event object), so this array
                // will not be confused with a leftover capture object.
                saved = _slice.call(arguments);
                dataPriv.set(this, type, saved); // Trigger the native event and capture its result
                // Support: IE <=9 - 11+
                // focus() and blur() are asynchronous

                notAsync = expectSync(this, type);
                this[type]();
                result = dataPriv.get(this, type);

                if (saved !== result || notAsync) {
                  dataPriv.set(this, type, false);
                } else {
                  result = {};
                }

                if (saved !== result) {
                  // Cancel the outer synthetic event
                  event.stopImmediatePropagation();
                  event.preventDefault();
                  return result.value;
                } // If this is an inner synthetic event for an event with a bubbling surrogate
                // (focus or blur), assume that the surrogate already propagated from triggering the
                // native event and prevent that from happening again here.
                // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
                // bubbling surrogate propagates *after* the non-bubbling base), but that seems
                // less bad than duplication.

              } else if ((jQuery.event.special[type] || {}).delegateType) {
                event.stopPropagation();
              } // If this is a native event triggered above, everything is now in order
              // Fire an inner synthetic event with the original arguments

            } else if (saved.length) {
              // ...and capture the result
              dataPriv.set(this, type, {
                value: jQuery.event.trigger( // Support: IE <=9 - 11+
                // Extend with the prototype to reset the above stopImmediatePropagation()
                jQuery.extend(saved[0], jQuery.Event.prototype), saved.slice(1), this)
              }); // Abort handling of the native event

              event.stopImmediatePropagation();
            }
          }
        });
      }

      jQuery.removeEvent = function (elem, type, handle) {
        // This "if" is needed for plain objects
        if (elem.removeEventListener) {
          elem.removeEventListener(type, handle);
        }
      };

      jQuery.Event = function (src, props) {
        // Allow instantiation without the 'new' keyword
        if (!(this instanceof jQuery.Event)) {
          return new jQuery.Event(src, props);
        } // Event object


        if (src && src.type) {
          this.originalEvent = src;
          this.type = src.type; // Events bubbling up the document may have been marked as prevented
          // by a handler lower down the tree; reflect the correct value.

          this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only
          src.returnValue === false ? returnTrue : returnFalse; // Create target properties
          // Support: Safari <=6 - 7 only
          // Target should not be a text node (#504, #13143)

          this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
          this.currentTarget = src.currentTarget;
          this.relatedTarget = src.relatedTarget; // Event type
        } else {
          this.type = src;
        } // Put explicitly provided properties onto the event object


        if (props) {
          jQuery.extend(this, props);
        } // Create a timestamp if incoming event doesn't have one


        this.timeStamp = src && src.timeStamp || Date.now(); // Mark it as fixed

        this[jQuery.expando] = true;
      }; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
      // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html


      jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,
        preventDefault: function preventDefault() {
          var e = this.originalEvent;
          this.isDefaultPrevented = returnTrue;

          if (e && !this.isSimulated) {
            e.preventDefault();
          }
        },
        stopPropagation: function stopPropagation() {
          var e = this.originalEvent;
          this.isPropagationStopped = returnTrue;

          if (e && !this.isSimulated) {
            e.stopPropagation();
          }
        },
        stopImmediatePropagation: function stopImmediatePropagation() {
          var e = this.originalEvent;
          this.isImmediatePropagationStopped = returnTrue;

          if (e && !this.isSimulated) {
            e.stopImmediatePropagation();
          }

          this.stopPropagation();
        }
      }; // Includes all common event props including KeyEvent and MouseEvent specific props

      jQuery.each({
        altKey: true,
        bubbles: true,
        cancelable: true,
        changedTouches: true,
        ctrlKey: true,
        detail: true,
        eventPhase: true,
        metaKey: true,
        pageX: true,
        pageY: true,
        shiftKey: true,
        view: true,
        "char": true,
        code: true,
        charCode: true,
        key: true,
        keyCode: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pointerId: true,
        pointerType: true,
        screenX: true,
        screenY: true,
        targetTouches: true,
        toElement: true,
        touches: true,
        which: function which(event) {
          var button = event.button; // Add which for key events

          if (event.which == null && rkeyEvent.test(event.type)) {
            return event.charCode != null ? event.charCode : event.keyCode;
          } // Add which for click: 1 === left; 2 === middle; 3 === right


          if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
            if (button & 1) {
              return 1;
            }

            if (button & 2) {
              return 3;
            }

            if (button & 4) {
              return 2;
            }

            return 0;
          }

          return event.which;
        }
      }, jQuery.event.addProp);
      jQuery.each({
        focus: "focusin",
        blur: "focusout"
      }, function (type, delegateType) {
        jQuery.event.special[type] = {
          // Utilize native event if possible so blur/focus sequence is correct
          setup: function setup() {
            // Claim the first handler
            // dataPriv.set( this, "focus", ... )
            // dataPriv.set( this, "blur", ... )
            leverageNative(this, type, expectSync); // Return false to allow normal processing in the caller

            return false;
          },
          trigger: function trigger() {
            // Force setup before trigger
            leverageNative(this, type); // Return non-false to allow normal event-path propagation

            return true;
          },
          delegateType: delegateType
        };
      }); // Create mouseenter/leave events using mouseover/out and event-time checks
      // so that event delegation works in jQuery.
      // Do the same for pointerenter/pointerleave and pointerover/pointerout
      //
      // Support: Safari 7 only
      // Safari sends mouseenter too often; see:
      // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
      // for the description of the bug (it existed in older Chrome versions as well).

      jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
      }, function (orig, fix) {
        jQuery.event.special[orig] = {
          delegateType: fix,
          bindType: fix,
          handle: function handle(event) {
            var ret,
                target = this,
                related = event.relatedTarget,
                handleObj = event.handleObj; // For mouseenter/leave call the handler if related is outside the target.
            // NB: No relatedTarget if the mouse left/entered the browser window

            if (!related || related !== target && !jQuery.contains(target, related)) {
              event.type = handleObj.origType;
              ret = handleObj.handler.apply(this, arguments);
              event.type = fix;
            }

            return ret;
          }
        };
      });
      jQuery.fn.extend({
        on: function on(types, selector, data, fn) {
          return _on(this, types, selector, data, fn);
        },
        one: function one(types, selector, data, fn) {
          return _on(this, types, selector, data, fn, 1);
        },
        off: function off(types, selector, fn) {
          var handleObj, type;

          if (types && types.preventDefault && types.handleObj) {
            // ( event )  dispatched jQuery.Event
            handleObj = types.handleObj;
            jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
            return this;
          }

          if (typeof types === "object") {
            // ( types-object [, selector] )
            for (type in types) {
              this.off(type, selector, types[type]);
            }

            return this;
          }

          if (selector === false || typeof selector === "function") {
            // ( types [, fn] )
            fn = selector;
            selector = undefined;
          }

          if (fn === false) {
            fn = returnFalse;
          }

          return this.each(function () {
            jQuery.event.remove(this, types, fn, selector);
          });
        }
      });
      var
      /* eslint-disable max-len */
      // See https://github.com/eslint/eslint/issues/3229
      rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

      /* eslint-enable */
      // Support: IE <=10 - 11, Edge 12 - 13 only
      // In IE/Edge using regex groups here causes severe slowdowns.
      // See https://connect.microsoft.com/IE/feedback/details/1736512/
      rnoInnerhtml = /<script|<style|<link/i,
          // checked="checked" or checked
      rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
          rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g; // Prefer a tbody over its parent table for containing new rows

      function manipulationTarget(elem, content) {
        if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
          return jQuery(elem).children("tbody")[0] || elem;
        }

        return elem;
      } // Replace/restore the type attribute of script elements for safe DOM manipulation


      function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
      }

      function restoreScript(elem) {
        if ((elem.type || "").slice(0, 5) === "true/") {
          elem.type = elem.type.slice(5);
        } else {
          elem.removeAttribute("type");
        }

        return elem;
      }

      function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

        if (dest.nodeType !== 1) {
          return;
        } // 1. Copy private data: events, handlers, etc.


        if (dataPriv.hasData(src)) {
          pdataOld = dataPriv.access(src);
          pdataCur = dataPriv.set(dest, pdataOld);
          events = pdataOld.events;

          if (events) {
            delete pdataCur.handle;
            pdataCur.events = {};

            for (type in events) {
              for (i = 0, l = events[type].length; i < l; i++) {
                jQuery.event.add(dest, type, events[type][i]);
              }
            }
          }
        } // 2. Copy user data


        if (dataUser.hasData(src)) {
          udataOld = dataUser.access(src);
          udataCur = jQuery.extend({}, udataOld);
          dataUser.set(dest, udataCur);
        }
      } // Fix IE bugs, see support tests


      function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase(); // Fails to persist the checked state of a cloned checkbox or radio button.

        if (nodeName === "input" && rcheckableType.test(src.type)) {
          dest.checked = src.checked; // Fails to return the selected option to the default selected state when cloning options
        } else if (nodeName === "input" || nodeName === "textarea") {
          dest.defaultValue = src.defaultValue;
        }
      }

      function domManip(collection, args, callback, ignored) {
        // Flatten any nested arrays
        args = concat.apply([], args);
        var fragment,
            first,
            scripts,
            hasScripts,
            node,
            doc,
            i = 0,
            l = collection.length,
            iNoClone = l - 1,
            value = args[0],
            valueIsFunction = isFunction(value); // We can't cloneNode fragments that contain checked, in WebKit

        if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
          return collection.each(function (index) {
            var self = collection.eq(index);

            if (valueIsFunction) {
              args[0] = value.call(this, index, self.html());
            }

            domManip(self, args, callback, ignored);
          });
        }

        if (l) {
          fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
          first = fragment.firstChild;

          if (fragment.childNodes.length === 1) {
            fragment = first;
          } // Require either new content or an interest in ignored elements to invoke the callback


          if (first || ignored) {
            scripts = jQuery.map(getAll(fragment, "script"), disableScript);
            hasScripts = scripts.length; // Use the original fragment for the last item
            // instead of the first because it can end up
            // being emptied incorrectly in certain situations (#8070).

            for (; i < l; i++) {
              node = fragment;

              if (i !== iNoClone) {
                node = jQuery.clone(node, true, true); // Keep references to cloned scripts for later restoration

                if (hasScripts) {
                  // Support: Android <=4.0 only, PhantomJS 1 only
                  // push.apply(_, arraylike) throws on ancient WebKit
                  jQuery.merge(scripts, getAll(node, "script"));
                }
              }

              callback.call(collection[i], node, i);
            }

            if (hasScripts) {
              doc = scripts[scripts.length - 1].ownerDocument; // Reenable scripts

              jQuery.map(scripts, restoreScript); // Evaluate executable scripts on first document insertion

              for (i = 0; i < hasScripts; i++) {
                node = scripts[i];

                if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                  if (node.src && (node.type || "").toLowerCase() !== "module") {
                    // Optional AJAX dependency, but won't run scripts if not present
                    if (jQuery._evalUrl && !node.noModule) {
                      jQuery._evalUrl(node.src, {
                        nonce: node.nonce || node.getAttribute("nonce")
                      });
                    }
                  } else {
                    DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                  }
                }
              }
            }
          }
        }

        return collection;
      }

      function _remove(elem, selector, keepData) {
        var node,
            nodes = selector ? jQuery.filter(selector, elem) : elem,
            i = 0;

        for (; (node = nodes[i]) != null; i++) {
          if (!keepData && node.nodeType === 1) {
            jQuery.cleanData(getAll(node));
          }

          if (node.parentNode) {
            if (keepData && isAttached(node)) {
              setGlobalEval(getAll(node, "script"));
            }

            node.parentNode.removeChild(node);
          }
        }

        return elem;
      }

      jQuery.extend({
        htmlPrefilter: function htmlPrefilter(html) {
          return html.replace(rxhtmlTag, "<$1></$2>");
        },
        clone: function clone(elem, dataAndEvents, deepDataAndEvents) {
          var i,
              l,
              srcElements,
              destElements,
              clone = elem.cloneNode(true),
              inPage = isAttached(elem); // Fix IE cloning issues

          if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
            // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
            destElements = getAll(clone);
            srcElements = getAll(elem);

            for (i = 0, l = srcElements.length; i < l; i++) {
              fixInput(srcElements[i], destElements[i]);
            }
          } // Copy the events from the original to the clone


          if (dataAndEvents) {
            if (deepDataAndEvents) {
              srcElements = srcElements || getAll(elem);
              destElements = destElements || getAll(clone);

              for (i = 0, l = srcElements.length; i < l; i++) {
                cloneCopyEvent(srcElements[i], destElements[i]);
              }
            } else {
              cloneCopyEvent(elem, clone);
            }
          } // Preserve script evaluation history


          destElements = getAll(clone, "script");

          if (destElements.length > 0) {
            setGlobalEval(destElements, !inPage && getAll(elem, "script"));
          } // Return the cloned set


          return clone;
        },
        cleanData: function cleanData(elems) {
          var data,
              elem,
              type,
              special = jQuery.event.special,
              i = 0;

          for (; (elem = elems[i]) !== undefined; i++) {
            if (acceptData(elem)) {
              if (data = elem[dataPriv.expando]) {
                if (data.events) {
                  for (type in data.events) {
                    if (special[type]) {
                      jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead
                    } else {
                      jQuery.removeEvent(elem, type, data.handle);
                    }
                  }
                } // Support: Chrome <=35 - 45+
                // Assign undefined instead of using delete, see Data#remove


                elem[dataPriv.expando] = undefined;
              }

              if (elem[dataUser.expando]) {
                // Support: Chrome <=35 - 45+
                // Assign undefined instead of using delete, see Data#remove
                elem[dataUser.expando] = undefined;
              }
            }
          }
        }
      });
      jQuery.fn.extend({
        detach: function detach(selector) {
          return _remove(this, selector, true);
        },
        remove: function remove(selector) {
          return _remove(this, selector);
        },
        text: function text(value) {
          return access(this, function (value) {
            return value === undefined ? jQuery.text(this) : this.empty().each(function () {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                this.textContent = value;
              }
            });
          }, null, value, arguments.length);
        },
        append: function append() {
          return domManip(this, arguments, function (elem) {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              var target = manipulationTarget(this, elem);
              target.appendChild(elem);
            }
          });
        },
        prepend: function prepend() {
          return domManip(this, arguments, function (elem) {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              var target = manipulationTarget(this, elem);
              target.insertBefore(elem, target.firstChild);
            }
          });
        },
        before: function before() {
          return domManip(this, arguments, function (elem) {
            if (this.parentNode) {
              this.parentNode.insertBefore(elem, this);
            }
          });
        },
        after: function after() {
          return domManip(this, arguments, function (elem) {
            if (this.parentNode) {
              this.parentNode.insertBefore(elem, this.nextSibling);
            }
          });
        },
        empty: function empty() {
          var elem,
              i = 0;

          for (; (elem = this[i]) != null; i++) {
            if (elem.nodeType === 1) {
              // Prevent memory leaks
              jQuery.cleanData(getAll(elem, false)); // Remove any remaining nodes

              elem.textContent = "";
            }
          }

          return this;
        },
        clone: function clone(dataAndEvents, deepDataAndEvents) {
          dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
          deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
          return this.map(function () {
            return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
          });
        },
        html: function html(value) {
          return access(this, function (value) {
            var elem = this[0] || {},
                i = 0,
                l = this.length;

            if (value === undefined && elem.nodeType === 1) {
              return elem.innerHTML;
            } // See if we can take a shortcut and just use innerHTML


            if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
              value = jQuery.htmlPrefilter(value);

              try {
                for (; i < l; i++) {
                  elem = this[i] || {}; // Remove element nodes and prevent memory leaks

                  if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                    elem.innerHTML = value;
                  }
                }

                elem = 0; // If using innerHTML throws an exception, use the fallback method
              } catch (e) {}
            }

            if (elem) {
              this.empty().append(value);
            }
          }, null, value, arguments.length);
        },
        replaceWith: function replaceWith() {
          var ignored = []; // Make the changes, replacing each non-ignored context element with the new content

          return domManip(this, arguments, function (elem) {
            var parent = this.parentNode;

            if (jQuery.inArray(this, ignored) < 0) {
              jQuery.cleanData(getAll(this));

              if (parent) {
                parent.replaceChild(elem, this);
              }
            } // Force callback invocation

          }, ignored);
        }
      });
      jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
      }, function (name, original) {
        jQuery.fn[name] = function (selector) {
          var elems,
              ret = [],
              insert = jQuery(selector),
              last = insert.length - 1,
              i = 0;

          for (; i <= last; i++) {
            elems = i === last ? this : this.clone(true);
            jQuery(insert[i])[original](elems); // Support: Android <=4.0 only, PhantomJS 1 only
            // .get() because push.apply(_, arraylike) throws on ancient WebKit

            push.apply(ret, elems.get());
          }

          return this.pushStack(ret);
        };
      });
      var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

      var getStyles = function getStyles(elem) {
        // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
        // IE throws on elements created in popups
        // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
        var view = elem.ownerDocument.defaultView;

        if (!view || !view.opener) {
          view = window;
        }

        return view.getComputedStyle(elem);
      };

      var rboxStyle = new RegExp(cssExpand.join("|"), "i");

      (function () {
        // Executing both pixelPosition & boxSizingReliable tests require only one layout
        // so they're executed at the same time to save the second computation.
        function computeStyleTests() {
          // This is a singleton, we need to execute it only once
          if (!div) {
            return;
          }

          container.style.cssText = "position:absolute;left:-11111px;width:60px;" + "margin-top:1px;padding:0;border:0";
          div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;" + "margin:auto;border:1px;padding:1px;" + "width:60%;top:1%";
          documentElement.appendChild(container).appendChild(div);
          var divStyle = window.getComputedStyle(div);
          pixelPositionVal = divStyle.top !== "1%"; // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44

          reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12; // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
          // Some styles come back with percentage values, even though they shouldn't

          div.style.right = "60%";
          pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36; // Support: IE 9 - 11 only
          // Detect misreporting of content dimensions for box-sizing:border-box elements

          boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36; // Support: IE 9 only
          // Detect overflow:scroll screwiness (gh-3699)
          // Support: Chrome <=64
          // Don't get tricked when zoom affects offsetWidth (gh-4029)

          div.style.position = "absolute";
          scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
          documentElement.removeChild(container); // Nullify the div so it wouldn't be stored in the memory and
          // it will also be a sign that checks already performed

          div = null;
        }

        function roundPixelMeasures(measure) {
          return Math.round(parseFloat(measure));
        }

        var pixelPositionVal,
            boxSizingReliableVal,
            scrollboxSizeVal,
            pixelBoxStylesVal,
            reliableMarginLeftVal,
            container = document.createElement("div"),
            div = document.createElement("div"); // Finish early in limited (non-browser) environments

        if (!div.style) {
          return;
        } // Support: IE <=9 - 11 only
        // Style of cloned element affects source element cloned (#8908)


        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";
        jQuery.extend(support, {
          boxSizingReliable: function boxSizingReliable() {
            computeStyleTests();
            return boxSizingReliableVal;
          },
          pixelBoxStyles: function pixelBoxStyles() {
            computeStyleTests();
            return pixelBoxStylesVal;
          },
          pixelPosition: function pixelPosition() {
            computeStyleTests();
            return pixelPositionVal;
          },
          reliableMarginLeft: function reliableMarginLeft() {
            computeStyleTests();
            return reliableMarginLeftVal;
          },
          scrollboxSize: function scrollboxSize() {
            computeStyleTests();
            return scrollboxSizeVal;
          }
        });
      })();

      function curCSS(elem, name, computed) {
        var width,
            minWidth,
            maxWidth,
            ret,
            // Support: Firefox 51+
        // Retrieving style before computed somehow
        // fixes an issue with getting wrong values
        // on detached elements
        style = elem.style;
        computed = computed || getStyles(elem); // getPropertyValue is needed for:
        //   .css('filter') (IE 9 only, #12537)
        //   .css('--customProperty) (#3144)

        if (computed) {
          ret = computed.getPropertyValue(name) || computed[name];

          if (ret === "" && !isAttached(elem)) {
            ret = jQuery.style(elem, name);
          } // A tribute to the "awesome hack by Dean Edwards"
          // Android Browser returns percentage for some values,
          // but width seems to be reliably pixels.
          // This is against the CSSOM draft spec:
          // https://drafts.csswg.org/cssom/#resolved-values


          if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
            // Remember the original values
            width = style.width;
            minWidth = style.minWidth;
            maxWidth = style.maxWidth; // Put in the new values to get a computed value out

            style.minWidth = style.maxWidth = style.width = ret;
            ret = computed.width; // Revert the changed values

            style.width = width;
            style.minWidth = minWidth;
            style.maxWidth = maxWidth;
          }
        }

        return ret !== undefined ? // Support: IE <=9 - 11 only
        // IE returns zIndex value as an integer.
        ret + "" : ret;
      }

      function addGetHookIf(conditionFn, hookFn) {
        // Define the hook, we'll check on the first run if it's really needed.
        return {
          get: function get() {
            if (conditionFn()) {
              // Hook not needed (or it's not possible to use it due
              // to missing dependency), remove it.
              delete this.get;
              return;
            } // Hook needed; redefine it so that the support test is not executed again.


            return (this.get = hookFn).apply(this, arguments);
          }
        };
      }

      var cssPrefixes = ["Webkit", "Moz", "ms"],
          emptyStyle = document.createElement("div").style,
          vendorProps = {}; // Return a vendor-prefixed property or undefined

      function vendorPropName(name) {
        // Check for vendor prefixed names
        var capName = name[0].toUpperCase() + name.slice(1),
            i = cssPrefixes.length;

        while (i--) {
          name = cssPrefixes[i] + capName;

          if (name in emptyStyle) {
            return name;
          }
        }
      } // Return a potentially-mapped jQuery.cssProps or vendor prefixed property


      function finalPropName(name) {
        var final = jQuery.cssProps[name] || vendorProps[name];

        if (final) {
          return final;
        }

        if (name in emptyStyle) {
          return name;
        }

        return vendorProps[name] = vendorPropName(name) || name;
      }

      var // Swappable if display is none or starts with table
      // except "table", "table-cell", or "table-caption"
      // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
      rdisplayswap = /^(none|table(?!-c[ea]).+)/,
          rcustomProp = /^--/,
          cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
      },
          cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
      };

      function setPositiveNumber(elem, value, subtract) {
        // Any relative (+/-) values have already been
        // normalized at this point
        var matches = rcssNum.exec(value);
        return matches ? // Guard against undefined "subtract", e.g., when used as in cssHooks
        Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
      }

      function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
        var i = dimension === "width" ? 1 : 0,
            extra = 0,
            delta = 0; // Adjustment may not be necessary

        if (box === (isBorderBox ? "border" : "content")) {
          return 0;
        }

        for (; i < 4; i += 2) {
          // Both box models exclude margin
          if (box === "margin") {
            delta += jQuery.css(elem, box + cssExpand[i], true, styles);
          } // If we get here with a content-box, we're seeking "padding" or "border" or "margin"


          if (!isBorderBox) {
            // Add padding
            delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles); // For "border" or "margin", add border

            if (box !== "padding") {
              delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles); // But still keep track of it otherwise
            } else {
              extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
            } // If we get here with a border-box (content + padding + border), we're seeking "content" or
            // "padding" or "margin"

          } else {
            // For "content", subtract padding
            if (box === "content") {
              delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
            } // For "content" or "padding", subtract border


            if (box !== "margin") {
              delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
            }
          }
        } // Account for positive content-box scroll gutter when requested by providing computedVal


        if (!isBorderBox && computedVal >= 0) {
          // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
          // Assuming integer scroll gutter, subtract the rest and round down
          delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5 // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
          // Use an explicit zero to avoid NaN (gh-3964)
          )) || 0;
        }

        return delta;
      }

      function getWidthOrHeight(elem, dimension, extra) {
        // Start with computed style
        var styles = getStyles(elem),
            // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
        // Fake content-box until we know it's needed to know the true value.
        boxSizingNeeded = !support.boxSizingReliable() || extra,
            isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
            valueIsBorderBox = isBorderBox,
            val = curCSS(elem, dimension, styles),
            offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1); // Support: Firefox <=54
        // Return a confounding non-pixel value or feign ignorance, as appropriate.

        if (rnumnonpx.test(val)) {
          if (!extra) {
            return val;
          }

          val = "auto";
        } // Fall back to offsetWidth/offsetHeight when value is "auto"
        // This happens for inline elements with no explicit setting (gh-3571)
        // Support: Android <=4.1 - 4.3 only
        // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
        // Support: IE 9-11 only
        // Also use offsetWidth/offsetHeight for when box sizing is unreliable
        // We use getClientRects() to check for hidden/disconnected.
        // In those cases, the computed value can be trusted to be border-box


        if ((!support.boxSizingReliable() && isBorderBox || val === "auto" || !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && elem.getClientRects().length) {
          isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box"; // Where available, offsetWidth/offsetHeight approximate border box dimensions.
          // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
          // retrieved value as a content box dimension.

          valueIsBorderBox = offsetProp in elem;

          if (valueIsBorderBox) {
            val = elem[offsetProp];
          }
        } // Normalize "" and auto


        val = parseFloat(val) || 0; // Adjust for the element's box model

        return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, // Provide the current computed size to request scroll gutter calculation (gh-3589)
        val) + "px";
      }

      jQuery.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
          opacity: {
            get: function get(elem, computed) {
              if (computed) {
                // We should always get a number back from opacity
                var ret = curCSS(elem, "opacity");
                return ret === "" ? "1" : ret;
              }
            }
          }
        },
        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
          "animationIterationCount": true,
          "columnCount": true,
          "fillOpacity": true,
          "flexGrow": true,
          "flexShrink": true,
          "fontWeight": true,
          "gridArea": true,
          "gridColumn": true,
          "gridColumnEnd": true,
          "gridColumnStart": true,
          "gridRow": true,
          "gridRowEnd": true,
          "gridRowStart": true,
          "lineHeight": true,
          "opacity": true,
          "order": true,
          "orphans": true,
          "widows": true,
          "zIndex": true,
          "zoom": true
        },
        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {},
        // Get and set the style property on a DOM Node
        style: function style(elem, name, value, extra) {
          // Don't set styles on text and comment nodes
          if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
            return;
          } // Make sure that we're working with the right name


          var ret,
              type,
              hooks,
              origName = camelCase(name),
              isCustomProp = rcustomProp.test(name),
              style = elem.style; // Make sure that we're working with the right name. We don't
          // want to query the value if it is a CSS custom property
          // since they are user-defined.

          if (!isCustomProp) {
            name = finalPropName(origName);
          } // Gets hook for the prefixed version, then unprefixed version


          hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // Check if we're setting a value

          if (value !== undefined) {
            type = typeof value; // Convert "+=" or "-=" to relative numbers (#7345)

            if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
              value = adjustCSS(elem, name, ret); // Fixes bug #9237

              type = "number";
            } // Make sure that null and NaN values aren't set (#7116)


            if (value == null || value !== value) {
              return;
            } // If a number was passed in, add the unit (except for certain CSS properties)
            // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
            // "px" to a few hardcoded values.


            if (type === "number" && !isCustomProp) {
              value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
            } // background-* props affect original clone's values


            if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
              style[name] = "inherit";
            } // If a hook was provided, use that value, otherwise just set the specified value


            if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
              if (isCustomProp) {
                style.setProperty(name, value);
              } else {
                style[name] = value;
              }
            }
          } else {
            // If a hook was provided get the non-computed value from there
            if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
              return ret;
            } // Otherwise just get the value from the style object


            return style[name];
          }
        },
        css: function css(elem, name, extra, styles) {
          var val,
              num,
              hooks,
              origName = camelCase(name),
              isCustomProp = rcustomProp.test(name); // Make sure that we're working with the right name. We don't
          // want to modify the value if it is a CSS custom property
          // since they are user-defined.

          if (!isCustomProp) {
            name = finalPropName(origName);
          } // Try prefixed name followed by the unprefixed name


          hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there

          if (hooks && "get" in hooks) {
            val = hooks.get(elem, true, extra);
          } // Otherwise, if a way to get the computed value exists, use that


          if (val === undefined) {
            val = curCSS(elem, name, styles);
          } // Convert "normal" to computed value


          if (val === "normal" && name in cssNormalTransform) {
            val = cssNormalTransform[name];
          } // Make numeric if forced or a qualifier was provided and val looks numeric


          if (extra === "" || extra) {
            num = parseFloat(val);
            return extra === true || isFinite(num) ? num || 0 : val;
          }

          return val;
        }
      });
      jQuery.each(["height", "width"], function (i, dimension) {
        jQuery.cssHooks[dimension] = {
          get: function get(elem, computed, extra) {
            if (computed) {
              // Certain elements can have dimension info if we invisibly show them
              // but it must have a current display style that would benefit
              return rdisplayswap.test(jQuery.css(elem, "display")) && ( // Support: Safari 8+
              // Table columns in Safari have non-zero offsetWidth & zero
              // getBoundingClientRect().width unless display is changed.
              // Support: IE <=11 only
              // Running getBoundingClientRect on a disconnected node
              // in IE throws an error.
              !elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
                return getWidthOrHeight(elem, dimension, extra);
              }) : getWidthOrHeight(elem, dimension, extra);
            }
          },
          set: function set(elem, value, extra) {
            var matches,
                styles = getStyles(elem),
                // Only read styles.position if the test has a chance to fail
            // to avoid forcing a reflow.
            scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute",
                // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
            boxSizingNeeded = scrollboxSizeBuggy || extra,
                isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
                subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0; // Account for unreliable border-box dimensions by comparing offset* to computed and
            // faking a content-box to get border and padding (gh-3699)

            if (isBorderBox && scrollboxSizeBuggy) {
              subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
            } // Convert to pixels if value adjustment is needed


            if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
              elem.style[dimension] = value;
              value = jQuery.css(elem, dimension);
            }

            return setPositiveNumber(elem, value, subtract);
          }
        };
      });
      jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
        if (computed) {
          return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
            marginLeft: 0
          }, function () {
            return elem.getBoundingClientRect().left;
          })) + "px";
        }
      }); // These hooks are used by animate to expand properties

      jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
      }, function (prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
          expand: function expand(value) {
            var i = 0,
                expanded = {},
                // Assumes a single number if not a string
            parts = typeof value === "string" ? value.split(" ") : [value];

            for (; i < 4; i++) {
              expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
            }

            return expanded;
          }
        };

        if (prefix !== "margin") {
          jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
      });
      jQuery.fn.extend({
        css: function css(name, value) {
          return access(this, function (elem, name, value) {
            var styles,
                len,
                map = {},
                i = 0;

            if (Array.isArray(name)) {
              styles = getStyles(elem);
              len = name.length;

              for (; i < len; i++) {
                map[name[i]] = jQuery.css(elem, name[i], false, styles);
              }

              return map;
            }

            return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
          }, name, value, arguments.length > 1);
        }
      });

      function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
      }

      jQuery.Tween = Tween;
      Tween.prototype = {
        constructor: Tween,
        init: function init(elem, options, prop, end, easing, unit) {
          this.elem = elem;
          this.prop = prop;
          this.easing = easing || jQuery.easing._default;
          this.options = options;
          this.start = this.now = this.cur();
          this.end = end;
          this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function cur() {
          var hooks = Tween.propHooks[this.prop];
          return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function run(percent) {
          var eased,
              hooks = Tween.propHooks[this.prop];

          if (this.options.duration) {
            this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
          } else {
            this.pos = eased = percent;
          }

          this.now = (this.end - this.start) * eased + this.start;

          if (this.options.step) {
            this.options.step.call(this.elem, this.now, this);
          }

          if (hooks && hooks.set) {
            hooks.set(this);
          } else {
            Tween.propHooks._default.set(this);
          }

          return this;
        }
      };
      Tween.prototype.init.prototype = Tween.prototype;
      Tween.propHooks = {
        _default: {
          get: function get(tween) {
            var result; // Use a property on the element directly when it is not a DOM element,
            // or when there is no matching style property that exists.

            if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
              return tween.elem[tween.prop];
            } // Passing an empty string as a 3rd parameter to .css will automatically
            // attempt a parseFloat and fallback to a string if the parse fails.
            // Simple values such as "10px" are parsed to Float;
            // complex values such as "rotate(1rad)" are returned as-is.


            result = jQuery.css(tween.elem, tween.prop, ""); // Empty strings, null, undefined and "auto" are converted to 0.

            return !result || result === "auto" ? 0 : result;
          },
          set: function set(tween) {
            // Use step hook for back compat.
            // Use cssHook if its there.
            // Use .style if available and use plain properties where available.
            if (jQuery.fx.step[tween.prop]) {
              jQuery.fx.step[tween.prop](tween);
            } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
              jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
            } else {
              tween.elem[tween.prop] = tween.now;
            }
          }
        }
      }; // Support: IE <=9 only
      // Panic based approach to setting things on disconnected nodes

      Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function set(tween) {
          if (tween.elem.nodeType && tween.elem.parentNode) {
            tween.elem[tween.prop] = tween.now;
          }
        }
      };
      jQuery.easing = {
        linear: function linear(p) {
          return p;
        },
        swing: function swing(p) {
          return 0.5 - Math.cos(p * Math.PI) / 2;
        },
        _default: "swing"
      };
      jQuery.fx = Tween.prototype.init; // Back compat <1.8 extension point

      jQuery.fx.step = {};
      var fxNow,
          inProgress,
          rfxtypes = /^(?:toggle|show|hide)$/,
          rrun = /queueHooks$/;

      function schedule() {
        if (inProgress) {
          if (document.hidden === false && window.requestAnimationFrame) {
            window.requestAnimationFrame(schedule);
          } else {
            window.setTimeout(schedule, jQuery.fx.interval);
          }

          jQuery.fx.tick();
        }
      } // Animations created synchronously will run synchronously


      function createFxNow() {
        window.setTimeout(function () {
          fxNow = undefined;
        });
        return fxNow = Date.now();
      } // Generate parameters to create a standard animation


      function genFx(type, includeWidth) {
        var which,
            i = 0,
            attrs = {
          height: type
        }; // If we include width, step value is 1 to do all cssExpand values,
        // otherwise step value is 2 to skip over Left and Right

        includeWidth = includeWidth ? 1 : 0;

        for (; i < 4; i += 2 - includeWidth) {
          which = cssExpand[i];
          attrs["margin" + which] = attrs["padding" + which] = type;
        }

        if (includeWidth) {
          attrs.opacity = attrs.width = type;
        }

        return attrs;
      }

      function createTween(value, prop, animation) {
        var tween,
            collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
            index = 0,
            length = collection.length;

        for (; index < length; index++) {
          if (tween = collection[index].call(animation, prop, value)) {
            // We're done with this property
            return tween;
          }
        }
      }

      function defaultPrefilter(elem, props, opts) {
        var prop,
            value,
            toggle,
            hooks,
            oldfire,
            propTween,
            restoreDisplay,
            display,
            isBox = "width" in props || "height" in props,
            anim = this,
            orig = {},
            style = elem.style,
            hidden = elem.nodeType && isHiddenWithinTree(elem),
            dataShow = dataPriv.get(elem, "fxshow"); // Queue-skipping animations hijack the fx hooks

        if (!opts.queue) {
          hooks = jQuery._queueHooks(elem, "fx");

          if (hooks.unqueued == null) {
            hooks.unqueued = 0;
            oldfire = hooks.empty.fire;

            hooks.empty.fire = function () {
              if (!hooks.unqueued) {
                oldfire();
              }
            };
          }

          hooks.unqueued++;
          anim.always(function () {
            // Ensure the complete handler is called before this completes
            anim.always(function () {
              hooks.unqueued--;

              if (!jQuery.queue(elem, "fx").length) {
                hooks.empty.fire();
              }
            });
          });
        } // Detect show/hide animations


        for (prop in props) {
          value = props[prop];

          if (rfxtypes.test(value)) {
            delete props[prop];
            toggle = toggle || value === "toggle";

            if (value === (hidden ? "hide" : "show")) {
              // Pretend to be hidden if this is a "show" and
              // there is still data from a stopped show/hide
              if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                hidden = true; // Ignore all other no-op show/hide data
              } else {
                continue;
              }
            }

            orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
          }
        } // Bail out if this is a no-op like .hide().hide()


        propTween = !jQuery.isEmptyObject(props);

        if (!propTween && jQuery.isEmptyObject(orig)) {
          return;
        } // Restrict "overflow" and "display" styles during box animations


        if (isBox && elem.nodeType === 1) {
          // Support: IE <=9 - 11, Edge 12 - 15
          // Record all 3 overflow attributes because IE does not infer the shorthand
          // from identically-valued overflowX and overflowY and Edge just mirrors
          // the overflowX value there.
          opts.overflow = [style.overflow, style.overflowX, style.overflowY]; // Identify a display type, preferring old show/hide data over the CSS cascade

          restoreDisplay = dataShow && dataShow.display;

          if (restoreDisplay == null) {
            restoreDisplay = dataPriv.get(elem, "display");
          }

          display = jQuery.css(elem, "display");

          if (display === "none") {
            if (restoreDisplay) {
              display = restoreDisplay;
            } else {
              // Get nonempty value(s) by temporarily forcing visibility
              showHide([elem], true);
              restoreDisplay = elem.style.display || restoreDisplay;
              display = jQuery.css(elem, "display");
              showHide([elem]);
            }
          } // Animate inline elements as inline-block


          if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
            if (jQuery.css(elem, "float") === "none") {
              // Restore the original display value at the end of pure show/hide animations
              if (!propTween) {
                anim.done(function () {
                  style.display = restoreDisplay;
                });

                if (restoreDisplay == null) {
                  display = style.display;
                  restoreDisplay = display === "none" ? "" : display;
                }
              }

              style.display = "inline-block";
            }
          }
        }

        if (opts.overflow) {
          style.overflow = "hidden";
          anim.always(function () {
            style.overflow = opts.overflow[0];
            style.overflowX = opts.overflow[1];
            style.overflowY = opts.overflow[2];
          });
        } // Implement show/hide animations


        propTween = false;

        for (prop in orig) {
          // General show/hide setup for this element animation
          if (!propTween) {
            if (dataShow) {
              if ("hidden" in dataShow) {
                hidden = dataShow.hidden;
              }
            } else {
              dataShow = dataPriv.access(elem, "fxshow", {
                display: restoreDisplay
              });
            } // Store hidden/visible for toggle so `.stop().toggle()` "reverses"


            if (toggle) {
              dataShow.hidden = !hidden;
            } // Show elements before animating them


            if (hidden) {
              showHide([elem], true);
            }
            /* eslint-disable no-loop-func */


            anim.done(function () {
              /* eslint-enable no-loop-func */
              // The final step of a "hide" animation is actually hiding the element
              if (!hidden) {
                showHide([elem]);
              }

              dataPriv.remove(elem, "fxshow");

              for (prop in orig) {
                jQuery.style(elem, prop, orig[prop]);
              }
            });
          } // Per-property setup


          propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

          if (!(prop in dataShow)) {
            dataShow[prop] = propTween.start;

            if (hidden) {
              propTween.end = propTween.start;
              propTween.start = 0;
            }
          }
        }
      }

      function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks; // camelCase, specialEasing and expand cssHook pass

        for (index in props) {
          name = camelCase(index);
          easing = specialEasing[name];
          value = props[index];

          if (Array.isArray(value)) {
            easing = value[1];
            value = props[index] = value[0];
          }

          if (index !== name) {
            props[name] = value;
            delete props[index];
          }

          hooks = jQuery.cssHooks[name];

          if (hooks && "expand" in hooks) {
            value = hooks.expand(value);
            delete props[name]; // Not quite $.extend, this won't overwrite existing keys.
            // Reusing 'index' because we have the correct "name"

            for (index in value) {
              if (!(index in props)) {
                props[index] = value[index];
                specialEasing[index] = easing;
              }
            }
          } else {
            specialEasing[name] = easing;
          }
        }
      }

      function Animation(elem, properties, options) {
        var result,
            stopped,
            index = 0,
            length = Animation.prefilters.length,
            deferred = jQuery.Deferred().always(function () {
          // Don't match elem in the :animated selector
          delete tick.elem;
        }),
            tick = function tick() {
          if (stopped) {
            return false;
          }

          var currentTime = fxNow || createFxNow(),
              remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
              // Support: Android 2.3 only
          // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
          temp = remaining / animation.duration || 0,
              percent = 1 - temp,
              index = 0,
              length = animation.tweens.length;

          for (; index < length; index++) {
            animation.tweens[index].run(percent);
          }

          deferred.notifyWith(elem, [animation, percent, remaining]); // If there's more to do, yield

          if (percent < 1 && length) {
            return remaining;
          } // If this was an empty animation, synthesize a final progress notification


          if (!length) {
            deferred.notifyWith(elem, [animation, 1, 0]);
          } // Resolve the animation and report its conclusion


          deferred.resolveWith(elem, [animation]);
          return false;
        },
            animation = deferred.promise({
          elem: elem,
          props: jQuery.extend({}, properties),
          opts: jQuery.extend(true, {
            specialEasing: {},
            easing: jQuery.easing._default
          }, options),
          originalProperties: properties,
          originalOptions: options,
          startTime: fxNow || createFxNow(),
          duration: options.duration,
          tweens: [],
          createTween: function createTween(prop, end) {
            var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
            animation.tweens.push(tween);
            return tween;
          },
          stop: function stop(gotoEnd) {
            var index = 0,
                // If we are going to the end, we want to run all the tweens
            // otherwise we skip this part
            length = gotoEnd ? animation.tweens.length : 0;

            if (stopped) {
              return this;
            }

            stopped = true;

            for (; index < length; index++) {
              animation.tweens[index].run(1);
            } // Resolve when we played the last frame; otherwise, reject


            if (gotoEnd) {
              deferred.notifyWith(elem, [animation, 1, 0]);
              deferred.resolveWith(elem, [animation, gotoEnd]);
            } else {
              deferred.rejectWith(elem, [animation, gotoEnd]);
            }

            return this;
          }
        }),
            props = animation.props;

        propFilter(props, animation.opts.specialEasing);

        for (; index < length; index++) {
          result = Animation.prefilters[index].call(animation, elem, props, animation.opts);

          if (result) {
            if (isFunction(result.stop)) {
              jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
            }

            return result;
          }
        }

        jQuery.map(props, createTween, animation);

        if (isFunction(animation.opts.start)) {
          animation.opts.start.call(elem, animation);
        } // Attach callbacks from options


        animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
        jQuery.fx.timer(jQuery.extend(tick, {
          elem: elem,
          anim: animation,
          queue: animation.opts.queue
        }));
        return animation;
      }

      jQuery.Animation = jQuery.extend(Animation, {
        tweeners: {
          "*": [function (prop, value) {
            var tween = this.createTween(prop, value);
            adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
            return tween;
          }]
        },
        tweener: function tweener(props, callback) {
          if (isFunction(props)) {
            callback = props;
            props = ["*"];
          } else {
            props = props.match(rnothtmlwhite);
          }

          var prop,
              index = 0,
              length = props.length;

          for (; index < length; index++) {
            prop = props[index];
            Animation.tweeners[prop] = Animation.tweeners[prop] || [];
            Animation.tweeners[prop].unshift(callback);
          }
        },
        prefilters: [defaultPrefilter],
        prefilter: function prefilter(callback, prepend) {
          if (prepend) {
            Animation.prefilters.unshift(callback);
          } else {
            Animation.prefilters.push(callback);
          }
        }
      });

      jQuery.speed = function (speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
          complete: fn || !fn && easing || isFunction(speed) && speed,
          duration: speed,
          easing: fn && easing || easing && !isFunction(easing) && easing
        }; // Go to the end state if fx are off

        if (jQuery.fx.off) {
          opt.duration = 0;
        } else {
          if (typeof opt.duration !== "number") {
            if (opt.duration in jQuery.fx.speeds) {
              opt.duration = jQuery.fx.speeds[opt.duration];
            } else {
              opt.duration = jQuery.fx.speeds._default;
            }
          }
        } // Normalize opt.queue - true/undefined/null -> "fx"


        if (opt.queue == null || opt.queue === true) {
          opt.queue = "fx";
        } // Queueing


        opt.old = opt.complete;

        opt.complete = function () {
          if (isFunction(opt.old)) {
            opt.old.call(this);
          }

          if (opt.queue) {
            jQuery.dequeue(this, opt.queue);
          }
        };

        return opt;
      };

      jQuery.fn.extend({
        fadeTo: function fadeTo(speed, to, easing, callback) {
          // Show any hidden elements after setting opacity to 0
          return this.filter(isHiddenWithinTree).css("opacity", 0).show() // Animate to the value specified
          .end().animate({
            opacity: to
          }, speed, easing, callback);
        },
        animate: function animate(prop, speed, easing, callback) {
          var empty = jQuery.isEmptyObject(prop),
              optall = jQuery.speed(speed, easing, callback),
              doAnimation = function doAnimation() {
            // Operate on a copy of prop so per-property easing won't be lost
            var anim = Animation(this, jQuery.extend({}, prop), optall); // Empty animations, or finishing resolves immediately

            if (empty || dataPriv.get(this, "finish")) {
              anim.stop(true);
            }
          };

          doAnimation.finish = doAnimation;
          return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function stop(type, clearQueue, gotoEnd) {
          var stopQueue = function stopQueue(hooks) {
            var stop = hooks.stop;
            delete hooks.stop;
            stop(gotoEnd);
          };

          if (typeof type !== "string") {
            gotoEnd = clearQueue;
            clearQueue = type;
            type = undefined;
          }

          if (clearQueue && type !== false) {
            this.queue(type || "fx", []);
          }

          return this.each(function () {
            var dequeue = true,
                index = type != null && type + "queueHooks",
                timers = jQuery.timers,
                data = dataPriv.get(this);

            if (index) {
              if (data[index] && data[index].stop) {
                stopQueue(data[index]);
              }
            } else {
              for (index in data) {
                if (data[index] && data[index].stop && rrun.test(index)) {
                  stopQueue(data[index]);
                }
              }
            }

            for (index = timers.length; index--;) {
              if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                timers[index].anim.stop(gotoEnd);
                dequeue = false;
                timers.splice(index, 1);
              }
            } // Start the next in the queue if the last step wasn't forced.
            // Timers currently will call their complete callbacks, which
            // will dequeue but only if they were gotoEnd.


            if (dequeue || !gotoEnd) {
              jQuery.dequeue(this, type);
            }
          });
        },
        finish: function finish(type) {
          if (type !== false) {
            type = type || "fx";
          }

          return this.each(function () {
            var index,
                data = dataPriv.get(this),
                queue = data[type + "queue"],
                hooks = data[type + "queueHooks"],
                timers = jQuery.timers,
                length = queue ? queue.length : 0; // Enable finishing flag on private data

            data.finish = true; // Empty the queue first

            jQuery.queue(this, type, []);

            if (hooks && hooks.stop) {
              hooks.stop.call(this, true);
            } // Look for any active animations, and finish them


            for (index = timers.length; index--;) {
              if (timers[index].elem === this && timers[index].queue === type) {
                timers[index].anim.stop(true);
                timers.splice(index, 1);
              }
            } // Look for any animations in the old queue and finish them


            for (index = 0; index < length; index++) {
              if (queue[index] && queue[index].finish) {
                queue[index].finish.call(this);
              }
            } // Turn off finishing flag


            delete data.finish;
          });
        }
      });
      jQuery.each(["toggle", "show", "hide"], function (i, name) {
        var cssFn = jQuery.fn[name];

        jQuery.fn[name] = function (speed, easing, callback) {
          return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
      }); // Generate shortcuts for custom animations

      jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {
          opacity: "show"
        },
        fadeOut: {
          opacity: "hide"
        },
        fadeToggle: {
          opacity: "toggle"
        }
      }, function (name, props) {
        jQuery.fn[name] = function (speed, easing, callback) {
          return this.animate(props, speed, easing, callback);
        };
      });
      jQuery.timers = [];

      jQuery.fx.tick = function () {
        var timer,
            i = 0,
            timers = jQuery.timers;
        fxNow = Date.now();

        for (; i < timers.length; i++) {
          timer = timers[i]; // Run the timer and safely remove it when done (allowing for external removal)

          if (!timer() && timers[i] === timer) {
            timers.splice(i--, 1);
          }
        }

        if (!timers.length) {
          jQuery.fx.stop();
        }

        fxNow = undefined;
      };

      jQuery.fx.timer = function (timer) {
        jQuery.timers.push(timer);
        jQuery.fx.start();
      };

      jQuery.fx.interval = 13;

      jQuery.fx.start = function () {
        if (inProgress) {
          return;
        }

        inProgress = true;
        schedule();
      };

      jQuery.fx.stop = function () {
        inProgress = null;
      };

      jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        // Default speed
        _default: 400
      }; // Based off of the plugin by Clint Helfers, with permission.
      // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/

      jQuery.fn.delay = function (time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || "fx";
        return this.queue(type, function (next, hooks) {
          var timeout = window.setTimeout(next, time);

          hooks.stop = function () {
            window.clearTimeout(timeout);
          };
        });
      };

      (function () {
        var input = document.createElement("input"),
            select = document.createElement("select"),
            opt = select.appendChild(document.createElement("option"));
        input.type = "checkbox"; // Support: Android <=4.3 only
        // Default value for a checkbox should be "on"

        support.checkOn = input.value !== ""; // Support: IE <=11 only
        // Must access selectedIndex to make default options select

        support.optSelected = opt.selected; // Support: IE <=11 only
        // An input loses its value after becoming a radio

        input = document.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
      })();

      var boolHook,
          attrHandle = jQuery.expr.attrHandle;
      jQuery.fn.extend({
        attr: function attr(name, value) {
          return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function removeAttr(name) {
          return this.each(function () {
            jQuery.removeAttr(this, name);
          });
        }
      });
      jQuery.extend({
        attr: function attr(elem, name, value) {
          var ret,
              hooks,
              nType = elem.nodeType; // Don't get/set attributes on text, comment and attribute nodes

          if (nType === 3 || nType === 8 || nType === 2) {
            return;
          } // Fallback to prop when attributes are not supported


          if (typeof elem.getAttribute === "undefined") {
            return jQuery.prop(elem, name, value);
          } // Attribute hooks are determined by the lowercase version
          // Grab necessary hook if one is defined


          if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
            hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
          }

          if (value !== undefined) {
            if (value === null) {
              jQuery.removeAttr(elem, name);
              return;
            }

            if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
              return ret;
            }

            elem.setAttribute(name, value + "");
            return value;
          }

          if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
            return ret;
          }

          ret = jQuery.find.attr(elem, name); // Non-existent attributes return null, we normalize to undefined

          return ret == null ? undefined : ret;
        },
        attrHooks: {
          type: {
            set: function set(elem, value) {
              if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                var val = elem.value;
                elem.setAttribute("type", value);

                if (val) {
                  elem.value = val;
                }

                return value;
              }
            }
          }
        },
        removeAttr: function removeAttr(elem, value) {
          var name,
              i = 0,
              // Attribute names can contain non-HTML whitespace characters
          // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
          attrNames = value && value.match(rnothtmlwhite);

          if (attrNames && elem.nodeType === 1) {
            while (name = attrNames[i++]) {
              elem.removeAttribute(name);
            }
          }
        }
      }); // Hooks for boolean attributes

      boolHook = {
        set: function set(elem, value, name) {
          if (value === false) {
            // Remove boolean attributes when set to false
            jQuery.removeAttr(elem, name);
          } else {
            elem.setAttribute(name, name);
          }

          return name;
        }
      };
      jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;

        attrHandle[name] = function (elem, name, isXML) {
          var ret,
              handle,
              lowercaseName = name.toLowerCase();

          if (!isXML) {
            // Avoid an infinite loop by temporarily removing this function from the getter
            handle = attrHandle[lowercaseName];
            attrHandle[lowercaseName] = ret;
            ret = getter(elem, name, isXML) != null ? lowercaseName : null;
            attrHandle[lowercaseName] = handle;
          }

          return ret;
        };
      });
      var rfocusable = /^(?:input|select|textarea|button)$/i,
          rclickable = /^(?:a|area)$/i;
      jQuery.fn.extend({
        prop: function prop(name, value) {
          return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function removeProp(name) {
          return this.each(function () {
            delete this[jQuery.propFix[name] || name];
          });
        }
      });
      jQuery.extend({
        prop: function prop(elem, name, value) {
          var ret,
              hooks,
              nType = elem.nodeType; // Don't get/set properties on text, comment and attribute nodes

          if (nType === 3 || nType === 8 || nType === 2) {
            return;
          }

          if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
            // Fix name and attach hooks
            name = jQuery.propFix[name] || name;
            hooks = jQuery.propHooks[name];
          }

          if (value !== undefined) {
            if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
              return ret;
            }

            return elem[name] = value;
          }

          if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
            return ret;
          }

          return elem[name];
        },
        propHooks: {
          tabIndex: {
            get: function get(elem) {
              // Support: IE <=9 - 11 only
              // elem.tabIndex doesn't always return the
              // correct value when it hasn't been explicitly set
              // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
              // Use proper attribute retrieval(#12072)
              var tabindex = jQuery.find.attr(elem, "tabindex");

              if (tabindex) {
                return parseInt(tabindex, 10);
              }

              if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                return 0;
              }

              return -1;
            }
          }
        },
        propFix: {
          "for": "htmlFor",
          "class": "className"
        }
      }); // Support: IE <=11 only
      // Accessing the selectedIndex property
      // forces the browser to respect setting selected
      // on the option
      // The getter ensures a default option is selected
      // when in an optgroup
      // eslint rule "no-unused-expressions" is disabled for this code
      // since it considers such accessions noop

      if (!support.optSelected) {
        jQuery.propHooks.selected = {
          get: function get(elem) {
            /* eslint no-unused-expressions: "off" */
            var parent = elem.parentNode;

            if (parent && parent.parentNode) {
              parent.parentNode.selectedIndex;
            }

            return null;
          },
          set: function set(elem) {
            /* eslint no-unused-expressions: "off" */
            var parent = elem.parentNode;

            if (parent) {
              parent.selectedIndex;

              if (parent.parentNode) {
                parent.parentNode.selectedIndex;
              }
            }
          }
        };
      }

      jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
        jQuery.propFix[this.toLowerCase()] = this;
      }); // Strip and collapse whitespace according to HTML spec
      // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace

      function stripAndCollapse(value) {
        var tokens = value.match(rnothtmlwhite) || [];
        return tokens.join(" ");
      }

      function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || "";
      }

      function classesToArray(value) {
        if (Array.isArray(value)) {
          return value;
        }

        if (typeof value === "string") {
          return value.match(rnothtmlwhite) || [];
        }

        return [];
      }

      jQuery.fn.extend({
        addClass: function addClass(value) {
          var classes,
              elem,
              cur,
              curValue,
              clazz,
              j,
              finalValue,
              i = 0;

          if (isFunction(value)) {
            return this.each(function (j) {
              jQuery(this).addClass(value.call(this, j, getClass(this)));
            });
          }

          classes = classesToArray(value);

          if (classes.length) {
            while (elem = this[i++]) {
              curValue = getClass(elem);
              cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

              if (cur) {
                j = 0;

                while (clazz = classes[j++]) {
                  if (cur.indexOf(" " + clazz + " ") < 0) {
                    cur += clazz + " ";
                  }
                } // Only assign if different to avoid unneeded rendering.


                finalValue = stripAndCollapse(cur);

                if (curValue !== finalValue) {
                  elem.setAttribute("class", finalValue);
                }
              }
            }
          }

          return this;
        },
        removeClass: function removeClass(value) {
          var classes,
              elem,
              cur,
              curValue,
              clazz,
              j,
              finalValue,
              i = 0;

          if (isFunction(value)) {
            return this.each(function (j) {
              jQuery(this).removeClass(value.call(this, j, getClass(this)));
            });
          }

          if (!arguments.length) {
            return this.attr("class", "");
          }

          classes = classesToArray(value);

          if (classes.length) {
            while (elem = this[i++]) {
              curValue = getClass(elem); // This expression is here for better compressibility (see addClass)

              cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

              if (cur) {
                j = 0;

                while (clazz = classes[j++]) {
                  // Remove *all* instances
                  while (cur.indexOf(" " + clazz + " ") > -1) {
                    cur = cur.replace(" " + clazz + " ", " ");
                  }
                } // Only assign if different to avoid unneeded rendering.


                finalValue = stripAndCollapse(cur);

                if (curValue !== finalValue) {
                  elem.setAttribute("class", finalValue);
                }
              }
            }
          }

          return this;
        },
        toggleClass: function toggleClass(value, stateVal) {
          var type = typeof value,
              isValidValue = type === "string" || Array.isArray(value);

          if (typeof stateVal === "boolean" && isValidValue) {
            return stateVal ? this.addClass(value) : this.removeClass(value);
          }

          if (isFunction(value)) {
            return this.each(function (i) {
              jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
            });
          }

          return this.each(function () {
            var className, i, self, classNames;

            if (isValidValue) {
              // Toggle individual class names
              i = 0;
              self = jQuery(this);
              classNames = classesToArray(value);

              while (className = classNames[i++]) {
                // Check each className given, space separated list
                if (self.hasClass(className)) {
                  self.removeClass(className);
                } else {
                  self.addClass(className);
                }
              } // Toggle whole class name

            } else if (value === undefined || type === "boolean") {
              className = getClass(this);

              if (className) {
                // Store className if set
                dataPriv.set(this, "__className__", className);
              } // If the element has a class name or if we're passed `false`,
              // then remove the whole classname (if there was one, the above saved it).
              // Otherwise bring back whatever was previously saved (if anything),
              // falling back to the empty string if nothing was stored.


              if (this.setAttribute) {
                this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
              }
            }
          });
        },
        hasClass: function hasClass(selector) {
          var className,
              elem,
              i = 0;
          className = " " + selector + " ";

          while (elem = this[i++]) {
            if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
              return true;
            }
          }

          return false;
        }
      });
      var rreturn = /\r/g;
      jQuery.fn.extend({
        val: function val(value) {
          var hooks,
              ret,
              valueIsFunction,
              elem = this[0];

          if (!arguments.length) {
            if (elem) {
              hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

              if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                return ret;
              }

              ret = elem.value; // Handle most common string cases

              if (typeof ret === "string") {
                return ret.replace(rreturn, "");
              } // Handle cases where value is null/undef or number


              return ret == null ? "" : ret;
            }

            return;
          }

          valueIsFunction = isFunction(value);
          return this.each(function (i) {
            var val;

            if (this.nodeType !== 1) {
              return;
            }

            if (valueIsFunction) {
              val = value.call(this, i, jQuery(this).val());
            } else {
              val = value;
            } // Treat null/undefined as ""; convert numbers to string


            if (val == null) {
              val = "";
            } else if (typeof val === "number") {
              val += "";
            } else if (Array.isArray(val)) {
              val = jQuery.map(val, function (value) {
                return value == null ? "" : value + "";
              });
            }

            hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting

            if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
              this.value = val;
            }
          });
        }
      });
      jQuery.extend({
        valHooks: {
          option: {
            get: function get(elem) {
              var val = jQuery.find.attr(elem, "value");
              return val != null ? val : // Support: IE <=10 - 11 only
              // option.text throws exceptions (#14686, #14858)
              // Strip and collapse whitespace
              // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
              stripAndCollapse(jQuery.text(elem));
            }
          },
          select: {
            get: function get(elem) {
              var value,
                  option,
                  i,
                  options = elem.options,
                  index = elem.selectedIndex,
                  one = elem.type === "select-one",
                  values = one ? null : [],
                  max = one ? index + 1 : options.length;

              if (index < 0) {
                i = max;
              } else {
                i = one ? index : 0;
              } // Loop through all the selected options


              for (; i < max; i++) {
                option = options[i]; // Support: IE <=9 only
                // IE8-9 doesn't update selected after form reset (#2551)

                if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
                !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                  // Get the specific value for the option
                  value = jQuery(option).val(); // We don't need an array for one selects

                  if (one) {
                    return value;
                  } // Multi-Selects return an array


                  values.push(value);
                }
              }

              return values;
            },
            set: function set(elem, value) {
              var optionSet,
                  option,
                  options = elem.options,
                  values = jQuery.makeArray(value),
                  i = options.length;

              while (i--) {
                option = options[i];
                /* eslint-disable no-cond-assign */

                if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
                  optionSet = true;
                }
                /* eslint-enable no-cond-assign */

              } // Force browsers to behave consistently when non-matching value is set


              if (!optionSet) {
                elem.selectedIndex = -1;
              }

              return values;
            }
          }
        }
      }); // Radios and checkboxes getter/setter

      jQuery.each(["radio", "checkbox"], function () {
        jQuery.valHooks[this] = {
          set: function set(elem, value) {
            if (Array.isArray(value)) {
              return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
            }
          }
        };

        if (!support.checkOn) {
          jQuery.valHooks[this].get = function (elem) {
            return elem.getAttribute("value") === null ? "on" : elem.value;
          };
        }
      }); // Return jQuery for attributes-only inclusion

      support.focusin = "onfocusin" in window;

      var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
          stopPropagationCallback = function stopPropagationCallback(e) {
        e.stopPropagation();
      };

      jQuery.extend(jQuery.event, {
        trigger: function trigger(event, data, elem, onlyHandlers) {
          var i,
              cur,
              tmp,
              bubbleType,
              ontype,
              handle,
              special,
              lastElement,
              eventPath = [elem || document],
              type = hasOwn.call(event, "type") ? event.type : event,
              namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
          cur = lastElement = tmp = elem = elem || document; // Don't do events on text and comment nodes

          if (elem.nodeType === 3 || elem.nodeType === 8) {
            return;
          } // focus/blur morphs to focusin/out; ensure we're not firing them right now


          if (rfocusMorph.test(type + jQuery.event.triggered)) {
            return;
          }

          if (type.indexOf(".") > -1) {
            // Namespaced trigger; create a regexp to match event type in handle()
            namespaces = type.split(".");
            type = namespaces.shift();
            namespaces.sort();
          }

          ontype = type.indexOf(":") < 0 && "on" + type; // Caller can pass in a jQuery.Event object, Object, or just an event type string

          event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event); // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)

          event.isTrigger = onlyHandlers ? 2 : 3;
          event.namespace = namespaces.join(".");
          event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null; // Clean up the event in case it is being reused

          event.result = undefined;

          if (!event.target) {
            event.target = elem;
          } // Clone any incoming data and prepend the event, creating the handler arg list


          data = data == null ? [event] : jQuery.makeArray(data, [event]); // Allow special events to draw outside the lines

          special = jQuery.event.special[type] || {};

          if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
            return;
          } // Determine event propagation path in advance, per W3C events spec (#9951)
          // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)


          if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
            bubbleType = special.delegateType || type;

            if (!rfocusMorph.test(bubbleType + type)) {
              cur = cur.parentNode;
            }

            for (; cur; cur = cur.parentNode) {
              eventPath.push(cur);
              tmp = cur;
            } // Only add window if we got to document (e.g., not plain obj or detached DOM)


            if (tmp === (elem.ownerDocument || document)) {
              eventPath.push(tmp.defaultView || tmp.parentWindow || window);
            }
          } // Fire handlers on the event path


          i = 0;

          while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
            lastElement = cur;
            event.type = i > 1 ? bubbleType : special.bindType || type; // jQuery handler

            handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");

            if (handle) {
              handle.apply(cur, data);
            } // Native handler


            handle = ontype && cur[ontype];

            if (handle && handle.apply && acceptData(cur)) {
              event.result = handle.apply(cur, data);

              if (event.result === false) {
                event.preventDefault();
              }
            }
          }

          event.type = type; // If nobody prevented the default action, do it now

          if (!onlyHandlers && !event.isDefaultPrevented()) {
            if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
              // Call a native DOM method on the target with the same name as the event.
              // Don't do default actions on window, that's where global variables be (#6170)
              if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
                // Don't re-trigger an onFOO event when we call its FOO() method
                tmp = elem[ontype];

                if (tmp) {
                  elem[ontype] = null;
                } // Prevent re-triggering of the same event, since we already bubbled it above


                jQuery.event.triggered = type;

                if (event.isPropagationStopped()) {
                  lastElement.addEventListener(type, stopPropagationCallback);
                }

                elem[type]();

                if (event.isPropagationStopped()) {
                  lastElement.removeEventListener(type, stopPropagationCallback);
                }

                jQuery.event.triggered = undefined;

                if (tmp) {
                  elem[ontype] = tmp;
                }
              }
            }
          }

          return event.result;
        },
        // Piggyback on a donor event to simulate a different one
        // Used only for `focus(in | out)` events
        simulate: function simulate(type, elem, event) {
          var e = jQuery.extend(new jQuery.Event(), event, {
            type: type,
            isSimulated: true
          });
          jQuery.event.trigger(e, null, elem);
        }
      });
      jQuery.fn.extend({
        trigger: function trigger(type, data) {
          return this.each(function () {
            jQuery.event.trigger(type, data, this);
          });
        },
        triggerHandler: function triggerHandler(type, data) {
          var elem = this[0];

          if (elem) {
            return jQuery.event.trigger(type, data, elem, true);
          }
        }
      }); // Support: Firefox <=44
      // Firefox doesn't have focus(in | out) events
      // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
      //
      // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
      // focus(in | out) events fire after focus & blur events,
      // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
      // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857

      if (!support.focusin) {
        jQuery.each({
          focus: "focusin",
          blur: "focusout"
        }, function (orig, fix) {
          // Attach a single capturing handler on the document while someone wants focusin/focusout
          var handler = function handler(event) {
            jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
          };

          jQuery.event.special[fix] = {
            setup: function setup() {
              var doc = this.ownerDocument || this,
                  attaches = dataPriv.access(doc, fix);

              if (!attaches) {
                doc.addEventListener(orig, handler, true);
              }

              dataPriv.access(doc, fix, (attaches || 0) + 1);
            },
            teardown: function teardown() {
              var doc = this.ownerDocument || this,
                  attaches = dataPriv.access(doc, fix) - 1;

              if (!attaches) {
                doc.removeEventListener(orig, handler, true);
                dataPriv.remove(doc, fix);
              } else {
                dataPriv.access(doc, fix, attaches);
              }
            }
          };
        });
      }

      var location = window.location;
      var nonce = Date.now();
      var rquery = /\?/; // Cross-browser xml parsing

      jQuery.parseXML = function (data) {
        var xml;

        if (!data || typeof data !== "string") {
          return null;
        } // Support: IE 9 - 11 only
        // IE throws on parseFromString with invalid input.


        try {
          xml = new window.DOMParser().parseFromString(data, "text/xml");
        } catch (e) {
          xml = undefined;
        }

        if (!xml || xml.getElementsByTagName("parsererror").length) {
          jQuery.error("Invalid XML: " + data);
        }

        return xml;
      };

      var rbracket = /\[\]$/,
          rCRLF = /\r?\n/g,
          rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
          rsubmittable = /^(?:input|select|textarea|keygen)/i;

      function buildParams(prefix, obj, traditional, add) {
        var name;

        if (Array.isArray(obj)) {
          // Serialize array item.
          jQuery.each(obj, function (i, v) {
            if (traditional || rbracket.test(prefix)) {
              // Treat each array item as a scalar.
              add(prefix, v);
            } else {
              // Item is non-scalar (array or object), encode its numeric index.
              buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
            }
          });
        } else if (!traditional && toType(obj) === "object") {
          // Serialize object item.
          for (name in obj) {
            buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
          }
        } else {
          // Serialize scalar item.
          add(prefix, obj);
        }
      } // Serialize an array of form elements or a set of
      // key/values into a query string


      jQuery.param = function (a, traditional) {
        var prefix,
            s = [],
            add = function add(key, valueOrFunction) {
          // If value is a function, invoke it and use its return value
          var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
          s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
        };

        if (a == null) {
          return "";
        } // If an array was passed in, assume that it is an array of form elements.


        if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
          // Serialize the form elements
          jQuery.each(a, function () {
            add(this.name, this.value);
          });
        } else {
          // If traditional, encode the "old" way (the way 1.3.2 or older
          // did it), otherwise encode params recursively.
          for (prefix in a) {
            buildParams(prefix, a[prefix], traditional, add);
          }
        } // Return the resulting serialization


        return s.join("&");
      };

      jQuery.fn.extend({
        serialize: function serialize() {
          return jQuery.param(this.serializeArray());
        },
        serializeArray: function serializeArray() {
          return this.map(function () {
            // Can add propHook for "elements" to filter or add form elements
            var elements = jQuery.prop(this, "elements");
            return elements ? jQuery.makeArray(elements) : this;
          }).filter(function () {
            var type = this.type; // Use .is( ":disabled" ) so that fieldset[disabled] works

            return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
          }).map(function (i, elem) {
            var val = jQuery(this).val();

            if (val == null) {
              return null;
            }

            if (Array.isArray(val)) {
              return jQuery.map(val, function (val) {
                return {
                  name: elem.name,
                  value: val.replace(rCRLF, "\r\n")
                };
              });
            }

            return {
              name: elem.name,
              value: val.replace(rCRLF, "\r\n")
            };
          }).get();
        }
      });
      var r20 = /%20/g,
          rhash = /#.*$/,
          rantiCache = /([?&])_=[^&]*/,
          rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
          // #7653, #8125, #8152: local protocol detection
      rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
          rnoContent = /^(?:GET|HEAD)$/,
          rprotocol = /^\/\//,

      /* Prefilters
       * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
       * 2) These are called:
       *    - BEFORE asking for a transport
       *    - AFTER param serialization (s.data is a string if s.processData is true)
       * 3) key is the dataType
       * 4) the catchall symbol "*" can be used
       * 5) execution will start with transport dataType and THEN continue down to "*" if needed
       */
      prefilters = {},

      /* Transports bindings
       * 1) key is the dataType
       * 2) the catchall symbol "*" can be used
       * 3) selection will start with transport dataType and THEN go to "*" if needed
       */
      transports = {},
          // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
      allTypes = "*/".concat("*"),
          // Anchor tag for parsing the document origin
      originAnchor = document.createElement("a");
      originAnchor.href = location.href; // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport

      function addToPrefiltersOrTransports(structure) {
        // dataTypeExpression is optional and defaults to "*"
        return function (dataTypeExpression, func) {
          if (typeof dataTypeExpression !== "string") {
            func = dataTypeExpression;
            dataTypeExpression = "*";
          }

          var dataType,
              i = 0,
              dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];

          if (isFunction(func)) {
            // For each dataType in the dataTypeExpression
            while (dataType = dataTypes[i++]) {
              // Prepend if requested
              if (dataType[0] === "+") {
                dataType = dataType.slice(1) || "*";
                (structure[dataType] = structure[dataType] || []).unshift(func); // Otherwise append
              } else {
                (structure[dataType] = structure[dataType] || []).push(func);
              }
            }
          }
        };
      } // Base inspection function for prefilters and transports


      function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {},
            seekingTransport = structure === transports;

        function inspect(dataType) {
          var selected;
          inspected[dataType] = true;
          jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
            var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);

            if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
              options.dataTypes.unshift(dataTypeOrTransport);
              inspect(dataTypeOrTransport);
              return false;
            } else if (seekingTransport) {
              return !(selected = dataTypeOrTransport);
            }
          });
          return selected;
        }

        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
      } // A special extend for ajax options
      // that takes "flat" options (not to be deep extended)
      // Fixes #9887


      function ajaxExtend(target, src) {
        var key,
            deep,
            flatOptions = jQuery.ajaxSettings.flatOptions || {};

        for (key in src) {
          if (src[key] !== undefined) {
            (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
          }
        }

        if (deep) {
          jQuery.extend(true, target, deep);
        }

        return target;
      }
      /* Handles responses to an ajax request:
       * - finds the right dataType (mediates between content-type and expected dataType)
       * - returns the corresponding response
       */


      function ajaxHandleResponses(s, jqXHR, responses) {
        var ct,
            type,
            finalDataType,
            firstDataType,
            contents = s.contents,
            dataTypes = s.dataTypes; // Remove auto dataType and get content-type in the process

        while (dataTypes[0] === "*") {
          dataTypes.shift();

          if (ct === undefined) {
            ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
          }
        } // Check if we're dealing with a known content-type


        if (ct) {
          for (type in contents) {
            if (contents[type] && contents[type].test(ct)) {
              dataTypes.unshift(type);
              break;
            }
          }
        } // Check to see if we have a response for the expected dataType


        if (dataTypes[0] in responses) {
          finalDataType = dataTypes[0];
        } else {
          // Try convertible dataTypes
          for (type in responses) {
            if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
              finalDataType = type;
              break;
            }

            if (!firstDataType) {
              firstDataType = type;
            }
          } // Or just use first one


          finalDataType = finalDataType || firstDataType;
        } // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response


        if (finalDataType) {
          if (finalDataType !== dataTypes[0]) {
            dataTypes.unshift(finalDataType);
          }

          return responses[finalDataType];
        }
      }
      /* Chain conversions given the request and the original response
       * Also sets the responseXXX fields on the jqXHR instance
       */


      function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2,
            current,
            conv,
            tmp,
            prev,
            converters = {},
            // Work with a copy of dataTypes in case we need to modify it for conversion
        dataTypes = s.dataTypes.slice(); // Create converters map with lowercased keys

        if (dataTypes[1]) {
          for (conv in s.converters) {
            converters[conv.toLowerCase()] = s.converters[conv];
          }
        }

        current = dataTypes.shift(); // Convert to each sequential dataType

        while (current) {
          if (s.responseFields[current]) {
            jqXHR[s.responseFields[current]] = response;
          } // Apply the dataFilter if provided


          if (!prev && isSuccess && s.dataFilter) {
            response = s.dataFilter(response, s.dataType);
          }

          prev = current;
          current = dataTypes.shift();

          if (current) {
            // There's only work to do if current dataType is non-auto
            if (current === "*") {
              current = prev; // Convert response if prev dataType is non-auto and differs from current
            } else if (prev !== "*" && prev !== current) {
              // Seek a direct converter
              conv = converters[prev + " " + current] || converters["* " + current]; // If none found, seek a pair

              if (!conv) {
                for (conv2 in converters) {
                  // If conv2 outputs current
                  tmp = conv2.split(" ");

                  if (tmp[1] === current) {
                    // If prev can be converted to accepted input
                    conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];

                    if (conv) {
                      // Condense equivalence converters
                      if (conv === true) {
                        conv = converters[conv2]; // Otherwise, insert the intermediate dataType
                      } else if (converters[conv2] !== true) {
                        current = tmp[0];
                        dataTypes.unshift(tmp[1]);
                      }

                      break;
                    }
                  }
                }
              } // Apply converter (if not an equivalence)


              if (conv !== true) {
                // Unless errors are allowed to bubble, catch and return them
                if (conv && s.throws) {
                  response = conv(response);
                } else {
                  try {
                    response = conv(response);
                  } catch (e) {
                    return {
                      state: "parsererror",
                      error: conv ? e : "No conversion from " + prev + " to " + current
                    };
                  }
                }
              }
            }
          }
        }

        return {
          state: "success",
          data: response
        };
      }

      jQuery.extend({
        // Counter for holding the number of active queries
        active: 0,
        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},
        ajaxSettings: {
          url: location.href,
          type: "GET",
          isLocal: rlocalProtocol.test(location.protocol),
          global: true,
          processData: true,
          async: true,
          contentType: "application/x-www-form-urlencoded; charset=UTF-8",

          /*
          timeout: 0,
          data: null,
          dataType: null,
          username: null,
          password: null,
          cache: null,
          throws: false,
          traditional: false,
          headers: {},
          */
          accepts: {
            "*": allTypes,
            text: "text/plain",
            html: "text/html",
            xml: "application/xml, text/xml",
            json: "application/json, text/javascript"
          },
          contents: {
            xml: /\bxml\b/,
            html: /\bhtml/,
            json: /\bjson\b/
          },
          responseFields: {
            xml: "responseXML",
            text: "responseText",
            json: "responseJSON"
          },
          // Data converters
          // Keys separate source (or catchall "*") and destination types with a single space
          converters: {
            // Convert anything to text
            "* text": String,
            // Text to html (true = no transformation)
            "text html": true,
            // Evaluate text as a json expression
            "text json": JSON.parse,
            // Parse text as xml
            "text xml": jQuery.parseXML
          },
          // For options that shouldn't be deep extended:
          // you can add your own custom options here if
          // and when you create one that shouldn't be
          // deep extended (see ajaxExtend)
          flatOptions: {
            url: true,
            context: true
          }
        },
        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function ajaxSetup(target, settings) {
          return settings ? // Building a settings object
          ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings
          ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        // Main method
        ajax: function ajax(url, options) {
          // If url is an object, simulate pre-1.5 signature
          if (typeof url === "object") {
            options = url;
            url = undefined;
          } // Force options to be an object


          options = options || {};

          var transport,
              // URL without anti-cache param
          cacheURL,
              // Response headers
          responseHeadersString,
              responseHeaders,
              // timeout handle
          timeoutTimer,
              // Url cleanup var
          urlAnchor,
              // Request state (becomes false upon send and true upon completion)
          completed,
              // To know if global events are to be dispatched
          fireGlobals,
              // Loop variable
          i,
              // uncached part of the url
          uncached,
              // Create the final options object
          s = jQuery.ajaxSetup({}, options),
              // Callbacks context
          callbackContext = s.context || s,
              // Context for global events is callbackContext if it is a DOM node or jQuery collection
          globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
              // Deferreds
          deferred = jQuery.Deferred(),
              completeDeferred = jQuery.Callbacks("once memory"),
              // Status-dependent callbacks
          _statusCode = s.statusCode || {},
              // Headers (they are sent all at once)
          requestHeaders = {},
              requestHeadersNames = {},
              // Default abort message
          strAbort = "canceled",
              // Fake xhr
          jqXHR = {
            readyState: 0,
            // Builds headers hashtable if needed
            getResponseHeader: function getResponseHeader(key) {
              var match;

              if (completed) {
                if (!responseHeaders) {
                  responseHeaders = {};

                  while (match = rheaders.exec(responseHeadersString)) {
                    responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                  }
                }

                match = responseHeaders[key.toLowerCase() + " "];
              }

              return match == null ? null : match.join(", ");
            },
            // Raw string
            getAllResponseHeaders: function getAllResponseHeaders() {
              return completed ? responseHeadersString : null;
            },
            // Caches the header
            setRequestHeader: function setRequestHeader(name, value) {
              if (completed == null) {
                name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                requestHeaders[name] = value;
              }

              return this;
            },
            // Overrides response content-type header
            overrideMimeType: function overrideMimeType(type) {
              if (completed == null) {
                s.mimeType = type;
              }

              return this;
            },
            // Status-dependent callbacks
            statusCode: function statusCode(map) {
              var code;

              if (map) {
                if (completed) {
                  // Execute the appropriate callbacks
                  jqXHR.always(map[jqXHR.status]);
                } else {
                  // Lazy-add the new callbacks in a way that preserves old ones
                  for (code in map) {
                    _statusCode[code] = [_statusCode[code], map[code]];
                  }
                }
              }

              return this;
            },
            // Cancel the request
            abort: function abort(statusText) {
              var finalText = statusText || strAbort;

              if (transport) {
                transport.abort(finalText);
              }

              done(0, finalText);
              return this;
            }
          }; // Attach deferreds


          deferred.promise(jqXHR); // Add protocol if not provided (prefilters might expect it)
          // Handle falsy url in the settings object (#10093: consistency with old signature)
          // We also use the url parameter if available

          s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//"); // Alias method option to type as per ticket #12004

          s.type = options.method || options.type || s.method || s.type; // Extract dataTypes list

          s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""]; // A cross-domain request is in order when the origin doesn't match the current origin.

          if (s.crossDomain == null) {
            urlAnchor = document.createElement("a"); // Support: IE <=8 - 11, Edge 12 - 15
            // IE throws exception on accessing the href property if url is malformed,
            // e.g. http://example.com:80x/

            try {
              urlAnchor.href = s.url; // Support: IE <=8 - 11 only
              // Anchor's host property isn't correctly set when s.url is relative

              urlAnchor.href = urlAnchor.href;
              s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
            } catch (e) {
              // If there is an error parsing the URL, assume it is crossDomain,
              // it can be rejected by the transport if it is invalid
              s.crossDomain = true;
            }
          } // Convert data if not already a string


          if (s.data && s.processData && typeof s.data !== "string") {
            s.data = jQuery.param(s.data, s.traditional);
          } // Apply prefilters


          inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there

          if (completed) {
            return jqXHR;
          } // We can fire global events as of now if asked to
          // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)


          fireGlobals = jQuery.event && s.global; // Watch for a new set of requests

          if (fireGlobals && jQuery.active++ === 0) {
            jQuery.event.trigger("ajaxStart");
          } // Uppercase the type


          s.type = s.type.toUpperCase(); // Determine if request has content

          s.hasContent = !rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since
          // and/or If-None-Match header later on
          // Remove hash to simplify url manipulation

          cacheURL = s.url.replace(rhash, ""); // More options handling for requests with no content

          if (!s.hasContent) {
            // Remember the hash so we can put it back
            uncached = s.url.slice(cacheURL.length); // If data is available and should be processed, append data to url

            if (s.data && (s.processData || typeof s.data === "string")) {
              cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data; // #9682: remove data so that it's not used in an eventual retry

              delete s.data;
            } // Add or update anti-cache param if needed


            if (s.cache === false) {
              cacheURL = cacheURL.replace(rantiCache, "$1");
              uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++ + uncached;
            } // Put hash and anti-cache on the URL that will be requested (gh-1732)


            s.url = cacheURL + uncached; // Change '%20' to '+' if this is encoded form body content (gh-2658)
          } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
            s.data = s.data.replace(r20, "+");
          } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.


          if (s.ifModified) {
            if (jQuery.lastModified[cacheURL]) {
              jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
            }

            if (jQuery.etag[cacheURL]) {
              jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
            }
          } // Set the correct header, if data is being sent


          if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
            jqXHR.setRequestHeader("Content-Type", s.contentType);
          } // Set the Accepts header for the server, depending on the dataType


          jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]); // Check for headers option

          for (i in s.headers) {
            jqXHR.setRequestHeader(i, s.headers[i]);
          } // Allow custom headers/mimetypes and early abort


          if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
            // Abort if not done already and return
            return jqXHR.abort();
          } // Aborting is no longer a cancellation


          strAbort = "abort"; // Install callbacks on deferreds

          completeDeferred.add(s.complete);
          jqXHR.done(s.success);
          jqXHR.fail(s.error); // Get transport

          transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort

          if (!transport) {
            done(-1, "No Transport");
          } else {
            jqXHR.readyState = 1; // Send global event

            if (fireGlobals) {
              globalEventContext.trigger("ajaxSend", [jqXHR, s]);
            } // If request was aborted inside ajaxSend, stop there


            if (completed) {
              return jqXHR;
            } // Timeout


            if (s.async && s.timeout > 0) {
              timeoutTimer = window.setTimeout(function () {
                jqXHR.abort("timeout");
              }, s.timeout);
            }

            try {
              completed = false;
              transport.send(requestHeaders, done);
            } catch (e) {
              // Rethrow post-completion exceptions
              if (completed) {
                throw e;
              } // Propagate others as results


              done(-1, e);
            }
          } // Callback for when everything is done


          function done(status, nativeStatusText, responses, headers) {
            var isSuccess,
                success,
                error,
                response,
                modified,
                statusText = nativeStatusText; // Ignore repeat invocations

            if (completed) {
              return;
            }

            completed = true; // Clear timeout if it exists

            if (timeoutTimer) {
              window.clearTimeout(timeoutTimer);
            } // Dereference transport for early garbage collection
            // (no matter how long the jqXHR object will be used)


            transport = undefined; // Cache response headers

            responseHeadersString = headers || ""; // Set readyState

            jqXHR.readyState = status > 0 ? 4 : 0; // Determine if successful

            isSuccess = status >= 200 && status < 300 || status === 304; // Get response data

            if (responses) {
              response = ajaxHandleResponses(s, jqXHR, responses);
            } // Convert no matter what (that way responseXXX fields are always set)


            response = ajaxConvert(s, response, jqXHR, isSuccess); // If successful, handle type chaining

            if (isSuccess) {
              // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
              if (s.ifModified) {
                modified = jqXHR.getResponseHeader("Last-Modified");

                if (modified) {
                  jQuery.lastModified[cacheURL] = modified;
                }

                modified = jqXHR.getResponseHeader("etag");

                if (modified) {
                  jQuery.etag[cacheURL] = modified;
                }
              } // if no content


              if (status === 204 || s.type === "HEAD") {
                statusText = "nocontent"; // if not modified
              } else if (status === 304) {
                statusText = "notmodified"; // If we have data, let's convert it
              } else {
                statusText = response.state;
                success = response.data;
                error = response.error;
                isSuccess = !error;
              }
            } else {
              // Extract error from statusText and normalize for non-aborts
              error = statusText;

              if (status || !statusText) {
                statusText = "error";

                if (status < 0) {
                  status = 0;
                }
              }
            } // Set data for the fake xhr object


            jqXHR.status = status;
            jqXHR.statusText = (nativeStatusText || statusText) + ""; // Success/Error

            if (isSuccess) {
              deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
            } else {
              deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
            } // Status-dependent callbacks


            jqXHR.statusCode(_statusCode);
            _statusCode = undefined;

            if (fireGlobals) {
              globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
            } // Complete


            completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

            if (fireGlobals) {
              globalEventContext.trigger("ajaxComplete", [jqXHR, s]); // Handle the global AJAX counter

              if (! --jQuery.active) {
                jQuery.event.trigger("ajaxStop");
              }
            }
          }

          return jqXHR;
        },
        getJSON: function getJSON(url, data, callback) {
          return jQuery.get(url, data, callback, "json");
        },
        getScript: function getScript(url, callback) {
          return jQuery.get(url, undefined, callback, "script");
        }
      });
      jQuery.each(["get", "post"], function (i, method) {
        jQuery[method] = function (url, data, callback, type) {
          // Shift arguments if data argument was omitted
          if (isFunction(data)) {
            type = type || callback;
            callback = data;
            data = undefined;
          } // The url can be an options object (which then must have .url)


          return jQuery.ajax(jQuery.extend({
            url: url,
            type: method,
            dataType: type,
            data: data,
            success: callback
          }, jQuery.isPlainObject(url) && url));
        };
      });

      jQuery._evalUrl = function (url, options) {
        return jQuery.ajax({
          url: url,
          // Make this explicit, since user can override this through ajaxSetup (#11264)
          type: "GET",
          dataType: "script",
          cache: true,
          async: false,
          global: false,
          // Only evaluate the response if it is successful (gh-4126)
          // dataFilter is not invoked for failure responses, so using it instead
          // of the default converter is kludgy but it works.
          converters: {
            "text script": function textScript() {}
          },
          dataFilter: function dataFilter(response) {
            jQuery.globalEval(response, options);
          }
        });
      };

      jQuery.fn.extend({
        wrapAll: function wrapAll(html) {
          var wrap;

          if (this[0]) {
            if (isFunction(html)) {
              html = html.call(this[0]);
            } // The elements to wrap the target around


            wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

            if (this[0].parentNode) {
              wrap.insertBefore(this[0]);
            }

            wrap.map(function () {
              var elem = this;

              while (elem.firstElementChild) {
                elem = elem.firstElementChild;
              }

              return elem;
            }).append(this);
          }

          return this;
        },
        wrapInner: function wrapInner(html) {
          if (isFunction(html)) {
            return this.each(function (i) {
              jQuery(this).wrapInner(html.call(this, i));
            });
          }

          return this.each(function () {
            var self = jQuery(this),
                contents = self.contents();

            if (contents.length) {
              contents.wrapAll(html);
            } else {
              self.append(html);
            }
          });
        },
        wrap: function wrap(html) {
          var htmlIsFunction = isFunction(html);
          return this.each(function (i) {
            jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
          });
        },
        unwrap: function unwrap(selector) {
          this.parent(selector).not("body").each(function () {
            jQuery(this).replaceWith(this.childNodes);
          });
          return this;
        }
      });

      jQuery.expr.pseudos.hidden = function (elem) {
        return !jQuery.expr.pseudos.visible(elem);
      };

      jQuery.expr.pseudos.visible = function (elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
      };

      jQuery.ajaxSettings.xhr = function () {
        try {
          return new window.XMLHttpRequest();
        } catch (e) {}
      };

      var xhrSuccessStatus = {
        // File protocol always yields status code 0, assume 200
        0: 200,
        // Support: IE <=9 only
        // #1450: sometimes IE returns 1223 when it should be 204
        1223: 204
      },
          xhrSupported = jQuery.ajaxSettings.xhr();
      support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
      support.ajax = xhrSupported = !!xhrSupported;
      jQuery.ajaxTransport(function (options) {
        var _callback2, errorCallback; // Cross domain only allowed if supported through XMLHttpRequest


        if (support.cors || xhrSupported && !options.crossDomain) {
          return {
            send: function send(headers, complete) {
              var i,
                  xhr = options.xhr();
              xhr.open(options.type, options.url, options.async, options.username, options.password); // Apply custom fields if provided

              if (options.xhrFields) {
                for (i in options.xhrFields) {
                  xhr[i] = options.xhrFields[i];
                }
              } // Override mime type if needed


              if (options.mimeType && xhr.overrideMimeType) {
                xhr.overrideMimeType(options.mimeType);
              } // X-Requested-With header
              // For cross-domain requests, seeing as conditions for a preflight are
              // akin to a jigsaw puzzle, we simply never set it to be sure.
              // (it can always be set on a per-request basis or even using ajaxSetup)
              // For same-domain requests, won't change header if already provided.


              if (!options.crossDomain && !headers["X-Requested-With"]) {
                headers["X-Requested-With"] = "XMLHttpRequest";
              } // Set headers


              for (i in headers) {
                xhr.setRequestHeader(i, headers[i]);
              } // Callback


              _callback2 = function callback(type) {
                return function () {
                  if (_callback2) {
                    _callback2 = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;

                    if (type === "abort") {
                      xhr.abort();
                    } else if (type === "error") {
                      // Support: IE <=9 only
                      // On a manual native abort, IE9 throws
                      // errors on any property access that is not readyState
                      if (typeof xhr.status !== "number") {
                        complete(0, "error");
                      } else {
                        complete( // File: protocol always yields status 0; see #8605, #14207
                        xhr.status, xhr.statusText);
                      }
                    } else {
                      complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE <=9 only
                      // IE9 has no XHR2 but throws on binary (trac-11426)
                      // For XHR2 non-text, let the caller handle it (gh-2498)
                      (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
                        binary: xhr.response
                      } : {
                        text: xhr.responseText
                      }, xhr.getAllResponseHeaders());
                    }
                  }
                };
              }; // Listen to events


              xhr.onload = _callback2();
              errorCallback = xhr.onerror = xhr.ontimeout = _callback2("error"); // Support: IE 9 only
              // Use onreadystatechange to replace onabort
              // to handle uncaught aborts

              if (xhr.onabort !== undefined) {
                xhr.onabort = errorCallback;
              } else {
                xhr.onreadystatechange = function () {
                  // Check readyState before timeout as it changes
                  if (xhr.readyState === 4) {
                    // Allow onerror to be called first,
                    // but that will not handle a native abort
                    // Also, save errorCallback to a variable
                    // as xhr.onerror cannot be accessed
                    window.setTimeout(function () {
                      if (_callback2) {
                        errorCallback();
                      }
                    });
                  }
                };
              } // Create the abort callback


              _callback2 = _callback2("abort");

              try {
                // Do send the request (this may raise an exception)
                xhr.send(options.hasContent && options.data || null);
              } catch (e) {
                // #14683: Only rethrow if this hasn't been notified as an error yet
                if (_callback2) {
                  throw e;
                }
              }
            },
            abort: function abort() {
              if (_callback2) {
                _callback2();
              }
            }
          };
        }
      }); // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)

      jQuery.ajaxPrefilter(function (s) {
        if (s.crossDomain) {
          s.contents.script = false;
        }
      }); // Install script dataType

      jQuery.ajaxSetup({
        accepts: {
          script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
        },
        contents: {
          script: /\b(?:java|ecma)script\b/
        },
        converters: {
          "text script": function textScript(text) {
            jQuery.globalEval(text);
            return text;
          }
        }
      }); // Handle cache's special case and crossDomain

      jQuery.ajaxPrefilter("script", function (s) {
        if (s.cache === undefined) {
          s.cache = false;
        }

        if (s.crossDomain) {
          s.type = "GET";
        }
      }); // Bind script tag hack transport

      jQuery.ajaxTransport("script", function (s) {
        // This transport only deals with cross domain or forced-by-attrs requests
        if (s.crossDomain || s.scriptAttrs) {
          var script, _callback3;

          return {
            send: function send(_, complete) {
              script = jQuery("<script>").attr(s.scriptAttrs || {}).prop({
                charset: s.scriptCharset,
                src: s.url
              }).on("load error", _callback3 = function callback(evt) {
                script.remove();
                _callback3 = null;

                if (evt) {
                  complete(evt.type === "error" ? 404 : 200, evt.type);
                }
              }); // Use native DOM manipulation to avoid our domManip AJAX trickery

              document.head.appendChild(script[0]);
            },
            abort: function abort() {
              if (_callback3) {
                _callback3();
              }
            }
          };
        }
      });
      var oldCallbacks = [],
          rjsonp = /(=)\?(?=&|$)|\?\?/; // Default jsonp settings

      jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function jsonpCallback() {
          var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
          this[callback] = true;
          return callback;
        }
      }); // Detect, normalize options and install callbacks for jsonp requests

      jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
        var callbackName,
            overwritten,
            responseContainer,
            jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data"); // Handle iff the expected data type is "jsonp" or we have a parameter to set

        if (jsonProp || s.dataTypes[0] === "jsonp") {
          // Get callback name, remembering preexisting value associated with it
          callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback; // Insert callback into url or form data

          if (jsonProp) {
            s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
          } else if (s.jsonp !== false) {
            s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
          } // Use data converter to retrieve json after script execution


          s.converters["script json"] = function () {
            if (!responseContainer) {
              jQuery.error(callbackName + " was not called");
            }

            return responseContainer[0];
          }; // Force json dataType


          s.dataTypes[0] = "json"; // Install callback

          overwritten = window[callbackName];

          window[callbackName] = function () {
            responseContainer = arguments;
          }; // Clean-up function (fires after converters)


          jqXHR.always(function () {
            // If previous value didn't exist - remove it
            if (overwritten === undefined) {
              jQuery(window).removeProp(callbackName); // Otherwise restore preexisting value
            } else {
              window[callbackName] = overwritten;
            } // Save back as free


            if (s[callbackName]) {
              // Make sure that re-using the options doesn't screw things around
              s.jsonpCallback = originalSettings.jsonpCallback; // Save the callback name for future use

              oldCallbacks.push(callbackName);
            } // Call if it was a function and we have a response


            if (responseContainer && isFunction(overwritten)) {
              overwritten(responseContainer[0]);
            }

            responseContainer = overwritten = undefined;
          }); // Delegate to script

          return "script";
        }
      }); // Support: Safari 8 only
      // In Safari 8 documents created via document.implementation.createHTMLDocument
      // collapse sibling forms: the second one becomes a child of the first one.
      // Because of that, this security measure has to be disabled in Safari 8.
      // https://bugs.webkit.org/show_bug.cgi?id=137337

      support.createHTMLDocument = function () {
        var body = document.implementation.createHTMLDocument("").body;
        body.innerHTML = "<form></form><form></form>";
        return body.childNodes.length === 2;
      }(); // Argument "data" should be string of html
      // context (optional): If specified, the fragment will be created in this context,
      // defaults to document
      // keepScripts (optional): If true, will include scripts passed in the html string


      jQuery.parseHTML = function (data, context, keepScripts) {
        if (typeof data !== "string") {
          return [];
        }

        if (typeof context === "boolean") {
          keepScripts = context;
          context = false;
        }

        var base, parsed, scripts;

        if (!context) {
          // Stop scripts or inline event handlers from being executed immediately
          // by using document.implementation
          if (support.createHTMLDocument) {
            context = document.implementation.createHTMLDocument(""); // Set the base href for the created document
            // so any parsed elements with URLs
            // are based on the document's URL (gh-2965)

            base = context.createElement("base");
            base.href = document.location.href;
            context.head.appendChild(base);
          } else {
            context = document;
          }
        }

        parsed = rsingleTag.exec(data);
        scripts = !keepScripts && []; // Single tag

        if (parsed) {
          return [context.createElement(parsed[1])];
        }

        parsed = buildFragment([data], context, scripts);

        if (scripts && scripts.length) {
          jQuery(scripts).remove();
        }

        return jQuery.merge([], parsed.childNodes);
      };
      /**
       * Load a url into a page
       */


      jQuery.fn.load = function (url, params, callback) {
        var selector,
            type,
            response,
            self = this,
            off = url.indexOf(" ");

        if (off > -1) {
          selector = stripAndCollapse(url.slice(off));
          url = url.slice(0, off);
        } // If it's a function


        if (isFunction(params)) {
          // We assume that it's the callback
          callback = params;
          params = undefined; // Otherwise, build a param string
        } else if (params && typeof params === "object") {
          type = "POST";
        } // If we have elements to modify, make the request


        if (self.length > 0) {
          jQuery.ajax({
            url: url,
            // If "type" variable is undefined, then "GET" method will be used.
            // Make value of this field explicit since
            // user can override it through ajaxSetup method
            type: type || "GET",
            dataType: "html",
            data: params
          }).done(function (responseText) {
            // Save response for use in complete callback
            response = arguments;
            self.html(selector ? // If a selector was specified, locate the right elements in a dummy div
            // Exclude scripts to avoid IE 'Permission Denied' errors
            jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result
            responseText); // If the request succeeds, this function gets "data", "status", "jqXHR"
            // but they are ignored because response was set above.
            // If it fails, this function gets "jqXHR", "status", "error"
          }).always(callback && function (jqXHR, status) {
            self.each(function () {
              callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
            });
          });
        }

        return this;
      }; // Attach a bunch of functions for handling common AJAX events


      jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
        jQuery.fn[type] = function (fn) {
          return this.on(type, fn);
        };
      });

      jQuery.expr.pseudos.animated = function (elem) {
        return jQuery.grep(jQuery.timers, function (fn) {
          return elem === fn.elem;
        }).length;
      };

      jQuery.offset = {
        setOffset: function setOffset(elem, options, i) {
          var curPosition,
              curLeft,
              curCSSTop,
              curTop,
              curOffset,
              curCSSLeft,
              calculatePosition,
              position = jQuery.css(elem, "position"),
              curElem = jQuery(elem),
              props = {}; // Set position first, in-case top/left are set even on static elem

          if (position === "static") {
            elem.style.position = "relative";
          }

          curOffset = curElem.offset();
          curCSSTop = jQuery.css(elem, "top");
          curCSSLeft = jQuery.css(elem, "left");
          calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1; // Need to be able to calculate position if either
          // top or left is auto and position is either absolute or fixed

          if (calculatePosition) {
            curPosition = curElem.position();
            curTop = curPosition.top;
            curLeft = curPosition.left;
          } else {
            curTop = parseFloat(curCSSTop) || 0;
            curLeft = parseFloat(curCSSLeft) || 0;
          }

          if (isFunction(options)) {
            // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
            options = options.call(elem, i, jQuery.extend({}, curOffset));
          }

          if (options.top != null) {
            props.top = options.top - curOffset.top + curTop;
          }

          if (options.left != null) {
            props.left = options.left - curOffset.left + curLeft;
          }

          if ("using" in options) {
            options.using.call(elem, props);
          } else {
            curElem.css(props);
          }
        }
      };
      jQuery.fn.extend({
        // offset() relates an element's border box to the document origin
        offset: function offset(options) {
          // Preserve chaining for setter
          if (arguments.length) {
            return options === undefined ? this : this.each(function (i) {
              jQuery.offset.setOffset(this, options, i);
            });
          }

          var rect,
              win,
              elem = this[0];

          if (!elem) {
            return;
          } // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
          // Support: IE <=11 only
          // Running getBoundingClientRect on a
          // disconnected node in IE throws an error


          if (!elem.getClientRects().length) {
            return {
              top: 0,
              left: 0
            };
          } // Get document-relative position by adding viewport scroll to viewport-relative gBCR


          rect = elem.getBoundingClientRect();
          win = elem.ownerDocument.defaultView;
          return {
            top: rect.top + win.pageYOffset,
            left: rect.left + win.pageXOffset
          };
        },
        // position() relates an element's margin box to its offset parent's padding box
        // This corresponds to the behavior of CSS absolute positioning
        position: function position() {
          if (!this[0]) {
            return;
          }

          var offsetParent,
              offset,
              doc,
              elem = this[0],
              parentOffset = {
            top: 0,
            left: 0
          }; // position:fixed elements are offset from the viewport, which itself always has zero offset

          if (jQuery.css(elem, "position") === "fixed") {
            // Assume position:fixed implies availability of getBoundingClientRect
            offset = elem.getBoundingClientRect();
          } else {
            offset = this.offset(); // Account for the *real* offset parent, which can be the document or its root element
            // when a statically positioned element is identified

            doc = elem.ownerDocument;
            offsetParent = elem.offsetParent || doc.documentElement;

            while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
              offsetParent = offsetParent.parentNode;
            }

            if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
              // Incorporate borders into its offset, since they are outside its content origin
              parentOffset = jQuery(offsetParent).offset();
              parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
              parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
            }
          } // Subtract parent offsets and element margins


          return {
            top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
            left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
          };
        },
        // This method will return documentElement in the following cases:
        // 1) For the element inside the iframe without offsetParent, this method will return
        //    documentElement of the parent window
        // 2) For the hidden or detached element
        // 3) For body or html element, i.e. in case of the html node - it will return itself
        //
        // but those exceptions were never presented as a real life use-cases
        // and might be considered as more preferable results.
        //
        // This logic, however, is not guaranteed and can change at any point in the future
        offsetParent: function offsetParent() {
          return this.map(function () {
            var offsetParent = this.offsetParent;

            while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
              offsetParent = offsetParent.offsetParent;
            }

            return offsetParent || documentElement;
          });
        }
      }); // Create scrollLeft and scrollTop methods

      jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
      }, function (method, prop) {
        var top = "pageYOffset" === prop;

        jQuery.fn[method] = function (val) {
          return access(this, function (elem, method, val) {
            // Coalesce documents and windows
            var win;

            if (isWindow(elem)) {
              win = elem;
            } else if (elem.nodeType === 9) {
              win = elem.defaultView;
            }

            if (val === undefined) {
              return win ? win[prop] : elem[method];
            }

            if (win) {
              win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
            } else {
              elem[method] = val;
            }
          }, method, val, arguments.length);
        };
      }); // Support: Safari <=7 - 9.1, Chrome <=37 - 49
      // Add the top/left cssHooks using jQuery.fn.position
      // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
      // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
      // getComputedStyle returns percent when specified for top/left/bottom/right;
      // rather than make the css module depend on the offset module, just check for it here

      jQuery.each(["top", "left"], function (i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
          if (computed) {
            computed = curCSS(elem, prop); // If curCSS returns percentage, fallback to offset

            return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
          }
        });
      }); // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods

      jQuery.each({
        Height: "height",
        Width: "width"
      }, function (name, type) {
        jQuery.each({
          padding: "inner" + name,
          content: type,
          "": "outer" + name
        }, function (defaultExtra, funcName) {
          // Margin is only for outerHeight, outerWidth
          jQuery.fn[funcName] = function (margin, value) {
            var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
                extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
            return access(this, function (elem, type, value) {
              var doc;

              if (isWindow(elem)) {
                // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
                return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
              } // Get document width or height


              if (elem.nodeType === 9) {
                doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                // whichever is greatest

                return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
              }

              return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat
              jQuery.css(elem, type, extra) : // Set width or height on the element
              jQuery.style(elem, type, value, extra);
            }, type, chainable ? margin : undefined, chainable);
          };
        });
      });
      jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function (i, name) {
        // Handle event binding
        jQuery.fn[name] = function (data, fn) {
          return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
      });
      jQuery.fn.extend({
        hover: function hover(fnOver, fnOut) {
          return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
      });
      jQuery.fn.extend({
        bind: function bind(types, data, fn) {
          return this.on(types, null, data, fn);
        },
        unbind: function unbind(types, fn) {
          return this.off(types, null, fn);
        },
        delegate: function delegate(selector, types, data, fn) {
          return this.on(types, selector, data, fn);
        },
        undelegate: function undelegate(selector, types, fn) {
          // ( namespace ) or ( selector, types [, fn] )
          return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        }
      }); // Bind a function to a context, optionally partially applying any
      // arguments.
      // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
      // However, it is not slated for removal any time soon

      jQuery.proxy = function (fn, context) {
        var tmp, args, proxy;

        if (typeof context === "string") {
          tmp = fn[context];
          context = fn;
          fn = tmp;
        } // Quick check to determine if target is callable, in the spec
        // this throws a TypeError, but we will just return undefined.


        if (!isFunction(fn)) {
          return undefined;
        } // Simulated bind


        args = _slice.call(arguments, 2);

        proxy = function proxy() {
          return fn.apply(context || this, args.concat(_slice.call(arguments)));
        }; // Set the guid of unique handler to the same of original handler, so it can be removed


        proxy.guid = fn.guid = fn.guid || jQuery.guid++;
        return proxy;
      };

      jQuery.holdReady = function (hold) {
        if (hold) {
          jQuery.readyWait++;
        } else {
          jQuery.ready(true);
        }
      };

      jQuery.isArray = Array.isArray;
      jQuery.parseJSON = JSON.parse;
      jQuery.nodeName = nodeName;
      jQuery.isFunction = isFunction;
      jQuery.isWindow = isWindow;
      jQuery.camelCase = camelCase;
      jQuery.type = toType;
      jQuery.now = Date.now;

      jQuery.isNumeric = function (obj) {
        // As of jQuery 3.0, isNumeric is limited to
        // strings and numbers (primitives or objects)
        // that can be coerced to finite numbers (gh-2662)
        var type = jQuery.type(obj);
        return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
        // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
        // subtraction forces infinities to NaN
        !isNaN(obj - parseFloat(obj));
      }; // Register as a named AMD module, since jQuery can be concatenated with other
      // files that may use define, but not via a proper concatenation script that
      // understands anonymous AMD modules. A named AMD is safest and most robust
      // way to register. Lowercase jquery is used because AMD module names are
      // derived from file names, and jQuery is normally delivered in a lowercase
      // file name. Do this after creating the global so that if an AMD module wants
      // to call noConflict to hide this version of jQuery, it will work.
      // Note that for maximum portability, libraries that are not jQuery should
      // declare themselves as anonymous modules, and avoid setting a global if an
      // AMD loader is present. jQuery is a special case. For more information, see
      // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon


      if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
          return jQuery;
        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      }

      var // Map over jQuery in case of overwrite
      _jQuery = window.jQuery,
          // Map over the $ in case of overwrite
      _$ = window.$;

      jQuery.noConflict = function (deep) {
        if (window.$ === jQuery) {
          window.$ = _$;
        }

        if (deep && window.jQuery === jQuery) {
          window.jQuery = _jQuery;
        }

        return jQuery;
      }; // Expose jQuery and $ identifiers, even in AMD
      // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
      // and CommonJS for browser emulators (#13566)


      if (!noGlobal) {
        window.jQuery = window.$ = jQuery;
      }

      return jQuery;
    });
    /***/

  },

  /***/
  "./node_modules/regenerator-runtime/runtime.js":
  /*!*****************************************************!*\
    !*** ./node_modules/regenerator-runtime/runtime.js ***!
    \*****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesRegeneratorRuntimeRuntimeJs(module, exports, __webpack_require__) {
    /**
     * Copyright (c) 2014-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var runtime = function (exports) {
      "use strict";

      var Op = Object.prototype;
      var hasOwn = Op.hasOwnProperty;
      var undefined; // More compressible than void 0.

      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

      function wrap(innerFn, outerFn, self, tryLocsList) {
        // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
        // .throw, and .return methods.

        generator._invoke = makeInvokeMethod(innerFn, self, context);
        return generator;
      }

      exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
      // record like context.tryEntries[i].completion. This interface could
      // have been (and was previously) designed to take a closure to be
      // invoked without arguments, but in all the cases we care about we
      // already have an existing method we want to call, so there's no need
      // to create a new function object. We can even get away with assuming
      // the method takes exactly one argument, since that happens to be true
      // in every case, so we don't have to touch the arguments object. The
      // only additional allocation required is the completion record, which
      // has a stable shape and so hopefully should be cheap to allocate.

      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }

      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
      // breaking out of the dispatch switch statement.

      var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
      // .constructor.prototype properties for functions that return Generator
      // objects. For full spec compliance, you may wish to configure your
      // minifier not to mangle the names of these two functions.

      function Generator() {}

      function GeneratorFunction() {}

      function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
      // don't natively support it.


      var IteratorPrototype = {};

      IteratorPrototype[iteratorSymbol] = function () {
        return this;
      };

      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        // This environment has a native %IteratorPrototype%; use it instead
        // of the polyfill.
        IteratorPrototype = NativeIteratorPrototype;
      }

      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
      GeneratorFunctionPrototype.constructor = GeneratorFunction;
      GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
      // Iterator interface in terms of a single ._invoke method.

      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function (method) {
          prototype[method] = function (arg) {
            return this._invoke(method, arg);
          };
        });
      }

      exports.isGeneratorFunction = function (genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };

      exports.mark = function (genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;

          if (!(toStringTagSymbol in genFun)) {
            genFun[toStringTagSymbol] = "GeneratorFunction";
          }
        }

        genFun.prototype = Object.create(Gp);
        return genFun;
      }; // Within the body of any async function, `await x` is transformed to
      // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
      // `hasOwn.call(value, "__await")` to determine if the yielded value is
      // meant to be awaited.


      exports.awrap = function (arg) {
        return {
          __await: arg
        };
      };

      function AsyncIterator(generator) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);

          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;

            if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
              return Promise.resolve(value.__await).then(function (value) {
                invoke("next", value, resolve, reject);
              }, function (err) {
                invoke("throw", err, resolve, reject);
              });
            }

            return Promise.resolve(value).then(function (unwrapped) {
              // When a yielded Promise is resolved, its final value becomes
              // the .value of the Promise<{value,done}> result for the
              // current iteration.
              result.value = unwrapped;
              resolve(result);
            }, function (error) {
              // If a rejected Promise was yielded, throw the rejection back
              // into the async generator function so it can be handled there.
              return invoke("throw", error, resolve, reject);
            });
          }
        }

        var previousPromise;

        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new Promise(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }

          return previousPromise = // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } // Define the unified helper method that is used to implement .next,
        // .throw, and .return (see defineIteratorMethods).


        this._invoke = enqueue;
      }

      defineIteratorMethods(AsyncIterator.prototype);

      AsyncIterator.prototype[asyncIteratorSymbol] = function () {
        return this;
      };

      exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
      // AsyncIterator objects; they just return a Promise for the value of
      // the final result produced by the iterator.

      exports.async = function (innerFn, outerFn, self, tryLocsList) {
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
        return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
        : iter.next().then(function (result) {
          return result.done ? result.value : iter.next();
        });
      };

      function makeInvokeMethod(innerFn, self, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }

          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            } // Be forgiving, per 25.3.3.3.3 of the spec:
            // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


            return doneResult();
          }

          context.method = method;
          context.arg = arg;

          while (true) {
            var delegate = context.delegate;

            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);

              if (delegateResult) {
                if (delegateResult === ContinueSentinel) continue;
                return delegateResult;
              }
            }

            if (context.method === "next") {
              // Setting context._sent for legacy support of Babel's
              // function.sent implementation.
              context.sent = context._sent = context.arg;
            } else if (context.method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context.arg;
              }

              context.dispatchException(context.arg);
            } else if (context.method === "return") {
              context.abrupt("return", context.arg);
            }

            state = GenStateExecuting;
            var record = tryCatch(innerFn, self, context);

            if (record.type === "normal") {
              // If an exception is thrown from innerFn, we leave state ===
              // GenStateExecuting and loop back for another invocation.
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;

              if (record.arg === ContinueSentinel) {
                continue;
              }

              return {
                value: record.arg,
                done: context.done
              };
            } else if (record.type === "throw") {
              state = GenStateCompleted; // Dispatch the exception by looping back around to the
              // context.dispatchException(context.arg) call above.

              context.method = "throw";
              context.arg = record.arg;
            }
          }
        };
      } // Call delegate.iterator[context.method](context.arg) and handle the
      // result, either by returning a { value, done } result from the
      // delegate iterator, or by modifying context.method and context.arg,
      // setting context.delegate to null, and returning the ContinueSentinel.


      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];

        if (method === undefined) {
          // A .throw or .return when the delegate iterator has no .throw
          // method always terminates the yield* loop.
          context.delegate = null;

          if (context.method === "throw") {
            // Note: ["return"] must be used for ES3 parsing compatibility.
            if (delegate.iterator["return"]) {
              // If the delegate iterator has a return method, give it a
              // chance to clean up.
              context.method = "return";
              context.arg = undefined;
              maybeInvokeDelegate(delegate, context);

              if (context.method === "throw") {
                // If maybeInvokeDelegate(context) changed context.method from
                // "return" to "throw", let that override the TypeError below.
                return ContinueSentinel;
              }
            }

            context.method = "throw";
            context.arg = new TypeError("The iterator does not provide a 'throw' method");
          }

          return ContinueSentinel;
        }

        var record = tryCatch(method, delegate.iterator, context.arg);

        if (record.type === "throw") {
          context.method = "throw";
          context.arg = record.arg;
          context.delegate = null;
          return ContinueSentinel;
        }

        var info = record.arg;

        if (!info) {
          context.method = "throw";
          context.arg = new TypeError("iterator result is not an object");
          context.delegate = null;
          return ContinueSentinel;
        }

        if (info.done) {
          // Assign the result of the finished delegate to the temporary
          // variable specified by delegate.resultName (see delegateYield).
          context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

          context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
          // exception, let the outer generator proceed normally. If
          // context.method was "next", forget context.arg since it has been
          // "consumed" by the delegate iterator. If context.method was
          // "return", allow the original .return call to continue in the
          // outer generator.

          if (context.method !== "return") {
            context.method = "next";
            context.arg = undefined;
          }
        } else {
          // Re-yield the result returned by the delegate method.
          return info;
        } // The delegate iterator is finished, so forget it and continue with
        // the outer generator.


        context.delegate = null;
        return ContinueSentinel;
      } // Define Generator.prototype.{next,throw,return} in terms of the
      // unified ._invoke helper method.


      defineIteratorMethods(Gp);
      Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
      // @@iterator function is called on it. Some browsers' implementations of the
      // iterator prototype chain incorrectly implement this, causing the Generator
      // object to not be returned from this call. This ensures that doesn't happen.
      // See https://github.com/facebook/regenerator/issues/274 for more details.

      Gp[iteratorSymbol] = function () {
        return this;
      };

      Gp.toString = function () {
        return "[object Generator]";
      };

      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };

        if (1 in locs) {
          entry.catchLoc = locs[1];
        }

        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }

        this.tryEntries.push(entry);
      }

      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }

      function Context(tryLocsList) {
        // The root entry object (effectively a try statement without a catch
        // or a finally block) gives us a place to store values thrown from
        // locations where there is no enclosing try statement.
        this.tryEntries = [{
          tryLoc: "root"
        }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }

      exports.keys = function (object) {
        var keys = [];

        for (var key in object) {
          keys.push(key);
        }

        keys.reverse(); // Rather than returning an object with a next method, we keep
        // things simple and return the next function itself.

        return function next() {
          while (keys.length) {
            var key = keys.pop();

            if (key in object) {
              next.value = key;
              next.done = false;
              return next;
            }
          } // To avoid creating an additional object, we just hang the .value
          // and .done properties off the next function object itself. This
          // also ensures that the minifier will not anonymize the function.


          next.done = true;
          return next;
        };
      };

      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];

          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }

          if (typeof iterable.next === "function") {
            return iterable;
          }

          if (!isNaN(iterable.length)) {
            var i = -1,
                next = function next() {
              while (++i < iterable.length) {
                if (hasOwn.call(iterable, i)) {
                  next.value = iterable[i];
                  next.done = false;
                  return next;
                }
              }

              next.value = undefined;
              next.done = true;
              return next;
            };

            return next.next = next;
          }
        } // Return an iterator with no values.


        return {
          next: doneResult
        };
      }

      exports.values = values;

      function doneResult() {
        return {
          value: undefined,
          done: true
        };
      }

      Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          this.prev = 0;
          this.next = 0; // Resetting context._sent for legacy support of Babel's
          // function.sent implementation.

          this.sent = this._sent = undefined;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined;
          this.tryEntries.forEach(resetTryEntry);

          if (!skipTempReset) {
            for (var name in this) {
              // Not sure about the optimal order of these conditions:
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined;
              }
            }
          }
        },
        stop: function stop() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;

          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }

          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done) {
            throw exception;
          }

          var context = this;

          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;

            if (caught) {
              // If the dispatched exception was caught by a catch block,
              // then let that catch block handle the exception normally.
              context.method = "next";
              context.arg = undefined;
            }

            return !!caught;
          }

          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;

            if (entry.tryLoc === "root") {
              // Exception thrown outside of any try block that could handle
              // it, so set the completion value of the entire function to
              // throw the exception.
              return handle("end");
            }

            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");

              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }

          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            // Ignore the finally entry if control is not jumping to a
            // location outside the try/catch block.
            finallyEntry = null;
          }

          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;

          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }

          return this.complete(record);
        },
        complete: function complete(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }

          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }

          return ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;

              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }

              return thrown;
            }
          } // The context.catch method must only be called with a location
          // argument that corresponds to a known catch block.


          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName: resultName,
            nextLoc: nextLoc
          };

          if (this.method === "next") {
            // Deliberately forget the last sent value so that we don't
            // accidentally pass it on to the delegate.
            this.arg = undefined;
          }

          return ContinueSentinel;
        }
      }; // Regardless of whether this script is executing as a CommonJS module
      // or not, return the runtime object so that we can declare the variable
      // regeneratorRuntime in the outer scope, which allows this module to be
      // injected easily by `bin/regenerator --include-runtime script.js`.

      return exports;
    }( // If this script is executing as a CommonJS module, use module.exports
    // as the regeneratorRuntime namespace. Otherwise create a new empty
    // object. Either way, the resulting object will be used to initialize
    // the regeneratorRuntime variable at the top of this file.
    true ? module.exports : undefined);

    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      // This module should not be running in strict mode, so the above
      // assignment should always work unless something is misconfigured. Just
      // in case runtime.js accidentally runs in strict mode, we can escape
      // strict mode using a global Function call. This could conceivably fail
      // if a Content Security Policy forbids using Function, but in that case
      // the proper solution is to fix the accidental strict mode problem. If
      // you've misconfigured your bundler to force strict mode and applied a
      // CSP to forbid Function, and you're not willing to fix either of those
      // problems, please detail your unique predicament in a GitHub issue.
      Function("r", "regeneratorRuntime = r")(runtime);
    }
    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/index.js":
  /*!*********************************************!*\
    !*** ./node_modules/rxjs/_esm2015/index.js ***!
    \*********************************************/

  /*! exports provided: Observable, ConnectableObservable, GroupedObservable, observable, Subject, BehaviorSubject, ReplaySubject, AsyncSubject, asapScheduler, asyncScheduler, queueScheduler, animationFrameScheduler, VirtualTimeScheduler, VirtualAction, Scheduler, Subscription, Subscriber, Notification, pipe, noop, identity, isObservable, ArgumentOutOfRangeError, EmptyError, ObjectUnsubscribedError, UnsubscriptionError, TimeoutError, bindCallback, bindNodeCallback, combineLatest, concat, defer, empty, forkJoin, from, fromEvent, fromEventPattern, generate, iif, interval, merge, never, of, onErrorResumeNext, pairs, race, range, throwError, timer, using, zip, EMPTY, NEVER, config */

  /***/
  function node_modulesRxjs_esm2015IndexJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony import */


    var _internal_Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./internal/Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "Observable", function () {
      return _internal_Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"];
    });
    /* harmony import */


    var _internal_observable_ConnectableObservable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./internal/observable/ConnectableObservable */
    "./node_modules/rxjs/_esm2015/internal/observable/ConnectableObservable.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "ConnectableObservable", function () {
      return _internal_observable_ConnectableObservable__WEBPACK_IMPORTED_MODULE_1__["ConnectableObservable"];
    });
    /* harmony import */


    var _internal_operators_groupBy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./internal/operators/groupBy */
    "./node_modules/rxjs/_esm2015/internal/operators/groupBy.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "GroupedObservable", function () {
      return _internal_operators_groupBy__WEBPACK_IMPORTED_MODULE_2__["GroupedObservable"];
    });
    /* harmony import */


    var _internal_symbol_observable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./internal/symbol/observable */
    "./node_modules/rxjs/_esm2015/internal/symbol/observable.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "observable", function () {
      return _internal_symbol_observable__WEBPACK_IMPORTED_MODULE_3__["observable"];
    });
    /* harmony import */


    var _internal_Subject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ./internal/Subject */
    "./node_modules/rxjs/_esm2015/internal/Subject.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "Subject", function () {
      return _internal_Subject__WEBPACK_IMPORTED_MODULE_4__["Subject"];
    });
    /* harmony import */


    var _internal_BehaviorSubject__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! ./internal/BehaviorSubject */
    "./node_modules/rxjs/_esm2015/internal/BehaviorSubject.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "BehaviorSubject", function () {
      return _internal_BehaviorSubject__WEBPACK_IMPORTED_MODULE_5__["BehaviorSubject"];
    });
    /* harmony import */


    var _internal_ReplaySubject__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! ./internal/ReplaySubject */
    "./node_modules/rxjs/_esm2015/internal/ReplaySubject.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "ReplaySubject", function () {
      return _internal_ReplaySubject__WEBPACK_IMPORTED_MODULE_6__["ReplaySubject"];
    });
    /* harmony import */


    var _internal_AsyncSubject__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
    /*! ./internal/AsyncSubject */
    "./node_modules/rxjs/_esm2015/internal/AsyncSubject.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "AsyncSubject", function () {
      return _internal_AsyncSubject__WEBPACK_IMPORTED_MODULE_7__["AsyncSubject"];
    });
    /* harmony import */


    var _internal_scheduler_asap__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
    /*! ./internal/scheduler/asap */
    "./node_modules/rxjs/_esm2015/internal/scheduler/asap.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "asapScheduler", function () {
      return _internal_scheduler_asap__WEBPACK_IMPORTED_MODULE_8__["asap"];
    });
    /* harmony import */


    var _internal_scheduler_async__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
    /*! ./internal/scheduler/async */
    "./node_modules/rxjs/_esm2015/internal/scheduler/async.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "asyncScheduler", function () {
      return _internal_scheduler_async__WEBPACK_IMPORTED_MODULE_9__["async"];
    });
    /* harmony import */


    var _internal_scheduler_queue__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
    /*! ./internal/scheduler/queue */
    "./node_modules/rxjs/_esm2015/internal/scheduler/queue.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "queueScheduler", function () {
      return _internal_scheduler_queue__WEBPACK_IMPORTED_MODULE_10__["queue"];
    });
    /* harmony import */


    var _internal_scheduler_animationFrame__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
    /*! ./internal/scheduler/animationFrame */
    "./node_modules/rxjs/_esm2015/internal/scheduler/animationFrame.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "animationFrameScheduler", function () {
      return _internal_scheduler_animationFrame__WEBPACK_IMPORTED_MODULE_11__["animationFrame"];
    });
    /* harmony import */


    var _internal_scheduler_VirtualTimeScheduler__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(
    /*! ./internal/scheduler/VirtualTimeScheduler */
    "./node_modules/rxjs/_esm2015/internal/scheduler/VirtualTimeScheduler.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "VirtualTimeScheduler", function () {
      return _internal_scheduler_VirtualTimeScheduler__WEBPACK_IMPORTED_MODULE_12__["VirtualTimeScheduler"];
    });
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "VirtualAction", function () {
      return _internal_scheduler_VirtualTimeScheduler__WEBPACK_IMPORTED_MODULE_12__["VirtualAction"];
    });
    /* harmony import */


    var _internal_Scheduler__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(
    /*! ./internal/Scheduler */
    "./node_modules/rxjs/_esm2015/internal/Scheduler.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "Scheduler", function () {
      return _internal_Scheduler__WEBPACK_IMPORTED_MODULE_13__["Scheduler"];
    });
    /* harmony import */


    var _internal_Subscription__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(
    /*! ./internal/Subscription */
    "./node_modules/rxjs/_esm2015/internal/Subscription.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "Subscription", function () {
      return _internal_Subscription__WEBPACK_IMPORTED_MODULE_14__["Subscription"];
    });
    /* harmony import */


    var _internal_Subscriber__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(
    /*! ./internal/Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "Subscriber", function () {
      return _internal_Subscriber__WEBPACK_IMPORTED_MODULE_15__["Subscriber"];
    });
    /* harmony import */


    var _internal_Notification__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(
    /*! ./internal/Notification */
    "./node_modules/rxjs/_esm2015/internal/Notification.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "Notification", function () {
      return _internal_Notification__WEBPACK_IMPORTED_MODULE_16__["Notification"];
    });
    /* harmony import */


    var _internal_util_pipe__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(
    /*! ./internal/util/pipe */
    "./node_modules/rxjs/_esm2015/internal/util/pipe.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "pipe", function () {
      return _internal_util_pipe__WEBPACK_IMPORTED_MODULE_17__["pipe"];
    });
    /* harmony import */


    var _internal_util_noop__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(
    /*! ./internal/util/noop */
    "./node_modules/rxjs/_esm2015/internal/util/noop.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "noop", function () {
      return _internal_util_noop__WEBPACK_IMPORTED_MODULE_18__["noop"];
    });
    /* harmony import */


    var _internal_util_identity__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(
    /*! ./internal/util/identity */
    "./node_modules/rxjs/_esm2015/internal/util/identity.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "identity", function () {
      return _internal_util_identity__WEBPACK_IMPORTED_MODULE_19__["identity"];
    });
    /* harmony import */


    var _internal_util_isObservable__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(
    /*! ./internal/util/isObservable */
    "./node_modules/rxjs/_esm2015/internal/util/isObservable.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "isObservable", function () {
      return _internal_util_isObservable__WEBPACK_IMPORTED_MODULE_20__["isObservable"];
    });
    /* harmony import */


    var _internal_util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(
    /*! ./internal/util/ArgumentOutOfRangeError */
    "./node_modules/rxjs/_esm2015/internal/util/ArgumentOutOfRangeError.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "ArgumentOutOfRangeError", function () {
      return _internal_util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_21__["ArgumentOutOfRangeError"];
    });
    /* harmony import */


    var _internal_util_EmptyError__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(
    /*! ./internal/util/EmptyError */
    "./node_modules/rxjs/_esm2015/internal/util/EmptyError.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "EmptyError", function () {
      return _internal_util_EmptyError__WEBPACK_IMPORTED_MODULE_22__["EmptyError"];
    });
    /* harmony import */


    var _internal_util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(
    /*! ./internal/util/ObjectUnsubscribedError */
    "./node_modules/rxjs/_esm2015/internal/util/ObjectUnsubscribedError.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "ObjectUnsubscribedError", function () {
      return _internal_util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_23__["ObjectUnsubscribedError"];
    });
    /* harmony import */


    var _internal_util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(
    /*! ./internal/util/UnsubscriptionError */
    "./node_modules/rxjs/_esm2015/internal/util/UnsubscriptionError.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "UnsubscriptionError", function () {
      return _internal_util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_24__["UnsubscriptionError"];
    });
    /* harmony import */


    var _internal_util_TimeoutError__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(
    /*! ./internal/util/TimeoutError */
    "./node_modules/rxjs/_esm2015/internal/util/TimeoutError.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "TimeoutError", function () {
      return _internal_util_TimeoutError__WEBPACK_IMPORTED_MODULE_25__["TimeoutError"];
    });
    /* harmony import */


    var _internal_observable_bindCallback__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(
    /*! ./internal/observable/bindCallback */
    "./node_modules/rxjs/_esm2015/internal/observable/bindCallback.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "bindCallback", function () {
      return _internal_observable_bindCallback__WEBPACK_IMPORTED_MODULE_26__["bindCallback"];
    });
    /* harmony import */


    var _internal_observable_bindNodeCallback__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(
    /*! ./internal/observable/bindNodeCallback */
    "./node_modules/rxjs/_esm2015/internal/observable/bindNodeCallback.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "bindNodeCallback", function () {
      return _internal_observable_bindNodeCallback__WEBPACK_IMPORTED_MODULE_27__["bindNodeCallback"];
    });
    /* harmony import */


    var _internal_observable_combineLatest__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(
    /*! ./internal/observable/combineLatest */
    "./node_modules/rxjs/_esm2015/internal/observable/combineLatest.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "combineLatest", function () {
      return _internal_observable_combineLatest__WEBPACK_IMPORTED_MODULE_28__["combineLatest"];
    });
    /* harmony import */


    var _internal_observable_concat__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(
    /*! ./internal/observable/concat */
    "./node_modules/rxjs/_esm2015/internal/observable/concat.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "concat", function () {
      return _internal_observable_concat__WEBPACK_IMPORTED_MODULE_29__["concat"];
    });
    /* harmony import */


    var _internal_observable_defer__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(
    /*! ./internal/observable/defer */
    "./node_modules/rxjs/_esm2015/internal/observable/defer.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "defer", function () {
      return _internal_observable_defer__WEBPACK_IMPORTED_MODULE_30__["defer"];
    });
    /* harmony import */


    var _internal_observable_empty__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(
    /*! ./internal/observable/empty */
    "./node_modules/rxjs/_esm2015/internal/observable/empty.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "empty", function () {
      return _internal_observable_empty__WEBPACK_IMPORTED_MODULE_31__["empty"];
    });
    /* harmony import */


    var _internal_observable_forkJoin__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(
    /*! ./internal/observable/forkJoin */
    "./node_modules/rxjs/_esm2015/internal/observable/forkJoin.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "forkJoin", function () {
      return _internal_observable_forkJoin__WEBPACK_IMPORTED_MODULE_32__["forkJoin"];
    });
    /* harmony import */


    var _internal_observable_from__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(
    /*! ./internal/observable/from */
    "./node_modules/rxjs/_esm2015/internal/observable/from.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "from", function () {
      return _internal_observable_from__WEBPACK_IMPORTED_MODULE_33__["from"];
    });
    /* harmony import */


    var _internal_observable_fromEvent__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(
    /*! ./internal/observable/fromEvent */
    "./node_modules/rxjs/_esm2015/internal/observable/fromEvent.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "fromEvent", function () {
      return _internal_observable_fromEvent__WEBPACK_IMPORTED_MODULE_34__["fromEvent"];
    });
    /* harmony import */


    var _internal_observable_fromEventPattern__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(
    /*! ./internal/observable/fromEventPattern */
    "./node_modules/rxjs/_esm2015/internal/observable/fromEventPattern.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "fromEventPattern", function () {
      return _internal_observable_fromEventPattern__WEBPACK_IMPORTED_MODULE_35__["fromEventPattern"];
    });
    /* harmony import */


    var _internal_observable_generate__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(
    /*! ./internal/observable/generate */
    "./node_modules/rxjs/_esm2015/internal/observable/generate.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "generate", function () {
      return _internal_observable_generate__WEBPACK_IMPORTED_MODULE_36__["generate"];
    });
    /* harmony import */


    var _internal_observable_iif__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(
    /*! ./internal/observable/iif */
    "./node_modules/rxjs/_esm2015/internal/observable/iif.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "iif", function () {
      return _internal_observable_iif__WEBPACK_IMPORTED_MODULE_37__["iif"];
    });
    /* harmony import */


    var _internal_observable_interval__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(
    /*! ./internal/observable/interval */
    "./node_modules/rxjs/_esm2015/internal/observable/interval.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "interval", function () {
      return _internal_observable_interval__WEBPACK_IMPORTED_MODULE_38__["interval"];
    });
    /* harmony import */


    var _internal_observable_merge__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(
    /*! ./internal/observable/merge */
    "./node_modules/rxjs/_esm2015/internal/observable/merge.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "merge", function () {
      return _internal_observable_merge__WEBPACK_IMPORTED_MODULE_39__["merge"];
    });
    /* harmony import */


    var _internal_observable_never__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(
    /*! ./internal/observable/never */
    "./node_modules/rxjs/_esm2015/internal/observable/never.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "never", function () {
      return _internal_observable_never__WEBPACK_IMPORTED_MODULE_40__["never"];
    });
    /* harmony import */


    var _internal_observable_of__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(
    /*! ./internal/observable/of */
    "./node_modules/rxjs/_esm2015/internal/observable/of.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "of", function () {
      return _internal_observable_of__WEBPACK_IMPORTED_MODULE_41__["of"];
    });
    /* harmony import */


    var _internal_observable_onErrorResumeNext__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(
    /*! ./internal/observable/onErrorResumeNext */
    "./node_modules/rxjs/_esm2015/internal/observable/onErrorResumeNext.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "onErrorResumeNext", function () {
      return _internal_observable_onErrorResumeNext__WEBPACK_IMPORTED_MODULE_42__["onErrorResumeNext"];
    });
    /* harmony import */


    var _internal_observable_pairs__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(
    /*! ./internal/observable/pairs */
    "./node_modules/rxjs/_esm2015/internal/observable/pairs.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "pairs", function () {
      return _internal_observable_pairs__WEBPACK_IMPORTED_MODULE_43__["pairs"];
    });
    /* harmony import */


    var _internal_observable_race__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(
    /*! ./internal/observable/race */
    "./node_modules/rxjs/_esm2015/internal/observable/race.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "race", function () {
      return _internal_observable_race__WEBPACK_IMPORTED_MODULE_44__["race"];
    });
    /* harmony import */


    var _internal_observable_range__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(
    /*! ./internal/observable/range */
    "./node_modules/rxjs/_esm2015/internal/observable/range.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "range", function () {
      return _internal_observable_range__WEBPACK_IMPORTED_MODULE_45__["range"];
    });
    /* harmony import */


    var _internal_observable_throwError__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(
    /*! ./internal/observable/throwError */
    "./node_modules/rxjs/_esm2015/internal/observable/throwError.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "throwError", function () {
      return _internal_observable_throwError__WEBPACK_IMPORTED_MODULE_46__["throwError"];
    });
    /* harmony import */


    var _internal_observable_timer__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(
    /*! ./internal/observable/timer */
    "./node_modules/rxjs/_esm2015/internal/observable/timer.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "timer", function () {
      return _internal_observable_timer__WEBPACK_IMPORTED_MODULE_47__["timer"];
    });
    /* harmony import */


    var _internal_observable_using__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(
    /*! ./internal/observable/using */
    "./node_modules/rxjs/_esm2015/internal/observable/using.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "using", function () {
      return _internal_observable_using__WEBPACK_IMPORTED_MODULE_48__["using"];
    });
    /* harmony import */


    var _internal_observable_zip__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(
    /*! ./internal/observable/zip */
    "./node_modules/rxjs/_esm2015/internal/observable/zip.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "zip", function () {
      return _internal_observable_zip__WEBPACK_IMPORTED_MODULE_49__["zip"];
    });
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "EMPTY", function () {
      return _internal_observable_empty__WEBPACK_IMPORTED_MODULE_31__["EMPTY"];
    });
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "NEVER", function () {
      return _internal_observable_never__WEBPACK_IMPORTED_MODULE_40__["NEVER"];
    });
    /* harmony import */


    var _internal_config__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(
    /*! ./internal/config */
    "./node_modules/rxjs/_esm2015/internal/config.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "config", function () {
      return _internal_config__WEBPACK_IMPORTED_MODULE_50__["config"];
    }); //# sourceMappingURL=index.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/AsyncSubject.js":
  /*!*************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/AsyncSubject.js ***!
    \*************************************************************/

  /*! exports provided: AsyncSubject */

  /***/
  function node_modulesRxjs_esm2015InternalAsyncSubjectJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AsyncSubject", function () {
      return AsyncSubject;
    });
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./Subject */
    "./node_modules/rxjs/_esm2015/internal/Subject.js");
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./Subscription */
    "./node_modules/rxjs/_esm2015/internal/Subscription.js");

    class AsyncSubject extends _Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"] {
      constructor() {
        super(...arguments);
        this.value = null;
        this.hasNext = false;
        this.hasCompleted = false;
      }

      _subscribe(subscriber) {
        if (this.hasError) {
          subscriber.error(this.thrownError);
          return _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"].EMPTY;
        } else if (this.hasCompleted && this.hasNext) {
          subscriber.next(this.value);
          subscriber.complete();
          return _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"].EMPTY;
        }

        return super._subscribe(subscriber);
      }

      next(value) {
        if (!this.hasCompleted) {
          this.value = value;
          this.hasNext = true;
        }
      }

      error(error) {
        if (!this.hasCompleted) {
          super.error(error);
        }
      }

      complete() {
        this.hasCompleted = true;

        if (this.hasNext) {
          super.next(this.value);
        }

        super.complete();
      }

    } //# sourceMappingURL=AsyncSubject.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/BehaviorSubject.js":
  /*!****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/BehaviorSubject.js ***!
    \****************************************************************/

  /*! exports provided: BehaviorSubject */

  /***/
  function node_modulesRxjs_esm2015InternalBehaviorSubjectJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "BehaviorSubject", function () {
      return BehaviorSubject;
    });
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./Subject */
    "./node_modules/rxjs/_esm2015/internal/Subject.js");
    /* harmony import */


    var _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./util/ObjectUnsubscribedError */
    "./node_modules/rxjs/_esm2015/internal/util/ObjectUnsubscribedError.js");

    class BehaviorSubject extends _Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"] {
      constructor(_value) {
        super();
        this._value = _value;
      }

      get value() {
        return this.getValue();
      }

      _subscribe(subscriber) {
        const subscription = super._subscribe(subscriber);

        if (subscription && !subscription.closed) {
          subscriber.next(this._value);
        }

        return subscription;
      }

      getValue() {
        if (this.hasError) {
          throw this.thrownError;
        } else if (this.closed) {
          throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_1__["ObjectUnsubscribedError"]();
        } else {
          return this._value;
        }
      }

      next(value) {
        super.next(this._value = value);
      }

    } //# sourceMappingURL=BehaviorSubject.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/InnerSubscriber.js":
  /*!****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/InnerSubscriber.js ***!
    \****************************************************************/

  /*! exports provided: InnerSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalInnerSubscriberJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "InnerSubscriber", function () {
      return InnerSubscriber;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");

    class InnerSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(parent, outerValue, outerIndex) {
        super();
        this.parent = parent;
        this.outerValue = outerValue;
        this.outerIndex = outerIndex;
        this.index = 0;
      }

      _next(value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
      }

      _error(error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
      }

      _complete() {
        this.parent.notifyComplete(this);
        this.unsubscribe();
      }

    } //# sourceMappingURL=InnerSubscriber.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/Notification.js":
  /*!*************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/Notification.js ***!
    \*************************************************************/

  /*! exports provided: NotificationKind, Notification */

  /***/
  function node_modulesRxjs_esm2015InternalNotificationJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NotificationKind", function () {
      return NotificationKind;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Notification", function () {
      return Notification;
    });
    /* harmony import */


    var _observable_empty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./observable/empty */
    "./node_modules/rxjs/_esm2015/internal/observable/empty.js");
    /* harmony import */


    var _observable_of__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./observable/of */
    "./node_modules/rxjs/_esm2015/internal/observable/of.js");
    /* harmony import */


    var _observable_throwError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./observable/throwError */
    "./node_modules/rxjs/_esm2015/internal/observable/throwError.js");

    var NotificationKind;

    (function (NotificationKind) {
      NotificationKind["NEXT"] = "N";
      NotificationKind["ERROR"] = "E";
      NotificationKind["COMPLETE"] = "C";
    })(NotificationKind || (NotificationKind = {}));

    class Notification {
      constructor(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === "N";
      }

      observe(observer) {
        switch (this.kind) {
          case "N":
            return observer.next && observer.next(this.value);

          case "E":
            return observer.error && observer.error(this.error);

          case "C":
            return observer.complete && observer.complete();
        }
      }

      do(next, error, complete) {
        const kind = this.kind;

        switch (kind) {
          case "N":
            return next && next(this.value);

          case "E":
            return error && error(this.error);

          case "C":
            return complete && complete();
        }
      }

      accept(nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
          return this.observe(nextOrObserver);
        } else {
          return this.do(nextOrObserver, error, complete);
        }
      }

      toObservable() {
        const kind = this.kind;

        switch (kind) {
          case "N":
            return Object(_observable_of__WEBPACK_IMPORTED_MODULE_1__["of"])(this.value);

          case "E":
            return Object(_observable_throwError__WEBPACK_IMPORTED_MODULE_2__["throwError"])(this.error);

          case "C":
            return Object(_observable_empty__WEBPACK_IMPORTED_MODULE_0__["empty"])();
        }

        throw new Error('unexpected notification kind value');
      }

      static createNext(value) {
        if (typeof value !== 'undefined') {
          return new Notification("N", value);
        }

        return Notification.undefinedValueNotification;
      }

      static createError(err) {
        return new Notification("E", undefined, err);
      }

      static createComplete() {
        return Notification.completeNotification;
      }

    }

    Notification.completeNotification = new Notification("C");
    Notification.undefinedValueNotification = new Notification("N", undefined); //# sourceMappingURL=Notification.js.map

    /***/
  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/Observable.js":
  /*!***********************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/Observable.js ***!
    \***********************************************************/

  /*! exports provided: Observable */

  /***/
  function node_modulesRxjs_esm2015InternalObservableJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Observable", function () {
      return Observable;
    });
    /* harmony import */


    var _util_canReportError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./util/canReportError */
    "./node_modules/rxjs/_esm2015/internal/util/canReportError.js");
    /* harmony import */


    var _util_toSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./util/toSubscriber */
    "./node_modules/rxjs/_esm2015/internal/util/toSubscriber.js");
    /* harmony import */


    var _internal_symbol_observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../internal/symbol/observable */
    "./node_modules/rxjs/_esm2015/internal/symbol/observable.js");
    /* harmony import */


    var _util_pipe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./util/pipe */
    "./node_modules/rxjs/_esm2015/internal/util/pipe.js");
    /* harmony import */


    var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ./config */
    "./node_modules/rxjs/_esm2015/internal/config.js");

    class Observable {
      constructor(subscribe) {
        this._isScalar = false;

        if (subscribe) {
          this._subscribe = subscribe;
        }
      }

      lift(operator) {
        const observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
      }

      subscribe(observerOrNext, error, complete) {
        const {
          operator
        } = this;
        const sink = Object(_util_toSubscriber__WEBPACK_IMPORTED_MODULE_1__["toSubscriber"])(observerOrNext, error, complete);

        if (operator) {
          sink.add(operator.call(sink, this.source));
        } else {
          sink.add(this.source || _config__WEBPACK_IMPORTED_MODULE_4__["config"].useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
        }

        if (_config__WEBPACK_IMPORTED_MODULE_4__["config"].useDeprecatedSynchronousErrorHandling) {
          if (sink.syncErrorThrowable) {
            sink.syncErrorThrowable = false;

            if (sink.syncErrorThrown) {
              throw sink.syncErrorValue;
            }
          }
        }

        return sink;
      }

      _trySubscribe(sink) {
        try {
          return this._subscribe(sink);
        } catch (err) {
          if (_config__WEBPACK_IMPORTED_MODULE_4__["config"].useDeprecatedSynchronousErrorHandling) {
            sink.syncErrorThrown = true;
            sink.syncErrorValue = err;
          }

          if (Object(_util_canReportError__WEBPACK_IMPORTED_MODULE_0__["canReportError"])(sink)) {
            sink.error(err);
          } else {
            console.warn(err);
          }
        }
      }

      forEach(next, promiseCtor) {
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor((resolve, reject) => {
          let subscription;
          subscription = this.subscribe(value => {
            try {
              next(value);
            } catch (err) {
              reject(err);

              if (subscription) {
                subscription.unsubscribe();
              }
            }
          }, reject, resolve);
        });
      }

      _subscribe(subscriber) {
        const {
          source
        } = this;
        return source && source.subscribe(subscriber);
      }

      [_internal_symbol_observable__WEBPACK_IMPORTED_MODULE_2__["observable"]]() {
        return this;
      }

      pipe(...operations) {
        if (operations.length === 0) {
          return this;
        }

        return Object(_util_pipe__WEBPACK_IMPORTED_MODULE_3__["pipeFromArray"])(operations)(this);
      }

      toPromise(promiseCtor) {
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor((resolve, reject) => {
          let value;
          this.subscribe(x => value = x, err => reject(err), () => resolve(value));
        });
      }

    }

    Observable.create = subscribe => {
      return new Observable(subscribe);
    };

    function getPromiseCtor(promiseCtor) {
      if (!promiseCtor) {
        promiseCtor = _config__WEBPACK_IMPORTED_MODULE_4__["config"].Promise || Promise;
      }

      if (!promiseCtor) {
        throw new Error('no Promise impl found');
      }

      return promiseCtor;
    } //# sourceMappingURL=Observable.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/Observer.js":
  /*!*********************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/Observer.js ***!
    \*********************************************************/

  /*! exports provided: empty */

  /***/
  function node_modulesRxjs_esm2015InternalObserverJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "empty", function () {
      return empty;
    });
    /* harmony import */


    var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./config */
    "./node_modules/rxjs/_esm2015/internal/config.js");
    /* harmony import */


    var _util_hostReportError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./util/hostReportError */
    "./node_modules/rxjs/_esm2015/internal/util/hostReportError.js");

    const empty = {
      closed: true,

      next(value) {},

      error(err) {
        if (_config__WEBPACK_IMPORTED_MODULE_0__["config"].useDeprecatedSynchronousErrorHandling) {
          throw err;
        } else {
          Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_1__["hostReportError"])(err);
        }
      },

      complete() {}

    }; //# sourceMappingURL=Observer.js.map

    /***/
  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js":
  /*!****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js ***!
    \****************************************************************/

  /*! exports provided: OuterSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalOuterSubscriberJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "OuterSubscriber", function () {
      return OuterSubscriber;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");

    class OuterSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
      }

      notifyError(error, innerSub) {
        this.destination.error(error);
      }

      notifyComplete(innerSub) {
        this.destination.complete();
      }

    } //# sourceMappingURL=OuterSubscriber.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/ReplaySubject.js":
  /*!**************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/ReplaySubject.js ***!
    \**************************************************************/

  /*! exports provided: ReplaySubject */

  /***/
  function node_modulesRxjs_esm2015InternalReplaySubjectJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ReplaySubject", function () {
      return ReplaySubject;
    });
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./Subject */
    "./node_modules/rxjs/_esm2015/internal/Subject.js");
    /* harmony import */


    var _scheduler_queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./scheduler/queue */
    "./node_modules/rxjs/_esm2015/internal/scheduler/queue.js");
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./Subscription */
    "./node_modules/rxjs/_esm2015/internal/Subscription.js");
    /* harmony import */


    var _operators_observeOn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./operators/observeOn */
    "./node_modules/rxjs/_esm2015/internal/operators/observeOn.js");
    /* harmony import */


    var _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ./util/ObjectUnsubscribedError */
    "./node_modules/rxjs/_esm2015/internal/util/ObjectUnsubscribedError.js");
    /* harmony import */


    var _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! ./SubjectSubscription */
    "./node_modules/rxjs/_esm2015/internal/SubjectSubscription.js");

    class ReplaySubject extends _Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"] {
      constructor(bufferSize = Number.POSITIVE_INFINITY, windowTime = Number.POSITIVE_INFINITY, scheduler) {
        super();
        this.scheduler = scheduler;
        this._events = [];
        this._infiniteTimeWindow = false;
        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        this._windowTime = windowTime < 1 ? 1 : windowTime;

        if (windowTime === Number.POSITIVE_INFINITY) {
          this._infiniteTimeWindow = true;
          this.next = this.nextInfiniteTimeWindow;
        } else {
          this.next = this.nextTimeWindow;
        }
      }

      nextInfiniteTimeWindow(value) {
        const _events = this._events;

        _events.push(value);

        if (_events.length > this._bufferSize) {
          _events.shift();
        }

        super.next(value);
      }

      nextTimeWindow(value) {
        this._events.push(new ReplayEvent(this._getNow(), value));

        this._trimBufferThenGetEvents();

        super.next(value);
      }

      _subscribe(subscriber) {
        const _infiniteTimeWindow = this._infiniteTimeWindow;

        const _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();

        const scheduler = this.scheduler;
        const len = _events.length;
        let subscription;

        if (this.closed) {
          throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__["ObjectUnsubscribedError"]();
        } else if (this.isStopped || this.hasError) {
          subscription = _Subscription__WEBPACK_IMPORTED_MODULE_2__["Subscription"].EMPTY;
        } else {
          this.observers.push(subscriber);
          subscription = new _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__["SubjectSubscription"](this, subscriber);
        }

        if (scheduler) {
          subscriber.add(subscriber = new _operators_observeOn__WEBPACK_IMPORTED_MODULE_3__["ObserveOnSubscriber"](subscriber, scheduler));
        }

        if (_infiniteTimeWindow) {
          for (let i = 0; i < len && !subscriber.closed; i++) {
            subscriber.next(_events[i]);
          }
        } else {
          for (let i = 0; i < len && !subscriber.closed; i++) {
            subscriber.next(_events[i].value);
          }
        }

        if (this.hasError) {
          subscriber.error(this.thrownError);
        } else if (this.isStopped) {
          subscriber.complete();
        }

        return subscription;
      }

      _getNow() {
        return (this.scheduler || _scheduler_queue__WEBPACK_IMPORTED_MODULE_1__["queue"]).now();
      }

      _trimBufferThenGetEvents() {
        const now = this._getNow();

        const _bufferSize = this._bufferSize;
        const _windowTime = this._windowTime;
        const _events = this._events;
        const eventsCount = _events.length;
        let spliceCount = 0;

        while (spliceCount < eventsCount) {
          if (now - _events[spliceCount].time < _windowTime) {
            break;
          }

          spliceCount++;
        }

        if (eventsCount > _bufferSize) {
          spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }

        if (spliceCount > 0) {
          _events.splice(0, spliceCount);
        }

        return _events;
      }

    }

    class ReplayEvent {
      constructor(time, value) {
        this.time = time;
        this.value = value;
      }

    } //# sourceMappingURL=ReplaySubject.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/Scheduler.js":
  /*!**********************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/Scheduler.js ***!
    \**********************************************************/

  /*! exports provided: Scheduler */

  /***/
  function node_modulesRxjs_esm2015InternalSchedulerJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Scheduler", function () {
      return Scheduler;
    });

    class Scheduler {
      constructor(SchedulerAction, now = Scheduler.now) {
        this.SchedulerAction = SchedulerAction;
        this.now = now;
      }

      schedule(work, delay = 0, state) {
        return new this.SchedulerAction(this, work).schedule(state, delay);
      }

    }

    Scheduler.now = () => Date.now(); //# sourceMappingURL=Scheduler.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/Subject.js":
  /*!********************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/Subject.js ***!
    \********************************************************/

  /*! exports provided: SubjectSubscriber, Subject, AnonymousSubject */

  /***/
  function node_modulesRxjs_esm2015InternalSubjectJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SubjectSubscriber", function () {
      return SubjectSubscriber;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Subject", function () {
      return Subject;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AnonymousSubject", function () {
      return AnonymousSubject;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./Subscription */
    "./node_modules/rxjs/_esm2015/internal/Subscription.js");
    /* harmony import */


    var _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./util/ObjectUnsubscribedError */
    "./node_modules/rxjs/_esm2015/internal/util/ObjectUnsubscribedError.js");
    /* harmony import */


    var _SubjectSubscription__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ./SubjectSubscription */
    "./node_modules/rxjs/_esm2015/internal/SubjectSubscription.js");
    /* harmony import */


    var _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! ../internal/symbol/rxSubscriber */
    "./node_modules/rxjs/_esm2015/internal/symbol/rxSubscriber.js");

    class SubjectSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"] {
      constructor(destination) {
        super(destination);
        this.destination = destination;
      }

    }

    class Subject extends _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"] {
      constructor() {
        super();
        this.observers = [];
        this.closed = false;
        this.isStopped = false;
        this.hasError = false;
        this.thrownError = null;
      }

      [_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_5__["rxSubscriber"]]() {
        return new SubjectSubscriber(this);
      }

      lift(operator) {
        const subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
      }

      next(value) {
        if (this.closed) {
          throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__["ObjectUnsubscribedError"]();
        }

        if (!this.isStopped) {
          const {
            observers
          } = this;
          const len = observers.length;
          const copy = observers.slice();

          for (let i = 0; i < len; i++) {
            copy[i].next(value);
          }
        }
      }

      error(err) {
        if (this.closed) {
          throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__["ObjectUnsubscribedError"]();
        }

        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        const {
          observers
        } = this;
        const len = observers.length;
        const copy = observers.slice();

        for (let i = 0; i < len; i++) {
          copy[i].error(err);
        }

        this.observers.length = 0;
      }

      complete() {
        if (this.closed) {
          throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__["ObjectUnsubscribedError"]();
        }

        this.isStopped = true;
        const {
          observers
        } = this;
        const len = observers.length;
        const copy = observers.slice();

        for (let i = 0; i < len; i++) {
          copy[i].complete();
        }

        this.observers.length = 0;
      }

      unsubscribe() {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
      }

      _trySubscribe(subscriber) {
        if (this.closed) {
          throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__["ObjectUnsubscribedError"]();
        } else {
          return super._trySubscribe(subscriber);
        }
      }

      _subscribe(subscriber) {
        if (this.closed) {
          throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_3__["ObjectUnsubscribedError"]();
        } else if (this.hasError) {
          subscriber.error(this.thrownError);
          return _Subscription__WEBPACK_IMPORTED_MODULE_2__["Subscription"].EMPTY;
        } else if (this.isStopped) {
          subscriber.complete();
          return _Subscription__WEBPACK_IMPORTED_MODULE_2__["Subscription"].EMPTY;
        } else {
          this.observers.push(subscriber);
          return new _SubjectSubscription__WEBPACK_IMPORTED_MODULE_4__["SubjectSubscription"](this, subscriber);
        }
      }

      asObservable() {
        const observable = new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"]();
        observable.source = this;
        return observable;
      }

    }

    Subject.create = (destination, source) => {
      return new AnonymousSubject(destination, source);
    };

    class AnonymousSubject extends Subject {
      constructor(destination, source) {
        super();
        this.destination = destination;
        this.source = source;
      }

      next(value) {
        const {
          destination
        } = this;

        if (destination && destination.next) {
          destination.next(value);
        }
      }

      error(err) {
        const {
          destination
        } = this;

        if (destination && destination.error) {
          this.destination.error(err);
        }
      }

      complete() {
        const {
          destination
        } = this;

        if (destination && destination.complete) {
          this.destination.complete();
        }
      }

      _subscribe(subscriber) {
        const {
          source
        } = this;

        if (source) {
          return this.source.subscribe(subscriber);
        } else {
          return _Subscription__WEBPACK_IMPORTED_MODULE_2__["Subscription"].EMPTY;
        }
      }

    } //# sourceMappingURL=Subject.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/SubjectSubscription.js":
  /*!********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/SubjectSubscription.js ***!
    \********************************************************************/

  /*! exports provided: SubjectSubscription */

  /***/
  function node_modulesRxjs_esm2015InternalSubjectSubscriptionJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SubjectSubscription", function () {
      return SubjectSubscription;
    });
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./Subscription */
    "./node_modules/rxjs/_esm2015/internal/Subscription.js");

    class SubjectSubscription extends _Subscription__WEBPACK_IMPORTED_MODULE_0__["Subscription"] {
      constructor(subject, subscriber) {
        super();
        this.subject = subject;
        this.subscriber = subscriber;
        this.closed = false;
      }

      unsubscribe() {
        if (this.closed) {
          return;
        }

        this.closed = true;
        const subject = this.subject;
        const observers = subject.observers;
        this.subject = null;

        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
          return;
        }

        const subscriberIndex = observers.indexOf(this.subscriber);

        if (subscriberIndex !== -1) {
          observers.splice(subscriberIndex, 1);
        }
      }

    } //# sourceMappingURL=SubjectSubscription.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/Subscriber.js":
  /*!***********************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/Subscriber.js ***!
    \***********************************************************/

  /*! exports provided: Subscriber, SafeSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalSubscriberJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Subscriber", function () {
      return Subscriber;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SafeSubscriber", function () {
      return SafeSubscriber;
    });
    /* harmony import */


    var _util_isFunction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./util/isFunction */
    "./node_modules/rxjs/_esm2015/internal/util/isFunction.js");
    /* harmony import */


    var _Observer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./Observer */
    "./node_modules/rxjs/_esm2015/internal/Observer.js");
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./Subscription */
    "./node_modules/rxjs/_esm2015/internal/Subscription.js");
    /* harmony import */


    var _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../internal/symbol/rxSubscriber */
    "./node_modules/rxjs/_esm2015/internal/symbol/rxSubscriber.js");
    /* harmony import */


    var _config__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ./config */
    "./node_modules/rxjs/_esm2015/internal/config.js");
    /* harmony import */


    var _util_hostReportError__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! ./util/hostReportError */
    "./node_modules/rxjs/_esm2015/internal/util/hostReportError.js");

    class Subscriber extends _Subscription__WEBPACK_IMPORTED_MODULE_2__["Subscription"] {
      constructor(destinationOrNext, error, complete) {
        super();
        this.syncErrorValue = null;
        this.syncErrorThrown = false;
        this.syncErrorThrowable = false;
        this.isStopped = false;

        switch (arguments.length) {
          case 0:
            this.destination = _Observer__WEBPACK_IMPORTED_MODULE_1__["empty"];
            break;

          case 1:
            if (!destinationOrNext) {
              this.destination = _Observer__WEBPACK_IMPORTED_MODULE_1__["empty"];
              break;
            }

            if (typeof destinationOrNext === 'object') {
              if (destinationOrNext instanceof Subscriber) {
                this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                this.destination = destinationOrNext;
                destinationOrNext.add(this);
              } else {
                this.syncErrorThrowable = true;
                this.destination = new SafeSubscriber(this, destinationOrNext);
              }

              break;
            }

          default:
            this.syncErrorThrowable = true;
            this.destination = new SafeSubscriber(this, destinationOrNext, error, complete);
            break;
        }
      }

      [_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_3__["rxSubscriber"]]() {
        return this;
      }

      static create(next, error, complete) {
        const subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
      }

      next(value) {
        if (!this.isStopped) {
          this._next(value);
        }
      }

      error(err) {
        if (!this.isStopped) {
          this.isStopped = true;

          this._error(err);
        }
      }

      complete() {
        if (!this.isStopped) {
          this.isStopped = true;

          this._complete();
        }
      }

      unsubscribe() {
        if (this.closed) {
          return;
        }

        this.isStopped = true;
        super.unsubscribe();
      }

      _next(value) {
        this.destination.next(value);
      }

      _error(err) {
        this.destination.error(err);
        this.unsubscribe();
      }

      _complete() {
        this.destination.complete();
        this.unsubscribe();
      }

      _unsubscribeAndRecycle() {
        const {
          _parent,
          _parents
        } = this;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        return this;
      }

    }

    class SafeSubscriber extends Subscriber {
      constructor(_parentSubscriber, observerOrNext, error, complete) {
        super();
        this._parentSubscriber = _parentSubscriber;
        let next;
        let context = this;

        if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(observerOrNext)) {
          next = observerOrNext;
        } else if (observerOrNext) {
          next = observerOrNext.next;
          error = observerOrNext.error;
          complete = observerOrNext.complete;

          if (observerOrNext !== _Observer__WEBPACK_IMPORTED_MODULE_1__["empty"]) {
            context = Object.create(observerOrNext);

            if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_0__["isFunction"])(context.unsubscribe)) {
              this.add(context.unsubscribe.bind(context));
            }

            context.unsubscribe = this.unsubscribe.bind(this);
          }
        }

        this._context = context;
        this._next = next;
        this._error = error;
        this._complete = complete;
      }

      next(value) {
        if (!this.isStopped && this._next) {
          const {
            _parentSubscriber
          } = this;

          if (!_config__WEBPACK_IMPORTED_MODULE_4__["config"].useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
            this.__tryOrUnsub(this._next, value);
          } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
            this.unsubscribe();
          }
        }
      }

      error(err) {
        if (!this.isStopped) {
          const {
            _parentSubscriber
          } = this;
          const {
            useDeprecatedSynchronousErrorHandling
          } = _config__WEBPACK_IMPORTED_MODULE_4__["config"];

          if (this._error) {
            if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
              this.__tryOrUnsub(this._error, err);

              this.unsubscribe();
            } else {
              this.__tryOrSetError(_parentSubscriber, this._error, err);

              this.unsubscribe();
            }
          } else if (!_parentSubscriber.syncErrorThrowable) {
            this.unsubscribe();

            if (useDeprecatedSynchronousErrorHandling) {
              throw err;
            }

            Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_5__["hostReportError"])(err);
          } else {
            if (useDeprecatedSynchronousErrorHandling) {
              _parentSubscriber.syncErrorValue = err;
              _parentSubscriber.syncErrorThrown = true;
            } else {
              Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_5__["hostReportError"])(err);
            }

            this.unsubscribe();
          }
        }
      }

      complete() {
        if (!this.isStopped) {
          const {
            _parentSubscriber
          } = this;

          if (this._complete) {
            const wrappedComplete = () => this._complete.call(this._context);

            if (!_config__WEBPACK_IMPORTED_MODULE_4__["config"].useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
              this.__tryOrUnsub(wrappedComplete);

              this.unsubscribe();
            } else {
              this.__tryOrSetError(_parentSubscriber, wrappedComplete);

              this.unsubscribe();
            }
          } else {
            this.unsubscribe();
          }
        }
      }

      __tryOrUnsub(fn, value) {
        try {
          fn.call(this._context, value);
        } catch (err) {
          this.unsubscribe();

          if (_config__WEBPACK_IMPORTED_MODULE_4__["config"].useDeprecatedSynchronousErrorHandling) {
            throw err;
          } else {
            Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_5__["hostReportError"])(err);
          }
        }
      }

      __tryOrSetError(parent, fn, value) {
        if (!_config__WEBPACK_IMPORTED_MODULE_4__["config"].useDeprecatedSynchronousErrorHandling) {
          throw new Error('bad call');
        }

        try {
          fn.call(this._context, value);
        } catch (err) {
          if (_config__WEBPACK_IMPORTED_MODULE_4__["config"].useDeprecatedSynchronousErrorHandling) {
            parent.syncErrorValue = err;
            parent.syncErrorThrown = true;
            return true;
          } else {
            Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_5__["hostReportError"])(err);
            return true;
          }
        }

        return false;
      }

      _unsubscribe() {
        const {
          _parentSubscriber
        } = this;
        this._context = null;
        this._parentSubscriber = null;

        _parentSubscriber.unsubscribe();
      }

    } //# sourceMappingURL=Subscriber.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/Subscription.js":
  /*!*************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/Subscription.js ***!
    \*************************************************************/

  /*! exports provided: Subscription */

  /***/
  function node_modulesRxjs_esm2015InternalSubscriptionJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Subscription", function () {
      return Subscription;
    });
    /* harmony import */


    var _util_isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./util/isArray */
    "./node_modules/rxjs/_esm2015/internal/util/isArray.js");
    /* harmony import */


    var _util_isObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./util/isObject */
    "./node_modules/rxjs/_esm2015/internal/util/isObject.js");
    /* harmony import */


    var _util_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./util/isFunction */
    "./node_modules/rxjs/_esm2015/internal/util/isFunction.js");
    /* harmony import */


    var _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./util/UnsubscriptionError */
    "./node_modules/rxjs/_esm2015/internal/util/UnsubscriptionError.js");

    class Subscription {
      constructor(unsubscribe) {
        this.closed = false;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;

        if (unsubscribe) {
          this._unsubscribe = unsubscribe;
        }
      }

      unsubscribe() {
        let hasErrors = false;
        let errors;

        if (this.closed) {
          return;
        }

        let {
          _parent,
          _parents,
          _unsubscribe,
          _subscriptions
        } = this;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        this._subscriptions = null;
        let index = -1;
        let len = _parents ? _parents.length : 0;

        while (_parent) {
          _parent.remove(this);

          _parent = ++index < len && _parents[index] || null;
        }

        if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_2__["isFunction"])(_unsubscribe)) {
          try {
            _unsubscribe.call(this);
          } catch (e) {
            hasErrors = true;
            errors = e instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_3__["UnsubscriptionError"] ? flattenUnsubscriptionErrors(e.errors) : [e];
          }
        }

        if (Object(_util_isArray__WEBPACK_IMPORTED_MODULE_0__["isArray"])(_subscriptions)) {
          index = -1;
          len = _subscriptions.length;

          while (++index < len) {
            const sub = _subscriptions[index];

            if (Object(_util_isObject__WEBPACK_IMPORTED_MODULE_1__["isObject"])(sub)) {
              try {
                sub.unsubscribe();
              } catch (e) {
                hasErrors = true;
                errors = errors || [];

                if (e instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_3__["UnsubscriptionError"]) {
                  errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                } else {
                  errors.push(e);
                }
              }
            }
          }
        }

        if (hasErrors) {
          throw new _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_3__["UnsubscriptionError"](errors);
        }
      }

      add(teardown) {
        let subscription = teardown;

        switch (typeof teardown) {
          case 'function':
            subscription = new Subscription(teardown);

          case 'object':
            if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
              return subscription;
            } else if (this.closed) {
              subscription.unsubscribe();
              return subscription;
            } else if (!(subscription instanceof Subscription)) {
              const tmp = subscription;
              subscription = new Subscription();
              subscription._subscriptions = [tmp];
            }

            break;

          default:
            {
              if (!teardown) {
                return Subscription.EMPTY;
              }

              throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
            }
        }

        if (subscription._addParent(this)) {
          const subscriptions = this._subscriptions;

          if (subscriptions) {
            subscriptions.push(subscription);
          } else {
            this._subscriptions = [subscription];
          }
        }

        return subscription;
      }

      remove(subscription) {
        const subscriptions = this._subscriptions;

        if (subscriptions) {
          const subscriptionIndex = subscriptions.indexOf(subscription);

          if (subscriptionIndex !== -1) {
            subscriptions.splice(subscriptionIndex, 1);
          }
        }
      }

      _addParent(parent) {
        let {
          _parent,
          _parents
        } = this;

        if (_parent === parent) {
          return false;
        } else if (!_parent) {
          this._parent = parent;
          return true;
        } else if (!_parents) {
          this._parents = [parent];
          return true;
        } else if (_parents.indexOf(parent) === -1) {
          _parents.push(parent);

          return true;
        }

        return false;
      }

    }

    Subscription.EMPTY = function (empty) {
      empty.closed = true;
      return empty;
    }(new Subscription());

    function flattenUnsubscriptionErrors(errors) {
      return errors.reduce((errs, err) => errs.concat(err instanceof _util_UnsubscriptionError__WEBPACK_IMPORTED_MODULE_3__["UnsubscriptionError"] ? err.errors : err), []);
    } //# sourceMappingURL=Subscription.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/config.js":
  /*!*******************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/config.js ***!
    \*******************************************************/

  /*! exports provided: config */

  /***/
  function node_modulesRxjs_esm2015InternalConfigJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "config", function () {
      return config;
    });

    let _enable_super_gross_mode_that_will_cause_bad_things = false;
    const config = {
      Promise: undefined,

      set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
          const error = new Error();
          console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
        } else if (_enable_super_gross_mode_that_will_cause_bad_things) {
          console.log('RxJS: Back to a better error behavior. Thank you. <3');
        }

        _enable_super_gross_mode_that_will_cause_bad_things = value;
      },

      get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
      }

    }; //# sourceMappingURL=config.js.map

    /***/
  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/ConnectableObservable.js":
  /*!*********************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/ConnectableObservable.js ***!
    \*********************************************************************************/

  /*! exports provided: ConnectableObservable, connectableObservableDescriptor */

  /***/
  function node_modulesRxjs_esm2015InternalObservableConnectableObservableJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ConnectableObservable", function () {
      return ConnectableObservable;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "connectableObservableDescriptor", function () {
      return connectableObservableDescriptor;
    });
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subject */
    "./node_modules/rxjs/_esm2015/internal/Subject.js");
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../Subscription */
    "./node_modules/rxjs/_esm2015/internal/Subscription.js");
    /* harmony import */


    var _operators_refCount__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ../operators/refCount */
    "./node_modules/rxjs/_esm2015/internal/operators/refCount.js");

    class ConnectableObservable extends _Observable__WEBPACK_IMPORTED_MODULE_1__["Observable"] {
      constructor(source, subjectFactory) {
        super();
        this.source = source;
        this.subjectFactory = subjectFactory;
        this._refCount = 0;
        this._isComplete = false;
      }

      _subscribe(subscriber) {
        return this.getSubject().subscribe(subscriber);
      }

      getSubject() {
        const subject = this._subject;

        if (!subject || subject.isStopped) {
          this._subject = this.subjectFactory();
        }

        return this._subject;
      }

      connect() {
        let connection = this._connection;

        if (!connection) {
          this._isComplete = false;
          connection = this._connection = new _Subscription__WEBPACK_IMPORTED_MODULE_3__["Subscription"]();
          connection.add(this.source.subscribe(new ConnectableSubscriber(this.getSubject(), this)));

          if (connection.closed) {
            this._connection = null;
            connection = _Subscription__WEBPACK_IMPORTED_MODULE_3__["Subscription"].EMPTY;
          } else {
            this._connection = connection;
          }
        }

        return connection;
      }

      refCount() {
        return Object(_operators_refCount__WEBPACK_IMPORTED_MODULE_4__["refCount"])()(this);
      }

    }

    const connectableProto = ConnectableObservable.prototype;
    const connectableObservableDescriptor = {
      operator: {
        value: null
      },
      _refCount: {
        value: 0,
        writable: true
      },
      _subject: {
        value: null,
        writable: true
      },
      _connection: {
        value: null,
        writable: true
      },
      _subscribe: {
        value: connectableProto._subscribe
      },
      _isComplete: {
        value: connectableProto._isComplete,
        writable: true
      },
      getSubject: {
        value: connectableProto.getSubject
      },
      connect: {
        value: connectableProto.connect
      },
      refCount: {
        value: connectableProto.refCount
      }
    };

    class ConnectableSubscriber extends _Subject__WEBPACK_IMPORTED_MODULE_0__["SubjectSubscriber"] {
      constructor(destination, connectable) {
        super(destination);
        this.connectable = connectable;
      }

      _error(err) {
        this._unsubscribe();

        super._error(err);
      }

      _complete() {
        this.connectable._isComplete = true;

        this._unsubscribe();

        super._complete();
      }

      _unsubscribe() {
        const connectable = this.connectable;

        if (connectable) {
          this.connectable = null;
          const connection = connectable._connection;
          connectable._refCount = 0;
          connectable._subject = null;
          connectable._connection = null;

          if (connection) {
            connection.unsubscribe();
          }
        }
      }

    }

    class RefCountOperator {
      constructor(connectable) {
        this.connectable = connectable;
      }

      call(subscriber, source) {
        const {
          connectable
        } = this;
        connectable._refCount++;
        const refCounter = new RefCountSubscriber(subscriber, connectable);
        const subscription = source.subscribe(refCounter);

        if (!refCounter.closed) {
          refCounter.connection = connectable.connect();
        }

        return subscription;
      }

    }

    class RefCountSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_2__["Subscriber"] {
      constructor(destination, connectable) {
        super(destination);
        this.connectable = connectable;
      }

      _unsubscribe() {
        const {
          connectable
        } = this;

        if (!connectable) {
          this.connection = null;
          return;
        }

        this.connectable = null;
        const refCount = connectable._refCount;

        if (refCount <= 0) {
          this.connection = null;
          return;
        }

        connectable._refCount = refCount - 1;

        if (refCount > 1) {
          this.connection = null;
          return;
        }

        const {
          connection
        } = this;
        const sharedConnection = connectable._connection;
        this.connection = null;

        if (sharedConnection && (!connection || sharedConnection === connection)) {
          sharedConnection.unsubscribe();
        }
      }

    } //# sourceMappingURL=ConnectableObservable.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/SubscribeOnObservable.js":
  /*!*********************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/SubscribeOnObservable.js ***!
    \*********************************************************************************/

  /*! exports provided: SubscribeOnObservable */

  /***/
  function node_modulesRxjs_esm2015InternalObservableSubscribeOnObservableJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SubscribeOnObservable", function () {
      return SubscribeOnObservable;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _scheduler_asap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../scheduler/asap */
    "./node_modules/rxjs/_esm2015/internal/scheduler/asap.js");
    /* harmony import */


    var _util_isNumeric__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/isNumeric */
    "./node_modules/rxjs/_esm2015/internal/util/isNumeric.js");

    class SubscribeOnObservable extends _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"] {
      constructor(source, delayTime = 0, scheduler = _scheduler_asap__WEBPACK_IMPORTED_MODULE_1__["asap"]) {
        super();
        this.source = source;
        this.delayTime = delayTime;
        this.scheduler = scheduler;

        if (!Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__["isNumeric"])(delayTime) || delayTime < 0) {
          this.delayTime = 0;
        }

        if (!scheduler || typeof scheduler.schedule !== 'function') {
          this.scheduler = _scheduler_asap__WEBPACK_IMPORTED_MODULE_1__["asap"];
        }
      }

      static create(source, delay = 0, scheduler = _scheduler_asap__WEBPACK_IMPORTED_MODULE_1__["asap"]) {
        return new SubscribeOnObservable(source, delay, scheduler);
      }

      static dispatch(arg) {
        const {
          source,
          subscriber
        } = arg;
        return this.add(source.subscribe(subscriber));
      }

      _subscribe(subscriber) {
        const delay = this.delayTime;
        const source = this.source;
        const scheduler = this.scheduler;
        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
          source,
          subscriber
        });
      }

    } //# sourceMappingURL=SubscribeOnObservable.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/bindCallback.js":
  /*!************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/bindCallback.js ***!
    \************************************************************************/

  /*! exports provided: bindCallback */

  /***/
  function node_modulesRxjs_esm2015InternalObservableBindCallbackJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "bindCallback", function () {
      return bindCallback;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _AsyncSubject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../AsyncSubject */
    "./node_modules/rxjs/_esm2015/internal/AsyncSubject.js");
    /* harmony import */


    var _operators_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../operators/map */
    "./node_modules/rxjs/_esm2015/internal/operators/map.js");
    /* harmony import */


    var _util_canReportError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../util/canReportError */
    "./node_modules/rxjs/_esm2015/internal/util/canReportError.js");
    /* harmony import */


    var _util_isArray__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ../util/isArray */
    "./node_modules/rxjs/_esm2015/internal/util/isArray.js");
    /* harmony import */


    var _util_isScheduler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! ../util/isScheduler */
    "./node_modules/rxjs/_esm2015/internal/util/isScheduler.js");

    function bindCallback(callbackFunc, resultSelector, scheduler) {
      if (resultSelector) {
        if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_5__["isScheduler"])(resultSelector)) {
          scheduler = resultSelector;
        } else {
          return (...args) => bindCallback(callbackFunc, scheduler)(...args).pipe(Object(_operators_map__WEBPACK_IMPORTED_MODULE_2__["map"])(args => Object(_util_isArray__WEBPACK_IMPORTED_MODULE_4__["isArray"])(args) ? resultSelector(...args) : resultSelector(args)));
        }
      }

      return function (...args) {
        const context = this;
        let subject;
        const params = {
          context,
          subject,
          callbackFunc,
          scheduler
        };
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](subscriber => {
          if (!scheduler) {
            if (!subject) {
              subject = new _AsyncSubject__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();

              const handler = (...innerArgs) => {
                subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                subject.complete();
              };

              try {
                callbackFunc.apply(context, [...args, handler]);
              } catch (err) {
                if (Object(_util_canReportError__WEBPACK_IMPORTED_MODULE_3__["canReportError"])(subject)) {
                  subject.error(err);
                } else {
                  console.warn(err);
                }
              }
            }

            return subject.subscribe(subscriber);
          } else {
            const state = {
              args,
              subscriber,
              params
            };
            return scheduler.schedule(dispatch, 0, state);
          }
        });
      };
    }

    function dispatch(state) {
      const self = this;
      const {
        args,
        subscriber,
        params
      } = state;
      const {
        callbackFunc,
        context,
        scheduler
      } = params;
      let {
        subject
      } = params;

      if (!subject) {
        subject = params.subject = new _AsyncSubject__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();

        const handler = (...innerArgs) => {
          const value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
          this.add(scheduler.schedule(dispatchNext, 0, {
            value,
            subject
          }));
        };

        try {
          callbackFunc.apply(context, [...args, handler]);
        } catch (err) {
          subject.error(err);
        }
      }

      this.add(subject.subscribe(subscriber));
    }

    function dispatchNext(state) {
      const {
        value,
        subject
      } = state;
      subject.next(value);
      subject.complete();
    }

    function dispatchError(state) {
      const {
        err,
        subject
      } = state;
      subject.error(err);
    } //# sourceMappingURL=bindCallback.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/bindNodeCallback.js":
  /*!****************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/bindNodeCallback.js ***!
    \****************************************************************************/

  /*! exports provided: bindNodeCallback */

  /***/
  function node_modulesRxjs_esm2015InternalObservableBindNodeCallbackJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "bindNodeCallback", function () {
      return bindNodeCallback;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _AsyncSubject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../AsyncSubject */
    "./node_modules/rxjs/_esm2015/internal/AsyncSubject.js");
    /* harmony import */


    var _operators_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../operators/map */
    "./node_modules/rxjs/_esm2015/internal/operators/map.js");
    /* harmony import */


    var _util_canReportError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../util/canReportError */
    "./node_modules/rxjs/_esm2015/internal/util/canReportError.js");
    /* harmony import */


    var _util_isScheduler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ../util/isScheduler */
    "./node_modules/rxjs/_esm2015/internal/util/isScheduler.js");
    /* harmony import */


    var _util_isArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! ../util/isArray */
    "./node_modules/rxjs/_esm2015/internal/util/isArray.js");

    function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
      if (resultSelector) {
        if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_4__["isScheduler"])(resultSelector)) {
          scheduler = resultSelector;
        } else {
          return (...args) => bindNodeCallback(callbackFunc, scheduler)(...args).pipe(Object(_operators_map__WEBPACK_IMPORTED_MODULE_2__["map"])(args => Object(_util_isArray__WEBPACK_IMPORTED_MODULE_5__["isArray"])(args) ? resultSelector(...args) : resultSelector(args)));
        }
      }

      return function (...args) {
        const params = {
          subject: undefined,
          args,
          callbackFunc,
          scheduler,
          context: this
        };
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](subscriber => {
          const {
            context
          } = params;
          let {
            subject
          } = params;

          if (!scheduler) {
            if (!subject) {
              subject = params.subject = new _AsyncSubject__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();

              const handler = (...innerArgs) => {
                const err = innerArgs.shift();

                if (err) {
                  subject.error(err);
                  return;
                }

                subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                subject.complete();
              };

              try {
                callbackFunc.apply(context, [...args, handler]);
              } catch (err) {
                if (Object(_util_canReportError__WEBPACK_IMPORTED_MODULE_3__["canReportError"])(subject)) {
                  subject.error(err);
                } else {
                  console.warn(err);
                }
              }
            }

            return subject.subscribe(subscriber);
          } else {
            return scheduler.schedule(dispatch, 0, {
              params,
              subscriber,
              context
            });
          }
        });
      };
    }

    function dispatch(state) {
      const {
        params,
        subscriber,
        context
      } = state;
      const {
        callbackFunc,
        args,
        scheduler
      } = params;
      let subject = params.subject;

      if (!subject) {
        subject = params.subject = new _AsyncSubject__WEBPACK_IMPORTED_MODULE_1__["AsyncSubject"]();

        const handler = (...innerArgs) => {
          const err = innerArgs.shift();

          if (err) {
            this.add(scheduler.schedule(dispatchError, 0, {
              err,
              subject
            }));
          } else {
            const value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
            this.add(scheduler.schedule(dispatchNext, 0, {
              value,
              subject
            }));
          }
        };

        try {
          callbackFunc.apply(context, [...args, handler]);
        } catch (err) {
          this.add(scheduler.schedule(dispatchError, 0, {
            err,
            subject
          }));
        }
      }

      this.add(subject.subscribe(subscriber));
    }

    function dispatchNext(arg) {
      const {
        value,
        subject
      } = arg;
      subject.next(value);
      subject.complete();
    }

    function dispatchError(arg) {
      const {
        err,
        subject
      } = arg;
      subject.error(err);
    } //# sourceMappingURL=bindNodeCallback.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/combineLatest.js":
  /*!*************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/combineLatest.js ***!
    \*************************************************************************/

  /*! exports provided: combineLatest, CombineLatestOperator, CombineLatestSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalObservableCombineLatestJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "combineLatest", function () {
      return combineLatest;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CombineLatestOperator", function () {
      return CombineLatestOperator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "CombineLatestSubscriber", function () {
      return CombineLatestSubscriber;
    });
    /* harmony import */


    var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../util/isScheduler */
    "./node_modules/rxjs/_esm2015/internal/util/isScheduler.js");
    /* harmony import */


    var _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/isArray */
    "./node_modules/rxjs/_esm2015/internal/util/isArray.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");
    /* harmony import */


    var _fromArray__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ./fromArray */
    "./node_modules/rxjs/_esm2015/internal/observable/fromArray.js");

    const NONE = {};

    function combineLatest(...observables) {
      let resultSelector = null;
      let scheduler = null;

      if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__["isScheduler"])(observables[observables.length - 1])) {
        scheduler = observables.pop();
      }

      if (typeof observables[observables.length - 1] === 'function') {
        resultSelector = observables.pop();
      }

      if (observables.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__["isArray"])(observables[0])) {
        observables = observables[0];
      }

      return Object(_fromArray__WEBPACK_IMPORTED_MODULE_4__["fromArray"])(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
    }

    class CombineLatestOperator {
      constructor(resultSelector) {
        this.resultSelector = resultSelector;
      }

      call(subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
      }

    }

    class CombineLatestSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__["OuterSubscriber"] {
      constructor(destination, resultSelector) {
        super(destination);
        this.resultSelector = resultSelector;
        this.active = 0;
        this.values = [];
        this.observables = [];
      }

      _next(observable) {
        this.values.push(NONE);
        this.observables.push(observable);
      }

      _complete() {
        const observables = this.observables;
        const len = observables.length;

        if (len === 0) {
          this.destination.complete();
        } else {
          this.active = len;
          this.toRespond = len;

          for (let i = 0; i < len; i++) {
            const observable = observables[i];
            this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__["subscribeToResult"])(this, observable, observable, i));
          }
        }
      }

      notifyComplete(unused) {
        if ((this.active -= 1) === 0) {
          this.destination.complete();
        }
      }

      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        const values = this.values;
        const oldVal = values[outerIndex];
        const toRespond = !this.toRespond ? 0 : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;

        if (toRespond === 0) {
          if (this.resultSelector) {
            this._tryResultSelector(values);
          } else {
            this.destination.next(values.slice());
          }
        }
      }

      _tryResultSelector(values) {
        let result;

        try {
          result = this.resultSelector.apply(this, values);
        } catch (err) {
          this.destination.error(err);
          return;
        }

        this.destination.next(result);
      }

    } //# sourceMappingURL=combineLatest.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/concat.js":
  /*!******************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/concat.js ***!
    \******************************************************************/

  /*! exports provided: concat */

  /***/
  function node_modulesRxjs_esm2015InternalObservableConcatJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "concat", function () {
      return concat;
    });
    /* harmony import */


    var _of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./of */
    "./node_modules/rxjs/_esm2015/internal/observable/of.js");
    /* harmony import */


    var _operators_concatAll__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../operators/concatAll */
    "./node_modules/rxjs/_esm2015/internal/operators/concatAll.js");

    function concat(...observables) {
      return Object(_operators_concatAll__WEBPACK_IMPORTED_MODULE_1__["concatAll"])()(Object(_of__WEBPACK_IMPORTED_MODULE_0__["of"])(...observables));
    } //# sourceMappingURL=concat.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/defer.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/defer.js ***!
    \*****************************************************************/

  /*! exports provided: defer */

  /***/
  function node_modulesRxjs_esm2015InternalObservableDeferJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "defer", function () {
      return defer;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./from */
    "./node_modules/rxjs/_esm2015/internal/observable/from.js");
    /* harmony import */


    var _empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./empty */
    "./node_modules/rxjs/_esm2015/internal/observable/empty.js");

    function defer(observableFactory) {
      return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](subscriber => {
        let input;

        try {
          input = observableFactory();
        } catch (err) {
          subscriber.error(err);
          return undefined;
        }

        const source = input ? Object(_from__WEBPACK_IMPORTED_MODULE_1__["from"])(input) : Object(_empty__WEBPACK_IMPORTED_MODULE_2__["empty"])();
        return source.subscribe(subscriber);
      });
    } //# sourceMappingURL=defer.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/empty.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/empty.js ***!
    \*****************************************************************/

  /*! exports provided: EMPTY, empty, emptyScheduled */

  /***/
  function node_modulesRxjs_esm2015InternalObservableEmptyJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "EMPTY", function () {
      return EMPTY;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "empty", function () {
      return empty;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "emptyScheduled", function () {
      return emptyScheduled;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");

    const EMPTY = new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](subscriber => subscriber.complete());

    function empty(scheduler) {
      return scheduler ? emptyScheduled(scheduler) : EMPTY;
    }

    function emptyScheduled(scheduler) {
      return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](subscriber => scheduler.schedule(() => subscriber.complete()));
    } //# sourceMappingURL=empty.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/forkJoin.js":
  /*!********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/forkJoin.js ***!
    \********************************************************************/

  /*! exports provided: forkJoin */

  /***/
  function node_modulesRxjs_esm2015InternalObservableForkJoinJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "forkJoin", function () {
      return forkJoin;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/isArray */
    "./node_modules/rxjs/_esm2015/internal/util/isArray.js");
    /* harmony import */


    var _empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./empty */
    "./node_modules/rxjs/_esm2015/internal/observable/empty.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _operators_map__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! ../operators/map */
    "./node_modules/rxjs/_esm2015/internal/operators/map.js");

    function forkJoin(...sources) {
      let resultSelector;

      if (typeof sources[sources.length - 1] === 'function') {
        resultSelector = sources.pop();
      }

      if (sources.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__["isArray"])(sources[0])) {
        sources = sources[0];
      }

      if (sources.length === 0) {
        return _empty__WEBPACK_IMPORTED_MODULE_2__["EMPTY"];
      }

      if (resultSelector) {
        return forkJoin(sources).pipe(Object(_operators_map__WEBPACK_IMPORTED_MODULE_5__["map"])(args => resultSelector(...args)));
      }

      return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](subscriber => {
        return new ForkJoinSubscriber(subscriber, sources);
      });
    }

    class ForkJoinSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_4__["OuterSubscriber"] {
      constructor(destination, sources) {
        super(destination);
        this.sources = sources;
        this.completed = 0;
        this.haveValues = 0;
        const len = sources.length;
        this.values = new Array(len);

        for (let i = 0; i < len; i++) {
          const source = sources[i];
          const innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__["subscribeToResult"])(this, source, null, i);

          if (innerSubscription) {
            this.add(innerSubscription);
          }
        }
      }

      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;

        if (!innerSub._hasValue) {
          innerSub._hasValue = true;
          this.haveValues++;
        }
      }

      notifyComplete(innerSub) {
        const {
          destination,
          haveValues,
          values
        } = this;
        const len = values.length;

        if (!innerSub._hasValue) {
          destination.complete();
          return;
        }

        this.completed++;

        if (this.completed !== len) {
          return;
        }

        if (haveValues === len) {
          destination.next(values);
        }

        destination.complete();
      }

    } //# sourceMappingURL=forkJoin.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/from.js":
  /*!****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/from.js ***!
    \****************************************************************/

  /*! exports provided: from */

  /***/
  function node_modulesRxjs_esm2015InternalObservableFromJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "from", function () {
      return from;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _util_isPromise__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/isPromise */
    "./node_modules/rxjs/_esm2015/internal/util/isPromise.js");
    /* harmony import */


    var _util_isArrayLike__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/isArrayLike */
    "./node_modules/rxjs/_esm2015/internal/util/isArrayLike.js");
    /* harmony import */


    var _util_isInteropObservable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../util/isInteropObservable */
    "./node_modules/rxjs/_esm2015/internal/util/isInteropObservable.js");
    /* harmony import */


    var _util_isIterable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ../util/isIterable */
    "./node_modules/rxjs/_esm2015/internal/util/isIterable.js");
    /* harmony import */


    var _fromArray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! ./fromArray */
    "./node_modules/rxjs/_esm2015/internal/observable/fromArray.js");
    /* harmony import */


    var _fromPromise__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! ./fromPromise */
    "./node_modules/rxjs/_esm2015/internal/observable/fromPromise.js");
    /* harmony import */


    var _fromIterable__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
    /*! ./fromIterable */
    "./node_modules/rxjs/_esm2015/internal/observable/fromIterable.js");
    /* harmony import */


    var _fromObservable__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
    /*! ./fromObservable */
    "./node_modules/rxjs/_esm2015/internal/observable/fromObservable.js");
    /* harmony import */


    var _util_subscribeTo__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
    /*! ../util/subscribeTo */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeTo.js");

    function from(input, scheduler) {
      if (!scheduler) {
        if (input instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"]) {
          return input;
        }

        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](Object(_util_subscribeTo__WEBPACK_IMPORTED_MODULE_9__["subscribeTo"])(input));
      }

      if (input != null) {
        if (Object(_util_isInteropObservable__WEBPACK_IMPORTED_MODULE_3__["isInteropObservable"])(input)) {
          return Object(_fromObservable__WEBPACK_IMPORTED_MODULE_8__["fromObservable"])(input, scheduler);
        } else if (Object(_util_isPromise__WEBPACK_IMPORTED_MODULE_1__["isPromise"])(input)) {
          return Object(_fromPromise__WEBPACK_IMPORTED_MODULE_6__["fromPromise"])(input, scheduler);
        } else if (Object(_util_isArrayLike__WEBPACK_IMPORTED_MODULE_2__["isArrayLike"])(input)) {
          return Object(_fromArray__WEBPACK_IMPORTED_MODULE_5__["fromArray"])(input, scheduler);
        } else if (Object(_util_isIterable__WEBPACK_IMPORTED_MODULE_4__["isIterable"])(input) || typeof input === 'string') {
          return Object(_fromIterable__WEBPACK_IMPORTED_MODULE_7__["fromIterable"])(input, scheduler);
        }
      }

      throw new TypeError((input !== null && typeof input || input) + ' is not observable');
    } //# sourceMappingURL=from.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/fromArray.js":
  /*!*********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/fromArray.js ***!
    \*********************************************************************/

  /*! exports provided: fromArray */

  /***/
  function node_modulesRxjs_esm2015InternalObservableFromArrayJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "fromArray", function () {
      return fromArray;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Subscription */
    "./node_modules/rxjs/_esm2015/internal/Subscription.js");
    /* harmony import */


    var _util_subscribeToArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/subscribeToArray */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToArray.js");

    function fromArray(input, scheduler) {
      if (!scheduler) {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](Object(_util_subscribeToArray__WEBPACK_IMPORTED_MODULE_2__["subscribeToArray"])(input));
      } else {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](subscriber => {
          const sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]();
          let i = 0;
          sub.add(scheduler.schedule(function () {
            if (i === input.length) {
              subscriber.complete();
              return;
            }

            subscriber.next(input[i++]);

            if (!subscriber.closed) {
              sub.add(this.schedule());
            }
          }));
          return sub;
        });
      }
    } //# sourceMappingURL=fromArray.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/fromEvent.js":
  /*!*********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/fromEvent.js ***!
    \*********************************************************************/

  /*! exports provided: fromEvent */

  /***/
  function node_modulesRxjs_esm2015InternalObservableFromEventJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "fromEvent", function () {
      return fromEvent;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/isArray */
    "./node_modules/rxjs/_esm2015/internal/util/isArray.js");
    /* harmony import */


    var _util_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/isFunction */
    "./node_modules/rxjs/_esm2015/internal/util/isFunction.js");
    /* harmony import */


    var _operators_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../operators/map */
    "./node_modules/rxjs/_esm2015/internal/operators/map.js");

    const toString = Object.prototype.toString;

    function fromEvent(target, eventName, options, resultSelector) {
      if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_2__["isFunction"])(options)) {
        resultSelector = options;
        options = undefined;
      }

      if (resultSelector) {
        return fromEvent(target, eventName, options).pipe(Object(_operators_map__WEBPACK_IMPORTED_MODULE_3__["map"])(args => Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__["isArray"])(args) ? resultSelector(...args) : resultSelector(args)));
      }

      return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](subscriber => {
        function handler(e) {
          if (arguments.length > 1) {
            subscriber.next(Array.prototype.slice.call(arguments));
          } else {
            subscriber.next(e);
          }
        }

        setupSubscription(target, eventName, handler, subscriber, options);
      });
    }

    function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
      let unsubscribe;

      if (isEventTarget(sourceObj)) {
        const source = sourceObj;
        sourceObj.addEventListener(eventName, handler, options);

        unsubscribe = () => source.removeEventListener(eventName, handler, options);
      } else if (isJQueryStyleEventEmitter(sourceObj)) {
        const source = sourceObj;
        sourceObj.on(eventName, handler);

        unsubscribe = () => source.off(eventName, handler);
      } else if (isNodeStyleEventEmitter(sourceObj)) {
        const source = sourceObj;
        sourceObj.addListener(eventName, handler);

        unsubscribe = () => source.removeListener(eventName, handler);
      } else if (sourceObj && sourceObj.length) {
        for (let i = 0, len = sourceObj.length; i < len; i++) {
          setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
        }
      } else {
        throw new TypeError('Invalid event target');
      }

      subscriber.add(unsubscribe);
    }

    function isNodeStyleEventEmitter(sourceObj) {
      return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
    }

    function isJQueryStyleEventEmitter(sourceObj) {
      return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
    }

    function isEventTarget(sourceObj) {
      return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
    } //# sourceMappingURL=fromEvent.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/fromEventPattern.js":
  /*!****************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/fromEventPattern.js ***!
    \****************************************************************************/

  /*! exports provided: fromEventPattern */

  /***/
  function node_modulesRxjs_esm2015InternalObservableFromEventPatternJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "fromEventPattern", function () {
      return fromEventPattern;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/isArray */
    "./node_modules/rxjs/_esm2015/internal/util/isArray.js");
    /* harmony import */


    var _util_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/isFunction */
    "./node_modules/rxjs/_esm2015/internal/util/isFunction.js");
    /* harmony import */


    var _operators_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../operators/map */
    "./node_modules/rxjs/_esm2015/internal/operators/map.js");

    function fromEventPattern(addHandler, removeHandler, resultSelector) {
      if (resultSelector) {
        return fromEventPattern(addHandler, removeHandler).pipe(Object(_operators_map__WEBPACK_IMPORTED_MODULE_3__["map"])(args => Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__["isArray"])(args) ? resultSelector(...args) : resultSelector(args)));
      }

      return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](subscriber => {
        const handler = (...e) => subscriber.next(e.length === 1 ? e[0] : e);

        let retValue;

        try {
          retValue = addHandler(handler);
        } catch (err) {
          subscriber.error(err);
          return undefined;
        }

        if (!Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_2__["isFunction"])(removeHandler)) {
          return undefined;
        }

        return () => removeHandler(handler, retValue);
      });
    } //# sourceMappingURL=fromEventPattern.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/fromIterable.js":
  /*!************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/fromIterable.js ***!
    \************************************************************************/

  /*! exports provided: fromIterable */

  /***/
  function node_modulesRxjs_esm2015InternalObservableFromIterableJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "fromIterable", function () {
      return fromIterable;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Subscription */
    "./node_modules/rxjs/_esm2015/internal/Subscription.js");
    /* harmony import */


    var _symbol_iterator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../symbol/iterator */
    "./node_modules/rxjs/_esm2015/internal/symbol/iterator.js");
    /* harmony import */


    var _util_subscribeToIterable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../util/subscribeToIterable */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToIterable.js");

    function fromIterable(input, scheduler) {
      if (!input) {
        throw new Error('Iterable cannot be null');
      }

      if (!scheduler) {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](Object(_util_subscribeToIterable__WEBPACK_IMPORTED_MODULE_3__["subscribeToIterable"])(input));
      } else {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](subscriber => {
          const sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]();
          let iterator;
          sub.add(() => {
            if (iterator && typeof iterator.return === 'function') {
              iterator.return();
            }
          });
          sub.add(scheduler.schedule(() => {
            iterator = input[_symbol_iterator__WEBPACK_IMPORTED_MODULE_2__["iterator"]]();
            sub.add(scheduler.schedule(function () {
              if (subscriber.closed) {
                return;
              }

              let value;
              let done;

              try {
                const result = iterator.next();
                value = result.value;
                done = result.done;
              } catch (err) {
                subscriber.error(err);
                return;
              }

              if (done) {
                subscriber.complete();
              } else {
                subscriber.next(value);
                this.schedule();
              }
            }));
          }));
          return sub;
        });
      }
    } //# sourceMappingURL=fromIterable.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/fromObservable.js":
  /*!**************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/fromObservable.js ***!
    \**************************************************************************/

  /*! exports provided: fromObservable */

  /***/
  function node_modulesRxjs_esm2015InternalObservableFromObservableJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "fromObservable", function () {
      return fromObservable;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Subscription */
    "./node_modules/rxjs/_esm2015/internal/Subscription.js");
    /* harmony import */


    var _symbol_observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../symbol/observable */
    "./node_modules/rxjs/_esm2015/internal/symbol/observable.js");
    /* harmony import */


    var _util_subscribeToObservable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../util/subscribeToObservable */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToObservable.js");

    function fromObservable(input, scheduler) {
      if (!scheduler) {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](Object(_util_subscribeToObservable__WEBPACK_IMPORTED_MODULE_3__["subscribeToObservable"])(input));
      } else {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](subscriber => {
          const sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]();
          sub.add(scheduler.schedule(() => {
            const observable = input[_symbol_observable__WEBPACK_IMPORTED_MODULE_2__["observable"]]();

            sub.add(observable.subscribe({
              next(value) {
                sub.add(scheduler.schedule(() => subscriber.next(value)));
              },

              error(err) {
                sub.add(scheduler.schedule(() => subscriber.error(err)));
              },

              complete() {
                sub.add(scheduler.schedule(() => subscriber.complete()));
              }

            }));
          }));
          return sub;
        });
      }
    } //# sourceMappingURL=fromObservable.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/fromPromise.js":
  /*!***********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/fromPromise.js ***!
    \***********************************************************************/

  /*! exports provided: fromPromise */

  /***/
  function node_modulesRxjs_esm2015InternalObservableFromPromiseJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "fromPromise", function () {
      return fromPromise;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Subscription */
    "./node_modules/rxjs/_esm2015/internal/Subscription.js");
    /* harmony import */


    var _util_subscribeToPromise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/subscribeToPromise */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToPromise.js");

    function fromPromise(input, scheduler) {
      if (!scheduler) {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](Object(_util_subscribeToPromise__WEBPACK_IMPORTED_MODULE_2__["subscribeToPromise"])(input));
      } else {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](subscriber => {
          const sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]();
          sub.add(scheduler.schedule(() => input.then(value => {
            sub.add(scheduler.schedule(() => {
              subscriber.next(value);
              sub.add(scheduler.schedule(() => subscriber.complete()));
            }));
          }, err => {
            sub.add(scheduler.schedule(() => subscriber.error(err)));
          })));
          return sub;
        });
      }
    } //# sourceMappingURL=fromPromise.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/generate.js":
  /*!********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/generate.js ***!
    \********************************************************************/

  /*! exports provided: generate */

  /***/
  function node_modulesRxjs_esm2015InternalObservableGenerateJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "generate", function () {
      return generate;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/identity */
    "./node_modules/rxjs/_esm2015/internal/util/identity.js");
    /* harmony import */


    var _util_isScheduler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/isScheduler */
    "./node_modules/rxjs/_esm2015/internal/util/isScheduler.js");

    function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
      let resultSelector;
      let initialState;

      if (arguments.length == 1) {
        const options = initialStateOrOptions;
        initialState = options.initialState;
        condition = options.condition;
        iterate = options.iterate;
        resultSelector = options.resultSelector || _util_identity__WEBPACK_IMPORTED_MODULE_1__["identity"];
        scheduler = options.scheduler;
      } else if (resultSelectorOrObservable === undefined || Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_2__["isScheduler"])(resultSelectorOrObservable)) {
        initialState = initialStateOrOptions;
        resultSelector = _util_identity__WEBPACK_IMPORTED_MODULE_1__["identity"];
        scheduler = resultSelectorOrObservable;
      } else {
        initialState = initialStateOrOptions;
        resultSelector = resultSelectorOrObservable;
      }

      return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](subscriber => {
        let state = initialState;

        if (scheduler) {
          return scheduler.schedule(dispatch, 0, {
            subscriber,
            iterate,
            condition,
            resultSelector,
            state
          });
        }

        do {
          if (condition) {
            let conditionResult;

            try {
              conditionResult = condition(state);
            } catch (err) {
              subscriber.error(err);
              return undefined;
            }

            if (!conditionResult) {
              subscriber.complete();
              break;
            }
          }

          let value;

          try {
            value = resultSelector(state);
          } catch (err) {
            subscriber.error(err);
            return undefined;
          }

          subscriber.next(value);

          if (subscriber.closed) {
            break;
          }

          try {
            state = iterate(state);
          } catch (err) {
            subscriber.error(err);
            return undefined;
          }
        } while (true);

        return undefined;
      });
    }

    function dispatch(state) {
      const {
        subscriber,
        condition
      } = state;

      if (subscriber.closed) {
        return undefined;
      }

      if (state.needIterate) {
        try {
          state.state = state.iterate(state.state);
        } catch (err) {
          subscriber.error(err);
          return undefined;
        }
      } else {
        state.needIterate = true;
      }

      if (condition) {
        let conditionResult;

        try {
          conditionResult = condition(state.state);
        } catch (err) {
          subscriber.error(err);
          return undefined;
        }

        if (!conditionResult) {
          subscriber.complete();
          return undefined;
        }

        if (subscriber.closed) {
          return undefined;
        }
      }

      let value;

      try {
        value = state.resultSelector(state.state);
      } catch (err) {
        subscriber.error(err);
        return undefined;
      }

      if (subscriber.closed) {
        return undefined;
      }

      subscriber.next(value);

      if (subscriber.closed) {
        return undefined;
      }

      return this.schedule(state);
    } //# sourceMappingURL=generate.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/iif.js":
  /*!***************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/iif.js ***!
    \***************************************************************/

  /*! exports provided: iif */

  /***/
  function node_modulesRxjs_esm2015InternalObservableIifJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "iif", function () {
      return iif;
    });
    /* harmony import */


    var _defer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./defer */
    "./node_modules/rxjs/_esm2015/internal/observable/defer.js");
    /* harmony import */


    var _empty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./empty */
    "./node_modules/rxjs/_esm2015/internal/observable/empty.js");

    function iif(condition, trueResult = _empty__WEBPACK_IMPORTED_MODULE_1__["EMPTY"], falseResult = _empty__WEBPACK_IMPORTED_MODULE_1__["EMPTY"]) {
      return Object(_defer__WEBPACK_IMPORTED_MODULE_0__["defer"])(() => condition() ? trueResult : falseResult);
    } //# sourceMappingURL=iif.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/interval.js":
  /*!********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/interval.js ***!
    \********************************************************************/

  /*! exports provided: interval */

  /***/
  function node_modulesRxjs_esm2015InternalObservableIntervalJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "interval", function () {
      return interval;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../scheduler/async */
    "./node_modules/rxjs/_esm2015/internal/scheduler/async.js");
    /* harmony import */


    var _util_isNumeric__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/isNumeric */
    "./node_modules/rxjs/_esm2015/internal/util/isNumeric.js");

    function interval(period = 0, scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__["async"]) {
      if (!Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__["isNumeric"])(period) || period < 0) {
        period = 0;
      }

      if (!scheduler || typeof scheduler.schedule !== 'function') {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__["async"];
      }

      return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](subscriber => {
        subscriber.add(scheduler.schedule(dispatch, period, {
          subscriber,
          counter: 0,
          period
        }));
        return subscriber;
      });
    }

    function dispatch(state) {
      const {
        subscriber,
        counter,
        period
      } = state;
      subscriber.next(counter);
      this.schedule({
        subscriber,
        counter: counter + 1,
        period
      }, period);
    } //# sourceMappingURL=interval.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/merge.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/merge.js ***!
    \*****************************************************************/

  /*! exports provided: merge */

  /***/
  function node_modulesRxjs_esm2015InternalObservableMergeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "merge", function () {
      return merge;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/isScheduler */
    "./node_modules/rxjs/_esm2015/internal/util/isScheduler.js");
    /* harmony import */


    var _operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../operators/mergeAll */
    "./node_modules/rxjs/_esm2015/internal/operators/mergeAll.js");
    /* harmony import */


    var _fromArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./fromArray */
    "./node_modules/rxjs/_esm2015/internal/observable/fromArray.js");

    function merge(...observables) {
      let concurrent = Number.POSITIVE_INFINITY;
      let scheduler = null;
      let last = observables[observables.length - 1];

      if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__["isScheduler"])(last)) {
        scheduler = observables.pop();

        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
          concurrent = observables.pop();
        }
      } else if (typeof last === 'number') {
        concurrent = observables.pop();
      }

      if (scheduler === null && observables.length === 1 && observables[0] instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"]) {
        return observables[0];
      }

      return Object(_operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__["mergeAll"])(concurrent)(Object(_fromArray__WEBPACK_IMPORTED_MODULE_3__["fromArray"])(observables, scheduler));
    } //# sourceMappingURL=merge.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/never.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/never.js ***!
    \*****************************************************************/

  /*! exports provided: NEVER, never */

  /***/
  function node_modulesRxjs_esm2015InternalObservableNeverJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "NEVER", function () {
      return NEVER;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "never", function () {
      return never;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _util_noop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/noop */
    "./node_modules/rxjs/_esm2015/internal/util/noop.js");

    const NEVER = new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](_util_noop__WEBPACK_IMPORTED_MODULE_1__["noop"]);

    function never() {
      return NEVER;
    } //# sourceMappingURL=never.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/of.js":
  /*!**************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/of.js ***!
    \**************************************************************/

  /*! exports provided: of */

  /***/
  function node_modulesRxjs_esm2015InternalObservableOfJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "of", function () {
      return of;
    });
    /* harmony import */


    var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../util/isScheduler */
    "./node_modules/rxjs/_esm2015/internal/util/isScheduler.js");
    /* harmony import */


    var _fromArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./fromArray */
    "./node_modules/rxjs/_esm2015/internal/observable/fromArray.js");
    /* harmony import */


    var _empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./empty */
    "./node_modules/rxjs/_esm2015/internal/observable/empty.js");
    /* harmony import */


    var _scalar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./scalar */
    "./node_modules/rxjs/_esm2015/internal/observable/scalar.js");

    function of(...args) {
      let scheduler = args[args.length - 1];

      if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__["isScheduler"])(scheduler)) {
        args.pop();
      } else {
        scheduler = undefined;
      }

      switch (args.length) {
        case 0:
          return Object(_empty__WEBPACK_IMPORTED_MODULE_2__["empty"])(scheduler);

        case 1:
          return scheduler ? Object(_fromArray__WEBPACK_IMPORTED_MODULE_1__["fromArray"])(args, scheduler) : Object(_scalar__WEBPACK_IMPORTED_MODULE_3__["scalar"])(args[0]);

        default:
          return Object(_fromArray__WEBPACK_IMPORTED_MODULE_1__["fromArray"])(args, scheduler);
      }
    } //# sourceMappingURL=of.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/onErrorResumeNext.js":
  /*!*****************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/onErrorResumeNext.js ***!
    \*****************************************************************************/

  /*! exports provided: onErrorResumeNext */

  /***/
  function node_modulesRxjs_esm2015InternalObservableOnErrorResumeNextJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "onErrorResumeNext", function () {
      return onErrorResumeNext;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./from */
    "./node_modules/rxjs/_esm2015/internal/observable/from.js");
    /* harmony import */


    var _util_isArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/isArray */
    "./node_modules/rxjs/_esm2015/internal/util/isArray.js");
    /* harmony import */


    var _empty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./empty */
    "./node_modules/rxjs/_esm2015/internal/observable/empty.js");

    function onErrorResumeNext(...sources) {
      if (sources.length === 0) {
        return _empty__WEBPACK_IMPORTED_MODULE_3__["EMPTY"];
      }

      const [first, ...remainder] = sources;

      if (sources.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_2__["isArray"])(first)) {
        return onErrorResumeNext(...first);
      }

      return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](subscriber => {
        const subNext = () => subscriber.add(onErrorResumeNext(...remainder).subscribe(subscriber));

        return Object(_from__WEBPACK_IMPORTED_MODULE_1__["from"])(first).subscribe({
          next(value) {
            subscriber.next(value);
          },

          error: subNext,
          complete: subNext
        });
      });
    } //# sourceMappingURL=onErrorResumeNext.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/pairs.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/pairs.js ***!
    \*****************************************************************/

  /*! exports provided: pairs, dispatch */

  /***/
  function node_modulesRxjs_esm2015InternalObservablePairsJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "pairs", function () {
      return pairs;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "dispatch", function () {
      return dispatch;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Subscription */
    "./node_modules/rxjs/_esm2015/internal/Subscription.js");

    function pairs(obj, scheduler) {
      if (!scheduler) {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](subscriber => {
          const keys = Object.keys(obj);

          for (let i = 0; i < keys.length && !subscriber.closed; i++) {
            const key = keys[i];

            if (obj.hasOwnProperty(key)) {
              subscriber.next([key, obj[key]]);
            }
          }

          subscriber.complete();
        });
      } else {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](subscriber => {
          const keys = Object.keys(obj);
          const subscription = new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]();
          subscription.add(scheduler.schedule(dispatch, 0, {
            keys,
            index: 0,
            subscriber,
            subscription,
            obj
          }));
          return subscription;
        });
      }
    }

    function dispatch(state) {
      const {
        keys,
        index,
        subscriber,
        subscription,
        obj
      } = state;

      if (!subscriber.closed) {
        if (index < keys.length) {
          const key = keys[index];
          subscriber.next([key, obj[key]]);
          subscription.add(this.schedule({
            keys,
            index: index + 1,
            subscriber,
            subscription,
            obj
          }));
        } else {
          subscriber.complete();
        }
      }
    } //# sourceMappingURL=pairs.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/race.js":
  /*!****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/race.js ***!
    \****************************************************************/

  /*! exports provided: race, RaceOperator, RaceSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalObservableRaceJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "race", function () {
      return race;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RaceOperator", function () {
      return RaceOperator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "RaceSubscriber", function () {
      return RaceSubscriber;
    });
    /* harmony import */


    var _util_isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../util/isArray */
    "./node_modules/rxjs/_esm2015/internal/util/isArray.js");
    /* harmony import */


    var _fromArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./fromArray */
    "./node_modules/rxjs/_esm2015/internal/observable/fromArray.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function race(...observables) {
      if (observables.length === 1) {
        if (Object(_util_isArray__WEBPACK_IMPORTED_MODULE_0__["isArray"])(observables[0])) {
          observables = observables[0];
        } else {
          return observables[0];
        }
      }

      return Object(_fromArray__WEBPACK_IMPORTED_MODULE_1__["fromArray"])(observables, undefined).lift(new RaceOperator());
    }

    class RaceOperator {
      call(subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
      }

    }

    class RaceSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__["OuterSubscriber"] {
      constructor(destination) {
        super(destination);
        this.hasFirst = false;
        this.observables = [];
        this.subscriptions = [];
      }

      _next(observable) {
        this.observables.push(observable);
      }

      _complete() {
        const observables = this.observables;
        const len = observables.length;

        if (len === 0) {
          this.destination.complete();
        } else {
          for (let i = 0; i < len && !this.hasFirst; i++) {
            let observable = observables[i];
            let subscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__["subscribeToResult"])(this, observable, observable, i);

            if (this.subscriptions) {
              this.subscriptions.push(subscription);
            }

            this.add(subscription);
          }

          this.observables = null;
        }
      }

      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (!this.hasFirst) {
          this.hasFirst = true;

          for (let i = 0; i < this.subscriptions.length; i++) {
            if (i !== outerIndex) {
              let subscription = this.subscriptions[i];
              subscription.unsubscribe();
              this.remove(subscription);
            }
          }

          this.subscriptions = null;
        }

        this.destination.next(innerValue);
      }

    } //# sourceMappingURL=race.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/range.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/range.js ***!
    \*****************************************************************/

  /*! exports provided: range, dispatch */

  /***/
  function node_modulesRxjs_esm2015InternalObservableRangeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "range", function () {
      return range;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "dispatch", function () {
      return dispatch;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");

    function range(start = 0, count, scheduler) {
      return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](subscriber => {
        if (count === undefined) {
          count = start;
          start = 0;
        }

        let index = 0;
        let current = start;

        if (scheduler) {
          return scheduler.schedule(dispatch, 0, {
            index,
            count,
            start,
            subscriber
          });
        } else {
          do {
            if (index++ >= count) {
              subscriber.complete();
              break;
            }

            subscriber.next(current++);

            if (subscriber.closed) {
              break;
            }
          } while (true);
        }

        return undefined;
      });
    }

    function dispatch(state) {
      const {
        start,
        index,
        count,
        subscriber
      } = state;

      if (index >= count) {
        subscriber.complete();
        return;
      }

      subscriber.next(start);

      if (subscriber.closed) {
        return;
      }

      state.index = index + 1;
      state.start = start + 1;
      this.schedule(state);
    } //# sourceMappingURL=range.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/scalar.js":
  /*!******************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/scalar.js ***!
    \******************************************************************/

  /*! exports provided: scalar */

  /***/
  function node_modulesRxjs_esm2015InternalObservableScalarJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scalar", function () {
      return scalar;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");

    function scalar(value) {
      const result = new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](subscriber => {
        subscriber.next(value);
        subscriber.complete();
      });
      result._isScalar = true;
      result.value = value;
      return result;
    } //# sourceMappingURL=scalar.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/throwError.js":
  /*!**********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/throwError.js ***!
    \**********************************************************************/

  /*! exports provided: throwError */

  /***/
  function node_modulesRxjs_esm2015InternalObservableThrowErrorJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "throwError", function () {
      return throwError;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");

    function throwError(error, scheduler) {
      if (!scheduler) {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](subscriber => subscriber.error(error));
      } else {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](subscriber => scheduler.schedule(dispatch, 0, {
          error,
          subscriber
        }));
      }
    }

    function dispatch({
      error,
      subscriber
    }) {
      subscriber.error(error);
    } //# sourceMappingURL=throwError.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/timer.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/timer.js ***!
    \*****************************************************************/

  /*! exports provided: timer */

  /***/
  function node_modulesRxjs_esm2015InternalObservableTimerJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "timer", function () {
      return timer;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../scheduler/async */
    "./node_modules/rxjs/_esm2015/internal/scheduler/async.js");
    /* harmony import */


    var _util_isNumeric__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/isNumeric */
    "./node_modules/rxjs/_esm2015/internal/util/isNumeric.js");
    /* harmony import */


    var _util_isScheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../util/isScheduler */
    "./node_modules/rxjs/_esm2015/internal/util/isScheduler.js");

    function timer(dueTime = 0, periodOrScheduler, scheduler) {
      let period = -1;

      if (Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__["isNumeric"])(periodOrScheduler)) {
        period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
      } else if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_3__["isScheduler"])(periodOrScheduler)) {
        scheduler = periodOrScheduler;
      }

      if (!Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_3__["isScheduler"])(scheduler)) {
        scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__["async"];
      }

      return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](subscriber => {
        const due = Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_2__["isNumeric"])(dueTime) ? dueTime : +dueTime - scheduler.now();
        return scheduler.schedule(dispatch, due, {
          index: 0,
          period,
          subscriber
        });
      });
    }

    function dispatch(state) {
      const {
        index,
        period,
        subscriber
      } = state;
      subscriber.next(index);

      if (subscriber.closed) {
        return;
      } else if (period === -1) {
        return subscriber.complete();
      }

      state.index = index + 1;
      this.schedule(state, period);
    } //# sourceMappingURL=timer.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/using.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/using.js ***!
    \*****************************************************************/

  /*! exports provided: using */

  /***/
  function node_modulesRxjs_esm2015InternalObservableUsingJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "using", function () {
      return using;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _from__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./from */
    "./node_modules/rxjs/_esm2015/internal/observable/from.js");
    /* harmony import */


    var _empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./empty */
    "./node_modules/rxjs/_esm2015/internal/observable/empty.js");

    function using(resourceFactory, observableFactory) {
      return new _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"](subscriber => {
        let resource;

        try {
          resource = resourceFactory();
        } catch (err) {
          subscriber.error(err);
          return undefined;
        }

        let result;

        try {
          result = observableFactory(resource);
        } catch (err) {
          subscriber.error(err);
          return undefined;
        }

        const source = result ? Object(_from__WEBPACK_IMPORTED_MODULE_1__["from"])(result) : _empty__WEBPACK_IMPORTED_MODULE_2__["EMPTY"];
        const subscription = source.subscribe(subscriber);
        return () => {
          subscription.unsubscribe();

          if (resource) {
            resource.unsubscribe();
          }
        };
      });
    } //# sourceMappingURL=using.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/observable/zip.js":
  /*!***************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/observable/zip.js ***!
    \***************************************************************/

  /*! exports provided: zip, ZipOperator, ZipSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalObservableZipJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "zip", function () {
      return zip;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ZipOperator", function () {
      return ZipOperator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ZipSubscriber", function () {
      return ZipSubscriber;
    });
    /* harmony import */


    var _fromArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./fromArray */
    "./node_modules/rxjs/_esm2015/internal/observable/fromArray.js");
    /* harmony import */


    var _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/isArray */
    "./node_modules/rxjs/_esm2015/internal/util/isArray.js");
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");
    /* harmony import */


    var _internal_symbol_iterator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! ../../internal/symbol/iterator */
    "./node_modules/rxjs/_esm2015/internal/symbol/iterator.js");

    function zip(...observables) {
      const resultSelector = observables[observables.length - 1];

      if (typeof resultSelector === 'function') {
        observables.pop();
      }

      return Object(_fromArray__WEBPACK_IMPORTED_MODULE_0__["fromArray"])(observables, undefined).lift(new ZipOperator(resultSelector));
    }

    class ZipOperator {
      constructor(resultSelector) {
        this.resultSelector = resultSelector;
      }

      call(subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
      }

    }

    class ZipSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_2__["Subscriber"] {
      constructor(destination, resultSelector, values = Object.create(null)) {
        super(destination);
        this.iterators = [];
        this.active = 0;
        this.resultSelector = typeof resultSelector === 'function' ? resultSelector : null;
        this.values = values;
      }

      _next(value) {
        const iterators = this.iterators;

        if (Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__["isArray"])(value)) {
          iterators.push(new StaticArrayIterator(value));
        } else if (typeof value[_internal_symbol_iterator__WEBPACK_IMPORTED_MODULE_5__["iterator"]] === 'function') {
          iterators.push(new StaticIterator(value[_internal_symbol_iterator__WEBPACK_IMPORTED_MODULE_5__["iterator"]]()));
        } else {
          iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
      }

      _complete() {
        const iterators = this.iterators;
        const len = iterators.length;
        this.unsubscribe();

        if (len === 0) {
          this.destination.complete();
          return;
        }

        this.active = len;

        for (let i = 0; i < len; i++) {
          let iterator = iterators[i];

          if (iterator.stillUnsubscribed) {
            const destination = this.destination;
            destination.add(iterator.subscribe(iterator, i));
          } else {
            this.active--;
          }
        }
      }

      notifyInactive() {
        this.active--;

        if (this.active === 0) {
          this.destination.complete();
        }
      }

      checkIterators() {
        const iterators = this.iterators;
        const len = iterators.length;
        const destination = this.destination;

        for (let i = 0; i < len; i++) {
          let iterator = iterators[i];

          if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
            return;
          }
        }

        let shouldComplete = false;
        const args = [];

        for (let i = 0; i < len; i++) {
          let iterator = iterators[i];
          let result = iterator.next();

          if (iterator.hasCompleted()) {
            shouldComplete = true;
          }

          if (result.done) {
            destination.complete();
            return;
          }

          args.push(result.value);
        }

        if (this.resultSelector) {
          this._tryresultSelector(args);
        } else {
          destination.next(args);
        }

        if (shouldComplete) {
          destination.complete();
        }
      }

      _tryresultSelector(args) {
        let result;

        try {
          result = this.resultSelector.apply(this, args);
        } catch (err) {
          this.destination.error(err);
          return;
        }

        this.destination.next(result);
      }

    }

    class StaticIterator {
      constructor(iterator) {
        this.iterator = iterator;
        this.nextResult = iterator.next();
      }

      hasValue() {
        return true;
      }

      next() {
        const result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
      }

      hasCompleted() {
        const nextResult = this.nextResult;
        return nextResult && nextResult.done;
      }

    }

    class StaticArrayIterator {
      constructor(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
      }

      [_internal_symbol_iterator__WEBPACK_IMPORTED_MODULE_5__["iterator"]]() {
        return this;
      }

      next(value) {
        const i = this.index++;
        const array = this.array;
        return i < this.length ? {
          value: array[i],
          done: false
        } : {
          value: null,
          done: true
        };
      }

      hasValue() {
        return this.array.length > this.index;
      }

      hasCompleted() {
        return this.array.length === this.index;
      }

    }

    class ZipBufferIterator extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_3__["OuterSubscriber"] {
      constructor(destination, parent, observable) {
        super(destination);
        this.parent = parent;
        this.observable = observable;
        this.stillUnsubscribed = true;
        this.buffer = [];
        this.isComplete = false;
      }

      [_internal_symbol_iterator__WEBPACK_IMPORTED_MODULE_5__["iterator"]]() {
        return this;
      }

      next() {
        const buffer = this.buffer;

        if (buffer.length === 0 && this.isComplete) {
          return {
            value: null,
            done: true
          };
        } else {
          return {
            value: buffer.shift(),
            done: false
          };
        }
      }

      hasValue() {
        return this.buffer.length > 0;
      }

      hasCompleted() {
        return this.buffer.length === 0 && this.isComplete;
      }

      notifyComplete() {
        if (this.buffer.length > 0) {
          this.isComplete = true;
          this.parent.notifyInactive();
        } else {
          this.destination.complete();
        }
      }

      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
      }

      subscribe(value, index) {
        return Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__["subscribeToResult"])(this, this.observable, this, index);
      }

    } //# sourceMappingURL=zip.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/audit.js":
  /*!****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/audit.js ***!
    \****************************************************************/

  /*! exports provided: audit */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsAuditJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "audit", function () {
      return audit;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function audit(durationSelector) {
      return function auditOperatorFunction(source) {
        return source.lift(new AuditOperator(durationSelector));
      };
    }

    class AuditOperator {
      constructor(durationSelector) {
        this.durationSelector = durationSelector;
      }

      call(subscriber, source) {
        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
      }

    }

    class AuditSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"] {
      constructor(destination, durationSelector) {
        super(destination);
        this.durationSelector = durationSelector;
        this.hasValue = false;
      }

      _next(value) {
        this.value = value;
        this.hasValue = true;

        if (!this.throttled) {
          let duration;

          try {
            const {
              durationSelector
            } = this;
            duration = durationSelector(value);
          } catch (err) {
            return this.destination.error(err);
          }

          const innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__["subscribeToResult"])(this, duration);

          if (!innerSubscription || innerSubscription.closed) {
            this.clearThrottle();
          } else {
            this.add(this.throttled = innerSubscription);
          }
        }
      }

      clearThrottle() {
        const {
          value,
          hasValue,
          throttled
        } = this;

        if (throttled) {
          this.remove(throttled);
          this.throttled = null;
          throttled.unsubscribe();
        }

        if (hasValue) {
          this.value = null;
          this.hasValue = false;
          this.destination.next(value);
        }
      }

      notifyNext(outerValue, innerValue, outerIndex, innerIndex) {
        this.clearThrottle();
      }

      notifyComplete() {
        this.clearThrottle();
      }

    } //# sourceMappingURL=audit.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/auditTime.js":
  /*!********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/auditTime.js ***!
    \********************************************************************/

  /*! exports provided: auditTime */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsAuditTimeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "auditTime", function () {
      return auditTime;
    });
    /* harmony import */


    var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../scheduler/async */
    "./node_modules/rxjs/_esm2015/internal/scheduler/async.js");
    /* harmony import */


    var _audit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./audit */
    "./node_modules/rxjs/_esm2015/internal/operators/audit.js");
    /* harmony import */


    var _observable_timer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../observable/timer */
    "./node_modules/rxjs/_esm2015/internal/observable/timer.js");

    function auditTime(duration, scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__["async"]) {
      return Object(_audit__WEBPACK_IMPORTED_MODULE_1__["audit"])(() => Object(_observable_timer__WEBPACK_IMPORTED_MODULE_2__["timer"])(duration, scheduler));
    } //# sourceMappingURL=auditTime.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/buffer.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/buffer.js ***!
    \*****************************************************************/

  /*! exports provided: buffer */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsBufferJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "buffer", function () {
      return buffer;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function buffer(closingNotifier) {
      return function bufferOperatorFunction(source) {
        return source.lift(new BufferOperator(closingNotifier));
      };
    }

    class BufferOperator {
      constructor(closingNotifier) {
        this.closingNotifier = closingNotifier;
      }

      call(subscriber, source) {
        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
      }

    }

    class BufferSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"] {
      constructor(destination, closingNotifier) {
        super(destination);
        this.buffer = [];
        this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__["subscribeToResult"])(this, closingNotifier));
      }

      _next(value) {
        this.buffer.push(value);
      }

      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        const buffer = this.buffer;
        this.buffer = [];
        this.destination.next(buffer);
      }

    } //# sourceMappingURL=buffer.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/bufferCount.js":
  /*!**********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/bufferCount.js ***!
    \**********************************************************************/

  /*! exports provided: bufferCount */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsBufferCountJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "bufferCount", function () {
      return bufferCount;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function bufferCount(bufferSize, startBufferEvery = null) {
      return function bufferCountOperatorFunction(source) {
        return source.lift(new BufferCountOperator(bufferSize, startBufferEvery));
      };
    }

    class BufferCountOperator {
      constructor(bufferSize, startBufferEvery) {
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;

        if (!startBufferEvery || bufferSize === startBufferEvery) {
          this.subscriberClass = BufferCountSubscriber;
        } else {
          this.subscriberClass = BufferSkipCountSubscriber;
        }
      }

      call(subscriber, source) {
        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
      }

    }

    class BufferCountSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, bufferSize) {
        super(destination);
        this.bufferSize = bufferSize;
        this.buffer = [];
      }

      _next(value) {
        const buffer = this.buffer;
        buffer.push(value);

        if (buffer.length == this.bufferSize) {
          this.destination.next(buffer);
          this.buffer = [];
        }
      }

      _complete() {
        const buffer = this.buffer;

        if (buffer.length > 0) {
          this.destination.next(buffer);
        }

        super._complete();
      }

    }

    class BufferSkipCountSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, bufferSize, startBufferEvery) {
        super(destination);
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        this.buffers = [];
        this.count = 0;
      }

      _next(value) {
        const {
          bufferSize,
          startBufferEvery,
          buffers,
          count
        } = this;
        this.count++;

        if (count % startBufferEvery === 0) {
          buffers.push([]);
        }

        for (let i = buffers.length; i--;) {
          const buffer = buffers[i];
          buffer.push(value);

          if (buffer.length === bufferSize) {
            buffers.splice(i, 1);
            this.destination.next(buffer);
          }
        }
      }

      _complete() {
        const {
          buffers,
          destination
        } = this;

        while (buffers.length > 0) {
          let buffer = buffers.shift();

          if (buffer.length > 0) {
            destination.next(buffer);
          }
        }

        super._complete();
      }

    } //# sourceMappingURL=bufferCount.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/bufferTime.js":
  /*!*********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/bufferTime.js ***!
    \*********************************************************************/

  /*! exports provided: bufferTime */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsBufferTimeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "bufferTime", function () {
      return bufferTime;
    });
    /* harmony import */


    var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../scheduler/async */
    "./node_modules/rxjs/_esm2015/internal/scheduler/async.js");
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _util_isScheduler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/isScheduler */
    "./node_modules/rxjs/_esm2015/internal/util/isScheduler.js");

    function bufferTime(bufferTimeSpan) {
      let length = arguments.length;
      let scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__["async"];

      if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_2__["isScheduler"])(arguments[arguments.length - 1])) {
        scheduler = arguments[arguments.length - 1];
        length--;
      }

      let bufferCreationInterval = null;

      if (length >= 2) {
        bufferCreationInterval = arguments[1];
      }

      let maxBufferSize = Number.POSITIVE_INFINITY;

      if (length >= 3) {
        maxBufferSize = arguments[2];
      }

      return function bufferTimeOperatorFunction(source) {
        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));
      };
    }

    class BufferTimeOperator {
      constructor(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
      }

      call(subscriber, source) {
        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
      }

    }

    class Context {
      constructor() {
        this.buffer = [];
      }

    }

    class BufferTimeSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_1__["Subscriber"] {
      constructor(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        super(destination);
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
        this.contexts = [];
        const context = this.openContext();
        this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;

        if (this.timespanOnly) {
          const timeSpanOnlyState = {
            subscriber: this,
            context,
            bufferTimeSpan
          };
          this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        } else {
          const closeState = {
            subscriber: this,
            context
          };
          const creationState = {
            bufferTimeSpan,
            bufferCreationInterval,
            subscriber: this,
            scheduler
          };
          this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
          this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        }
      }

      _next(value) {
        const contexts = this.contexts;
        const len = contexts.length;
        let filledBufferContext;

        for (let i = 0; i < len; i++) {
          const context = contexts[i];
          const buffer = context.buffer;
          buffer.push(value);

          if (buffer.length == this.maxBufferSize) {
            filledBufferContext = context;
          }
        }

        if (filledBufferContext) {
          this.onBufferFull(filledBufferContext);
        }
      }

      _error(err) {
        this.contexts.length = 0;

        super._error(err);
      }

      _complete() {
        const {
          contexts,
          destination
        } = this;

        while (contexts.length > 0) {
          const context = contexts.shift();
          destination.next(context.buffer);
        }

        super._complete();
      }

      _unsubscribe() {
        this.contexts = null;
      }

      onBufferFull(context) {
        this.closeContext(context);
        const closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);

        if (!this.closed && this.timespanOnly) {
          context = this.openContext();
          const bufferTimeSpan = this.bufferTimeSpan;
          const timeSpanOnlyState = {
            subscriber: this,
            context,
            bufferTimeSpan
          };
          this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
      }

      openContext() {
        const context = new Context();
        this.contexts.push(context);
        return context;
      }

      closeContext(context) {
        this.destination.next(context.buffer);
        const contexts = this.contexts;
        const spliceIndex = contexts ? contexts.indexOf(context) : -1;

        if (spliceIndex >= 0) {
          contexts.splice(contexts.indexOf(context), 1);
        }
      }

    }

    function dispatchBufferTimeSpanOnly(state) {
      const subscriber = state.subscriber;
      const prevContext = state.context;

      if (prevContext) {
        subscriber.closeContext(prevContext);
      }

      if (!subscriber.closed) {
        state.context = subscriber.openContext();
        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
      }
    }

    function dispatchBufferCreation(state) {
      const {
        bufferCreationInterval,
        bufferTimeSpan,
        subscriber,
        scheduler
      } = state;
      const context = subscriber.openContext();
      const action = this;

      if (!subscriber.closed) {
        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, {
          subscriber,
          context
        }));
        action.schedule(state, bufferCreationInterval);
      }
    }

    function dispatchBufferClose(arg) {
      const {
        subscriber,
        context
      } = arg;
      subscriber.closeContext(context);
    } //# sourceMappingURL=bufferTime.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/bufferToggle.js":
  /*!***********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/bufferToggle.js ***!
    \***********************************************************************/

  /*! exports provided: bufferToggle */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsBufferToggleJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "bufferToggle", function () {
      return bufferToggle;
    });
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscription */
    "./node_modules/rxjs/_esm2015/internal/Subscription.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");

    function bufferToggle(openings, closingSelector) {
      return function bufferToggleOperatorFunction(source) {
        return source.lift(new BufferToggleOperator(openings, closingSelector));
      };
    }

    class BufferToggleOperator {
      constructor(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
      }

      call(subscriber, source) {
        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
      }

    }

    class BufferToggleSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__["OuterSubscriber"] {
      constructor(destination, openings, closingSelector) {
        super(destination);
        this.openings = openings;
        this.closingSelector = closingSelector;
        this.contexts = [];
        this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__["subscribeToResult"])(this, openings));
      }

      _next(value) {
        const contexts = this.contexts;
        const len = contexts.length;

        for (let i = 0; i < len; i++) {
          contexts[i].buffer.push(value);
        }
      }

      _error(err) {
        const contexts = this.contexts;

        while (contexts.length > 0) {
          const context = contexts.shift();
          context.subscription.unsubscribe();
          context.buffer = null;
          context.subscription = null;
        }

        this.contexts = null;

        super._error(err);
      }

      _complete() {
        const contexts = this.contexts;

        while (contexts.length > 0) {
          const context = contexts.shift();
          this.destination.next(context.buffer);
          context.subscription.unsubscribe();
          context.buffer = null;
          context.subscription = null;
        }

        this.contexts = null;

        super._complete();
      }

      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
      }

      notifyComplete(innerSub) {
        this.closeBuffer(innerSub.context);
      }

      openBuffer(value) {
        try {
          const closingSelector = this.closingSelector;
          const closingNotifier = closingSelector.call(this, value);

          if (closingNotifier) {
            this.trySubscribe(closingNotifier);
          }
        } catch (err) {
          this._error(err);
        }
      }

      closeBuffer(context) {
        const contexts = this.contexts;

        if (contexts && context) {
          const {
            buffer,
            subscription
          } = context;
          this.destination.next(buffer);
          contexts.splice(contexts.indexOf(context), 1);
          this.remove(subscription);
          subscription.unsubscribe();
        }
      }

      trySubscribe(closingNotifier) {
        const contexts = this.contexts;
        const buffer = [];
        const subscription = new _Subscription__WEBPACK_IMPORTED_MODULE_0__["Subscription"]();
        const context = {
          buffer,
          subscription
        };
        contexts.push(context);
        const innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__["subscribeToResult"])(this, closingNotifier, context);

        if (!innerSubscription || innerSubscription.closed) {
          this.closeBuffer(context);
        } else {
          innerSubscription.context = context;
          this.add(innerSubscription);
          subscription.add(innerSubscription);
        }
      }

    } //# sourceMappingURL=bufferToggle.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/bufferWhen.js":
  /*!*********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/bufferWhen.js ***!
    \*********************************************************************/

  /*! exports provided: bufferWhen */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsBufferWhenJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "bufferWhen", function () {
      return bufferWhen;
    });
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscription */
    "./node_modules/rxjs/_esm2015/internal/Subscription.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function bufferWhen(closingSelector) {
      return function (source) {
        return source.lift(new BufferWhenOperator(closingSelector));
      };
    }

    class BufferWhenOperator {
      constructor(closingSelector) {
        this.closingSelector = closingSelector;
      }

      call(subscriber, source) {
        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
      }

    }

    class BufferWhenSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"] {
      constructor(destination, closingSelector) {
        super(destination);
        this.closingSelector = closingSelector;
        this.subscribing = false;
        this.openBuffer();
      }

      _next(value) {
        this.buffer.push(value);
      }

      _complete() {
        const buffer = this.buffer;

        if (buffer) {
          this.destination.next(buffer);
        }

        super._complete();
      }

      _unsubscribe() {
        this.buffer = null;
        this.subscribing = false;
      }

      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openBuffer();
      }

      notifyComplete() {
        if (this.subscribing) {
          this.complete();
        } else {
          this.openBuffer();
        }
      }

      openBuffer() {
        let {
          closingSubscription
        } = this;

        if (closingSubscription) {
          this.remove(closingSubscription);
          closingSubscription.unsubscribe();
        }

        const buffer = this.buffer;

        if (this.buffer) {
          this.destination.next(buffer);
        }

        this.buffer = [];
        let closingNotifier;

        try {
          const {
            closingSelector
          } = this;
          closingNotifier = closingSelector();
        } catch (err) {
          return this.error(err);
        }

        closingSubscription = new _Subscription__WEBPACK_IMPORTED_MODULE_0__["Subscription"]();
        this.closingSubscription = closingSubscription;
        this.add(closingSubscription);
        this.subscribing = true;
        closingSubscription.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, closingNotifier));
        this.subscribing = false;
      }

    } //# sourceMappingURL=bufferWhen.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/catchError.js":
  /*!*********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/catchError.js ***!
    \*********************************************************************/

  /*! exports provided: catchError */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsCatchErrorJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "catchError", function () {
      return catchError;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../InnerSubscriber */
    "./node_modules/rxjs/_esm2015/internal/InnerSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function catchError(selector) {
      return function catchErrorOperatorFunction(source) {
        const operator = new CatchOperator(selector);
        const caught = source.lift(operator);
        return operator.caught = caught;
      };
    }

    class CatchOperator {
      constructor(selector) {
        this.selector = selector;
      }

      call(subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
      }

    }

    class CatchSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"] {
      constructor(destination, selector, caught) {
        super(destination);
        this.selector = selector;
        this.caught = caught;
      }

      error(err) {
        if (!this.isStopped) {
          let result;

          try {
            result = this.selector(err, this.caught);
          } catch (err2) {
            super.error(err2);
            return;
          }

          this._unsubscribeAndRecycle();

          const innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_1__["InnerSubscriber"](this, undefined, undefined);
          this.add(innerSubscriber);
          Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, result, undefined, undefined, innerSubscriber);
        }
      }

    } //# sourceMappingURL=catchError.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/combineAll.js":
  /*!*********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/combineAll.js ***!
    \*********************************************************************/

  /*! exports provided: combineAll */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsCombineAllJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "combineAll", function () {
      return combineAll;
    });
    /* harmony import */


    var _observable_combineLatest__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../observable/combineLatest */
    "./node_modules/rxjs/_esm2015/internal/observable/combineLatest.js");

    function combineAll(project) {
      return source => source.lift(new _observable_combineLatest__WEBPACK_IMPORTED_MODULE_0__["CombineLatestOperator"](project));
    } //# sourceMappingURL=combineAll.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/combineLatest.js":
  /*!************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/combineLatest.js ***!
    \************************************************************************/

  /*! exports provided: combineLatest */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsCombineLatestJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "combineLatest", function () {
      return combineLatest;
    });
    /* harmony import */


    var _util_isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../util/isArray */
    "./node_modules/rxjs/_esm2015/internal/util/isArray.js");
    /* harmony import */


    var _observable_combineLatest__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../observable/combineLatest */
    "./node_modules/rxjs/_esm2015/internal/observable/combineLatest.js");
    /* harmony import */


    var _observable_from__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../observable/from */
    "./node_modules/rxjs/_esm2015/internal/observable/from.js");

    const none = {};

    function combineLatest(...observables) {
      let project = null;

      if (typeof observables[observables.length - 1] === 'function') {
        project = observables.pop();
      }

      if (observables.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_0__["isArray"])(observables[0])) {
        observables = observables[0].slice();
      }

      return source => source.lift.call(Object(_observable_from__WEBPACK_IMPORTED_MODULE_2__["from"])([source, ...observables]), new _observable_combineLatest__WEBPACK_IMPORTED_MODULE_1__["CombineLatestOperator"](project));
    } //# sourceMappingURL=combineLatest.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/concat.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/concat.js ***!
    \*****************************************************************/

  /*! exports provided: concat */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsConcatJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "concat", function () {
      return concat;
    });
    /* harmony import */


    var _observable_concat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../observable/concat */
    "./node_modules/rxjs/_esm2015/internal/observable/concat.js");

    function concat(...observables) {
      return source => source.lift.call(Object(_observable_concat__WEBPACK_IMPORTED_MODULE_0__["concat"])(source, ...observables));
    } //# sourceMappingURL=concat.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/concatAll.js":
  /*!********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/concatAll.js ***!
    \********************************************************************/

  /*! exports provided: concatAll */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsConcatAllJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "concatAll", function () {
      return concatAll;
    });
    /* harmony import */


    var _mergeAll__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./mergeAll */
    "./node_modules/rxjs/_esm2015/internal/operators/mergeAll.js");

    function concatAll() {
      return Object(_mergeAll__WEBPACK_IMPORTED_MODULE_0__["mergeAll"])(1);
    } //# sourceMappingURL=concatAll.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/concatMap.js":
  /*!********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/concatMap.js ***!
    \********************************************************************/

  /*! exports provided: concatMap */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsConcatMapJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "concatMap", function () {
      return concatMap;
    });
    /* harmony import */


    var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./mergeMap */
    "./node_modules/rxjs/_esm2015/internal/operators/mergeMap.js");

    function concatMap(project, resultSelector) {
      return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__["mergeMap"])(project, resultSelector, 1);
    } //# sourceMappingURL=concatMap.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/concatMapTo.js":
  /*!**********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/concatMapTo.js ***!
    \**********************************************************************/

  /*! exports provided: concatMapTo */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsConcatMapToJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "concatMapTo", function () {
      return concatMapTo;
    });
    /* harmony import */


    var _concatMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./concatMap */
    "./node_modules/rxjs/_esm2015/internal/operators/concatMap.js");

    function concatMapTo(innerObservable, resultSelector) {
      return Object(_concatMap__WEBPACK_IMPORTED_MODULE_0__["concatMap"])(() => innerObservable, resultSelector);
    } //# sourceMappingURL=concatMapTo.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/count.js":
  /*!****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/count.js ***!
    \****************************************************************/

  /*! exports provided: count */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsCountJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "count", function () {
      return count;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function count(predicate) {
      return source => source.lift(new CountOperator(predicate, source));
    }

    class CountOperator {
      constructor(predicate, source) {
        this.predicate = predicate;
        this.source = source;
      }

      call(subscriber, source) {
        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
      }

    }

    class CountSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, predicate, source) {
        super(destination);
        this.predicate = predicate;
        this.source = source;
        this.count = 0;
        this.index = 0;
      }

      _next(value) {
        if (this.predicate) {
          this._tryPredicate(value);
        } else {
          this.count++;
        }
      }

      _tryPredicate(value) {
        let result;

        try {
          result = this.predicate(value, this.index++, this.source);
        } catch (err) {
          this.destination.error(err);
          return;
        }

        if (result) {
          this.count++;
        }
      }

      _complete() {
        this.destination.next(this.count);
        this.destination.complete();
      }

    } //# sourceMappingURL=count.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/debounce.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/debounce.js ***!
    \*******************************************************************/

  /*! exports provided: debounce */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsDebounceJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "debounce", function () {
      return debounce;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function debounce(durationSelector) {
      return source => source.lift(new DebounceOperator(durationSelector));
    }

    class DebounceOperator {
      constructor(durationSelector) {
        this.durationSelector = durationSelector;
      }

      call(subscriber, source) {
        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
      }

    }

    class DebounceSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"] {
      constructor(destination, durationSelector) {
        super(destination);
        this.durationSelector = durationSelector;
        this.hasValue = false;
        this.durationSubscription = null;
      }

      _next(value) {
        try {
          const result = this.durationSelector.call(this, value);

          if (result) {
            this._tryNext(value, result);
          }
        } catch (err) {
          this.destination.error(err);
        }
      }

      _complete() {
        this.emitValue();
        this.destination.complete();
      }

      _tryNext(value, duration) {
        let subscription = this.durationSubscription;
        this.value = value;
        this.hasValue = true;

        if (subscription) {
          subscription.unsubscribe();
          this.remove(subscription);
        }

        subscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__["subscribeToResult"])(this, duration);

        if (subscription && !subscription.closed) {
          this.add(this.durationSubscription = subscription);
        }
      }

      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
      }

      notifyComplete() {
        this.emitValue();
      }

      emitValue() {
        if (this.hasValue) {
          const value = this.value;
          const subscription = this.durationSubscription;

          if (subscription) {
            this.durationSubscription = null;
            subscription.unsubscribe();
            this.remove(subscription);
          }

          this.value = null;
          this.hasValue = false;

          super._next(value);
        }
      }

    } //# sourceMappingURL=debounce.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/debounceTime.js":
  /*!***********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/debounceTime.js ***!
    \***********************************************************************/

  /*! exports provided: debounceTime */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsDebounceTimeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "debounceTime", function () {
      return debounceTime;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../scheduler/async */
    "./node_modules/rxjs/_esm2015/internal/scheduler/async.js");

    function debounceTime(dueTime, scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__["async"]) {
      return source => source.lift(new DebounceTimeOperator(dueTime, scheduler));
    }

    class DebounceTimeOperator {
      constructor(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
      }

      call(subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
      }

    }

    class DebounceTimeSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, dueTime, scheduler) {
        super(destination);
        this.dueTime = dueTime;
        this.scheduler = scheduler;
        this.debouncedSubscription = null;
        this.lastValue = null;
        this.hasValue = false;
      }

      _next(value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
      }

      _complete() {
        this.debouncedNext();
        this.destination.complete();
      }

      debouncedNext() {
        this.clearDebounce();

        if (this.hasValue) {
          const {
            lastValue
          } = this;
          this.lastValue = null;
          this.hasValue = false;
          this.destination.next(lastValue);
        }
      }

      clearDebounce() {
        const debouncedSubscription = this.debouncedSubscription;

        if (debouncedSubscription !== null) {
          this.remove(debouncedSubscription);
          debouncedSubscription.unsubscribe();
          this.debouncedSubscription = null;
        }
      }

    }

    function dispatchNext(subscriber) {
      subscriber.debouncedNext();
    } //# sourceMappingURL=debounceTime.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/defaultIfEmpty.js":
  /*!*************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/defaultIfEmpty.js ***!
    \*************************************************************************/

  /*! exports provided: defaultIfEmpty */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsDefaultIfEmptyJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "defaultIfEmpty", function () {
      return defaultIfEmpty;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function defaultIfEmpty(defaultValue = null) {
      return source => source.lift(new DefaultIfEmptyOperator(defaultValue));
    }

    class DefaultIfEmptyOperator {
      constructor(defaultValue) {
        this.defaultValue = defaultValue;
      }

      call(subscriber, source) {
        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
      }

    }

    class DefaultIfEmptySubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, defaultValue) {
        super(destination);
        this.defaultValue = defaultValue;
        this.isEmpty = true;
      }

      _next(value) {
        this.isEmpty = false;
        this.destination.next(value);
      }

      _complete() {
        if (this.isEmpty) {
          this.destination.next(this.defaultValue);
        }

        this.destination.complete();
      }

    } //# sourceMappingURL=defaultIfEmpty.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/delay.js":
  /*!****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/delay.js ***!
    \****************************************************************/

  /*! exports provided: delay */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsDelayJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "delay", function () {
      return delay;
    });
    /* harmony import */


    var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../scheduler/async */
    "./node_modules/rxjs/_esm2015/internal/scheduler/async.js");
    /* harmony import */


    var _util_isDate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/isDate */
    "./node_modules/rxjs/_esm2015/internal/util/isDate.js");
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _Notification__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../Notification */
    "./node_modules/rxjs/_esm2015/internal/Notification.js");

    function delay(delay, scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__["async"]) {
      const absoluteDelay = Object(_util_isDate__WEBPACK_IMPORTED_MODULE_1__["isDate"])(delay);
      const delayFor = absoluteDelay ? +delay - scheduler.now() : Math.abs(delay);
      return source => source.lift(new DelayOperator(delayFor, scheduler));
    }

    class DelayOperator {
      constructor(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
      }

      call(subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
      }

    }

    class DelaySubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_2__["Subscriber"] {
      constructor(destination, delay, scheduler) {
        super(destination);
        this.delay = delay;
        this.scheduler = scheduler;
        this.queue = [];
        this.active = false;
        this.errored = false;
      }

      static dispatch(state) {
        const source = state.source;
        const queue = source.queue;
        const scheduler = state.scheduler;
        const destination = state.destination;

        while (queue.length > 0 && queue[0].time - scheduler.now() <= 0) {
          queue.shift().notification.observe(destination);
        }

        if (queue.length > 0) {
          const delay = Math.max(0, queue[0].time - scheduler.now());
          this.schedule(state, delay);
        } else {
          this.unsubscribe();
          source.active = false;
        }
      }

      _schedule(scheduler) {
        this.active = true;
        const destination = this.destination;
        destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
          source: this,
          destination: this.destination,
          scheduler: scheduler
        }));
      }

      scheduleNotification(notification) {
        if (this.errored === true) {
          return;
        }

        const scheduler = this.scheduler;
        const message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);

        if (this.active === false) {
          this._schedule(scheduler);
        }
      }

      _next(value) {
        this.scheduleNotification(_Notification__WEBPACK_IMPORTED_MODULE_3__["Notification"].createNext(value));
      }

      _error(err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
        this.unsubscribe();
      }

      _complete() {
        this.scheduleNotification(_Notification__WEBPACK_IMPORTED_MODULE_3__["Notification"].createComplete());
        this.unsubscribe();
      }

    }

    class DelayMessage {
      constructor(time, notification) {
        this.time = time;
        this.notification = notification;
      }

    } //# sourceMappingURL=delay.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/delayWhen.js":
  /*!********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/delayWhen.js ***!
    \********************************************************************/

  /*! exports provided: delayWhen */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsDelayWhenJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "delayWhen", function () {
      return delayWhen;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function delayWhen(delayDurationSelector, subscriptionDelay) {
      if (subscriptionDelay) {
        return source => new SubscriptionDelayObservable(source, subscriptionDelay).lift(new DelayWhenOperator(delayDurationSelector));
      }

      return source => source.lift(new DelayWhenOperator(delayDurationSelector));
    }

    class DelayWhenOperator {
      constructor(delayDurationSelector) {
        this.delayDurationSelector = delayDurationSelector;
      }

      call(subscriber, source) {
        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
      }

    }

    class DelayWhenSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__["OuterSubscriber"] {
      constructor(destination, delayDurationSelector) {
        super(destination);
        this.delayDurationSelector = delayDurationSelector;
        this.completed = false;
        this.delayNotifierSubscriptions = [];
        this.index = 0;
      }

      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(outerValue);
        this.removeSubscription(innerSub);
        this.tryComplete();
      }

      notifyError(error, innerSub) {
        this._error(error);
      }

      notifyComplete(innerSub) {
        const value = this.removeSubscription(innerSub);

        if (value) {
          this.destination.next(value);
        }

        this.tryComplete();
      }

      _next(value) {
        const index = this.index++;

        try {
          const delayNotifier = this.delayDurationSelector(value, index);

          if (delayNotifier) {
            this.tryDelay(delayNotifier, value);
          }
        } catch (err) {
          this.destination.error(err);
        }
      }

      _complete() {
        this.completed = true;
        this.tryComplete();
        this.unsubscribe();
      }

      removeSubscription(subscription) {
        subscription.unsubscribe();
        const subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);

        if (subscriptionIdx !== -1) {
          this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
        }

        return subscription.outerValue;
      }

      tryDelay(delayNotifier, value) {
        const notifierSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__["subscribeToResult"])(this, delayNotifier, value);

        if (notifierSubscription && !notifierSubscription.closed) {
          const destination = this.destination;
          destination.add(notifierSubscription);
          this.delayNotifierSubscriptions.push(notifierSubscription);
        }
      }

      tryComplete() {
        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
          this.destination.complete();
        }
      }

    }

    class SubscriptionDelayObservable extends _Observable__WEBPACK_IMPORTED_MODULE_1__["Observable"] {
      constructor(source, subscriptionDelay) {
        super();
        this.source = source;
        this.subscriptionDelay = subscriptionDelay;
      }

      _subscribe(subscriber) {
        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
      }

    }

    class SubscriptionDelaySubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(parent, source) {
        super();
        this.parent = parent;
        this.source = source;
        this.sourceSubscribed = false;
      }

      _next(unused) {
        this.subscribeToSource();
      }

      _error(err) {
        this.unsubscribe();
        this.parent.error(err);
      }

      _complete() {
        this.unsubscribe();
        this.subscribeToSource();
      }

      subscribeToSource() {
        if (!this.sourceSubscribed) {
          this.sourceSubscribed = true;
          this.unsubscribe();
          this.source.subscribe(this.parent);
        }
      }

    } //# sourceMappingURL=delayWhen.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/dematerialize.js":
  /*!************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/dematerialize.js ***!
    \************************************************************************/

  /*! exports provided: dematerialize */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsDematerializeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "dematerialize", function () {
      return dematerialize;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function dematerialize() {
      return function dematerializeOperatorFunction(source) {
        return source.lift(new DeMaterializeOperator());
      };
    }

    class DeMaterializeOperator {
      call(subscriber, source) {
        return source.subscribe(new DeMaterializeSubscriber(subscriber));
      }

    }

    class DeMaterializeSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination) {
        super(destination);
      }

      _next(value) {
        value.observe(this.destination);
      }

    } //# sourceMappingURL=dematerialize.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/distinct.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/distinct.js ***!
    \*******************************************************************/

  /*! exports provided: distinct, DistinctSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsDistinctJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "distinct", function () {
      return distinct;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "DistinctSubscriber", function () {
      return DistinctSubscriber;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function distinct(keySelector, flushes) {
      return source => source.lift(new DistinctOperator(keySelector, flushes));
    }

    class DistinctOperator {
      constructor(keySelector, flushes) {
        this.keySelector = keySelector;
        this.flushes = flushes;
      }

      call(subscriber, source) {
        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
      }

    }

    class DistinctSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"] {
      constructor(destination, keySelector, flushes) {
        super(destination);
        this.keySelector = keySelector;
        this.values = new Set();

        if (flushes) {
          this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__["subscribeToResult"])(this, flushes));
        }
      }

      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values.clear();
      }

      notifyError(error, innerSub) {
        this._error(error);
      }

      _next(value) {
        if (this.keySelector) {
          this._useKeySelector(value);
        } else {
          this._finalizeNext(value, value);
        }
      }

      _useKeySelector(value) {
        let key;
        const {
          destination
        } = this;

        try {
          key = this.keySelector(value);
        } catch (err) {
          destination.error(err);
          return;
        }

        this._finalizeNext(key, value);
      }

      _finalizeNext(key, value) {
        const {
          values
        } = this;

        if (!values.has(key)) {
          values.add(key);
          this.destination.next(value);
        }
      }

    } //# sourceMappingURL=distinct.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/distinctUntilChanged.js":
  /*!*******************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/distinctUntilChanged.js ***!
    \*******************************************************************************/

  /*! exports provided: distinctUntilChanged */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsDistinctUntilChangedJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "distinctUntilChanged", function () {
      return distinctUntilChanged;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function distinctUntilChanged(compare, keySelector) {
      return source => source.lift(new DistinctUntilChangedOperator(compare, keySelector));
    }

    class DistinctUntilChangedOperator {
      constructor(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
      }

      call(subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
      }

    }

    class DistinctUntilChangedSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, compare, keySelector) {
        super(destination);
        this.keySelector = keySelector;
        this.hasKey = false;

        if (typeof compare === 'function') {
          this.compare = compare;
        }
      }

      compare(x, y) {
        return x === y;
      }

      _next(value) {
        let key;

        try {
          const {
            keySelector
          } = this;
          key = keySelector ? keySelector(value) : value;
        } catch (err) {
          return this.destination.error(err);
        }

        let result = false;

        if (this.hasKey) {
          try {
            const {
              compare
            } = this;
            result = compare(this.key, key);
          } catch (err) {
            return this.destination.error(err);
          }
        } else {
          this.hasKey = true;
        }

        if (!result) {
          this.key = key;
          this.destination.next(value);
        }
      }

    } //# sourceMappingURL=distinctUntilChanged.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/distinctUntilKeyChanged.js":
  /*!**********************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/distinctUntilKeyChanged.js ***!
    \**********************************************************************************/

  /*! exports provided: distinctUntilKeyChanged */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsDistinctUntilKeyChangedJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "distinctUntilKeyChanged", function () {
      return distinctUntilKeyChanged;
    });
    /* harmony import */


    var _distinctUntilChanged__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./distinctUntilChanged */
    "./node_modules/rxjs/_esm2015/internal/operators/distinctUntilChanged.js");

    function distinctUntilKeyChanged(key, compare) {
      return Object(_distinctUntilChanged__WEBPACK_IMPORTED_MODULE_0__["distinctUntilChanged"])((x, y) => compare ? compare(x[key], y[key]) : x[key] === y[key]);
    } //# sourceMappingURL=distinctUntilKeyChanged.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/elementAt.js":
  /*!********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/elementAt.js ***!
    \********************************************************************/

  /*! exports provided: elementAt */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsElementAtJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "elementAt", function () {
      return elementAt;
    });
    /* harmony import */


    var _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../util/ArgumentOutOfRangeError */
    "./node_modules/rxjs/_esm2015/internal/util/ArgumentOutOfRangeError.js");
    /* harmony import */


    var _filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./filter */
    "./node_modules/rxjs/_esm2015/internal/operators/filter.js");
    /* harmony import */


    var _throwIfEmpty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./throwIfEmpty */
    "./node_modules/rxjs/_esm2015/internal/operators/throwIfEmpty.js");
    /* harmony import */


    var _defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./defaultIfEmpty */
    "./node_modules/rxjs/_esm2015/internal/operators/defaultIfEmpty.js");
    /* harmony import */


    var _take__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ./take */
    "./node_modules/rxjs/_esm2015/internal/operators/take.js");

    function elementAt(index, defaultValue) {
      if (index < 0) {
        throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_0__["ArgumentOutOfRangeError"]();
      }

      const hasDefaultValue = arguments.length >= 2;
      return source => source.pipe(Object(_filter__WEBPACK_IMPORTED_MODULE_1__["filter"])((v, i) => i === index), Object(_take__WEBPACK_IMPORTED_MODULE_4__["take"])(1), hasDefaultValue ? Object(_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__["defaultIfEmpty"])(defaultValue) : Object(_throwIfEmpty__WEBPACK_IMPORTED_MODULE_2__["throwIfEmpty"])(() => new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_0__["ArgumentOutOfRangeError"]()));
    } //# sourceMappingURL=elementAt.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/endWith.js":
  /*!******************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/endWith.js ***!
    \******************************************************************/

  /*! exports provided: endWith */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsEndWithJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "endWith", function () {
      return endWith;
    });
    /* harmony import */


    var _observable_fromArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../observable/fromArray */
    "./node_modules/rxjs/_esm2015/internal/observable/fromArray.js");
    /* harmony import */


    var _observable_scalar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../observable/scalar */
    "./node_modules/rxjs/_esm2015/internal/observable/scalar.js");
    /* harmony import */


    var _observable_empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../observable/empty */
    "./node_modules/rxjs/_esm2015/internal/observable/empty.js");
    /* harmony import */


    var _observable_concat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../observable/concat */
    "./node_modules/rxjs/_esm2015/internal/observable/concat.js");
    /* harmony import */


    var _util_isScheduler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ../util/isScheduler */
    "./node_modules/rxjs/_esm2015/internal/util/isScheduler.js");

    function endWith(...array) {
      return source => {
        let scheduler = array[array.length - 1];

        if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_4__["isScheduler"])(scheduler)) {
          array.pop();
        } else {
          scheduler = null;
        }

        const len = array.length;

        if (len === 1 && !scheduler) {
          return Object(_observable_concat__WEBPACK_IMPORTED_MODULE_3__["concat"])(source, Object(_observable_scalar__WEBPACK_IMPORTED_MODULE_1__["scalar"])(array[0]));
        } else if (len > 0) {
          return Object(_observable_concat__WEBPACK_IMPORTED_MODULE_3__["concat"])(source, Object(_observable_fromArray__WEBPACK_IMPORTED_MODULE_0__["fromArray"])(array, scheduler));
        } else {
          return Object(_observable_concat__WEBPACK_IMPORTED_MODULE_3__["concat"])(source, Object(_observable_empty__WEBPACK_IMPORTED_MODULE_2__["empty"])(scheduler));
        }
      };
    } //# sourceMappingURL=endWith.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/every.js":
  /*!****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/every.js ***!
    \****************************************************************/

  /*! exports provided: every */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsEveryJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "every", function () {
      return every;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function every(predicate, thisArg) {
      return source => source.lift(new EveryOperator(predicate, thisArg, source));
    }

    class EveryOperator {
      constructor(predicate, thisArg, source) {
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
      }

      call(observer, source) {
        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
      }

    }

    class EverySubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, predicate, thisArg, source) {
        super(destination);
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
        this.index = 0;
        this.thisArg = thisArg || this;
      }

      notifyComplete(everyValueMatch) {
        this.destination.next(everyValueMatch);
        this.destination.complete();
      }

      _next(value) {
        let result = false;

        try {
          result = this.predicate.call(this.thisArg, value, this.index++, this.source);
        } catch (err) {
          this.destination.error(err);
          return;
        }

        if (!result) {
          this.notifyComplete(false);
        }
      }

      _complete() {
        this.notifyComplete(true);
      }

    } //# sourceMappingURL=every.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/exhaust.js":
  /*!******************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/exhaust.js ***!
    \******************************************************************/

  /*! exports provided: exhaust */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsExhaustJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "exhaust", function () {
      return exhaust;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function exhaust() {
      return source => source.lift(new SwitchFirstOperator());
    }

    class SwitchFirstOperator {
      call(subscriber, source) {
        return source.subscribe(new SwitchFirstSubscriber(subscriber));
      }

    }

    class SwitchFirstSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"] {
      constructor(destination) {
        super(destination);
        this.hasCompleted = false;
        this.hasSubscription = false;
      }

      _next(value) {
        if (!this.hasSubscription) {
          this.hasSubscription = true;
          this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__["subscribeToResult"])(this, value));
        }
      }

      _complete() {
        this.hasCompleted = true;

        if (!this.hasSubscription) {
          this.destination.complete();
        }
      }

      notifyComplete(innerSub) {
        this.remove(innerSub);
        this.hasSubscription = false;

        if (this.hasCompleted) {
          this.destination.complete();
        }
      }

    } //# sourceMappingURL=exhaust.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/exhaustMap.js":
  /*!*********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/exhaustMap.js ***!
    \*********************************************************************/

  /*! exports provided: exhaustMap */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsExhaustMapJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "exhaustMap", function () {
      return exhaustMap;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../InnerSubscriber */
    "./node_modules/rxjs/_esm2015/internal/InnerSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");
    /* harmony import */


    var _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./map */
    "./node_modules/rxjs/_esm2015/internal/operators/map.js");
    /* harmony import */


    var _observable_from__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ../observable/from */
    "./node_modules/rxjs/_esm2015/internal/observable/from.js");

    function exhaustMap(project, resultSelector) {
      if (resultSelector) {
        return source => source.pipe(exhaustMap((a, i) => Object(_observable_from__WEBPACK_IMPORTED_MODULE_4__["from"])(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_3__["map"])((b, ii) => resultSelector(a, b, i, ii)))));
      }

      return source => source.lift(new ExhaustMapOperator(project));
    }

    class ExhaustMapOperator {
      constructor(project) {
        this.project = project;
      }

      call(subscriber, source) {
        return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
      }

    }

    class ExhaustMapSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"] {
      constructor(destination, project) {
        super(destination);
        this.project = project;
        this.hasSubscription = false;
        this.hasCompleted = false;
        this.index = 0;
      }

      _next(value) {
        if (!this.hasSubscription) {
          this.tryNext(value);
        }
      }

      tryNext(value) {
        let result;
        const index = this.index++;

        try {
          result = this.project(value, index);
        } catch (err) {
          this.destination.error(err);
          return;
        }

        this.hasSubscription = true;

        this._innerSub(result, value, index);
      }

      _innerSub(result, value, index) {
        const innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_1__["InnerSubscriber"](this, undefined, undefined);
        const destination = this.destination;
        destination.add(innerSubscriber);
        Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, result, value, index, innerSubscriber);
      }

      _complete() {
        this.hasCompleted = true;

        if (!this.hasSubscription) {
          this.destination.complete();
        }

        this.unsubscribe();
      }

      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
      }

      notifyError(err) {
        this.destination.error(err);
      }

      notifyComplete(innerSub) {
        const destination = this.destination;
        destination.remove(innerSub);
        this.hasSubscription = false;

        if (this.hasCompleted) {
          this.destination.complete();
        }
      }

    } //# sourceMappingURL=exhaustMap.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/expand.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/expand.js ***!
    \*****************************************************************/

  /*! exports provided: expand, ExpandOperator, ExpandSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsExpandJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "expand", function () {
      return expand;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ExpandOperator", function () {
      return ExpandOperator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ExpandSubscriber", function () {
      return ExpandSubscriber;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function expand(project, concurrent = Number.POSITIVE_INFINITY, scheduler = undefined) {
      concurrent = (concurrent || 0) < 1 ? Number.POSITIVE_INFINITY : concurrent;
      return source => source.lift(new ExpandOperator(project, concurrent, scheduler));
    }

    class ExpandOperator {
      constructor(project, concurrent, scheduler) {
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
      }

      call(subscriber, source) {
        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
      }

    }

    class ExpandSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"] {
      constructor(destination, project, concurrent, scheduler) {
        super(destination);
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
        this.index = 0;
        this.active = 0;
        this.hasCompleted = false;

        if (concurrent < Number.POSITIVE_INFINITY) {
          this.buffer = [];
        }
      }

      static dispatch(arg) {
        const {
          subscriber,
          result,
          value,
          index
        } = arg;
        subscriber.subscribeToProjection(result, value, index);
      }

      _next(value) {
        const destination = this.destination;

        if (destination.closed) {
          this._complete();

          return;
        }

        const index = this.index++;

        if (this.active < this.concurrent) {
          destination.next(value);

          try {
            const {
              project
            } = this;
            const result = project(value, index);

            if (!this.scheduler) {
              this.subscribeToProjection(result, value, index);
            } else {
              const state = {
                subscriber: this,
                result,
                value,
                index
              };
              const destination = this.destination;
              destination.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
            }
          } catch (e) {
            destination.error(e);
          }
        } else {
          this.buffer.push(value);
        }
      }

      subscribeToProjection(result, value, index) {
        this.active++;
        const destination = this.destination;
        destination.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__["subscribeToResult"])(this, result, value, index));
      }

      _complete() {
        this.hasCompleted = true;

        if (this.hasCompleted && this.active === 0) {
          this.destination.complete();
        }

        this.unsubscribe();
      }

      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this._next(innerValue);
      }

      notifyComplete(innerSub) {
        const buffer = this.buffer;
        const destination = this.destination;
        destination.remove(innerSub);
        this.active--;

        if (buffer && buffer.length > 0) {
          this._next(buffer.shift());
        }

        if (this.hasCompleted && this.active === 0) {
          this.destination.complete();
        }
      }

    } //# sourceMappingURL=expand.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/filter.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/filter.js ***!
    \*****************************************************************/

  /*! exports provided: filter */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsFilterJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "filter", function () {
      return filter;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function filter(predicate, thisArg) {
      return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
      };
    }

    class FilterOperator {
      constructor(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
      }

      call(subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
      }

    }

    class FilterSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, predicate, thisArg) {
        super(destination);
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.count = 0;
      }

      _next(value) {
        let result;

        try {
          result = this.predicate.call(this.thisArg, value, this.count++);
        } catch (err) {
          this.destination.error(err);
          return;
        }

        if (result) {
          this.destination.next(value);
        }
      }

    } //# sourceMappingURL=filter.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/finalize.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/finalize.js ***!
    \*******************************************************************/

  /*! exports provided: finalize */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsFinalizeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "finalize", function () {
      return finalize;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Subscription */
    "./node_modules/rxjs/_esm2015/internal/Subscription.js");

    function finalize(callback) {
      return source => source.lift(new FinallyOperator(callback));
    }

    class FinallyOperator {
      constructor(callback) {
        this.callback = callback;
      }

      call(subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
      }

    }

    class FinallySubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, callback) {
        super(destination);
        this.add(new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"](callback));
      }

    } //# sourceMappingURL=finalize.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/find.js":
  /*!***************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/find.js ***!
    \***************************************************************/

  /*! exports provided: find, FindValueOperator, FindValueSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsFindJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "find", function () {
      return find;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FindValueOperator", function () {
      return FindValueOperator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "FindValueSubscriber", function () {
      return FindValueSubscriber;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function find(predicate, thisArg) {
      if (typeof predicate !== 'function') {
        throw new TypeError('predicate is not a function');
      }

      return source => source.lift(new FindValueOperator(predicate, source, false, thisArg));
    }

    class FindValueOperator {
      constructor(predicate, source, yieldIndex, thisArg) {
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
      }

      call(observer, source) {
        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
      }

    }

    class FindValueSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, predicate, source, yieldIndex, thisArg) {
        super(destination);
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
        this.index = 0;
      }

      notifyComplete(value) {
        const destination = this.destination;
        destination.next(value);
        destination.complete();
        this.unsubscribe();
      }

      _next(value) {
        const {
          predicate,
          thisArg
        } = this;
        const index = this.index++;

        try {
          const result = predicate.call(thisArg || this, value, index, this.source);

          if (result) {
            this.notifyComplete(this.yieldIndex ? index : value);
          }
        } catch (err) {
          this.destination.error(err);
        }
      }

      _complete() {
        this.notifyComplete(this.yieldIndex ? -1 : undefined);
      }

    } //# sourceMappingURL=find.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/findIndex.js":
  /*!********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/findIndex.js ***!
    \********************************************************************/

  /*! exports provided: findIndex */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsFindIndexJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "findIndex", function () {
      return findIndex;
    });
    /* harmony import */


    var _operators_find__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../operators/find */
    "./node_modules/rxjs/_esm2015/internal/operators/find.js");

    function findIndex(predicate, thisArg) {
      return source => source.lift(new _operators_find__WEBPACK_IMPORTED_MODULE_0__["FindValueOperator"](predicate, source, true, thisArg));
    } //# sourceMappingURL=findIndex.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/first.js":
  /*!****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/first.js ***!
    \****************************************************************/

  /*! exports provided: first */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsFirstJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "first", function () {
      return first;
    });
    /* harmony import */


    var _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../util/EmptyError */
    "./node_modules/rxjs/_esm2015/internal/util/EmptyError.js");
    /* harmony import */


    var _filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./filter */
    "./node_modules/rxjs/_esm2015/internal/operators/filter.js");
    /* harmony import */


    var _take__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./take */
    "./node_modules/rxjs/_esm2015/internal/operators/take.js");
    /* harmony import */


    var _defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./defaultIfEmpty */
    "./node_modules/rxjs/_esm2015/internal/operators/defaultIfEmpty.js");
    /* harmony import */


    var _throwIfEmpty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ./throwIfEmpty */
    "./node_modules/rxjs/_esm2015/internal/operators/throwIfEmpty.js");
    /* harmony import */


    var _util_identity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! ../util/identity */
    "./node_modules/rxjs/_esm2015/internal/util/identity.js");

    function first(predicate, defaultValue) {
      const hasDefaultValue = arguments.length >= 2;
      return source => source.pipe(predicate ? Object(_filter__WEBPACK_IMPORTED_MODULE_1__["filter"])((v, i) => predicate(v, i, source)) : _util_identity__WEBPACK_IMPORTED_MODULE_5__["identity"], Object(_take__WEBPACK_IMPORTED_MODULE_2__["take"])(1), hasDefaultValue ? Object(_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_3__["defaultIfEmpty"])(defaultValue) : Object(_throwIfEmpty__WEBPACK_IMPORTED_MODULE_4__["throwIfEmpty"])(() => new _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__["EmptyError"]()));
    } //# sourceMappingURL=first.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/groupBy.js":
  /*!******************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/groupBy.js ***!
    \******************************************************************/

  /*! exports provided: groupBy, GroupedObservable */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsGroupByJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "groupBy", function () {
      return groupBy;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "GroupedObservable", function () {
      return GroupedObservable;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Subscription */
    "./node_modules/rxjs/_esm2015/internal/Subscription.js");
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../Subject */
    "./node_modules/rxjs/_esm2015/internal/Subject.js");

    function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
      return source => source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
    }

    class GroupByOperator {
      constructor(keySelector, elementSelector, durationSelector, subjectSelector) {
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
      }

      call(subscriber, source) {
        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
      }

    }

    class GroupBySubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        super(destination);
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
        this.groups = null;
        this.attemptedToUnsubscribe = false;
        this.count = 0;
      }

      _next(value) {
        let key;

        try {
          key = this.keySelector(value);
        } catch (err) {
          this.error(err);
          return;
        }

        this._group(value, key);
      }

      _group(value, key) {
        let groups = this.groups;

        if (!groups) {
          groups = this.groups = new Map();
        }

        let group = groups.get(key);
        let element;

        if (this.elementSelector) {
          try {
            element = this.elementSelector(value);
          } catch (err) {
            this.error(err);
          }
        } else {
          element = value;
        }

        if (!group) {
          group = this.subjectSelector ? this.subjectSelector() : new _Subject__WEBPACK_IMPORTED_MODULE_3__["Subject"]();
          groups.set(key, group);
          const groupedObservable = new GroupedObservable(key, group, this);
          this.destination.next(groupedObservable);

          if (this.durationSelector) {
            let duration;

            try {
              duration = this.durationSelector(new GroupedObservable(key, group));
            } catch (err) {
              this.error(err);
              return;
            }

            this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
          }
        }

        if (!group.closed) {
          group.next(element);
        }
      }

      _error(err) {
        const groups = this.groups;

        if (groups) {
          groups.forEach((group, key) => {
            group.error(err);
          });
          groups.clear();
        }

        this.destination.error(err);
      }

      _complete() {
        const groups = this.groups;

        if (groups) {
          groups.forEach((group, key) => {
            group.complete();
          });
          groups.clear();
        }

        this.destination.complete();
      }

      removeGroup(key) {
        this.groups.delete(key);
      }

      unsubscribe() {
        if (!this.closed) {
          this.attemptedToUnsubscribe = true;

          if (this.count === 0) {
            super.unsubscribe();
          }
        }
      }

    }

    class GroupDurationSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(key, group, parent) {
        super(group);
        this.key = key;
        this.group = group;
        this.parent = parent;
      }

      _next(value) {
        this.complete();
      }

      _unsubscribe() {
        const {
          parent,
          key
        } = this;
        this.key = this.parent = null;

        if (parent) {
          parent.removeGroup(key);
        }
      }

    }

    class GroupedObservable extends _Observable__WEBPACK_IMPORTED_MODULE_2__["Observable"] {
      constructor(key, groupSubject, refCountSubscription) {
        super();
        this.key = key;
        this.groupSubject = groupSubject;
        this.refCountSubscription = refCountSubscription;
      }

      _subscribe(subscriber) {
        const subscription = new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]();
        const {
          refCountSubscription,
          groupSubject
        } = this;

        if (refCountSubscription && !refCountSubscription.closed) {
          subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }

        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
      }

    }

    class InnerRefCountSubscription extends _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"] {
      constructor(parent) {
        super();
        this.parent = parent;
        parent.count++;
      }

      unsubscribe() {
        const parent = this.parent;

        if (!parent.closed && !this.closed) {
          super.unsubscribe();
          parent.count -= 1;

          if (parent.count === 0 && parent.attemptedToUnsubscribe) {
            parent.unsubscribe();
          }
        }
      }

    } //# sourceMappingURL=groupBy.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/ignoreElements.js":
  /*!*************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/ignoreElements.js ***!
    \*************************************************************************/

  /*! exports provided: ignoreElements */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsIgnoreElementsJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ignoreElements", function () {
      return ignoreElements;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function ignoreElements() {
      return function ignoreElementsOperatorFunction(source) {
        return source.lift(new IgnoreElementsOperator());
      };
    }

    class IgnoreElementsOperator {
      call(subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
      }

    }

    class IgnoreElementsSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      _next(unused) {}

    } //# sourceMappingURL=ignoreElements.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/isEmpty.js":
  /*!******************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/isEmpty.js ***!
    \******************************************************************/

  /*! exports provided: isEmpty */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsIsEmptyJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isEmpty", function () {
      return isEmpty;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function isEmpty() {
      return source => source.lift(new IsEmptyOperator());
    }

    class IsEmptyOperator {
      call(observer, source) {
        return source.subscribe(new IsEmptySubscriber(observer));
      }

    }

    class IsEmptySubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination) {
        super(destination);
      }

      notifyComplete(isEmpty) {
        const destination = this.destination;
        destination.next(isEmpty);
        destination.complete();
      }

      _next(value) {
        this.notifyComplete(false);
      }

      _complete() {
        this.notifyComplete(true);
      }

    } //# sourceMappingURL=isEmpty.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/last.js":
  /*!***************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/last.js ***!
    \***************************************************************/

  /*! exports provided: last */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsLastJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "last", function () {
      return last;
    });
    /* harmony import */


    var _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../util/EmptyError */
    "./node_modules/rxjs/_esm2015/internal/util/EmptyError.js");
    /* harmony import */


    var _filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./filter */
    "./node_modules/rxjs/_esm2015/internal/operators/filter.js");
    /* harmony import */


    var _takeLast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./takeLast */
    "./node_modules/rxjs/_esm2015/internal/operators/takeLast.js");
    /* harmony import */


    var _throwIfEmpty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./throwIfEmpty */
    "./node_modules/rxjs/_esm2015/internal/operators/throwIfEmpty.js");
    /* harmony import */


    var _defaultIfEmpty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ./defaultIfEmpty */
    "./node_modules/rxjs/_esm2015/internal/operators/defaultIfEmpty.js");
    /* harmony import */


    var _util_identity__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! ../util/identity */
    "./node_modules/rxjs/_esm2015/internal/util/identity.js");

    function last(predicate, defaultValue) {
      const hasDefaultValue = arguments.length >= 2;
      return source => source.pipe(predicate ? Object(_filter__WEBPACK_IMPORTED_MODULE_1__["filter"])((v, i) => predicate(v, i, source)) : _util_identity__WEBPACK_IMPORTED_MODULE_5__["identity"], Object(_takeLast__WEBPACK_IMPORTED_MODULE_2__["takeLast"])(1), hasDefaultValue ? Object(_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_4__["defaultIfEmpty"])(defaultValue) : Object(_throwIfEmpty__WEBPACK_IMPORTED_MODULE_3__["throwIfEmpty"])(() => new _util_EmptyError__WEBPACK_IMPORTED_MODULE_0__["EmptyError"]()));
    } //# sourceMappingURL=last.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/map.js":
  /*!**************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/map.js ***!
    \**************************************************************/

  /*! exports provided: map, MapOperator */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsMapJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "map", function () {
      return map;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "MapOperator", function () {
      return MapOperator;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function map(project, thisArg) {
      return function mapOperation(source) {
        if (typeof project !== 'function') {
          throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }

        return source.lift(new MapOperator(project, thisArg));
      };
    }

    class MapOperator {
      constructor(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
      }

      call(subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
      }

    }

    class MapSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, project, thisArg) {
        super(destination);
        this.project = project;
        this.count = 0;
        this.thisArg = thisArg || this;
      }

      _next(value) {
        let result;

        try {
          result = this.project.call(this.thisArg, value, this.count++);
        } catch (err) {
          this.destination.error(err);
          return;
        }

        this.destination.next(result);
      }

    } //# sourceMappingURL=map.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/mapTo.js":
  /*!****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/mapTo.js ***!
    \****************************************************************/

  /*! exports provided: mapTo */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsMapToJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "mapTo", function () {
      return mapTo;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function mapTo(value) {
      return source => source.lift(new MapToOperator(value));
    }

    class MapToOperator {
      constructor(value) {
        this.value = value;
      }

      call(subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
      }

    }

    class MapToSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, value) {
        super(destination);
        this.value = value;
      }

      _next(x) {
        this.destination.next(this.value);
      }

    } //# sourceMappingURL=mapTo.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/materialize.js":
  /*!**********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/materialize.js ***!
    \**********************************************************************/

  /*! exports provided: materialize */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsMaterializeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "materialize", function () {
      return materialize;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _Notification__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Notification */
    "./node_modules/rxjs/_esm2015/internal/Notification.js");

    function materialize() {
      return function materializeOperatorFunction(source) {
        return source.lift(new MaterializeOperator());
      };
    }

    class MaterializeOperator {
      call(subscriber, source) {
        return source.subscribe(new MaterializeSubscriber(subscriber));
      }

    }

    class MaterializeSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination) {
        super(destination);
      }

      _next(value) {
        this.destination.next(_Notification__WEBPACK_IMPORTED_MODULE_1__["Notification"].createNext(value));
      }

      _error(err) {
        const destination = this.destination;
        destination.next(_Notification__WEBPACK_IMPORTED_MODULE_1__["Notification"].createError(err));
        destination.complete();
      }

      _complete() {
        const destination = this.destination;
        destination.next(_Notification__WEBPACK_IMPORTED_MODULE_1__["Notification"].createComplete());
        destination.complete();
      }

    } //# sourceMappingURL=materialize.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/max.js":
  /*!**************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/max.js ***!
    \**************************************************************/

  /*! exports provided: max */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsMaxJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "max", function () {
      return max;
    });
    /* harmony import */


    var _reduce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./reduce */
    "./node_modules/rxjs/_esm2015/internal/operators/reduce.js");

    function max(comparer) {
      const max = typeof comparer === 'function' ? (x, y) => comparer(x, y) > 0 ? x : y : (x, y) => x > y ? x : y;
      return Object(_reduce__WEBPACK_IMPORTED_MODULE_0__["reduce"])(max);
    } //# sourceMappingURL=max.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/merge.js":
  /*!****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/merge.js ***!
    \****************************************************************/

  /*! exports provided: merge */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsMergeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "merge", function () {
      return merge;
    });
    /* harmony import */


    var _observable_merge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../observable/merge */
    "./node_modules/rxjs/_esm2015/internal/observable/merge.js");

    function merge(...observables) {
      return source => source.lift.call(Object(_observable_merge__WEBPACK_IMPORTED_MODULE_0__["merge"])(source, ...observables));
    } //# sourceMappingURL=merge.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/mergeAll.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/mergeAll.js ***!
    \*******************************************************************/

  /*! exports provided: mergeAll */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsMergeAllJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "mergeAll", function () {
      return mergeAll;
    });
    /* harmony import */


    var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./mergeMap */
    "./node_modules/rxjs/_esm2015/internal/operators/mergeMap.js");
    /* harmony import */


    var _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/identity */
    "./node_modules/rxjs/_esm2015/internal/util/identity.js");

    function mergeAll(concurrent = Number.POSITIVE_INFINITY) {
      return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__["mergeMap"])(_util_identity__WEBPACK_IMPORTED_MODULE_1__["identity"], concurrent);
    } //# sourceMappingURL=mergeAll.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/mergeMap.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/mergeMap.js ***!
    \*******************************************************************/

  /*! exports provided: mergeMap, MergeMapOperator, MergeMapSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsMergeMapJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "mergeMap", function () {
      return mergeMap;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "MergeMapOperator", function () {
      return MergeMapOperator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "MergeMapSubscriber", function () {
      return MergeMapSubscriber;
    });
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../InnerSubscriber */
    "./node_modules/rxjs/_esm2015/internal/InnerSubscriber.js");
    /* harmony import */


    var _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./map */
    "./node_modules/rxjs/_esm2015/internal/operators/map.js");
    /* harmony import */


    var _observable_from__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ../observable/from */
    "./node_modules/rxjs/_esm2015/internal/observable/from.js");

    function mergeMap(project, resultSelector, concurrent = Number.POSITIVE_INFINITY) {
      if (typeof resultSelector === 'function') {
        return source => source.pipe(mergeMap((a, i) => Object(_observable_from__WEBPACK_IMPORTED_MODULE_4__["from"])(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_3__["map"])((b, ii) => resultSelector(a, b, i, ii))), concurrent));
      } else if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
      }

      return source => source.lift(new MergeMapOperator(project, concurrent));
    }

    class MergeMapOperator {
      constructor(project, concurrent = Number.POSITIVE_INFINITY) {
        this.project = project;
        this.concurrent = concurrent;
      }

      call(observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
      }

    }

    class MergeMapSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"] {
      constructor(destination, project, concurrent = Number.POSITIVE_INFINITY) {
        super(destination);
        this.project = project;
        this.concurrent = concurrent;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
      }

      _next(value) {
        if (this.active < this.concurrent) {
          this._tryNext(value);
        } else {
          this.buffer.push(value);
        }
      }

      _tryNext(value) {
        let result;
        const index = this.index++;

        try {
          result = this.project(value, index);
        } catch (err) {
          this.destination.error(err);
          return;
        }

        this.active++;

        this._innerSub(result, value, index);
      }

      _innerSub(ish, value, index) {
        const innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__["InnerSubscriber"](this, undefined, undefined);
        const destination = this.destination;
        destination.add(innerSubscriber);
        Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_0__["subscribeToResult"])(this, ish, value, index, innerSubscriber);
      }

      _complete() {
        this.hasCompleted = true;

        if (this.active === 0 && this.buffer.length === 0) {
          this.destination.complete();
        }

        this.unsubscribe();
      }

      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
      }

      notifyComplete(innerSub) {
        const buffer = this.buffer;
        this.remove(innerSub);
        this.active--;

        if (buffer.length > 0) {
          this._next(buffer.shift());
        } else if (this.active === 0 && this.hasCompleted) {
          this.destination.complete();
        }
      }

    } //# sourceMappingURL=mergeMap.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/mergeMapTo.js":
  /*!*********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/mergeMapTo.js ***!
    \*********************************************************************/

  /*! exports provided: mergeMapTo */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsMergeMapToJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "mergeMapTo", function () {
      return mergeMapTo;
    });
    /* harmony import */


    var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./mergeMap */
    "./node_modules/rxjs/_esm2015/internal/operators/mergeMap.js");

    function mergeMapTo(innerObservable, resultSelector, concurrent = Number.POSITIVE_INFINITY) {
      if (typeof resultSelector === 'function') {
        return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__["mergeMap"])(() => innerObservable, resultSelector, concurrent);
      }

      if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
      }

      return Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__["mergeMap"])(() => innerObservable, concurrent);
    } //# sourceMappingURL=mergeMapTo.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/mergeScan.js":
  /*!********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/mergeScan.js ***!
    \********************************************************************/

  /*! exports provided: mergeScan, MergeScanOperator, MergeScanSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsMergeScanJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "mergeScan", function () {
      return mergeScan;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "MergeScanOperator", function () {
      return MergeScanOperator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "MergeScanSubscriber", function () {
      return MergeScanSubscriber;
    });
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../InnerSubscriber */
    "./node_modules/rxjs/_esm2015/internal/InnerSubscriber.js");

    function mergeScan(accumulator, seed, concurrent = Number.POSITIVE_INFINITY) {
      return source => source.lift(new MergeScanOperator(accumulator, seed, concurrent));
    }

    class MergeScanOperator {
      constructor(accumulator, seed, concurrent) {
        this.accumulator = accumulator;
        this.seed = seed;
        this.concurrent = concurrent;
      }

      call(subscriber, source) {
        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
      }

    }

    class MergeScanSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"] {
      constructor(destination, accumulator, acc, concurrent) {
        super(destination);
        this.accumulator = accumulator;
        this.acc = acc;
        this.concurrent = concurrent;
        this.hasValue = false;
        this.hasCompleted = false;
        this.buffer = [];
        this.active = 0;
        this.index = 0;
      }

      _next(value) {
        if (this.active < this.concurrent) {
          const index = this.index++;
          const destination = this.destination;
          let ish;

          try {
            const {
              accumulator
            } = this;
            ish = accumulator(this.acc, value, index);
          } catch (e) {
            return destination.error(e);
          }

          this.active++;

          this._innerSub(ish, value, index);
        } else {
          this.buffer.push(value);
        }
      }

      _innerSub(ish, value, index) {
        const innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_2__["InnerSubscriber"](this, undefined, undefined);
        const destination = this.destination;
        destination.add(innerSubscriber);
        Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_0__["subscribeToResult"])(this, ish, value, index, innerSubscriber);
      }

      _complete() {
        this.hasCompleted = true;

        if (this.active === 0 && this.buffer.length === 0) {
          if (this.hasValue === false) {
            this.destination.next(this.acc);
          }

          this.destination.complete();
        }

        this.unsubscribe();
      }

      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        const {
          destination
        } = this;
        this.acc = innerValue;
        this.hasValue = true;
        destination.next(innerValue);
      }

      notifyComplete(innerSub) {
        const buffer = this.buffer;
        const destination = this.destination;
        destination.remove(innerSub);
        this.active--;

        if (buffer.length > 0) {
          this._next(buffer.shift());
        } else if (this.active === 0 && this.hasCompleted) {
          if (this.hasValue === false) {
            this.destination.next(this.acc);
          }

          this.destination.complete();
        }
      }

    } //# sourceMappingURL=mergeScan.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/min.js":
  /*!**************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/min.js ***!
    \**************************************************************/

  /*! exports provided: min */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsMinJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "min", function () {
      return min;
    });
    /* harmony import */


    var _reduce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./reduce */
    "./node_modules/rxjs/_esm2015/internal/operators/reduce.js");

    function min(comparer) {
      const min = typeof comparer === 'function' ? (x, y) => comparer(x, y) < 0 ? x : y : (x, y) => x < y ? x : y;
      return Object(_reduce__WEBPACK_IMPORTED_MODULE_0__["reduce"])(min);
    } //# sourceMappingURL=min.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/multicast.js":
  /*!********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/multicast.js ***!
    \********************************************************************/

  /*! exports provided: multicast, MulticastOperator */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsMulticastJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "multicast", function () {
      return multicast;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "MulticastOperator", function () {
      return MulticastOperator;
    });
    /* harmony import */


    var _observable_ConnectableObservable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../observable/ConnectableObservable */
    "./node_modules/rxjs/_esm2015/internal/observable/ConnectableObservable.js");

    function multicast(subjectOrSubjectFactory, selector) {
      return function multicastOperatorFunction(source) {
        let subjectFactory;

        if (typeof subjectOrSubjectFactory === 'function') {
          subjectFactory = subjectOrSubjectFactory;
        } else {
          subjectFactory = function subjectFactory() {
            return subjectOrSubjectFactory;
          };
        }

        if (typeof selector === 'function') {
          return source.lift(new MulticastOperator(subjectFactory, selector));
        }

        const connectable = Object.create(source, _observable_ConnectableObservable__WEBPACK_IMPORTED_MODULE_0__["connectableObservableDescriptor"]);
        connectable.source = source;
        connectable.subjectFactory = subjectFactory;
        return connectable;
      };
    }

    class MulticastOperator {
      constructor(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
      }

      call(subscriber, source) {
        const {
          selector
        } = this;
        const subject = this.subjectFactory();
        const subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
      }

    } //# sourceMappingURL=multicast.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/observeOn.js":
  /*!********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/observeOn.js ***!
    \********************************************************************/

  /*! exports provided: observeOn, ObserveOnOperator, ObserveOnSubscriber, ObserveOnMessage */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsObserveOnJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "observeOn", function () {
      return observeOn;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ObserveOnOperator", function () {
      return ObserveOnOperator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ObserveOnSubscriber", function () {
      return ObserveOnSubscriber;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ObserveOnMessage", function () {
      return ObserveOnMessage;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _Notification__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Notification */
    "./node_modules/rxjs/_esm2015/internal/Notification.js");

    function observeOn(scheduler, delay = 0) {
      return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
      };
    }

    class ObserveOnOperator {
      constructor(scheduler, delay = 0) {
        this.scheduler = scheduler;
        this.delay = delay;
      }

      call(subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
      }

    }

    class ObserveOnSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, scheduler, delay = 0) {
        super(destination);
        this.scheduler = scheduler;
        this.delay = delay;
      }

      static dispatch(arg) {
        const {
          notification,
          destination
        } = arg;
        notification.observe(destination);
        this.unsubscribe();
      }

      scheduleMessage(notification) {
        const destination = this.destination;
        destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
      }

      _next(value) {
        this.scheduleMessage(_Notification__WEBPACK_IMPORTED_MODULE_1__["Notification"].createNext(value));
      }

      _error(err) {
        this.scheduleMessage(_Notification__WEBPACK_IMPORTED_MODULE_1__["Notification"].createError(err));
        this.unsubscribe();
      }

      _complete() {
        this.scheduleMessage(_Notification__WEBPACK_IMPORTED_MODULE_1__["Notification"].createComplete());
        this.unsubscribe();
      }

    }

    class ObserveOnMessage {
      constructor(notification, destination) {
        this.notification = notification;
        this.destination = destination;
      }

    } //# sourceMappingURL=observeOn.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/onErrorResumeNext.js":
  /*!****************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/onErrorResumeNext.js ***!
    \****************************************************************************/

  /*! exports provided: onErrorResumeNext, onErrorResumeNextStatic */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsOnErrorResumeNextJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "onErrorResumeNext", function () {
      return onErrorResumeNext;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "onErrorResumeNextStatic", function () {
      return onErrorResumeNextStatic;
    });
    /* harmony import */


    var _observable_from__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../observable/from */
    "./node_modules/rxjs/_esm2015/internal/observable/from.js");
    /* harmony import */


    var _util_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/isArray */
    "./node_modules/rxjs/_esm2015/internal/util/isArray.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../InnerSubscriber */
    "./node_modules/rxjs/_esm2015/internal/InnerSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function onErrorResumeNext(...nextSources) {
      if (nextSources.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__["isArray"])(nextSources[0])) {
        nextSources = nextSources[0];
      }

      return source => source.lift(new OnErrorResumeNextOperator(nextSources));
    }

    function onErrorResumeNextStatic(...nextSources) {
      let source = null;

      if (nextSources.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_1__["isArray"])(nextSources[0])) {
        nextSources = nextSources[0];
      }

      source = nextSources.shift();
      return Object(_observable_from__WEBPACK_IMPORTED_MODULE_0__["from"])(source, null).lift(new OnErrorResumeNextOperator(nextSources));
    }

    class OnErrorResumeNextOperator {
      constructor(nextSources) {
        this.nextSources = nextSources;
      }

      call(subscriber, source) {
        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
      }

    }

    class OnErrorResumeNextSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__["OuterSubscriber"] {
      constructor(destination, nextSources) {
        super(destination);
        this.destination = destination;
        this.nextSources = nextSources;
      }

      notifyError(error, innerSub) {
        this.subscribeToNextSource();
      }

      notifyComplete(innerSub) {
        this.subscribeToNextSource();
      }

      _error(err) {
        this.subscribeToNextSource();
        this.unsubscribe();
      }

      _complete() {
        this.subscribeToNextSource();
        this.unsubscribe();
      }

      subscribeToNextSource() {
        const next = this.nextSources.shift();

        if (!!next) {
          const innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_3__["InnerSubscriber"](this, undefined, undefined);
          const destination = this.destination;
          destination.add(innerSubscriber);
          Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_4__["subscribeToResult"])(this, next, undefined, undefined, innerSubscriber);
        } else {
          this.destination.complete();
        }
      }

    } //# sourceMappingURL=onErrorResumeNext.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/pairwise.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/pairwise.js ***!
    \*******************************************************************/

  /*! exports provided: pairwise */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsPairwiseJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "pairwise", function () {
      return pairwise;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function pairwise() {
      return source => source.lift(new PairwiseOperator());
    }

    class PairwiseOperator {
      call(subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
      }

    }

    class PairwiseSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination) {
        super(destination);
        this.hasPrev = false;
      }

      _next(value) {
        if (this.hasPrev) {
          this.destination.next([this.prev, value]);
        } else {
          this.hasPrev = true;
        }

        this.prev = value;
      }

    } //# sourceMappingURL=pairwise.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/partition.js":
  /*!********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/partition.js ***!
    \********************************************************************/

  /*! exports provided: partition */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsPartitionJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "partition", function () {
      return partition;
    });
    /* harmony import */


    var _util_not__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../util/not */
    "./node_modules/rxjs/_esm2015/internal/util/not.js");
    /* harmony import */


    var _filter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./filter */
    "./node_modules/rxjs/_esm2015/internal/operators/filter.js");

    function partition(predicate, thisArg) {
      return source => [Object(_filter__WEBPACK_IMPORTED_MODULE_1__["filter"])(predicate, thisArg)(source), Object(_filter__WEBPACK_IMPORTED_MODULE_1__["filter"])(Object(_util_not__WEBPACK_IMPORTED_MODULE_0__["not"])(predicate, thisArg))(source)];
    } //# sourceMappingURL=partition.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/pluck.js":
  /*!****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/pluck.js ***!
    \****************************************************************/

  /*! exports provided: pluck */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsPluckJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "pluck", function () {
      return pluck;
    });
    /* harmony import */


    var _map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./map */
    "./node_modules/rxjs/_esm2015/internal/operators/map.js");

    function pluck(...properties) {
      const length = properties.length;

      if (length === 0) {
        throw new Error('list of properties cannot be empty.');
      }

      return source => Object(_map__WEBPACK_IMPORTED_MODULE_0__["map"])(plucker(properties, length))(source);
    }

    function plucker(props, length) {
      const mapper = x => {
        let currentProp = x;

        for (let i = 0; i < length; i++) {
          const p = currentProp[props[i]];

          if (typeof p !== 'undefined') {
            currentProp = p;
          } else {
            return undefined;
          }
        }

        return currentProp;
      };

      return mapper;
    } //# sourceMappingURL=pluck.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/publish.js":
  /*!******************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/publish.js ***!
    \******************************************************************/

  /*! exports provided: publish */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsPublishJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "publish", function () {
      return publish;
    });
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subject */
    "./node_modules/rxjs/_esm2015/internal/Subject.js");
    /* harmony import */


    var _multicast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./multicast */
    "./node_modules/rxjs/_esm2015/internal/operators/multicast.js");

    function publish(selector) {
      return selector ? Object(_multicast__WEBPACK_IMPORTED_MODULE_1__["multicast"])(() => new _Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"](), selector) : Object(_multicast__WEBPACK_IMPORTED_MODULE_1__["multicast"])(new _Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"]());
    } //# sourceMappingURL=publish.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/publishBehavior.js":
  /*!**************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/publishBehavior.js ***!
    \**************************************************************************/

  /*! exports provided: publishBehavior */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsPublishBehaviorJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "publishBehavior", function () {
      return publishBehavior;
    });
    /* harmony import */


    var _BehaviorSubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../BehaviorSubject */
    "./node_modules/rxjs/_esm2015/internal/BehaviorSubject.js");
    /* harmony import */


    var _multicast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./multicast */
    "./node_modules/rxjs/_esm2015/internal/operators/multicast.js");

    function publishBehavior(value) {
      return source => Object(_multicast__WEBPACK_IMPORTED_MODULE_1__["multicast"])(new _BehaviorSubject__WEBPACK_IMPORTED_MODULE_0__["BehaviorSubject"](value))(source);
    } //# sourceMappingURL=publishBehavior.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/publishLast.js":
  /*!**********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/publishLast.js ***!
    \**********************************************************************/

  /*! exports provided: publishLast */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsPublishLastJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "publishLast", function () {
      return publishLast;
    });
    /* harmony import */


    var _AsyncSubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../AsyncSubject */
    "./node_modules/rxjs/_esm2015/internal/AsyncSubject.js");
    /* harmony import */


    var _multicast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./multicast */
    "./node_modules/rxjs/_esm2015/internal/operators/multicast.js");

    function publishLast() {
      return source => Object(_multicast__WEBPACK_IMPORTED_MODULE_1__["multicast"])(new _AsyncSubject__WEBPACK_IMPORTED_MODULE_0__["AsyncSubject"]())(source);
    } //# sourceMappingURL=publishLast.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/publishReplay.js":
  /*!************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/publishReplay.js ***!
    \************************************************************************/

  /*! exports provided: publishReplay */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsPublishReplayJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "publishReplay", function () {
      return publishReplay;
    });
    /* harmony import */


    var _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../ReplaySubject */
    "./node_modules/rxjs/_esm2015/internal/ReplaySubject.js");
    /* harmony import */


    var _multicast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./multicast */
    "./node_modules/rxjs/_esm2015/internal/operators/multicast.js");

    function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {
      if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {
        scheduler = selectorOrScheduler;
      }

      const selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;
      const subject = new _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__["ReplaySubject"](bufferSize, windowTime, scheduler);
      return source => Object(_multicast__WEBPACK_IMPORTED_MODULE_1__["multicast"])(() => subject, selector)(source);
    } //# sourceMappingURL=publishReplay.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/race.js":
  /*!***************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/race.js ***!
    \***************************************************************/

  /*! exports provided: race */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsRaceJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "race", function () {
      return race;
    });
    /* harmony import */


    var _util_isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../util/isArray */
    "./node_modules/rxjs/_esm2015/internal/util/isArray.js");
    /* harmony import */


    var _observable_race__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../observable/race */
    "./node_modules/rxjs/_esm2015/internal/observable/race.js");

    function race(...observables) {
      return function raceOperatorFunction(source) {
        if (observables.length === 1 && Object(_util_isArray__WEBPACK_IMPORTED_MODULE_0__["isArray"])(observables[0])) {
          observables = observables[0];
        }

        return source.lift.call(Object(_observable_race__WEBPACK_IMPORTED_MODULE_1__["race"])(source, ...observables));
      };
    } //# sourceMappingURL=race.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/reduce.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/reduce.js ***!
    \*****************************************************************/

  /*! exports provided: reduce */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsReduceJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "reduce", function () {
      return reduce;
    });
    /* harmony import */


    var _scan__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./scan */
    "./node_modules/rxjs/_esm2015/internal/operators/scan.js");
    /* harmony import */


    var _takeLast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./takeLast */
    "./node_modules/rxjs/_esm2015/internal/operators/takeLast.js");
    /* harmony import */


    var _defaultIfEmpty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./defaultIfEmpty */
    "./node_modules/rxjs/_esm2015/internal/operators/defaultIfEmpty.js");
    /* harmony import */


    var _util_pipe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../util/pipe */
    "./node_modules/rxjs/_esm2015/internal/util/pipe.js");

    function reduce(accumulator, seed) {
      if (arguments.length >= 2) {
        return function reduceOperatorFunctionWithSeed(source) {
          return Object(_util_pipe__WEBPACK_IMPORTED_MODULE_3__["pipe"])(Object(_scan__WEBPACK_IMPORTED_MODULE_0__["scan"])(accumulator, seed), Object(_takeLast__WEBPACK_IMPORTED_MODULE_1__["takeLast"])(1), Object(_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_2__["defaultIfEmpty"])(seed))(source);
        };
      }

      return function reduceOperatorFunction(source) {
        return Object(_util_pipe__WEBPACK_IMPORTED_MODULE_3__["pipe"])(Object(_scan__WEBPACK_IMPORTED_MODULE_0__["scan"])((acc, value, index) => accumulator(acc, value, index + 1)), Object(_takeLast__WEBPACK_IMPORTED_MODULE_1__["takeLast"])(1))(source);
      };
    } //# sourceMappingURL=reduce.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/refCount.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/refCount.js ***!
    \*******************************************************************/

  /*! exports provided: refCount */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsRefCountJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "refCount", function () {
      return refCount;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function refCount() {
      return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator(source));
      };
    }

    class RefCountOperator {
      constructor(connectable) {
        this.connectable = connectable;
      }

      call(subscriber, source) {
        const {
          connectable
        } = this;
        connectable._refCount++;
        const refCounter = new RefCountSubscriber(subscriber, connectable);
        const subscription = source.subscribe(refCounter);

        if (!refCounter.closed) {
          refCounter.connection = connectable.connect();
        }

        return subscription;
      }

    }

    class RefCountSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, connectable) {
        super(destination);
        this.connectable = connectable;
      }

      _unsubscribe() {
        const {
          connectable
        } = this;

        if (!connectable) {
          this.connection = null;
          return;
        }

        this.connectable = null;
        const refCount = connectable._refCount;

        if (refCount <= 0) {
          this.connection = null;
          return;
        }

        connectable._refCount = refCount - 1;

        if (refCount > 1) {
          this.connection = null;
          return;
        }

        const {
          connection
        } = this;
        const sharedConnection = connectable._connection;
        this.connection = null;

        if (sharedConnection && (!connection || sharedConnection === connection)) {
          sharedConnection.unsubscribe();
        }
      }

    } //# sourceMappingURL=refCount.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/repeat.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/repeat.js ***!
    \*****************************************************************/

  /*! exports provided: repeat */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsRepeatJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "repeat", function () {
      return repeat;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _observable_empty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../observable/empty */
    "./node_modules/rxjs/_esm2015/internal/observable/empty.js");

    function repeat(count = -1) {
      return source => {
        if (count === 0) {
          return Object(_observable_empty__WEBPACK_IMPORTED_MODULE_1__["empty"])();
        } else if (count < 0) {
          return source.lift(new RepeatOperator(-1, source));
        } else {
          return source.lift(new RepeatOperator(count - 1, source));
        }
      };
    }

    class RepeatOperator {
      constructor(count, source) {
        this.count = count;
        this.source = source;
      }

      call(subscriber, source) {
        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
      }

    }

    class RepeatSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, count, source) {
        super(destination);
        this.count = count;
        this.source = source;
      }

      complete() {
        if (!this.isStopped) {
          const {
            source,
            count
          } = this;

          if (count === 0) {
            return super.complete();
          } else if (count > -1) {
            this.count = count - 1;
          }

          source.subscribe(this._unsubscribeAndRecycle());
        }
      }

    } //# sourceMappingURL=repeat.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/repeatWhen.js":
  /*!*********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/repeatWhen.js ***!
    \*********************************************************************/

  /*! exports provided: repeatWhen */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsRepeatWhenJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "repeatWhen", function () {
      return repeatWhen;
    });
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subject */
    "./node_modules/rxjs/_esm2015/internal/Subject.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function repeatWhen(notifier) {
      return source => source.lift(new RepeatWhenOperator(notifier));
    }

    class RepeatWhenOperator {
      constructor(notifier) {
        this.notifier = notifier;
      }

      call(subscriber, source) {
        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
      }

    }

    class RepeatWhenSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"] {
      constructor(destination, notifier, source) {
        super(destination);
        this.notifier = notifier;
        this.source = source;
        this.sourceIsBeingSubscribedTo = true;
      }

      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.sourceIsBeingSubscribedTo = true;
        this.source.subscribe(this);
      }

      notifyComplete(innerSub) {
        if (this.sourceIsBeingSubscribedTo === false) {
          return super.complete();
        }
      }

      complete() {
        this.sourceIsBeingSubscribedTo = false;

        if (!this.isStopped) {
          if (!this.retries) {
            this.subscribeToRetries();
          }

          if (!this.retriesSubscription || this.retriesSubscription.closed) {
            return super.complete();
          }

          this._unsubscribeAndRecycle();

          this.notifications.next();
        }
      }

      _unsubscribe() {
        const {
          notifications,
          retriesSubscription
        } = this;

        if (notifications) {
          notifications.unsubscribe();
          this.notifications = null;
        }

        if (retriesSubscription) {
          retriesSubscription.unsubscribe();
          this.retriesSubscription = null;
        }

        this.retries = null;
      }

      _unsubscribeAndRecycle() {
        const {
          _unsubscribe
        } = this;
        this._unsubscribe = null;

        super._unsubscribeAndRecycle();

        this._unsubscribe = _unsubscribe;
        return this;
      }

      subscribeToRetries() {
        this.notifications = new _Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"]();
        let retries;

        try {
          const {
            notifier
          } = this;
          retries = notifier(this.notifications);
        } catch (e) {
          return super.complete();
        }

        this.retries = retries;
        this.retriesSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, retries);
      }

    } //# sourceMappingURL=repeatWhen.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/retry.js":
  /*!****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/retry.js ***!
    \****************************************************************/

  /*! exports provided: retry */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsRetryJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "retry", function () {
      return retry;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function retry(count = -1) {
      return source => source.lift(new RetryOperator(count, source));
    }

    class RetryOperator {
      constructor(count, source) {
        this.count = count;
        this.source = source;
      }

      call(subscriber, source) {
        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
      }

    }

    class RetrySubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, count, source) {
        super(destination);
        this.count = count;
        this.source = source;
      }

      error(err) {
        if (!this.isStopped) {
          const {
            source,
            count
          } = this;

          if (count === 0) {
            return super.error(err);
          } else if (count > -1) {
            this.count = count - 1;
          }

          source.subscribe(this._unsubscribeAndRecycle());
        }
      }

    } //# sourceMappingURL=retry.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/retryWhen.js":
  /*!********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/retryWhen.js ***!
    \********************************************************************/

  /*! exports provided: retryWhen */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsRetryWhenJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "retryWhen", function () {
      return retryWhen;
    });
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subject */
    "./node_modules/rxjs/_esm2015/internal/Subject.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function retryWhen(notifier) {
      return source => source.lift(new RetryWhenOperator(notifier, source));
    }

    class RetryWhenOperator {
      constructor(notifier, source) {
        this.notifier = notifier;
        this.source = source;
      }

      call(subscriber, source) {
        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
      }

    }

    class RetryWhenSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"] {
      constructor(destination, notifier, source) {
        super(destination);
        this.notifier = notifier;
        this.source = source;
      }

      error(err) {
        if (!this.isStopped) {
          let errors = this.errors;
          let retries = this.retries;
          let retriesSubscription = this.retriesSubscription;

          if (!retries) {
            errors = new _Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"]();

            try {
              const {
                notifier
              } = this;
              retries = notifier(errors);
            } catch (e) {
              return super.error(e);
            }

            retriesSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, retries);
          } else {
            this.errors = null;
            this.retriesSubscription = null;
          }

          this._unsubscribeAndRecycle();

          this.errors = errors;
          this.retries = retries;
          this.retriesSubscription = retriesSubscription;
          errors.next(err);
        }
      }

      _unsubscribe() {
        const {
          errors,
          retriesSubscription
        } = this;

        if (errors) {
          errors.unsubscribe();
          this.errors = null;
        }

        if (retriesSubscription) {
          retriesSubscription.unsubscribe();
          this.retriesSubscription = null;
        }

        this.retries = null;
      }

      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        const {
          _unsubscribe
        } = this;
        this._unsubscribe = null;

        this._unsubscribeAndRecycle();

        this._unsubscribe = _unsubscribe;
        this.source.subscribe(this);
      }

    } //# sourceMappingURL=retryWhen.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/sample.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/sample.js ***!
    \*****************************************************************/

  /*! exports provided: sample */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsSampleJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "sample", function () {
      return sample;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function sample(notifier) {
      return source => source.lift(new SampleOperator(notifier));
    }

    class SampleOperator {
      constructor(notifier) {
        this.notifier = notifier;
      }

      call(subscriber, source) {
        const sampleSubscriber = new SampleSubscriber(subscriber);
        const subscription = source.subscribe(sampleSubscriber);
        subscription.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__["subscribeToResult"])(sampleSubscriber, this.notifier));
        return subscription;
      }

    }

    class SampleSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"] {
      constructor() {
        super(...arguments);
        this.hasValue = false;
      }

      _next(value) {
        this.value = value;
        this.hasValue = true;
      }

      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
      }

      notifyComplete() {
        this.emitValue();
      }

      emitValue() {
        if (this.hasValue) {
          this.hasValue = false;
          this.destination.next(this.value);
        }
      }

    } //# sourceMappingURL=sample.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/sampleTime.js":
  /*!*********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/sampleTime.js ***!
    \*********************************************************************/

  /*! exports provided: sampleTime */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsSampleTimeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "sampleTime", function () {
      return sampleTime;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../scheduler/async */
    "./node_modules/rxjs/_esm2015/internal/scheduler/async.js");

    function sampleTime(period, scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__["async"]) {
      return source => source.lift(new SampleTimeOperator(period, scheduler));
    }

    class SampleTimeOperator {
      constructor(period, scheduler) {
        this.period = period;
        this.scheduler = scheduler;
      }

      call(subscriber, source) {
        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
      }

    }

    class SampleTimeSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, period, scheduler) {
        super(destination);
        this.period = period;
        this.scheduler = scheduler;
        this.hasValue = false;
        this.add(scheduler.schedule(dispatchNotification, period, {
          subscriber: this,
          period
        }));
      }

      _next(value) {
        this.lastValue = value;
        this.hasValue = true;
      }

      notifyNext() {
        if (this.hasValue) {
          this.hasValue = false;
          this.destination.next(this.lastValue);
        }
      }

    }

    function dispatchNotification(state) {
      let {
        subscriber,
        period
      } = state;
      subscriber.notifyNext();
      this.schedule(state, period);
    } //# sourceMappingURL=sampleTime.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/scan.js":
  /*!***************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/scan.js ***!
    \***************************************************************/

  /*! exports provided: scan */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsScanJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "scan", function () {
      return scan;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function scan(accumulator, seed) {
      let hasSeed = false;

      if (arguments.length >= 2) {
        hasSeed = true;
      }

      return function scanOperatorFunction(source) {
        return source.lift(new ScanOperator(accumulator, seed, hasSeed));
      };
    }

    class ScanOperator {
      constructor(accumulator, seed, hasSeed = false) {
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
      }

      call(subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
      }

    }

    class ScanSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, accumulator, _seed, hasSeed) {
        super(destination);
        this.accumulator = accumulator;
        this._seed = _seed;
        this.hasSeed = hasSeed;
        this.index = 0;
      }

      get seed() {
        return this._seed;
      }

      set seed(value) {
        this.hasSeed = true;
        this._seed = value;
      }

      _next(value) {
        if (!this.hasSeed) {
          this.seed = value;
          this.destination.next(value);
        } else {
          return this._tryNext(value);
        }
      }

      _tryNext(value) {
        const index = this.index++;
        let result;

        try {
          result = this.accumulator(this.seed, value, index);
        } catch (err) {
          this.destination.error(err);
        }

        this.seed = result;
        this.destination.next(result);
      }

    } //# sourceMappingURL=scan.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/sequenceEqual.js":
  /*!************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/sequenceEqual.js ***!
    \************************************************************************/

  /*! exports provided: sequenceEqual, SequenceEqualOperator, SequenceEqualSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsSequenceEqualJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "sequenceEqual", function () {
      return sequenceEqual;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SequenceEqualOperator", function () {
      return SequenceEqualOperator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "SequenceEqualSubscriber", function () {
      return SequenceEqualSubscriber;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function sequenceEqual(compareTo, comparator) {
      return source => source.lift(new SequenceEqualOperator(compareTo, comparator));
    }

    class SequenceEqualOperator {
      constructor(compareTo, comparator) {
        this.compareTo = compareTo;
        this.comparator = comparator;
      }

      call(subscriber, source) {
        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
      }

    }

    class SequenceEqualSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, compareTo, comparator) {
        super(destination);
        this.compareTo = compareTo;
        this.comparator = comparator;
        this._a = [];
        this._b = [];
        this._oneComplete = false;
        this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, this)));
      }

      _next(value) {
        if (this._oneComplete && this._b.length === 0) {
          this.emit(false);
        } else {
          this._a.push(value);

          this.checkValues();
        }
      }

      _complete() {
        if (this._oneComplete) {
          this.emit(this._a.length === 0 && this._b.length === 0);
        } else {
          this._oneComplete = true;
        }

        this.unsubscribe();
      }

      checkValues() {
        const {
          _a,
          _b,
          comparator
        } = this;

        while (_a.length > 0 && _b.length > 0) {
          let a = _a.shift();

          let b = _b.shift();

          let areEqual = false;

          try {
            areEqual = comparator ? comparator(a, b) : a === b;
          } catch (e) {
            this.destination.error(e);
          }

          if (!areEqual) {
            this.emit(false);
          }
        }
      }

      emit(value) {
        const {
          destination
        } = this;
        destination.next(value);
        destination.complete();
      }

      nextB(value) {
        if (this._oneComplete && this._a.length === 0) {
          this.emit(false);
        } else {
          this._b.push(value);

          this.checkValues();
        }
      }

      completeB() {
        if (this._oneComplete) {
          this.emit(this._a.length === 0 && this._b.length === 0);
        } else {
          this._oneComplete = true;
        }
      }

    }

    class SequenceEqualCompareToSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, parent) {
        super(destination);
        this.parent = parent;
      }

      _next(value) {
        this.parent.nextB(value);
      }

      _error(err) {
        this.parent.error(err);
        this.unsubscribe();
      }

      _complete() {
        this.parent.completeB();
        this.unsubscribe();
      }

    } //# sourceMappingURL=sequenceEqual.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/share.js":
  /*!****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/share.js ***!
    \****************************************************************/

  /*! exports provided: share */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsShareJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "share", function () {
      return share;
    });
    /* harmony import */


    var _multicast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./multicast */
    "./node_modules/rxjs/_esm2015/internal/operators/multicast.js");
    /* harmony import */


    var _refCount__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./refCount */
    "./node_modules/rxjs/_esm2015/internal/operators/refCount.js");
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../Subject */
    "./node_modules/rxjs/_esm2015/internal/Subject.js");

    function shareSubjectFactory() {
      return new _Subject__WEBPACK_IMPORTED_MODULE_2__["Subject"]();
    }

    function share() {
      return source => Object(_refCount__WEBPACK_IMPORTED_MODULE_1__["refCount"])()(Object(_multicast__WEBPACK_IMPORTED_MODULE_0__["multicast"])(shareSubjectFactory)(source));
    } //# sourceMappingURL=share.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/shareReplay.js":
  /*!**********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/shareReplay.js ***!
    \**********************************************************************/

  /*! exports provided: shareReplay */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsShareReplayJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "shareReplay", function () {
      return shareReplay;
    });
    /* harmony import */


    var _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../ReplaySubject */
    "./node_modules/rxjs/_esm2015/internal/ReplaySubject.js");

    function shareReplay(configOrBufferSize, windowTime, scheduler) {
      let config;

      if (configOrBufferSize && typeof configOrBufferSize === 'object') {
        config = configOrBufferSize;
      } else {
        config = {
          bufferSize: configOrBufferSize,
          windowTime,
          refCount: false,
          scheduler
        };
      }

      return source => source.lift(shareReplayOperator(config));
    }

    function shareReplayOperator({
      bufferSize = Number.POSITIVE_INFINITY,
      windowTime = Number.POSITIVE_INFINITY,
      refCount: useRefCount,
      scheduler
    }) {
      let subject;
      let refCount = 0;
      let subscription;
      let hasError = false;
      let isComplete = false;
      return function shareReplayOperation(source) {
        refCount++;

        if (!subject || hasError) {
          hasError = false;
          subject = new _ReplaySubject__WEBPACK_IMPORTED_MODULE_0__["ReplaySubject"](bufferSize, windowTime, scheduler);
          subscription = source.subscribe({
            next(value) {
              subject.next(value);
            },

            error(err) {
              hasError = true;
              subject.error(err);
            },

            complete() {
              isComplete = true;
              subject.complete();
            }

          });
        }

        const innerSub = subject.subscribe(this);
        this.add(() => {
          refCount--;
          innerSub.unsubscribe();

          if (subscription && !isComplete && useRefCount && refCount === 0) {
            subscription.unsubscribe();
            subscription = undefined;
            subject = undefined;
          }
        });
      };
    } //# sourceMappingURL=shareReplay.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/single.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/single.js ***!
    \*****************************************************************/

  /*! exports provided: single */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsSingleJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "single", function () {
      return single;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _util_EmptyError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/EmptyError */
    "./node_modules/rxjs/_esm2015/internal/util/EmptyError.js");

    function single(predicate) {
      return source => source.lift(new SingleOperator(predicate, source));
    }

    class SingleOperator {
      constructor(predicate, source) {
        this.predicate = predicate;
        this.source = source;
      }

      call(subscriber, source) {
        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
      }

    }

    class SingleSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, predicate, source) {
        super(destination);
        this.predicate = predicate;
        this.source = source;
        this.seenValue = false;
        this.index = 0;
      }

      applySingleValue(value) {
        if (this.seenValue) {
          this.destination.error('Sequence contains more than one element');
        } else {
          this.seenValue = true;
          this.singleValue = value;
        }
      }

      _next(value) {
        const index = this.index++;

        if (this.predicate) {
          this.tryNext(value, index);
        } else {
          this.applySingleValue(value);
        }
      }

      tryNext(value, index) {
        try {
          if (this.predicate(value, index, this.source)) {
            this.applySingleValue(value);
          }
        } catch (err) {
          this.destination.error(err);
        }
      }

      _complete() {
        const destination = this.destination;

        if (this.index > 0) {
          destination.next(this.seenValue ? this.singleValue : undefined);
          destination.complete();
        } else {
          destination.error(new _util_EmptyError__WEBPACK_IMPORTED_MODULE_1__["EmptyError"]());
        }
      }

    } //# sourceMappingURL=single.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/skip.js":
  /*!***************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/skip.js ***!
    \***************************************************************/

  /*! exports provided: skip */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsSkipJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "skip", function () {
      return skip;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function skip(count) {
      return source => source.lift(new SkipOperator(count));
    }

    class SkipOperator {
      constructor(total) {
        this.total = total;
      }

      call(subscriber, source) {
        return source.subscribe(new SkipSubscriber(subscriber, this.total));
      }

    }

    class SkipSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, total) {
        super(destination);
        this.total = total;
        this.count = 0;
      }

      _next(x) {
        if (++this.count > this.total) {
          this.destination.next(x);
        }
      }

    } //# sourceMappingURL=skip.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/skipLast.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/skipLast.js ***!
    \*******************************************************************/

  /*! exports provided: skipLast */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsSkipLastJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "skipLast", function () {
      return skipLast;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/ArgumentOutOfRangeError */
    "./node_modules/rxjs/_esm2015/internal/util/ArgumentOutOfRangeError.js");

    function skipLast(count) {
      return source => source.lift(new SkipLastOperator(count));
    }

    class SkipLastOperator {
      constructor(_skipCount) {
        this._skipCount = _skipCount;

        if (this._skipCount < 0) {
          throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_1__["ArgumentOutOfRangeError"]();
        }
      }

      call(subscriber, source) {
        if (this._skipCount === 0) {
          return source.subscribe(new _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"](subscriber));
        } else {
          return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
        }
      }

    }

    class SkipLastSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, _skipCount) {
        super(destination);
        this._skipCount = _skipCount;
        this._count = 0;
        this._ring = new Array(_skipCount);
      }

      _next(value) {
        const skipCount = this._skipCount;
        const count = this._count++;

        if (count < skipCount) {
          this._ring[count] = value;
        } else {
          const currentIndex = count % skipCount;
          const ring = this._ring;
          const oldValue = ring[currentIndex];
          ring[currentIndex] = value;
          this.destination.next(oldValue);
        }
      }

    } //# sourceMappingURL=skipLast.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/skipUntil.js":
  /*!********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/skipUntil.js ***!
    \********************************************************************/

  /*! exports provided: skipUntil */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsSkipUntilJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "skipUntil", function () {
      return skipUntil;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../InnerSubscriber */
    "./node_modules/rxjs/_esm2015/internal/InnerSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function skipUntil(notifier) {
      return source => source.lift(new SkipUntilOperator(notifier));
    }

    class SkipUntilOperator {
      constructor(notifier) {
        this.notifier = notifier;
      }

      call(destination, source) {
        return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
      }

    }

    class SkipUntilSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"] {
      constructor(destination, notifier) {
        super(destination);
        this.hasValue = false;
        const innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_1__["InnerSubscriber"](this, undefined, undefined);
        this.add(innerSubscriber);
        this.innerSubscription = innerSubscriber;
        Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, notifier, undefined, undefined, innerSubscriber);
      }

      _next(value) {
        if (this.hasValue) {
          super._next(value);
        }
      }

      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.hasValue = true;

        if (this.innerSubscription) {
          this.innerSubscription.unsubscribe();
        }
      }

      notifyComplete() {}

    } //# sourceMappingURL=skipUntil.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/skipWhile.js":
  /*!********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/skipWhile.js ***!
    \********************************************************************/

  /*! exports provided: skipWhile */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsSkipWhileJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "skipWhile", function () {
      return skipWhile;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function skipWhile(predicate) {
      return source => source.lift(new SkipWhileOperator(predicate));
    }

    class SkipWhileOperator {
      constructor(predicate) {
        this.predicate = predicate;
      }

      call(subscriber, source) {
        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
      }

    }

    class SkipWhileSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, predicate) {
        super(destination);
        this.predicate = predicate;
        this.skipping = true;
        this.index = 0;
      }

      _next(value) {
        const destination = this.destination;

        if (this.skipping) {
          this.tryCallPredicate(value);
        }

        if (!this.skipping) {
          destination.next(value);
        }
      }

      tryCallPredicate(value) {
        try {
          const result = this.predicate(value, this.index++);
          this.skipping = Boolean(result);
        } catch (err) {
          this.destination.error(err);
        }
      }

    } //# sourceMappingURL=skipWhile.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/startWith.js":
  /*!********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/startWith.js ***!
    \********************************************************************/

  /*! exports provided: startWith */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsStartWithJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "startWith", function () {
      return startWith;
    });
    /* harmony import */


    var _observable_fromArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../observable/fromArray */
    "./node_modules/rxjs/_esm2015/internal/observable/fromArray.js");
    /* harmony import */


    var _observable_scalar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../observable/scalar */
    "./node_modules/rxjs/_esm2015/internal/observable/scalar.js");
    /* harmony import */


    var _observable_empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../observable/empty */
    "./node_modules/rxjs/_esm2015/internal/observable/empty.js");
    /* harmony import */


    var _observable_concat__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../observable/concat */
    "./node_modules/rxjs/_esm2015/internal/observable/concat.js");
    /* harmony import */


    var _util_isScheduler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ../util/isScheduler */
    "./node_modules/rxjs/_esm2015/internal/util/isScheduler.js");

    function startWith(...array) {
      return source => {
        let scheduler = array[array.length - 1];

        if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_4__["isScheduler"])(scheduler)) {
          array.pop();
        } else {
          scheduler = null;
        }

        const len = array.length;

        if (len === 1 && !scheduler) {
          return Object(_observable_concat__WEBPACK_IMPORTED_MODULE_3__["concat"])(Object(_observable_scalar__WEBPACK_IMPORTED_MODULE_1__["scalar"])(array[0]), source);
        } else if (len > 0) {
          return Object(_observable_concat__WEBPACK_IMPORTED_MODULE_3__["concat"])(Object(_observable_fromArray__WEBPACK_IMPORTED_MODULE_0__["fromArray"])(array, scheduler), source);
        } else {
          return Object(_observable_concat__WEBPACK_IMPORTED_MODULE_3__["concat"])(Object(_observable_empty__WEBPACK_IMPORTED_MODULE_2__["empty"])(scheduler), source);
        }
      };
    } //# sourceMappingURL=startWith.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/subscribeOn.js":
  /*!**********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/subscribeOn.js ***!
    \**********************************************************************/

  /*! exports provided: subscribeOn */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsSubscribeOnJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "subscribeOn", function () {
      return subscribeOn;
    });
    /* harmony import */


    var _observable_SubscribeOnObservable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../observable/SubscribeOnObservable */
    "./node_modules/rxjs/_esm2015/internal/observable/SubscribeOnObservable.js");

    function subscribeOn(scheduler, delay = 0) {
      return function subscribeOnOperatorFunction(source) {
        return source.lift(new SubscribeOnOperator(scheduler, delay));
      };
    }

    class SubscribeOnOperator {
      constructor(scheduler, delay) {
        this.scheduler = scheduler;
        this.delay = delay;
      }

      call(subscriber, source) {
        return new _observable_SubscribeOnObservable__WEBPACK_IMPORTED_MODULE_0__["SubscribeOnObservable"](source, this.delay, this.scheduler).subscribe(subscriber);
      }

    } //# sourceMappingURL=subscribeOn.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/switchAll.js":
  /*!********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/switchAll.js ***!
    \********************************************************************/

  /*! exports provided: switchAll */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsSwitchAllJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "switchAll", function () {
      return switchAll;
    });
    /* harmony import */


    var _switchMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./switchMap */
    "./node_modules/rxjs/_esm2015/internal/operators/switchMap.js");
    /* harmony import */


    var _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/identity */
    "./node_modules/rxjs/_esm2015/internal/util/identity.js");

    function switchAll() {
      return Object(_switchMap__WEBPACK_IMPORTED_MODULE_0__["switchMap"])(_util_identity__WEBPACK_IMPORTED_MODULE_1__["identity"]);
    } //# sourceMappingURL=switchAll.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/switchMap.js":
  /*!********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/switchMap.js ***!
    \********************************************************************/

  /*! exports provided: switchMap */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsSwitchMapJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "switchMap", function () {
      return switchMap;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../InnerSubscriber */
    "./node_modules/rxjs/_esm2015/internal/InnerSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");
    /* harmony import */


    var _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./map */
    "./node_modules/rxjs/_esm2015/internal/operators/map.js");
    /* harmony import */


    var _observable_from__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ../observable/from */
    "./node_modules/rxjs/_esm2015/internal/observable/from.js");

    function switchMap(project, resultSelector) {
      if (typeof resultSelector === 'function') {
        return source => source.pipe(switchMap((a, i) => Object(_observable_from__WEBPACK_IMPORTED_MODULE_4__["from"])(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_3__["map"])((b, ii) => resultSelector(a, b, i, ii)))));
      }

      return source => source.lift(new SwitchMapOperator(project));
    }

    class SwitchMapOperator {
      constructor(project) {
        this.project = project;
      }

      call(subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
      }

    }

    class SwitchMapSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"] {
      constructor(destination, project) {
        super(destination);
        this.project = project;
        this.index = 0;
      }

      _next(value) {
        let result;
        const index = this.index++;

        try {
          result = this.project(value, index);
        } catch (error) {
          this.destination.error(error);
          return;
        }

        this._innerSub(result, value, index);
      }

      _innerSub(result, value, index) {
        const innerSubscription = this.innerSubscription;

        if (innerSubscription) {
          innerSubscription.unsubscribe();
        }

        const innerSubscriber = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_1__["InnerSubscriber"](this, undefined, undefined);
        const destination = this.destination;
        destination.add(innerSubscriber);
        this.innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, result, value, index, innerSubscriber);
      }

      _complete() {
        const {
          innerSubscription
        } = this;

        if (!innerSubscription || innerSubscription.closed) {
          super._complete();
        }

        this.unsubscribe();
      }

      _unsubscribe() {
        this.innerSubscription = null;
      }

      notifyComplete(innerSub) {
        const destination = this.destination;
        destination.remove(innerSub);
        this.innerSubscription = null;

        if (this.isStopped) {
          super._complete();
        }
      }

      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
      }

    } //# sourceMappingURL=switchMap.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/switchMapTo.js":
  /*!**********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/switchMapTo.js ***!
    \**********************************************************************/

  /*! exports provided: switchMapTo */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsSwitchMapToJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "switchMapTo", function () {
      return switchMapTo;
    });
    /* harmony import */


    var _switchMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./switchMap */
    "./node_modules/rxjs/_esm2015/internal/operators/switchMap.js");

    function switchMapTo(innerObservable, resultSelector) {
      return resultSelector ? Object(_switchMap__WEBPACK_IMPORTED_MODULE_0__["switchMap"])(() => innerObservable, resultSelector) : Object(_switchMap__WEBPACK_IMPORTED_MODULE_0__["switchMap"])(() => innerObservable);
    } //# sourceMappingURL=switchMapTo.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/take.js":
  /*!***************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/take.js ***!
    \***************************************************************/

  /*! exports provided: take */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsTakeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "take", function () {
      return take;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/ArgumentOutOfRangeError */
    "./node_modules/rxjs/_esm2015/internal/util/ArgumentOutOfRangeError.js");
    /* harmony import */


    var _observable_empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../observable/empty */
    "./node_modules/rxjs/_esm2015/internal/observable/empty.js");

    function take(count) {
      return source => {
        if (count === 0) {
          return Object(_observable_empty__WEBPACK_IMPORTED_MODULE_2__["empty"])();
        } else {
          return source.lift(new TakeOperator(count));
        }
      };
    }

    class TakeOperator {
      constructor(total) {
        this.total = total;

        if (this.total < 0) {
          throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_1__["ArgumentOutOfRangeError"]();
        }
      }

      call(subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
      }

    }

    class TakeSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, total) {
        super(destination);
        this.total = total;
        this.count = 0;
      }

      _next(value) {
        const total = this.total;
        const count = ++this.count;

        if (count <= total) {
          this.destination.next(value);

          if (count === total) {
            this.destination.complete();
            this.unsubscribe();
          }
        }
      }

    } //# sourceMappingURL=take.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/takeLast.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/takeLast.js ***!
    \*******************************************************************/

  /*! exports provided: takeLast */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsTakeLastJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "takeLast", function () {
      return takeLast;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/ArgumentOutOfRangeError */
    "./node_modules/rxjs/_esm2015/internal/util/ArgumentOutOfRangeError.js");
    /* harmony import */


    var _observable_empty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../observable/empty */
    "./node_modules/rxjs/_esm2015/internal/observable/empty.js");

    function takeLast(count) {
      return function takeLastOperatorFunction(source) {
        if (count === 0) {
          return Object(_observable_empty__WEBPACK_IMPORTED_MODULE_2__["empty"])();
        } else {
          return source.lift(new TakeLastOperator(count));
        }
      };
    }

    class TakeLastOperator {
      constructor(total) {
        this.total = total;

        if (this.total < 0) {
          throw new _util_ArgumentOutOfRangeError__WEBPACK_IMPORTED_MODULE_1__["ArgumentOutOfRangeError"]();
        }
      }

      call(subscriber, source) {
        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
      }

    }

    class TakeLastSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, total) {
        super(destination);
        this.total = total;
        this.ring = new Array();
        this.count = 0;
      }

      _next(value) {
        const ring = this.ring;
        const total = this.total;
        const count = this.count++;

        if (ring.length < total) {
          ring.push(value);
        } else {
          const index = count % total;
          ring[index] = value;
        }
      }

      _complete() {
        const destination = this.destination;
        let count = this.count;

        if (count > 0) {
          const total = this.count >= this.total ? this.total : this.count;
          const ring = this.ring;

          for (let i = 0; i < total; i++) {
            const idx = count++ % total;
            destination.next(ring[idx]);
          }
        }

        destination.complete();
      }

    } //# sourceMappingURL=takeLast.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/takeUntil.js":
  /*!********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/takeUntil.js ***!
    \********************************************************************/

  /*! exports provided: takeUntil */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsTakeUntilJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "takeUntil", function () {
      return takeUntil;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function takeUntil(notifier) {
      return source => source.lift(new TakeUntilOperator(notifier));
    }

    class TakeUntilOperator {
      constructor(notifier) {
        this.notifier = notifier;
      }

      call(subscriber, source) {
        const takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
        const notifierSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__["subscribeToResult"])(takeUntilSubscriber, this.notifier);

        if (notifierSubscription && !takeUntilSubscriber.seenValue) {
          takeUntilSubscriber.add(notifierSubscription);
          return source.subscribe(takeUntilSubscriber);
        }

        return takeUntilSubscriber;
      }

    }

    class TakeUntilSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"] {
      constructor(destination) {
        super(destination);
        this.seenValue = false;
      }

      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.seenValue = true;
        this.complete();
      }

      notifyComplete() {}

    } //# sourceMappingURL=takeUntil.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/takeWhile.js":
  /*!********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/takeWhile.js ***!
    \********************************************************************/

  /*! exports provided: takeWhile */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsTakeWhileJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "takeWhile", function () {
      return takeWhile;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function takeWhile(predicate, inclusive = false) {
      return source => source.lift(new TakeWhileOperator(predicate, inclusive));
    }

    class TakeWhileOperator {
      constructor(predicate, inclusive) {
        this.predicate = predicate;
        this.inclusive = inclusive;
      }

      call(subscriber, source) {
        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
      }

    }

    class TakeWhileSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, predicate, inclusive) {
        super(destination);
        this.predicate = predicate;
        this.inclusive = inclusive;
        this.index = 0;
      }

      _next(value) {
        const destination = this.destination;
        let result;

        try {
          result = this.predicate(value, this.index++);
        } catch (err) {
          destination.error(err);
          return;
        }

        this.nextOrComplete(value, result);
      }

      nextOrComplete(value, predicateResult) {
        const destination = this.destination;

        if (Boolean(predicateResult)) {
          destination.next(value);
        } else {
          if (this.inclusive) {
            destination.next(value);
          }

          destination.complete();
        }
      }

    } //# sourceMappingURL=takeWhile.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/tap.js":
  /*!**************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/tap.js ***!
    \**************************************************************/

  /*! exports provided: tap */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsTapJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "tap", function () {
      return tap;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _util_noop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/noop */
    "./node_modules/rxjs/_esm2015/internal/util/noop.js");
    /* harmony import */


    var _util_isFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/isFunction */
    "./node_modules/rxjs/_esm2015/internal/util/isFunction.js");

    function tap(nextOrObserver, error, complete) {
      return function tapOperatorFunction(source) {
        return source.lift(new DoOperator(nextOrObserver, error, complete));
      };
    }

    class DoOperator {
      constructor(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
      }

      call(subscriber, source) {
        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
      }

    }

    class TapSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, observerOrNext, error, complete) {
        super(destination);
        this._tapNext = _util_noop__WEBPACK_IMPORTED_MODULE_1__["noop"];
        this._tapError = _util_noop__WEBPACK_IMPORTED_MODULE_1__["noop"];
        this._tapComplete = _util_noop__WEBPACK_IMPORTED_MODULE_1__["noop"];
        this._tapError = error || _util_noop__WEBPACK_IMPORTED_MODULE_1__["noop"];
        this._tapComplete = complete || _util_noop__WEBPACK_IMPORTED_MODULE_1__["noop"];

        if (Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_2__["isFunction"])(observerOrNext)) {
          this._context = this;
          this._tapNext = observerOrNext;
        } else if (observerOrNext) {
          this._context = observerOrNext;
          this._tapNext = observerOrNext.next || _util_noop__WEBPACK_IMPORTED_MODULE_1__["noop"];
          this._tapError = observerOrNext.error || _util_noop__WEBPACK_IMPORTED_MODULE_1__["noop"];
          this._tapComplete = observerOrNext.complete || _util_noop__WEBPACK_IMPORTED_MODULE_1__["noop"];
        }
      }

      _next(value) {
        try {
          this._tapNext.call(this._context, value);
        } catch (err) {
          this.destination.error(err);
          return;
        }

        this.destination.next(value);
      }

      _error(err) {
        try {
          this._tapError.call(this._context, err);
        } catch (err) {
          this.destination.error(err);
          return;
        }

        this.destination.error(err);
      }

      _complete() {
        try {
          this._tapComplete.call(this._context);
        } catch (err) {
          this.destination.error(err);
          return;
        }

        return this.destination.complete();
      }

    } //# sourceMappingURL=tap.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/throttle.js":
  /*!*******************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/throttle.js ***!
    \*******************************************************************/

  /*! exports provided: defaultThrottleConfig, throttle */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsThrottleJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "defaultThrottleConfig", function () {
      return defaultThrottleConfig;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "throttle", function () {
      return throttle;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    const defaultThrottleConfig = {
      leading: true,
      trailing: false
    };

    function throttle(durationSelector, config = defaultThrottleConfig) {
      return source => source.lift(new ThrottleOperator(durationSelector, config.leading, config.trailing));
    }

    class ThrottleOperator {
      constructor(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
      }

      call(subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
      }

    }

    class ThrottleSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"] {
      constructor(destination, durationSelector, _leading, _trailing) {
        super(destination);
        this.destination = destination;
        this.durationSelector = durationSelector;
        this._leading = _leading;
        this._trailing = _trailing;
        this._hasValue = false;
      }

      _next(value) {
        this._hasValue = true;
        this._sendValue = value;

        if (!this._throttled) {
          if (this._leading) {
            this.send();
          } else {
            this.throttle(value);
          }
        }
      }

      send() {
        const {
          _hasValue,
          _sendValue
        } = this;

        if (_hasValue) {
          this.destination.next(_sendValue);
          this.throttle(_sendValue);
        }

        this._hasValue = false;
        this._sendValue = null;
      }

      throttle(value) {
        const duration = this.tryDurationSelector(value);

        if (!!duration) {
          this.add(this._throttled = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__["subscribeToResult"])(this, duration));
        }
      }

      tryDurationSelector(value) {
        try {
          return this.durationSelector(value);
        } catch (err) {
          this.destination.error(err);
          return null;
        }
      }

      throttlingDone() {
        const {
          _throttled,
          _trailing
        } = this;

        if (_throttled) {
          _throttled.unsubscribe();
        }

        this._throttled = null;

        if (_trailing) {
          this.send();
        }
      }

      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.throttlingDone();
      }

      notifyComplete() {
        this.throttlingDone();
      }

    } //# sourceMappingURL=throttle.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/throttleTime.js":
  /*!***********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/throttleTime.js ***!
    \***********************************************************************/

  /*! exports provided: throttleTime */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsThrottleTimeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "throttleTime", function () {
      return throttleTime;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../scheduler/async */
    "./node_modules/rxjs/_esm2015/internal/scheduler/async.js");
    /* harmony import */


    var _throttle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./throttle */
    "./node_modules/rxjs/_esm2015/internal/operators/throttle.js");

    function throttleTime(duration, scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__["async"], config = _throttle__WEBPACK_IMPORTED_MODULE_2__["defaultThrottleConfig"]) {
      return source => source.lift(new ThrottleTimeOperator(duration, scheduler, config.leading, config.trailing));
    }

    class ThrottleTimeOperator {
      constructor(duration, scheduler, leading, trailing) {
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
      }

      call(subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
      }

    }

    class ThrottleTimeSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, duration, scheduler, leading, trailing) {
        super(destination);
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
        this._hasTrailingValue = false;
        this._trailingValue = null;
      }

      _next(value) {
        if (this.throttled) {
          if (this.trailing) {
            this._trailingValue = value;
            this._hasTrailingValue = true;
          }
        } else {
          this.add(this.throttled = this.scheduler.schedule(dispatchNext, this.duration, {
            subscriber: this
          }));

          if (this.leading) {
            this.destination.next(value);
          }
        }
      }

      _complete() {
        if (this._hasTrailingValue) {
          this.destination.next(this._trailingValue);
          this.destination.complete();
        } else {
          this.destination.complete();
        }
      }

      clearThrottle() {
        const throttled = this.throttled;

        if (throttled) {
          if (this.trailing && this._hasTrailingValue) {
            this.destination.next(this._trailingValue);
            this._trailingValue = null;
            this._hasTrailingValue = false;
          }

          throttled.unsubscribe();
          this.remove(throttled);
          this.throttled = null;
        }
      }

    }

    function dispatchNext(arg) {
      const {
        subscriber
      } = arg;
      subscriber.clearThrottle();
    } //# sourceMappingURL=throttleTime.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/throwIfEmpty.js":
  /*!***********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/throwIfEmpty.js ***!
    \***********************************************************************/

  /*! exports provided: throwIfEmpty */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsThrowIfEmptyJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "throwIfEmpty", function () {
      return throwIfEmpty;
    });
    /* harmony import */


    var _tap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./tap */
    "./node_modules/rxjs/_esm2015/internal/operators/tap.js");
    /* harmony import */


    var _util_EmptyError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/EmptyError */
    "./node_modules/rxjs/_esm2015/internal/util/EmptyError.js");

    const throwIfEmpty = (errorFactory = defaultErrorFactory) => Object(_tap__WEBPACK_IMPORTED_MODULE_0__["tap"])({
      hasValue: false,

      next() {
        this.hasValue = true;
      },

      complete() {
        if (!this.hasValue) {
          throw errorFactory();
        }
      }

    });

    function defaultErrorFactory() {
      return new _util_EmptyError__WEBPACK_IMPORTED_MODULE_1__["EmptyError"]();
    } //# sourceMappingURL=throwIfEmpty.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/timeInterval.js":
  /*!***********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/timeInterval.js ***!
    \***********************************************************************/

  /*! exports provided: timeInterval, TimeInterval */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsTimeIntervalJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "timeInterval", function () {
      return timeInterval;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TimeInterval", function () {
      return TimeInterval;
    });
    /* harmony import */


    var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../scheduler/async */
    "./node_modules/rxjs/_esm2015/internal/scheduler/async.js");
    /* harmony import */


    var _scan__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./scan */
    "./node_modules/rxjs/_esm2015/internal/operators/scan.js");
    /* harmony import */


    var _observable_defer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../observable/defer */
    "./node_modules/rxjs/_esm2015/internal/observable/defer.js");
    /* harmony import */


    var _map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./map */
    "./node_modules/rxjs/_esm2015/internal/operators/map.js");

    function timeInterval(scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__["async"]) {
      return source => Object(_observable_defer__WEBPACK_IMPORTED_MODULE_2__["defer"])(() => {
        return source.pipe(Object(_scan__WEBPACK_IMPORTED_MODULE_1__["scan"])(({
          current
        }, value) => ({
          value,
          current: scheduler.now(),
          last: current
        }), {
          current: scheduler.now(),
          value: undefined,
          last: undefined
        }), Object(_map__WEBPACK_IMPORTED_MODULE_3__["map"])(({
          current,
          last,
          value
        }) => new TimeInterval(value, current - last)));
      });
    }

    class TimeInterval {
      constructor(value, interval) {
        this.value = value;
        this.interval = interval;
      }

    } //# sourceMappingURL=timeInterval.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/timeout.js":
  /*!******************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/timeout.js ***!
    \******************************************************************/

  /*! exports provided: timeout */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsTimeoutJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "timeout", function () {
      return timeout;
    });
    /* harmony import */


    var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../scheduler/async */
    "./node_modules/rxjs/_esm2015/internal/scheduler/async.js");
    /* harmony import */


    var _util_TimeoutError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/TimeoutError */
    "./node_modules/rxjs/_esm2015/internal/util/TimeoutError.js");
    /* harmony import */


    var _timeoutWith__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./timeoutWith */
    "./node_modules/rxjs/_esm2015/internal/operators/timeoutWith.js");
    /* harmony import */


    var _observable_throwError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../observable/throwError */
    "./node_modules/rxjs/_esm2015/internal/observable/throwError.js");

    function timeout(due, scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__["async"]) {
      return Object(_timeoutWith__WEBPACK_IMPORTED_MODULE_2__["timeoutWith"])(due, Object(_observable_throwError__WEBPACK_IMPORTED_MODULE_3__["throwError"])(new _util_TimeoutError__WEBPACK_IMPORTED_MODULE_1__["TimeoutError"]()), scheduler);
    } //# sourceMappingURL=timeout.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/timeoutWith.js":
  /*!**********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/timeoutWith.js ***!
    \**********************************************************************/

  /*! exports provided: timeoutWith */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsTimeoutWithJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "timeoutWith", function () {
      return timeoutWith;
    });
    /* harmony import */


    var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../scheduler/async */
    "./node_modules/rxjs/_esm2015/internal/scheduler/async.js");
    /* harmony import */


    var _util_isDate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/isDate */
    "./node_modules/rxjs/_esm2015/internal/util/isDate.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function timeoutWith(due, withObservable, scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__["async"]) {
      return source => {
        let absoluteTimeout = Object(_util_isDate__WEBPACK_IMPORTED_MODULE_1__["isDate"])(due);
        let waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);
        return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
      };
    }

    class TimeoutWithOperator {
      constructor(waitFor, absoluteTimeout, withObservable, scheduler) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
      }

      call(subscriber, source) {
        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
      }

    }

    class TimeoutWithSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__["OuterSubscriber"] {
      constructor(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        super(destination);
        this.absoluteTimeout = absoluteTimeout;
        this.waitFor = waitFor;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
        this.action = null;
        this.scheduleTimeout();
      }

      static dispatchTimeout(subscriber) {
        const {
          withObservable
        } = subscriber;

        subscriber._unsubscribeAndRecycle();

        subscriber.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__["subscribeToResult"])(subscriber, withObservable));
      }

      scheduleTimeout() {
        const {
          action
        } = this;

        if (action) {
          this.action = action.schedule(this, this.waitFor);
        } else {
          this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
        }
      }

      _next(value) {
        if (!this.absoluteTimeout) {
          this.scheduleTimeout();
        }

        super._next(value);
      }

      _unsubscribe() {
        this.action = null;
        this.scheduler = null;
        this.withObservable = null;
      }

    } //# sourceMappingURL=timeoutWith.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/timestamp.js":
  /*!********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/timestamp.js ***!
    \********************************************************************/

  /*! exports provided: timestamp, Timestamp */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsTimestampJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "timestamp", function () {
      return timestamp;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Timestamp", function () {
      return Timestamp;
    });
    /* harmony import */


    var _scheduler_async__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../scheduler/async */
    "./node_modules/rxjs/_esm2015/internal/scheduler/async.js");
    /* harmony import */


    var _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./map */
    "./node_modules/rxjs/_esm2015/internal/operators/map.js");

    function timestamp(scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_0__["async"]) {
      return Object(_map__WEBPACK_IMPORTED_MODULE_1__["map"])(value => new Timestamp(value, scheduler.now()));
    }

    class Timestamp {
      constructor(value, timestamp) {
        this.value = value;
        this.timestamp = timestamp;
      }

    } //# sourceMappingURL=timestamp.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/toArray.js":
  /*!******************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/toArray.js ***!
    \******************************************************************/

  /*! exports provided: toArray */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsToArrayJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "toArray", function () {
      return toArray;
    });
    /* harmony import */


    var _reduce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./reduce */
    "./node_modules/rxjs/_esm2015/internal/operators/reduce.js");

    function toArrayReducer(arr, item, index) {
      if (index === 0) {
        return [item];
      }

      arr.push(item);
      return arr;
    }

    function toArray() {
      return Object(_reduce__WEBPACK_IMPORTED_MODULE_0__["reduce"])(toArrayReducer, []);
    } //# sourceMappingURL=toArray.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/window.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/window.js ***!
    \*****************************************************************/

  /*! exports provided: window */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsWindowJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "window", function () {
      return window;
    });
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subject */
    "./node_modules/rxjs/_esm2015/internal/Subject.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function window(windowBoundaries) {
      return function windowOperatorFunction(source) {
        return source.lift(new WindowOperator(windowBoundaries));
      };
    }

    class WindowOperator {
      constructor(windowBoundaries) {
        this.windowBoundaries = windowBoundaries;
      }

      call(subscriber, source) {
        const windowSubscriber = new WindowSubscriber(subscriber);
        const sourceSubscription = source.subscribe(windowSubscriber);

        if (!sourceSubscription.closed) {
          windowSubscriber.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(windowSubscriber, this.windowBoundaries));
        }

        return sourceSubscription;
      }

    }

    class WindowSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"] {
      constructor(destination) {
        super(destination);
        this.window = new _Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"]();
        destination.next(this.window);
      }

      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow();
      }

      notifyError(error, innerSub) {
        this._error(error);
      }

      notifyComplete(innerSub) {
        this._complete();
      }

      _next(value) {
        this.window.next(value);
      }

      _error(err) {
        this.window.error(err);
        this.destination.error(err);
      }

      _complete() {
        this.window.complete();
        this.destination.complete();
      }

      _unsubscribe() {
        this.window = null;
      }

      openWindow() {
        const prevWindow = this.window;

        if (prevWindow) {
          prevWindow.complete();
        }

        const destination = this.destination;
        const newWindow = this.window = new _Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"]();
        destination.next(newWindow);
      }

    } //# sourceMappingURL=window.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/windowCount.js":
  /*!**********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/windowCount.js ***!
    \**********************************************************************/

  /*! exports provided: windowCount */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsWindowCountJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "windowCount", function () {
      return windowCount;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Subject */
    "./node_modules/rxjs/_esm2015/internal/Subject.js");

    function windowCount(windowSize, startWindowEvery = 0) {
      return function windowCountOperatorFunction(source) {
        return source.lift(new WindowCountOperator(windowSize, startWindowEvery));
      };
    }

    class WindowCountOperator {
      constructor(windowSize, startWindowEvery) {
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
      }

      call(subscriber, source) {
        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
      }

    }

    class WindowCountSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"] {
      constructor(destination, windowSize, startWindowEvery) {
        super(destination);
        this.destination = destination;
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
        this.windows = [new _Subject__WEBPACK_IMPORTED_MODULE_1__["Subject"]()];
        this.count = 0;
        destination.next(this.windows[0]);
      }

      _next(value) {
        const startWindowEvery = this.startWindowEvery > 0 ? this.startWindowEvery : this.windowSize;
        const destination = this.destination;
        const windowSize = this.windowSize;
        const windows = this.windows;
        const len = windows.length;

        for (let i = 0; i < len && !this.closed; i++) {
          windows[i].next(value);
        }

        const c = this.count - windowSize + 1;

        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
          windows.shift().complete();
        }

        if (++this.count % startWindowEvery === 0 && !this.closed) {
          const window = new _Subject__WEBPACK_IMPORTED_MODULE_1__["Subject"]();
          windows.push(window);
          destination.next(window);
        }
      }

      _error(err) {
        const windows = this.windows;

        if (windows) {
          while (windows.length > 0 && !this.closed) {
            windows.shift().error(err);
          }
        }

        this.destination.error(err);
      }

      _complete() {
        const windows = this.windows;

        if (windows) {
          while (windows.length > 0 && !this.closed) {
            windows.shift().complete();
          }
        }

        this.destination.complete();
      }

      _unsubscribe() {
        this.count = 0;
        this.windows = null;
      }

    } //# sourceMappingURL=windowCount.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/windowTime.js":
  /*!*********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/windowTime.js ***!
    \*********************************************************************/

  /*! exports provided: windowTime */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsWindowTimeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "windowTime", function () {
      return windowTime;
    });
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subject */
    "./node_modules/rxjs/_esm2015/internal/Subject.js");
    /* harmony import */


    var _scheduler_async__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../scheduler/async */
    "./node_modules/rxjs/_esm2015/internal/scheduler/async.js");
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _util_isNumeric__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../util/isNumeric */
    "./node_modules/rxjs/_esm2015/internal/util/isNumeric.js");
    /* harmony import */


    var _util_isScheduler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ../util/isScheduler */
    "./node_modules/rxjs/_esm2015/internal/util/isScheduler.js");

    function windowTime(windowTimeSpan) {
      let scheduler = _scheduler_async__WEBPACK_IMPORTED_MODULE_1__["async"];
      let windowCreationInterval = null;
      let maxWindowSize = Number.POSITIVE_INFINITY;

      if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_4__["isScheduler"])(arguments[3])) {
        scheduler = arguments[3];
      }

      if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_4__["isScheduler"])(arguments[2])) {
        scheduler = arguments[2];
      } else if (Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_3__["isNumeric"])(arguments[2])) {
        maxWindowSize = arguments[2];
      }

      if (Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_4__["isScheduler"])(arguments[1])) {
        scheduler = arguments[1];
      } else if (Object(_util_isNumeric__WEBPACK_IMPORTED_MODULE_3__["isNumeric"])(arguments[1])) {
        windowCreationInterval = arguments[1];
      }

      return function windowTimeOperatorFunction(source) {
        return source.lift(new WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler));
      };
    }

    class WindowTimeOperator {
      constructor(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
      }

      call(subscriber, source) {
        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
      }

    }

    class CountedSubject extends _Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"] {
      constructor() {
        super(...arguments);
        this._numberOfNextedValues = 0;
      }

      next(value) {
        this._numberOfNextedValues++;
        super.next(value);
      }

      get numberOfNextedValues() {
        return this._numberOfNextedValues;
      }

    }

    class WindowTimeSubscriber extends _Subscriber__WEBPACK_IMPORTED_MODULE_2__["Subscriber"] {
      constructor(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        super(destination);
        this.destination = destination;
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
        this.windows = [];
        const window = this.openWindow();

        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
          const closeState = {
            subscriber: this,
            window,
            context: null
          };
          const creationState = {
            windowTimeSpan,
            windowCreationInterval,
            subscriber: this,
            scheduler
          };
          this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
          this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        } else {
          const timeSpanOnlyState = {
            subscriber: this,
            window,
            windowTimeSpan
          };
          this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        }
      }

      _next(value) {
        const windows = this.windows;
        const len = windows.length;

        for (let i = 0; i < len; i++) {
          const window = windows[i];

          if (!window.closed) {
            window.next(value);

            if (window.numberOfNextedValues >= this.maxWindowSize) {
              this.closeWindow(window);
            }
          }
        }
      }

      _error(err) {
        const windows = this.windows;

        while (windows.length > 0) {
          windows.shift().error(err);
        }

        this.destination.error(err);
      }

      _complete() {
        const windows = this.windows;

        while (windows.length > 0) {
          const window = windows.shift();

          if (!window.closed) {
            window.complete();
          }
        }

        this.destination.complete();
      }

      openWindow() {
        const window = new CountedSubject();
        this.windows.push(window);
        const destination = this.destination;
        destination.next(window);
        return window;
      }

      closeWindow(window) {
        window.complete();
        const windows = this.windows;
        windows.splice(windows.indexOf(window), 1);
      }

    }

    function dispatchWindowTimeSpanOnly(state) {
      const {
        subscriber,
        windowTimeSpan,
        window
      } = state;

      if (window) {
        subscriber.closeWindow(window);
      }

      state.window = subscriber.openWindow();
      this.schedule(state, windowTimeSpan);
    }

    function dispatchWindowCreation(state) {
      const {
        windowTimeSpan,
        subscriber,
        scheduler,
        windowCreationInterval
      } = state;
      const window = subscriber.openWindow();
      const action = this;
      let context = {
        action,
        subscription: null
      };
      const timeSpanState = {
        subscriber,
        window,
        context
      };
      context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
      action.add(context.subscription);
      action.schedule(state, windowCreationInterval);
    }

    function dispatchWindowClose(state) {
      const {
        subscriber,
        window,
        context
      } = state;

      if (context && context.action && context.subscription) {
        context.action.remove(context.subscription);
      }

      subscriber.closeWindow(window);
    } //# sourceMappingURL=windowTime.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/windowToggle.js":
  /*!***********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/windowToggle.js ***!
    \***********************************************************************/

  /*! exports provided: windowToggle */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsWindowToggleJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "windowToggle", function () {
      return windowToggle;
    });
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subject */
    "./node_modules/rxjs/_esm2015/internal/Subject.js");
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../Subscription */
    "./node_modules/rxjs/_esm2015/internal/Subscription.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function windowToggle(openings, closingSelector) {
      return source => source.lift(new WindowToggleOperator(openings, closingSelector));
    }

    class WindowToggleOperator {
      constructor(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
      }

      call(subscriber, source) {
        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
      }

    }

    class WindowToggleSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_2__["OuterSubscriber"] {
      constructor(destination, openings, closingSelector) {
        super(destination);
        this.openings = openings;
        this.closingSelector = closingSelector;
        this.contexts = [];
        this.add(this.openSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__["subscribeToResult"])(this, openings, openings));
      }

      _next(value) {
        const {
          contexts
        } = this;

        if (contexts) {
          const len = contexts.length;

          for (let i = 0; i < len; i++) {
            contexts[i].window.next(value);
          }
        }
      }

      _error(err) {
        const {
          contexts
        } = this;
        this.contexts = null;

        if (contexts) {
          const len = contexts.length;
          let index = -1;

          while (++index < len) {
            const context = contexts[index];
            context.window.error(err);
            context.subscription.unsubscribe();
          }
        }

        super._error(err);
      }

      _complete() {
        const {
          contexts
        } = this;
        this.contexts = null;

        if (contexts) {
          const len = contexts.length;
          let index = -1;

          while (++index < len) {
            const context = contexts[index];
            context.window.complete();
            context.subscription.unsubscribe();
          }
        }

        super._complete();
      }

      _unsubscribe() {
        const {
          contexts
        } = this;
        this.contexts = null;

        if (contexts) {
          const len = contexts.length;
          let index = -1;

          while (++index < len) {
            const context = contexts[index];
            context.window.unsubscribe();
            context.subscription.unsubscribe();
          }
        }
      }

      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (outerValue === this.openings) {
          let closingNotifier;

          try {
            const {
              closingSelector
            } = this;
            closingNotifier = closingSelector(innerValue);
          } catch (e) {
            return this.error(e);
          }

          const window = new _Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"]();
          const subscription = new _Subscription__WEBPACK_IMPORTED_MODULE_1__["Subscription"]();
          const context = {
            window,
            subscription
          };
          this.contexts.push(context);
          const innerSubscription = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_3__["subscribeToResult"])(this, closingNotifier, context);

          if (innerSubscription.closed) {
            this.closeWindow(this.contexts.length - 1);
          } else {
            innerSubscription.context = context;
            subscription.add(innerSubscription);
          }

          this.destination.next(window);
        } else {
          this.closeWindow(this.contexts.indexOf(outerValue));
        }
      }

      notifyError(err) {
        this.error(err);
      }

      notifyComplete(inner) {
        if (inner !== this.openSubscription) {
          this.closeWindow(this.contexts.indexOf(inner.context));
        }
      }

      closeWindow(index) {
        if (index === -1) {
          return;
        }

        const {
          contexts
        } = this;
        const context = contexts[index];
        const {
          window,
          subscription
        } = context;
        contexts.splice(index, 1);
        window.complete();
        subscription.unsubscribe();
      }

    } //# sourceMappingURL=windowToggle.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/windowWhen.js":
  /*!*********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/windowWhen.js ***!
    \*********************************************************************/

  /*! exports provided: windowWhen */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsWindowWhenJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "windowWhen", function () {
      return windowWhen;
    });
    /* harmony import */


    var _Subject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subject */
    "./node_modules/rxjs/_esm2015/internal/Subject.js");
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function windowWhen(closingSelector) {
      return function windowWhenOperatorFunction(source) {
        return source.lift(new WindowOperator(closingSelector));
      };
    }

    class WindowOperator {
      constructor(closingSelector) {
        this.closingSelector = closingSelector;
      }

      call(subscriber, source) {
        return source.subscribe(new WindowSubscriber(subscriber, this.closingSelector));
      }

    }

    class WindowSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_1__["OuterSubscriber"] {
      constructor(destination, closingSelector) {
        super(destination);
        this.destination = destination;
        this.closingSelector = closingSelector;
        this.openWindow();
      }

      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow(innerSub);
      }

      notifyError(error, innerSub) {
        this._error(error);
      }

      notifyComplete(innerSub) {
        this.openWindow(innerSub);
      }

      _next(value) {
        this.window.next(value);
      }

      _error(err) {
        this.window.error(err);
        this.destination.error(err);
        this.unsubscribeClosingNotification();
      }

      _complete() {
        this.window.complete();
        this.destination.complete();
        this.unsubscribeClosingNotification();
      }

      unsubscribeClosingNotification() {
        if (this.closingNotification) {
          this.closingNotification.unsubscribe();
        }
      }

      openWindow(innerSub = null) {
        if (innerSub) {
          this.remove(innerSub);
          innerSub.unsubscribe();
        }

        const prevWindow = this.window;

        if (prevWindow) {
          prevWindow.complete();
        }

        const window = this.window = new _Subject__WEBPACK_IMPORTED_MODULE_0__["Subject"]();
        this.destination.next(window);
        let closingNotifier;

        try {
          const {
            closingSelector
          } = this;
          closingNotifier = closingSelector();
        } catch (e) {
          this.destination.error(e);
          this.window.error(e);
          return;
        }

        this.add(this.closingNotification = Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_2__["subscribeToResult"])(this, closingNotifier));
      }

    } //# sourceMappingURL=windowWhen.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/withLatestFrom.js":
  /*!*************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/withLatestFrom.js ***!
    \*************************************************************************/

  /*! exports provided: withLatestFrom */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsWithLatestFromJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "withLatestFrom", function () {
      return withLatestFrom;
    });
    /* harmony import */


    var _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../OuterSubscriber */
    "./node_modules/rxjs/_esm2015/internal/OuterSubscriber.js");
    /* harmony import */


    var _util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../util/subscribeToResult */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js");

    function withLatestFrom(...args) {
      return source => {
        let project;

        if (typeof args[args.length - 1] === 'function') {
          project = args.pop();
        }

        const observables = args;
        return source.lift(new WithLatestFromOperator(observables, project));
      };
    }

    class WithLatestFromOperator {
      constructor(observables, project) {
        this.observables = observables;
        this.project = project;
      }

      call(subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
      }

    }

    class WithLatestFromSubscriber extends _OuterSubscriber__WEBPACK_IMPORTED_MODULE_0__["OuterSubscriber"] {
      constructor(destination, observables, project) {
        super(destination);
        this.observables = observables;
        this.project = project;
        this.toRespond = [];
        const len = observables.length;
        this.values = new Array(len);

        for (let i = 0; i < len; i++) {
          this.toRespond.push(i);
        }

        for (let i = 0; i < len; i++) {
          let observable = observables[i];
          this.add(Object(_util_subscribeToResult__WEBPACK_IMPORTED_MODULE_1__["subscribeToResult"])(this, observable, observable, i));
        }
      }

      notifyNext(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        const toRespond = this.toRespond;

        if (toRespond.length > 0) {
          const found = toRespond.indexOf(outerIndex);

          if (found !== -1) {
            toRespond.splice(found, 1);
          }
        }
      }

      notifyComplete() {}

      _next(value) {
        if (this.toRespond.length === 0) {
          const args = [value, ...this.values];

          if (this.project) {
            this._tryProject(args);
          } else {
            this.destination.next(args);
          }
        }
      }

      _tryProject(args) {
        let result;

        try {
          result = this.project.apply(this, args);
        } catch (err) {
          this.destination.error(err);
          return;
        }

        this.destination.next(result);
      }

    } //# sourceMappingURL=withLatestFrom.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/zip.js":
  /*!**************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/zip.js ***!
    \**************************************************************/

  /*! exports provided: zip */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsZipJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "zip", function () {
      return zip;
    });
    /* harmony import */


    var _observable_zip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../observable/zip */
    "./node_modules/rxjs/_esm2015/internal/observable/zip.js");

    function zip(...observables) {
      return function zipOperatorFunction(source) {
        return source.lift.call(Object(_observable_zip__WEBPACK_IMPORTED_MODULE_0__["zip"])(source, ...observables));
      };
    } //# sourceMappingURL=zip.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/operators/zipAll.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/operators/zipAll.js ***!
    \*****************************************************************/

  /*! exports provided: zipAll */

  /***/
  function node_modulesRxjs_esm2015InternalOperatorsZipAllJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "zipAll", function () {
      return zipAll;
    });
    /* harmony import */


    var _observable_zip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../observable/zip */
    "./node_modules/rxjs/_esm2015/internal/observable/zip.js");

    function zipAll(project) {
      return source => source.lift(new _observable_zip__WEBPACK_IMPORTED_MODULE_0__["ZipOperator"](project));
    } //# sourceMappingURL=zipAll.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/scheduler/Action.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/scheduler/Action.js ***!
    \*****************************************************************/

  /*! exports provided: Action */

  /***/
  function node_modulesRxjs_esm2015InternalSchedulerActionJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Action", function () {
      return Action;
    });
    /* harmony import */


    var _Subscription__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscription */
    "./node_modules/rxjs/_esm2015/internal/Subscription.js");

    class Action extends _Subscription__WEBPACK_IMPORTED_MODULE_0__["Subscription"] {
      constructor(scheduler, work) {
        super();
      }

      schedule(state, delay = 0) {
        return this;
      }

    } //# sourceMappingURL=Action.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/scheduler/AnimationFrameAction.js":
  /*!*******************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/scheduler/AnimationFrameAction.js ***!
    \*******************************************************************************/

  /*! exports provided: AnimationFrameAction */

  /***/
  function node_modulesRxjs_esm2015InternalSchedulerAnimationFrameActionJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AnimationFrameAction", function () {
      return AnimationFrameAction;
    });
    /* harmony import */


    var _AsyncAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./AsyncAction */
    "./node_modules/rxjs/_esm2015/internal/scheduler/AsyncAction.js");

    class AnimationFrameAction extends _AsyncAction__WEBPACK_IMPORTED_MODULE_0__["AsyncAction"] {
      constructor(scheduler, work) {
        super(scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
      }

      requestAsyncId(scheduler, id, delay = 0) {
        if (delay !== null && delay > 0) {
          return super.requestAsyncId(scheduler, id, delay);
        }

        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(() => scheduler.flush(null)));
      }

      recycleAsyncId(scheduler, id, delay = 0) {
        if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
          return super.recycleAsyncId(scheduler, id, delay);
        }

        if (scheduler.actions.length === 0) {
          cancelAnimationFrame(id);
          scheduler.scheduled = undefined;
        }

        return undefined;
      }

    } //# sourceMappingURL=AnimationFrameAction.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/scheduler/AnimationFrameScheduler.js":
  /*!**********************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/scheduler/AnimationFrameScheduler.js ***!
    \**********************************************************************************/

  /*! exports provided: AnimationFrameScheduler */

  /***/
  function node_modulesRxjs_esm2015InternalSchedulerAnimationFrameSchedulerJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AnimationFrameScheduler", function () {
      return AnimationFrameScheduler;
    });
    /* harmony import */


    var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./AsyncScheduler */
    "./node_modules/rxjs/_esm2015/internal/scheduler/AsyncScheduler.js");

    class AnimationFrameScheduler extends _AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__["AsyncScheduler"] {
      flush(action) {
        this.active = true;
        this.scheduled = undefined;
        const {
          actions
        } = this;
        let error;
        let index = -1;
        let count = actions.length;
        action = action || actions.shift();

        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (++index < count && (action = actions.shift()));

        this.active = false;

        if (error) {
          while (++index < count && (action = actions.shift())) {
            action.unsubscribe();
          }

          throw error;
        }
      }

    } //# sourceMappingURL=AnimationFrameScheduler.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/scheduler/AsapAction.js":
  /*!*********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/scheduler/AsapAction.js ***!
    \*********************************************************************/

  /*! exports provided: AsapAction */

  /***/
  function node_modulesRxjs_esm2015InternalSchedulerAsapActionJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AsapAction", function () {
      return AsapAction;
    });
    /* harmony import */


    var _util_Immediate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../util/Immediate */
    "./node_modules/rxjs/_esm2015/internal/util/Immediate.js");
    /* harmony import */


    var _AsyncAction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./AsyncAction */
    "./node_modules/rxjs/_esm2015/internal/scheduler/AsyncAction.js");

    class AsapAction extends _AsyncAction__WEBPACK_IMPORTED_MODULE_1__["AsyncAction"] {
      constructor(scheduler, work) {
        super(scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
      }

      requestAsyncId(scheduler, id, delay = 0) {
        if (delay !== null && delay > 0) {
          return super.requestAsyncId(scheduler, id, delay);
        }

        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = _util_Immediate__WEBPACK_IMPORTED_MODULE_0__["Immediate"].setImmediate(scheduler.flush.bind(scheduler, null)));
      }

      recycleAsyncId(scheduler, id, delay = 0) {
        if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
          return super.recycleAsyncId(scheduler, id, delay);
        }

        if (scheduler.actions.length === 0) {
          _util_Immediate__WEBPACK_IMPORTED_MODULE_0__["Immediate"].clearImmediate(id);

          scheduler.scheduled = undefined;
        }

        return undefined;
      }

    } //# sourceMappingURL=AsapAction.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/scheduler/AsapScheduler.js":
  /*!************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/scheduler/AsapScheduler.js ***!
    \************************************************************************/

  /*! exports provided: AsapScheduler */

  /***/
  function node_modulesRxjs_esm2015InternalSchedulerAsapSchedulerJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AsapScheduler", function () {
      return AsapScheduler;
    });
    /* harmony import */


    var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./AsyncScheduler */
    "./node_modules/rxjs/_esm2015/internal/scheduler/AsyncScheduler.js");

    class AsapScheduler extends _AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__["AsyncScheduler"] {
      flush(action) {
        this.active = true;
        this.scheduled = undefined;
        const {
          actions
        } = this;
        let error;
        let index = -1;
        let count = actions.length;
        action = action || actions.shift();

        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (++index < count && (action = actions.shift()));

        this.active = false;

        if (error) {
          while (++index < count && (action = actions.shift())) {
            action.unsubscribe();
          }

          throw error;
        }
      }

    } //# sourceMappingURL=AsapScheduler.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/scheduler/AsyncAction.js":
  /*!**********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/scheduler/AsyncAction.js ***!
    \**********************************************************************/

  /*! exports provided: AsyncAction */

  /***/
  function node_modulesRxjs_esm2015InternalSchedulerAsyncActionJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AsyncAction", function () {
      return AsyncAction;
    });
    /* harmony import */


    var _Action__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./Action */
    "./node_modules/rxjs/_esm2015/internal/scheduler/Action.js");

    class AsyncAction extends _Action__WEBPACK_IMPORTED_MODULE_0__["Action"] {
      constructor(scheduler, work) {
        super(scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
        this.pending = false;
      }

      schedule(state, delay = 0) {
        if (this.closed) {
          return this;
        }

        this.state = state;
        const id = this.id;
        const scheduler = this.scheduler;

        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, delay);
        }

        this.pending = true;
        this.delay = delay;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
      }

      requestAsyncId(scheduler, id, delay = 0) {
        return setInterval(scheduler.flush.bind(scheduler, this), delay);
      }

      recycleAsyncId(scheduler, id, delay = 0) {
        if (delay !== null && this.delay === delay && this.pending === false) {
          return id;
        }

        clearInterval(id);
        return undefined;
      }

      execute(state, delay) {
        if (this.closed) {
          return new Error('executing a cancelled action');
        }

        this.pending = false;

        const error = this._execute(state, delay);

        if (error) {
          return error;
        } else if (this.pending === false && this.id != null) {
          this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
      }

      _execute(state, delay) {
        let errored = false;
        let errorValue = undefined;

        try {
          this.work(state);
        } catch (e) {
          errored = true;
          errorValue = !!e && e || new Error(e);
        }

        if (errored) {
          this.unsubscribe();
          return errorValue;
        }
      }

      _unsubscribe() {
        const id = this.id;
        const scheduler = this.scheduler;
        const actions = scheduler.actions;
        const index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;

        if (index !== -1) {
          actions.splice(index, 1);
        }

        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, null);
        }

        this.delay = null;
      }

    } //# sourceMappingURL=AsyncAction.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/scheduler/AsyncScheduler.js":
  /*!*************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/scheduler/AsyncScheduler.js ***!
    \*************************************************************************/

  /*! exports provided: AsyncScheduler */

  /***/
  function node_modulesRxjs_esm2015InternalSchedulerAsyncSchedulerJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "AsyncScheduler", function () {
      return AsyncScheduler;
    });
    /* harmony import */


    var _Scheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Scheduler */
    "./node_modules/rxjs/_esm2015/internal/Scheduler.js");

    class AsyncScheduler extends _Scheduler__WEBPACK_IMPORTED_MODULE_0__["Scheduler"] {
      constructor(SchedulerAction, now = _Scheduler__WEBPACK_IMPORTED_MODULE_0__["Scheduler"].now) {
        super(SchedulerAction, () => {
          if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
            return AsyncScheduler.delegate.now();
          } else {
            return now();
          }
        });
        this.actions = [];
        this.active = false;
        this.scheduled = undefined;
      }

      schedule(work, delay = 0, state) {
        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
          return AsyncScheduler.delegate.schedule(work, delay, state);
        } else {
          return super.schedule(work, delay, state);
        }
      }

      flush(action) {
        const {
          actions
        } = this;

        if (this.active) {
          actions.push(action);
          return;
        }

        let error;
        this.active = true;

        do {
          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        } while (action = actions.shift());

        this.active = false;

        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }

          throw error;
        }
      }

    } //# sourceMappingURL=AsyncScheduler.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/scheduler/QueueAction.js":
  /*!**********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/scheduler/QueueAction.js ***!
    \**********************************************************************/

  /*! exports provided: QueueAction */

  /***/
  function node_modulesRxjs_esm2015InternalSchedulerQueueActionJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "QueueAction", function () {
      return QueueAction;
    });
    /* harmony import */


    var _AsyncAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./AsyncAction */
    "./node_modules/rxjs/_esm2015/internal/scheduler/AsyncAction.js");

    class QueueAction extends _AsyncAction__WEBPACK_IMPORTED_MODULE_0__["AsyncAction"] {
      constructor(scheduler, work) {
        super(scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
      }

      schedule(state, delay = 0) {
        if (delay > 0) {
          return super.schedule(state, delay);
        }

        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
      }

      execute(state, delay) {
        return delay > 0 || this.closed ? super.execute(state, delay) : this._execute(state, delay);
      }

      requestAsyncId(scheduler, id, delay = 0) {
        if (delay !== null && delay > 0 || delay === null && this.delay > 0) {
          return super.requestAsyncId(scheduler, id, delay);
        }

        return scheduler.flush(this);
      }

    } //# sourceMappingURL=QueueAction.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/scheduler/QueueScheduler.js":
  /*!*************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/scheduler/QueueScheduler.js ***!
    \*************************************************************************/

  /*! exports provided: QueueScheduler */

  /***/
  function node_modulesRxjs_esm2015InternalSchedulerQueueSchedulerJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "QueueScheduler", function () {
      return QueueScheduler;
    });
    /* harmony import */


    var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./AsyncScheduler */
    "./node_modules/rxjs/_esm2015/internal/scheduler/AsyncScheduler.js");

    class QueueScheduler extends _AsyncScheduler__WEBPACK_IMPORTED_MODULE_0__["AsyncScheduler"] {} //# sourceMappingURL=QueueScheduler.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/scheduler/VirtualTimeScheduler.js":
  /*!*******************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/scheduler/VirtualTimeScheduler.js ***!
    \*******************************************************************************/

  /*! exports provided: VirtualTimeScheduler, VirtualAction */

  /***/
  function node_modulesRxjs_esm2015InternalSchedulerVirtualTimeSchedulerJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "VirtualTimeScheduler", function () {
      return VirtualTimeScheduler;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "VirtualAction", function () {
      return VirtualAction;
    });
    /* harmony import */


    var _AsyncAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./AsyncAction */
    "./node_modules/rxjs/_esm2015/internal/scheduler/AsyncAction.js");
    /* harmony import */


    var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./AsyncScheduler */
    "./node_modules/rxjs/_esm2015/internal/scheduler/AsyncScheduler.js");

    class VirtualTimeScheduler extends _AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__["AsyncScheduler"] {
      constructor(SchedulerAction = VirtualAction, maxFrames = Number.POSITIVE_INFINITY) {
        super(SchedulerAction, () => this.frame);
        this.maxFrames = maxFrames;
        this.frame = 0;
        this.index = -1;
      }

      flush() {
        const {
          actions,
          maxFrames
        } = this;
        let error, action;

        while ((action = actions[0]) && action.delay <= maxFrames) {
          actions.shift();
          this.frame = action.delay;

          if (error = action.execute(action.state, action.delay)) {
            break;
          }
        }

        if (error) {
          while (action = actions.shift()) {
            action.unsubscribe();
          }

          throw error;
        }
      }

    }

    VirtualTimeScheduler.frameTimeFactor = 10;

    class VirtualAction extends _AsyncAction__WEBPACK_IMPORTED_MODULE_0__["AsyncAction"] {
      constructor(scheduler, work, index = scheduler.index += 1) {
        super(scheduler, work);
        this.scheduler = scheduler;
        this.work = work;
        this.index = index;
        this.active = true;
        this.index = scheduler.index = index;
      }

      schedule(state, delay = 0) {
        if (!this.id) {
          return super.schedule(state, delay);
        }

        this.active = false;
        const action = new VirtualAction(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay);
      }

      requestAsyncId(scheduler, id, delay = 0) {
        this.delay = scheduler.frame + delay;
        const {
          actions
        } = scheduler;
        actions.push(this);
        actions.sort(VirtualAction.sortActions);
        return true;
      }

      recycleAsyncId(scheduler, id, delay = 0) {
        return undefined;
      }

      _execute(state, delay) {
        if (this.active === true) {
          return super._execute(state, delay);
        }
      }

      static sortActions(a, b) {
        if (a.delay === b.delay) {
          if (a.index === b.index) {
            return 0;
          } else if (a.index > b.index) {
            return 1;
          } else {
            return -1;
          }
        } else if (a.delay > b.delay) {
          return 1;
        } else {
          return -1;
        }
      }

    } //# sourceMappingURL=VirtualTimeScheduler.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/scheduler/animationFrame.js":
  /*!*************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/scheduler/animationFrame.js ***!
    \*************************************************************************/

  /*! exports provided: animationFrame */

  /***/
  function node_modulesRxjs_esm2015InternalSchedulerAnimationFrameJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "animationFrame", function () {
      return animationFrame;
    });
    /* harmony import */


    var _AnimationFrameAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./AnimationFrameAction */
    "./node_modules/rxjs/_esm2015/internal/scheduler/AnimationFrameAction.js");
    /* harmony import */


    var _AnimationFrameScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./AnimationFrameScheduler */
    "./node_modules/rxjs/_esm2015/internal/scheduler/AnimationFrameScheduler.js");

    const animationFrame = new _AnimationFrameScheduler__WEBPACK_IMPORTED_MODULE_1__["AnimationFrameScheduler"](_AnimationFrameAction__WEBPACK_IMPORTED_MODULE_0__["AnimationFrameAction"]); //# sourceMappingURL=animationFrame.js.map

    /***/
  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/scheduler/asap.js":
  /*!***************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/scheduler/asap.js ***!
    \***************************************************************/

  /*! exports provided: asap */

  /***/
  function node_modulesRxjs_esm2015InternalSchedulerAsapJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "asap", function () {
      return asap;
    });
    /* harmony import */


    var _AsapAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./AsapAction */
    "./node_modules/rxjs/_esm2015/internal/scheduler/AsapAction.js");
    /* harmony import */


    var _AsapScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./AsapScheduler */
    "./node_modules/rxjs/_esm2015/internal/scheduler/AsapScheduler.js");

    const asap = new _AsapScheduler__WEBPACK_IMPORTED_MODULE_1__["AsapScheduler"](_AsapAction__WEBPACK_IMPORTED_MODULE_0__["AsapAction"]); //# sourceMappingURL=asap.js.map

    /***/
  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/scheduler/async.js":
  /*!****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/scheduler/async.js ***!
    \****************************************************************/

  /*! exports provided: async */

  /***/
  function node_modulesRxjs_esm2015InternalSchedulerAsyncJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "async", function () {
      return async;
    });
    /* harmony import */


    var _AsyncAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./AsyncAction */
    "./node_modules/rxjs/_esm2015/internal/scheduler/AsyncAction.js");
    /* harmony import */


    var _AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./AsyncScheduler */
    "./node_modules/rxjs/_esm2015/internal/scheduler/AsyncScheduler.js");

    const async = new _AsyncScheduler__WEBPACK_IMPORTED_MODULE_1__["AsyncScheduler"](_AsyncAction__WEBPACK_IMPORTED_MODULE_0__["AsyncAction"]); //# sourceMappingURL=async.js.map

    /***/
  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/scheduler/queue.js":
  /*!****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/scheduler/queue.js ***!
    \****************************************************************/

  /*! exports provided: queue */

  /***/
  function node_modulesRxjs_esm2015InternalSchedulerQueueJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "queue", function () {
      return queue;
    });
    /* harmony import */


    var _QueueAction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./QueueAction */
    "./node_modules/rxjs/_esm2015/internal/scheduler/QueueAction.js");
    /* harmony import */


    var _QueueScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./QueueScheduler */
    "./node_modules/rxjs/_esm2015/internal/scheduler/QueueScheduler.js");

    const queue = new _QueueScheduler__WEBPACK_IMPORTED_MODULE_1__["QueueScheduler"](_QueueAction__WEBPACK_IMPORTED_MODULE_0__["QueueAction"]); //# sourceMappingURL=queue.js.map

    /***/
  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/symbol/iterator.js":
  /*!****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/symbol/iterator.js ***!
    \****************************************************************/

  /*! exports provided: getSymbolIterator, iterator, $$iterator */

  /***/
  function node_modulesRxjs_esm2015InternalSymbolIteratorJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "getSymbolIterator", function () {
      return getSymbolIterator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "iterator", function () {
      return iterator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "$$iterator", function () {
      return $$iterator;
    });

    function getSymbolIterator() {
      if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
      }

      return Symbol.iterator;
    }

    const iterator = getSymbolIterator();
    const $$iterator = iterator; //# sourceMappingURL=iterator.js.map

    /***/
  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/symbol/observable.js":
  /*!******************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/symbol/observable.js ***!
    \******************************************************************/

  /*! exports provided: observable */

  /***/
  function node_modulesRxjs_esm2015InternalSymbolObservableJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "observable", function () {
      return observable;
    });

    const observable = typeof Symbol === 'function' && Symbol.observable || '@@observable'; //# sourceMappingURL=observable.js.map

    /***/
  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/symbol/rxSubscriber.js":
  /*!********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/symbol/rxSubscriber.js ***!
    \********************************************************************/

  /*! exports provided: rxSubscriber, $$rxSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalSymbolRxSubscriberJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "rxSubscriber", function () {
      return rxSubscriber;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "$$rxSubscriber", function () {
      return $$rxSubscriber;
    });

    const rxSubscriber = typeof Symbol === 'function' ? Symbol('rxSubscriber') : '@@rxSubscriber_' + Math.random();
    const $$rxSubscriber = rxSubscriber; //# sourceMappingURL=rxSubscriber.js.map

    /***/
  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/ArgumentOutOfRangeError.js":
  /*!*****************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/ArgumentOutOfRangeError.js ***!
    \*****************************************************************************/

  /*! exports provided: ArgumentOutOfRangeError */

  /***/
  function node_modulesRxjs_esm2015InternalUtilArgumentOutOfRangeErrorJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ArgumentOutOfRangeError", function () {
      return ArgumentOutOfRangeError;
    });

    function ArgumentOutOfRangeErrorImpl() {
      Error.call(this);
      this.message = 'argument out of range';
      this.name = 'ArgumentOutOfRangeError';
      return this;
    }

    ArgumentOutOfRangeErrorImpl.prototype = Object.create(Error.prototype);
    const ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl; //# sourceMappingURL=ArgumentOutOfRangeError.js.map

    /***/
  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/EmptyError.js":
  /*!****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/EmptyError.js ***!
    \****************************************************************/

  /*! exports provided: EmptyError */

  /***/
  function node_modulesRxjs_esm2015InternalUtilEmptyErrorJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "EmptyError", function () {
      return EmptyError;
    });

    function EmptyErrorImpl() {
      Error.call(this);
      this.message = 'no elements in sequence';
      this.name = 'EmptyError';
      return this;
    }

    EmptyErrorImpl.prototype = Object.create(Error.prototype);
    const EmptyError = EmptyErrorImpl; //# sourceMappingURL=EmptyError.js.map

    /***/
  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/Immediate.js":
  /*!***************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/Immediate.js ***!
    \***************************************************************/

  /*! exports provided: Immediate */

  /***/
  function node_modulesRxjs_esm2015InternalUtilImmediateJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "Immediate", function () {
      return Immediate;
    });

    let nextHandle = 1;
    const tasksByHandle = {};

    function runIfPresent(handle) {
      const cb = tasksByHandle[handle];

      if (cb) {
        cb();
      }
    }

    const Immediate = {
      setImmediate(cb) {
        const handle = nextHandle++;
        tasksByHandle[handle] = cb;
        Promise.resolve().then(() => runIfPresent(handle));
        return handle;
      },

      clearImmediate(handle) {
        delete tasksByHandle[handle];
      }

    }; //# sourceMappingURL=Immediate.js.map

    /***/
  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/ObjectUnsubscribedError.js":
  /*!*****************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/ObjectUnsubscribedError.js ***!
    \*****************************************************************************/

  /*! exports provided: ObjectUnsubscribedError */

  /***/
  function node_modulesRxjs_esm2015InternalUtilObjectUnsubscribedErrorJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "ObjectUnsubscribedError", function () {
      return ObjectUnsubscribedError;
    });

    function ObjectUnsubscribedErrorImpl() {
      Error.call(this);
      this.message = 'object unsubscribed';
      this.name = 'ObjectUnsubscribedError';
      return this;
    }

    ObjectUnsubscribedErrorImpl.prototype = Object.create(Error.prototype);
    const ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl; //# sourceMappingURL=ObjectUnsubscribedError.js.map

    /***/
  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/TimeoutError.js":
  /*!******************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/TimeoutError.js ***!
    \******************************************************************/

  /*! exports provided: TimeoutError */

  /***/
  function node_modulesRxjs_esm2015InternalUtilTimeoutErrorJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "TimeoutError", function () {
      return TimeoutError;
    });

    function TimeoutErrorImpl() {
      Error.call(this);
      this.message = 'Timeout has occurred';
      this.name = 'TimeoutError';
      return this;
    }

    TimeoutErrorImpl.prototype = Object.create(Error.prototype);
    const TimeoutError = TimeoutErrorImpl; //# sourceMappingURL=TimeoutError.js.map

    /***/
  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/UnsubscriptionError.js":
  /*!*************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/UnsubscriptionError.js ***!
    \*************************************************************************/

  /*! exports provided: UnsubscriptionError */

  /***/
  function node_modulesRxjs_esm2015InternalUtilUnsubscriptionErrorJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "UnsubscriptionError", function () {
      return UnsubscriptionError;
    });

    function UnsubscriptionErrorImpl(errors) {
      Error.call(this);
      this.message = errors ? "".concat(errors.length, " errors occurred during unsubscription:\n").concat(errors.map((err, i) => "".concat(i + 1, ") ").concat(err.toString())).join('\n  ')) : '';
      this.name = 'UnsubscriptionError';
      this.errors = errors;
      return this;
    }

    UnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);
    const UnsubscriptionError = UnsubscriptionErrorImpl; //# sourceMappingURL=UnsubscriptionError.js.map

    /***/
  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/canReportError.js":
  /*!********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/canReportError.js ***!
    \********************************************************************/

  /*! exports provided: canReportError */

  /***/
  function node_modulesRxjs_esm2015InternalUtilCanReportErrorJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "canReportError", function () {
      return canReportError;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");

    function canReportError(observer) {
      while (observer) {
        const {
          closed,
          destination,
          isStopped
        } = observer;

        if (closed || isStopped) {
          return false;
        } else if (destination && destination instanceof _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]) {
          observer = destination;
        } else {
          observer = null;
        }
      }

      return true;
    } //# sourceMappingURL=canReportError.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/hostReportError.js":
  /*!*********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/hostReportError.js ***!
    \*********************************************************************/

  /*! exports provided: hostReportError */

  /***/
  function node_modulesRxjs_esm2015InternalUtilHostReportErrorJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "hostReportError", function () {
      return hostReportError;
    });

    function hostReportError(err) {
      setTimeout(() => {
        throw err;
      });
    } //# sourceMappingURL=hostReportError.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/identity.js":
  /*!**************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/identity.js ***!
    \**************************************************************/

  /*! exports provided: identity */

  /***/
  function node_modulesRxjs_esm2015InternalUtilIdentityJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "identity", function () {
      return identity;
    });

    function identity(x) {
      return x;
    } //# sourceMappingURL=identity.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/isArray.js":
  /*!*************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/isArray.js ***!
    \*************************************************************/

  /*! exports provided: isArray */

  /***/
  function node_modulesRxjs_esm2015InternalUtilIsArrayJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isArray", function () {
      return isArray;
    });

    const isArray = Array.isArray || (x => x && typeof x.length === 'number'); //# sourceMappingURL=isArray.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/isArrayLike.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/isArrayLike.js ***!
    \*****************************************************************/

  /*! exports provided: isArrayLike */

  /***/
  function node_modulesRxjs_esm2015InternalUtilIsArrayLikeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isArrayLike", function () {
      return isArrayLike;
    });

    const isArrayLike = x => x && typeof x.length === 'number' && typeof x !== 'function'; //# sourceMappingURL=isArrayLike.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/isDate.js":
  /*!************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/isDate.js ***!
    \************************************************************/

  /*! exports provided: isDate */

  /***/
  function node_modulesRxjs_esm2015InternalUtilIsDateJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isDate", function () {
      return isDate;
    });

    function isDate(value) {
      return value instanceof Date && !isNaN(+value);
    } //# sourceMappingURL=isDate.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/isFunction.js":
  /*!****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/isFunction.js ***!
    \****************************************************************/

  /*! exports provided: isFunction */

  /***/
  function node_modulesRxjs_esm2015InternalUtilIsFunctionJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isFunction", function () {
      return isFunction;
    });

    function isFunction(x) {
      return typeof x === 'function';
    } //# sourceMappingURL=isFunction.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/isInteropObservable.js":
  /*!*************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/isInteropObservable.js ***!
    \*************************************************************************/

  /*! exports provided: isInteropObservable */

  /***/
  function node_modulesRxjs_esm2015InternalUtilIsInteropObservableJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isInteropObservable", function () {
      return isInteropObservable;
    });
    /* harmony import */


    var _symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../symbol/observable */
    "./node_modules/rxjs/_esm2015/internal/symbol/observable.js");

    function isInteropObservable(input) {
      return input && typeof input[_symbol_observable__WEBPACK_IMPORTED_MODULE_0__["observable"]] === 'function';
    } //# sourceMappingURL=isInteropObservable.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/isIterable.js":
  /*!****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/isIterable.js ***!
    \****************************************************************/

  /*! exports provided: isIterable */

  /***/
  function node_modulesRxjs_esm2015InternalUtilIsIterableJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isIterable", function () {
      return isIterable;
    });
    /* harmony import */


    var _symbol_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../symbol/iterator */
    "./node_modules/rxjs/_esm2015/internal/symbol/iterator.js");

    function isIterable(input) {
      return input && typeof input[_symbol_iterator__WEBPACK_IMPORTED_MODULE_0__["iterator"]] === 'function';
    } //# sourceMappingURL=isIterable.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/isNumeric.js":
  /*!***************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/isNumeric.js ***!
    \***************************************************************/

  /*! exports provided: isNumeric */

  /***/
  function node_modulesRxjs_esm2015InternalUtilIsNumericJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isNumeric", function () {
      return isNumeric;
    });
    /* harmony import */


    var _isArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./isArray */
    "./node_modules/rxjs/_esm2015/internal/util/isArray.js");

    function isNumeric(val) {
      return !Object(_isArray__WEBPACK_IMPORTED_MODULE_0__["isArray"])(val) && val - parseFloat(val) + 1 >= 0;
    } //# sourceMappingURL=isNumeric.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/isObject.js":
  /*!**************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/isObject.js ***!
    \**************************************************************/

  /*! exports provided: isObject */

  /***/
  function node_modulesRxjs_esm2015InternalUtilIsObjectJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isObject", function () {
      return isObject;
    });

    function isObject(x) {
      return x !== null && typeof x === 'object';
    } //# sourceMappingURL=isObject.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/isObservable.js":
  /*!******************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/isObservable.js ***!
    \******************************************************************/

  /*! exports provided: isObservable */

  /***/
  function node_modulesRxjs_esm2015InternalUtilIsObservableJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isObservable", function () {
      return isObservable;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");

    function isObservable(obj) {
      return !!obj && (obj instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"] || typeof obj.lift === 'function' && typeof obj.subscribe === 'function');
    } //# sourceMappingURL=isObservable.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/isPromise.js":
  /*!***************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/isPromise.js ***!
    \***************************************************************/

  /*! exports provided: isPromise */

  /***/
  function node_modulesRxjs_esm2015InternalUtilIsPromiseJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isPromise", function () {
      return isPromise;
    });

    function isPromise(value) {
      return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
    } //# sourceMappingURL=isPromise.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/isScheduler.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/isScheduler.js ***!
    \*****************************************************************/

  /*! exports provided: isScheduler */

  /***/
  function node_modulesRxjs_esm2015InternalUtilIsSchedulerJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "isScheduler", function () {
      return isScheduler;
    });

    function isScheduler(value) {
      return value && typeof value.schedule === 'function';
    } //# sourceMappingURL=isScheduler.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/noop.js":
  /*!**********************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/noop.js ***!
    \**********************************************************/

  /*! exports provided: noop */

  /***/
  function node_modulesRxjs_esm2015InternalUtilNoopJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "noop", function () {
      return noop;
    });

    function noop() {} //# sourceMappingURL=noop.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/not.js":
  /*!*********************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/not.js ***!
    \*********************************************************/

  /*! exports provided: not */

  /***/
  function node_modulesRxjs_esm2015InternalUtilNotJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "not", function () {
      return not;
    });

    function not(pred, thisArg) {
      function notPred() {
        return !notPred.pred.apply(notPred.thisArg, arguments);
      }

      notPred.pred = pred;
      notPred.thisArg = thisArg;
      return notPred;
    } //# sourceMappingURL=not.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/pipe.js":
  /*!**********************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/pipe.js ***!
    \**********************************************************/

  /*! exports provided: pipe, pipeFromArray */

  /***/
  function node_modulesRxjs_esm2015InternalUtilPipeJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "pipe", function () {
      return pipe;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "pipeFromArray", function () {
      return pipeFromArray;
    });
    /* harmony import */


    var _noop__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./noop */
    "./node_modules/rxjs/_esm2015/internal/util/noop.js");

    function pipe(...fns) {
      return pipeFromArray(fns);
    }

    function pipeFromArray(fns) {
      if (!fns) {
        return _noop__WEBPACK_IMPORTED_MODULE_0__["noop"];
      }

      if (fns.length === 1) {
        return fns[0];
      }

      return function piped(input) {
        return fns.reduce((prev, fn) => fn(prev), input);
      };
    } //# sourceMappingURL=pipe.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/subscribeTo.js":
  /*!*****************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/subscribeTo.js ***!
    \*****************************************************************/

  /*! exports provided: subscribeTo */

  /***/
  function node_modulesRxjs_esm2015InternalUtilSubscribeToJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "subscribeTo", function () {
      return subscribeTo;
    });
    /* harmony import */


    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Observable */
    "./node_modules/rxjs/_esm2015/internal/Observable.js");
    /* harmony import */


    var _subscribeToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./subscribeToArray */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToArray.js");
    /* harmony import */


    var _subscribeToPromise__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ./subscribeToPromise */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToPromise.js");
    /* harmony import */


    var _subscribeToIterable__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ./subscribeToIterable */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToIterable.js");
    /* harmony import */


    var _subscribeToObservable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ./subscribeToObservable */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeToObservable.js");
    /* harmony import */


    var _isArrayLike__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! ./isArrayLike */
    "./node_modules/rxjs/_esm2015/internal/util/isArrayLike.js");
    /* harmony import */


    var _isPromise__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! ./isPromise */
    "./node_modules/rxjs/_esm2015/internal/util/isPromise.js");
    /* harmony import */


    var _isObject__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
    /*! ./isObject */
    "./node_modules/rxjs/_esm2015/internal/util/isObject.js");
    /* harmony import */


    var _symbol_iterator__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
    /*! ../symbol/iterator */
    "./node_modules/rxjs/_esm2015/internal/symbol/iterator.js");
    /* harmony import */


    var _symbol_observable__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
    /*! ../symbol/observable */
    "./node_modules/rxjs/_esm2015/internal/symbol/observable.js");

    const subscribeTo = result => {
      if (result instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__["Observable"]) {
        return subscriber => {
          if (result._isScalar) {
            subscriber.next(result.value);
            subscriber.complete();
            return undefined;
          } else {
            return result.subscribe(subscriber);
          }
        };
      } else if (!!result && typeof result[_symbol_observable__WEBPACK_IMPORTED_MODULE_9__["observable"]] === 'function') {
        return Object(_subscribeToObservable__WEBPACK_IMPORTED_MODULE_4__["subscribeToObservable"])(result);
      } else if (Object(_isArrayLike__WEBPACK_IMPORTED_MODULE_5__["isArrayLike"])(result)) {
        return Object(_subscribeToArray__WEBPACK_IMPORTED_MODULE_1__["subscribeToArray"])(result);
      } else if (Object(_isPromise__WEBPACK_IMPORTED_MODULE_6__["isPromise"])(result)) {
        return Object(_subscribeToPromise__WEBPACK_IMPORTED_MODULE_2__["subscribeToPromise"])(result);
      } else if (!!result && typeof result[_symbol_iterator__WEBPACK_IMPORTED_MODULE_8__["iterator"]] === 'function') {
        return Object(_subscribeToIterable__WEBPACK_IMPORTED_MODULE_3__["subscribeToIterable"])(result);
      } else {
        const value = Object(_isObject__WEBPACK_IMPORTED_MODULE_7__["isObject"])(result) ? 'an invalid object' : "'".concat(result, "'");
        const msg = "You provided ".concat(value, " where a stream was expected.") + ' You can provide an Observable, Promise, Array, or Iterable.';
        throw new TypeError(msg);
      }
    }; //# sourceMappingURL=subscribeTo.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/subscribeToArray.js":
  /*!**********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/subscribeToArray.js ***!
    \**********************************************************************/

  /*! exports provided: subscribeToArray */

  /***/
  function node_modulesRxjs_esm2015InternalUtilSubscribeToArrayJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "subscribeToArray", function () {
      return subscribeToArray;
    });

    const subscribeToArray = array => subscriber => {
      for (let i = 0, len = array.length; i < len && !subscriber.closed; i++) {
        subscriber.next(array[i]);
      }

      if (!subscriber.closed) {
        subscriber.complete();
      }
    }; //# sourceMappingURL=subscribeToArray.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/subscribeToIterable.js":
  /*!*************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/subscribeToIterable.js ***!
    \*************************************************************************/

  /*! exports provided: subscribeToIterable */

  /***/
  function node_modulesRxjs_esm2015InternalUtilSubscribeToIterableJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "subscribeToIterable", function () {
      return subscribeToIterable;
    });
    /* harmony import */


    var _symbol_iterator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../symbol/iterator */
    "./node_modules/rxjs/_esm2015/internal/symbol/iterator.js");

    const subscribeToIterable = iterable => subscriber => {
      const iterator = iterable[_symbol_iterator__WEBPACK_IMPORTED_MODULE_0__["iterator"]]();

      do {
        const item = iterator.next();

        if (item.done) {
          subscriber.complete();
          break;
        }

        subscriber.next(item.value);

        if (subscriber.closed) {
          break;
        }
      } while (true);

      if (typeof iterator.return === 'function') {
        subscriber.add(() => {
          if (iterator.return) {
            iterator.return();
          }
        });
      }

      return subscriber;
    }; //# sourceMappingURL=subscribeToIterable.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/subscribeToObservable.js":
  /*!***************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/subscribeToObservable.js ***!
    \***************************************************************************/

  /*! exports provided: subscribeToObservable */

  /***/
  function node_modulesRxjs_esm2015InternalUtilSubscribeToObservableJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "subscribeToObservable", function () {
      return subscribeToObservable;
    });
    /* harmony import */


    var _symbol_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../symbol/observable */
    "./node_modules/rxjs/_esm2015/internal/symbol/observable.js");

    const subscribeToObservable = obj => subscriber => {
      const obs = obj[_symbol_observable__WEBPACK_IMPORTED_MODULE_0__["observable"]]();

      if (typeof obs.subscribe !== 'function') {
        throw new TypeError('Provided object does not correctly implement Symbol.observable');
      } else {
        return obs.subscribe(subscriber);
      }
    }; //# sourceMappingURL=subscribeToObservable.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/subscribeToPromise.js":
  /*!************************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/subscribeToPromise.js ***!
    \************************************************************************/

  /*! exports provided: subscribeToPromise */

  /***/
  function node_modulesRxjs_esm2015InternalUtilSubscribeToPromiseJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "subscribeToPromise", function () {
      return subscribeToPromise;
    });
    /* harmony import */


    var _hostReportError__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ./hostReportError */
    "./node_modules/rxjs/_esm2015/internal/util/hostReportError.js");

    const subscribeToPromise = promise => subscriber => {
      promise.then(value => {
        if (!subscriber.closed) {
          subscriber.next(value);
          subscriber.complete();
        }
      }, err => subscriber.error(err)).then(null, _hostReportError__WEBPACK_IMPORTED_MODULE_0__["hostReportError"]);
      return subscriber;
    }; //# sourceMappingURL=subscribeToPromise.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js":
  /*!***********************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/subscribeToResult.js ***!
    \***********************************************************************/

  /*! exports provided: subscribeToResult */

  /***/
  function node_modulesRxjs_esm2015InternalUtilSubscribeToResultJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "subscribeToResult", function () {
      return subscribeToResult;
    });
    /* harmony import */


    var _InnerSubscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../InnerSubscriber */
    "./node_modules/rxjs/_esm2015/internal/InnerSubscriber.js");
    /* harmony import */


    var _subscribeTo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ./subscribeTo */
    "./node_modules/rxjs/_esm2015/internal/util/subscribeTo.js");

    function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, destination = new _InnerSubscriber__WEBPACK_IMPORTED_MODULE_0__["InnerSubscriber"](outerSubscriber, outerValue, outerIndex)) {
      if (destination.closed) {
        return;
      }

      return Object(_subscribeTo__WEBPACK_IMPORTED_MODULE_1__["subscribeTo"])(result)(destination);
    } //# sourceMappingURL=subscribeToResult.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/internal/util/toSubscriber.js":
  /*!******************************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/internal/util/toSubscriber.js ***!
    \******************************************************************/

  /*! exports provided: toSubscriber */

  /***/
  function node_modulesRxjs_esm2015InternalUtilToSubscriberJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "toSubscriber", function () {
      return toSubscriber;
    });
    /* harmony import */


    var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../Subscriber */
    "./node_modules/rxjs/_esm2015/internal/Subscriber.js");
    /* harmony import */


    var _symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../symbol/rxSubscriber */
    "./node_modules/rxjs/_esm2015/internal/symbol/rxSubscriber.js");
    /* harmony import */


    var _Observer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../Observer */
    "./node_modules/rxjs/_esm2015/internal/Observer.js");

    function toSubscriber(nextOrObserver, error, complete) {
      if (nextOrObserver) {
        if (nextOrObserver instanceof _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"]) {
          return nextOrObserver;
        }

        if (nextOrObserver[_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_1__["rxSubscriber"]]) {
          return nextOrObserver[_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_1__["rxSubscriber"]]();
        }
      }

      if (!nextOrObserver && !error && !complete) {
        return new _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"](_Observer__WEBPACK_IMPORTED_MODULE_2__["empty"]);
      }

      return new _Subscriber__WEBPACK_IMPORTED_MODULE_0__["Subscriber"](nextOrObserver, error, complete);
    } //# sourceMappingURL=toSubscriber.js.map

    /***/

  },

  /***/
  "./node_modules/rxjs/_esm2015/operators/index.js":
  /*!*******************************************************!*\
    !*** ./node_modules/rxjs/_esm2015/operators/index.js ***!
    \*******************************************************/

  /*! exports provided: audit, auditTime, buffer, bufferCount, bufferTime, bufferToggle, bufferWhen, catchError, combineAll, combineLatest, concat, concatAll, concatMap, concatMapTo, count, debounce, debounceTime, defaultIfEmpty, delay, delayWhen, dematerialize, distinct, distinctUntilChanged, distinctUntilKeyChanged, elementAt, endWith, every, exhaust, exhaustMap, expand, filter, finalize, find, findIndex, first, groupBy, ignoreElements, isEmpty, last, map, mapTo, materialize, max, merge, mergeAll, mergeMap, flatMap, mergeMapTo, mergeScan, min, multicast, observeOn, onErrorResumeNext, pairwise, partition, pluck, publish, publishBehavior, publishLast, publishReplay, race, reduce, repeat, repeatWhen, retry, retryWhen, refCount, sample, sampleTime, scan, sequenceEqual, share, shareReplay, single, skip, skipLast, skipUntil, skipWhile, startWith, subscribeOn, switchAll, switchMap, switchMapTo, take, takeLast, takeUntil, takeWhile, tap, throttle, throttleTime, throwIfEmpty, timeInterval, timeout, timeoutWith, timestamp, toArray, window, windowCount, windowTime, windowToggle, windowWhen, withLatestFrom, zip, zipAll */

  /***/
  function node_modulesRxjs_esm2015OperatorsIndexJs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony import */


    var _internal_operators_audit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! ../internal/operators/audit */
    "./node_modules/rxjs/_esm2015/internal/operators/audit.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "audit", function () {
      return _internal_operators_audit__WEBPACK_IMPORTED_MODULE_0__["audit"];
    });
    /* harmony import */


    var _internal_operators_auditTime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! ../internal/operators/auditTime */
    "./node_modules/rxjs/_esm2015/internal/operators/auditTime.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "auditTime", function () {
      return _internal_operators_auditTime__WEBPACK_IMPORTED_MODULE_1__["auditTime"];
    });
    /* harmony import */


    var _internal_operators_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! ../internal/operators/buffer */
    "./node_modules/rxjs/_esm2015/internal/operators/buffer.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "buffer", function () {
      return _internal_operators_buffer__WEBPACK_IMPORTED_MODULE_2__["buffer"];
    });
    /* harmony import */


    var _internal_operators_bufferCount__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! ../internal/operators/bufferCount */
    "./node_modules/rxjs/_esm2015/internal/operators/bufferCount.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "bufferCount", function () {
      return _internal_operators_bufferCount__WEBPACK_IMPORTED_MODULE_3__["bufferCount"];
    });
    /* harmony import */


    var _internal_operators_bufferTime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! ../internal/operators/bufferTime */
    "./node_modules/rxjs/_esm2015/internal/operators/bufferTime.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "bufferTime", function () {
      return _internal_operators_bufferTime__WEBPACK_IMPORTED_MODULE_4__["bufferTime"];
    });
    /* harmony import */


    var _internal_operators_bufferToggle__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! ../internal/operators/bufferToggle */
    "./node_modules/rxjs/_esm2015/internal/operators/bufferToggle.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "bufferToggle", function () {
      return _internal_operators_bufferToggle__WEBPACK_IMPORTED_MODULE_5__["bufferToggle"];
    });
    /* harmony import */


    var _internal_operators_bufferWhen__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
    /*! ../internal/operators/bufferWhen */
    "./node_modules/rxjs/_esm2015/internal/operators/bufferWhen.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "bufferWhen", function () {
      return _internal_operators_bufferWhen__WEBPACK_IMPORTED_MODULE_6__["bufferWhen"];
    });
    /* harmony import */


    var _internal_operators_catchError__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
    /*! ../internal/operators/catchError */
    "./node_modules/rxjs/_esm2015/internal/operators/catchError.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "catchError", function () {
      return _internal_operators_catchError__WEBPACK_IMPORTED_MODULE_7__["catchError"];
    });
    /* harmony import */


    var _internal_operators_combineAll__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
    /*! ../internal/operators/combineAll */
    "./node_modules/rxjs/_esm2015/internal/operators/combineAll.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "combineAll", function () {
      return _internal_operators_combineAll__WEBPACK_IMPORTED_MODULE_8__["combineAll"];
    });
    /* harmony import */


    var _internal_operators_combineLatest__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
    /*! ../internal/operators/combineLatest */
    "./node_modules/rxjs/_esm2015/internal/operators/combineLatest.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "combineLatest", function () {
      return _internal_operators_combineLatest__WEBPACK_IMPORTED_MODULE_9__["combineLatest"];
    });
    /* harmony import */


    var _internal_operators_concat__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
    /*! ../internal/operators/concat */
    "./node_modules/rxjs/_esm2015/internal/operators/concat.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "concat", function () {
      return _internal_operators_concat__WEBPACK_IMPORTED_MODULE_10__["concat"];
    });
    /* harmony import */


    var _internal_operators_concatAll__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
    /*! ../internal/operators/concatAll */
    "./node_modules/rxjs/_esm2015/internal/operators/concatAll.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "concatAll", function () {
      return _internal_operators_concatAll__WEBPACK_IMPORTED_MODULE_11__["concatAll"];
    });
    /* harmony import */


    var _internal_operators_concatMap__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(
    /*! ../internal/operators/concatMap */
    "./node_modules/rxjs/_esm2015/internal/operators/concatMap.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "concatMap", function () {
      return _internal_operators_concatMap__WEBPACK_IMPORTED_MODULE_12__["concatMap"];
    });
    /* harmony import */


    var _internal_operators_concatMapTo__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(
    /*! ../internal/operators/concatMapTo */
    "./node_modules/rxjs/_esm2015/internal/operators/concatMapTo.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "concatMapTo", function () {
      return _internal_operators_concatMapTo__WEBPACK_IMPORTED_MODULE_13__["concatMapTo"];
    });
    /* harmony import */


    var _internal_operators_count__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(
    /*! ../internal/operators/count */
    "./node_modules/rxjs/_esm2015/internal/operators/count.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "count", function () {
      return _internal_operators_count__WEBPACK_IMPORTED_MODULE_14__["count"];
    });
    /* harmony import */


    var _internal_operators_debounce__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(
    /*! ../internal/operators/debounce */
    "./node_modules/rxjs/_esm2015/internal/operators/debounce.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "debounce", function () {
      return _internal_operators_debounce__WEBPACK_IMPORTED_MODULE_15__["debounce"];
    });
    /* harmony import */


    var _internal_operators_debounceTime__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(
    /*! ../internal/operators/debounceTime */
    "./node_modules/rxjs/_esm2015/internal/operators/debounceTime.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "debounceTime", function () {
      return _internal_operators_debounceTime__WEBPACK_IMPORTED_MODULE_16__["debounceTime"];
    });
    /* harmony import */


    var _internal_operators_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(
    /*! ../internal/operators/defaultIfEmpty */
    "./node_modules/rxjs/_esm2015/internal/operators/defaultIfEmpty.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "defaultIfEmpty", function () {
      return _internal_operators_defaultIfEmpty__WEBPACK_IMPORTED_MODULE_17__["defaultIfEmpty"];
    });
    /* harmony import */


    var _internal_operators_delay__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(
    /*! ../internal/operators/delay */
    "./node_modules/rxjs/_esm2015/internal/operators/delay.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "delay", function () {
      return _internal_operators_delay__WEBPACK_IMPORTED_MODULE_18__["delay"];
    });
    /* harmony import */


    var _internal_operators_delayWhen__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(
    /*! ../internal/operators/delayWhen */
    "./node_modules/rxjs/_esm2015/internal/operators/delayWhen.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "delayWhen", function () {
      return _internal_operators_delayWhen__WEBPACK_IMPORTED_MODULE_19__["delayWhen"];
    });
    /* harmony import */


    var _internal_operators_dematerialize__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(
    /*! ../internal/operators/dematerialize */
    "./node_modules/rxjs/_esm2015/internal/operators/dematerialize.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "dematerialize", function () {
      return _internal_operators_dematerialize__WEBPACK_IMPORTED_MODULE_20__["dematerialize"];
    });
    /* harmony import */


    var _internal_operators_distinct__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(
    /*! ../internal/operators/distinct */
    "./node_modules/rxjs/_esm2015/internal/operators/distinct.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "distinct", function () {
      return _internal_operators_distinct__WEBPACK_IMPORTED_MODULE_21__["distinct"];
    });
    /* harmony import */


    var _internal_operators_distinctUntilChanged__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(
    /*! ../internal/operators/distinctUntilChanged */
    "./node_modules/rxjs/_esm2015/internal/operators/distinctUntilChanged.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "distinctUntilChanged", function () {
      return _internal_operators_distinctUntilChanged__WEBPACK_IMPORTED_MODULE_22__["distinctUntilChanged"];
    });
    /* harmony import */


    var _internal_operators_distinctUntilKeyChanged__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(
    /*! ../internal/operators/distinctUntilKeyChanged */
    "./node_modules/rxjs/_esm2015/internal/operators/distinctUntilKeyChanged.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "distinctUntilKeyChanged", function () {
      return _internal_operators_distinctUntilKeyChanged__WEBPACK_IMPORTED_MODULE_23__["distinctUntilKeyChanged"];
    });
    /* harmony import */


    var _internal_operators_elementAt__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(
    /*! ../internal/operators/elementAt */
    "./node_modules/rxjs/_esm2015/internal/operators/elementAt.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "elementAt", function () {
      return _internal_operators_elementAt__WEBPACK_IMPORTED_MODULE_24__["elementAt"];
    });
    /* harmony import */


    var _internal_operators_endWith__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(
    /*! ../internal/operators/endWith */
    "./node_modules/rxjs/_esm2015/internal/operators/endWith.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "endWith", function () {
      return _internal_operators_endWith__WEBPACK_IMPORTED_MODULE_25__["endWith"];
    });
    /* harmony import */


    var _internal_operators_every__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(
    /*! ../internal/operators/every */
    "./node_modules/rxjs/_esm2015/internal/operators/every.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "every", function () {
      return _internal_operators_every__WEBPACK_IMPORTED_MODULE_26__["every"];
    });
    /* harmony import */


    var _internal_operators_exhaust__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(
    /*! ../internal/operators/exhaust */
    "./node_modules/rxjs/_esm2015/internal/operators/exhaust.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "exhaust", function () {
      return _internal_operators_exhaust__WEBPACK_IMPORTED_MODULE_27__["exhaust"];
    });
    /* harmony import */


    var _internal_operators_exhaustMap__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(
    /*! ../internal/operators/exhaustMap */
    "./node_modules/rxjs/_esm2015/internal/operators/exhaustMap.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "exhaustMap", function () {
      return _internal_operators_exhaustMap__WEBPACK_IMPORTED_MODULE_28__["exhaustMap"];
    });
    /* harmony import */


    var _internal_operators_expand__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(
    /*! ../internal/operators/expand */
    "./node_modules/rxjs/_esm2015/internal/operators/expand.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "expand", function () {
      return _internal_operators_expand__WEBPACK_IMPORTED_MODULE_29__["expand"];
    });
    /* harmony import */


    var _internal_operators_filter__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(
    /*! ../internal/operators/filter */
    "./node_modules/rxjs/_esm2015/internal/operators/filter.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "filter", function () {
      return _internal_operators_filter__WEBPACK_IMPORTED_MODULE_30__["filter"];
    });
    /* harmony import */


    var _internal_operators_finalize__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(
    /*! ../internal/operators/finalize */
    "./node_modules/rxjs/_esm2015/internal/operators/finalize.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "finalize", function () {
      return _internal_operators_finalize__WEBPACK_IMPORTED_MODULE_31__["finalize"];
    });
    /* harmony import */


    var _internal_operators_find__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(
    /*! ../internal/operators/find */
    "./node_modules/rxjs/_esm2015/internal/operators/find.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "find", function () {
      return _internal_operators_find__WEBPACK_IMPORTED_MODULE_32__["find"];
    });
    /* harmony import */


    var _internal_operators_findIndex__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(
    /*! ../internal/operators/findIndex */
    "./node_modules/rxjs/_esm2015/internal/operators/findIndex.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "findIndex", function () {
      return _internal_operators_findIndex__WEBPACK_IMPORTED_MODULE_33__["findIndex"];
    });
    /* harmony import */


    var _internal_operators_first__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(
    /*! ../internal/operators/first */
    "./node_modules/rxjs/_esm2015/internal/operators/first.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "first", function () {
      return _internal_operators_first__WEBPACK_IMPORTED_MODULE_34__["first"];
    });
    /* harmony import */


    var _internal_operators_groupBy__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(
    /*! ../internal/operators/groupBy */
    "./node_modules/rxjs/_esm2015/internal/operators/groupBy.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "groupBy", function () {
      return _internal_operators_groupBy__WEBPACK_IMPORTED_MODULE_35__["groupBy"];
    });
    /* harmony import */


    var _internal_operators_ignoreElements__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(
    /*! ../internal/operators/ignoreElements */
    "./node_modules/rxjs/_esm2015/internal/operators/ignoreElements.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "ignoreElements", function () {
      return _internal_operators_ignoreElements__WEBPACK_IMPORTED_MODULE_36__["ignoreElements"];
    });
    /* harmony import */


    var _internal_operators_isEmpty__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(
    /*! ../internal/operators/isEmpty */
    "./node_modules/rxjs/_esm2015/internal/operators/isEmpty.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "isEmpty", function () {
      return _internal_operators_isEmpty__WEBPACK_IMPORTED_MODULE_37__["isEmpty"];
    });
    /* harmony import */


    var _internal_operators_last__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(
    /*! ../internal/operators/last */
    "./node_modules/rxjs/_esm2015/internal/operators/last.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "last", function () {
      return _internal_operators_last__WEBPACK_IMPORTED_MODULE_38__["last"];
    });
    /* harmony import */


    var _internal_operators_map__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(
    /*! ../internal/operators/map */
    "./node_modules/rxjs/_esm2015/internal/operators/map.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "map", function () {
      return _internal_operators_map__WEBPACK_IMPORTED_MODULE_39__["map"];
    });
    /* harmony import */


    var _internal_operators_mapTo__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(
    /*! ../internal/operators/mapTo */
    "./node_modules/rxjs/_esm2015/internal/operators/mapTo.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "mapTo", function () {
      return _internal_operators_mapTo__WEBPACK_IMPORTED_MODULE_40__["mapTo"];
    });
    /* harmony import */


    var _internal_operators_materialize__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(
    /*! ../internal/operators/materialize */
    "./node_modules/rxjs/_esm2015/internal/operators/materialize.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "materialize", function () {
      return _internal_operators_materialize__WEBPACK_IMPORTED_MODULE_41__["materialize"];
    });
    /* harmony import */


    var _internal_operators_max__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(
    /*! ../internal/operators/max */
    "./node_modules/rxjs/_esm2015/internal/operators/max.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "max", function () {
      return _internal_operators_max__WEBPACK_IMPORTED_MODULE_42__["max"];
    });
    /* harmony import */


    var _internal_operators_merge__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(
    /*! ../internal/operators/merge */
    "./node_modules/rxjs/_esm2015/internal/operators/merge.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "merge", function () {
      return _internal_operators_merge__WEBPACK_IMPORTED_MODULE_43__["merge"];
    });
    /* harmony import */


    var _internal_operators_mergeAll__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(
    /*! ../internal/operators/mergeAll */
    "./node_modules/rxjs/_esm2015/internal/operators/mergeAll.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "mergeAll", function () {
      return _internal_operators_mergeAll__WEBPACK_IMPORTED_MODULE_44__["mergeAll"];
    });
    /* harmony import */


    var _internal_operators_mergeMap__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(
    /*! ../internal/operators/mergeMap */
    "./node_modules/rxjs/_esm2015/internal/operators/mergeMap.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "mergeMap", function () {
      return _internal_operators_mergeMap__WEBPACK_IMPORTED_MODULE_45__["mergeMap"];
    });
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "flatMap", function () {
      return _internal_operators_mergeMap__WEBPACK_IMPORTED_MODULE_45__["mergeMap"];
    });
    /* harmony import */


    var _internal_operators_mergeMapTo__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(
    /*! ../internal/operators/mergeMapTo */
    "./node_modules/rxjs/_esm2015/internal/operators/mergeMapTo.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "mergeMapTo", function () {
      return _internal_operators_mergeMapTo__WEBPACK_IMPORTED_MODULE_46__["mergeMapTo"];
    });
    /* harmony import */


    var _internal_operators_mergeScan__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(
    /*! ../internal/operators/mergeScan */
    "./node_modules/rxjs/_esm2015/internal/operators/mergeScan.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "mergeScan", function () {
      return _internal_operators_mergeScan__WEBPACK_IMPORTED_MODULE_47__["mergeScan"];
    });
    /* harmony import */


    var _internal_operators_min__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(
    /*! ../internal/operators/min */
    "./node_modules/rxjs/_esm2015/internal/operators/min.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "min", function () {
      return _internal_operators_min__WEBPACK_IMPORTED_MODULE_48__["min"];
    });
    /* harmony import */


    var _internal_operators_multicast__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(
    /*! ../internal/operators/multicast */
    "./node_modules/rxjs/_esm2015/internal/operators/multicast.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "multicast", function () {
      return _internal_operators_multicast__WEBPACK_IMPORTED_MODULE_49__["multicast"];
    });
    /* harmony import */


    var _internal_operators_observeOn__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(
    /*! ../internal/operators/observeOn */
    "./node_modules/rxjs/_esm2015/internal/operators/observeOn.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "observeOn", function () {
      return _internal_operators_observeOn__WEBPACK_IMPORTED_MODULE_50__["observeOn"];
    });
    /* harmony import */


    var _internal_operators_onErrorResumeNext__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(
    /*! ../internal/operators/onErrorResumeNext */
    "./node_modules/rxjs/_esm2015/internal/operators/onErrorResumeNext.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "onErrorResumeNext", function () {
      return _internal_operators_onErrorResumeNext__WEBPACK_IMPORTED_MODULE_51__["onErrorResumeNext"];
    });
    /* harmony import */


    var _internal_operators_pairwise__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(
    /*! ../internal/operators/pairwise */
    "./node_modules/rxjs/_esm2015/internal/operators/pairwise.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "pairwise", function () {
      return _internal_operators_pairwise__WEBPACK_IMPORTED_MODULE_52__["pairwise"];
    });
    /* harmony import */


    var _internal_operators_partition__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(
    /*! ../internal/operators/partition */
    "./node_modules/rxjs/_esm2015/internal/operators/partition.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "partition", function () {
      return _internal_operators_partition__WEBPACK_IMPORTED_MODULE_53__["partition"];
    });
    /* harmony import */


    var _internal_operators_pluck__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(
    /*! ../internal/operators/pluck */
    "./node_modules/rxjs/_esm2015/internal/operators/pluck.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "pluck", function () {
      return _internal_operators_pluck__WEBPACK_IMPORTED_MODULE_54__["pluck"];
    });
    /* harmony import */


    var _internal_operators_publish__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(
    /*! ../internal/operators/publish */
    "./node_modules/rxjs/_esm2015/internal/operators/publish.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "publish", function () {
      return _internal_operators_publish__WEBPACK_IMPORTED_MODULE_55__["publish"];
    });
    /* harmony import */


    var _internal_operators_publishBehavior__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(
    /*! ../internal/operators/publishBehavior */
    "./node_modules/rxjs/_esm2015/internal/operators/publishBehavior.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "publishBehavior", function () {
      return _internal_operators_publishBehavior__WEBPACK_IMPORTED_MODULE_56__["publishBehavior"];
    });
    /* harmony import */


    var _internal_operators_publishLast__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(
    /*! ../internal/operators/publishLast */
    "./node_modules/rxjs/_esm2015/internal/operators/publishLast.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "publishLast", function () {
      return _internal_operators_publishLast__WEBPACK_IMPORTED_MODULE_57__["publishLast"];
    });
    /* harmony import */


    var _internal_operators_publishReplay__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(
    /*! ../internal/operators/publishReplay */
    "./node_modules/rxjs/_esm2015/internal/operators/publishReplay.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "publishReplay", function () {
      return _internal_operators_publishReplay__WEBPACK_IMPORTED_MODULE_58__["publishReplay"];
    });
    /* harmony import */


    var _internal_operators_race__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(
    /*! ../internal/operators/race */
    "./node_modules/rxjs/_esm2015/internal/operators/race.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "race", function () {
      return _internal_operators_race__WEBPACK_IMPORTED_MODULE_59__["race"];
    });
    /* harmony import */


    var _internal_operators_reduce__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(
    /*! ../internal/operators/reduce */
    "./node_modules/rxjs/_esm2015/internal/operators/reduce.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "reduce", function () {
      return _internal_operators_reduce__WEBPACK_IMPORTED_MODULE_60__["reduce"];
    });
    /* harmony import */


    var _internal_operators_repeat__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(
    /*! ../internal/operators/repeat */
    "./node_modules/rxjs/_esm2015/internal/operators/repeat.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "repeat", function () {
      return _internal_operators_repeat__WEBPACK_IMPORTED_MODULE_61__["repeat"];
    });
    /* harmony import */


    var _internal_operators_repeatWhen__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(
    /*! ../internal/operators/repeatWhen */
    "./node_modules/rxjs/_esm2015/internal/operators/repeatWhen.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "repeatWhen", function () {
      return _internal_operators_repeatWhen__WEBPACK_IMPORTED_MODULE_62__["repeatWhen"];
    });
    /* harmony import */


    var _internal_operators_retry__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(
    /*! ../internal/operators/retry */
    "./node_modules/rxjs/_esm2015/internal/operators/retry.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "retry", function () {
      return _internal_operators_retry__WEBPACK_IMPORTED_MODULE_63__["retry"];
    });
    /* harmony import */


    var _internal_operators_retryWhen__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(
    /*! ../internal/operators/retryWhen */
    "./node_modules/rxjs/_esm2015/internal/operators/retryWhen.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "retryWhen", function () {
      return _internal_operators_retryWhen__WEBPACK_IMPORTED_MODULE_64__["retryWhen"];
    });
    /* harmony import */


    var _internal_operators_refCount__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(
    /*! ../internal/operators/refCount */
    "./node_modules/rxjs/_esm2015/internal/operators/refCount.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "refCount", function () {
      return _internal_operators_refCount__WEBPACK_IMPORTED_MODULE_65__["refCount"];
    });
    /* harmony import */


    var _internal_operators_sample__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(
    /*! ../internal/operators/sample */
    "./node_modules/rxjs/_esm2015/internal/operators/sample.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "sample", function () {
      return _internal_operators_sample__WEBPACK_IMPORTED_MODULE_66__["sample"];
    });
    /* harmony import */


    var _internal_operators_sampleTime__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(
    /*! ../internal/operators/sampleTime */
    "./node_modules/rxjs/_esm2015/internal/operators/sampleTime.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "sampleTime", function () {
      return _internal_operators_sampleTime__WEBPACK_IMPORTED_MODULE_67__["sampleTime"];
    });
    /* harmony import */


    var _internal_operators_scan__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(
    /*! ../internal/operators/scan */
    "./node_modules/rxjs/_esm2015/internal/operators/scan.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "scan", function () {
      return _internal_operators_scan__WEBPACK_IMPORTED_MODULE_68__["scan"];
    });
    /* harmony import */


    var _internal_operators_sequenceEqual__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(
    /*! ../internal/operators/sequenceEqual */
    "./node_modules/rxjs/_esm2015/internal/operators/sequenceEqual.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "sequenceEqual", function () {
      return _internal_operators_sequenceEqual__WEBPACK_IMPORTED_MODULE_69__["sequenceEqual"];
    });
    /* harmony import */


    var _internal_operators_share__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(
    /*! ../internal/operators/share */
    "./node_modules/rxjs/_esm2015/internal/operators/share.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "share", function () {
      return _internal_operators_share__WEBPACK_IMPORTED_MODULE_70__["share"];
    });
    /* harmony import */


    var _internal_operators_shareReplay__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(
    /*! ../internal/operators/shareReplay */
    "./node_modules/rxjs/_esm2015/internal/operators/shareReplay.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "shareReplay", function () {
      return _internal_operators_shareReplay__WEBPACK_IMPORTED_MODULE_71__["shareReplay"];
    });
    /* harmony import */


    var _internal_operators_single__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(
    /*! ../internal/operators/single */
    "./node_modules/rxjs/_esm2015/internal/operators/single.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "single", function () {
      return _internal_operators_single__WEBPACK_IMPORTED_MODULE_72__["single"];
    });
    /* harmony import */


    var _internal_operators_skip__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(
    /*! ../internal/operators/skip */
    "./node_modules/rxjs/_esm2015/internal/operators/skip.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "skip", function () {
      return _internal_operators_skip__WEBPACK_IMPORTED_MODULE_73__["skip"];
    });
    /* harmony import */


    var _internal_operators_skipLast__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(
    /*! ../internal/operators/skipLast */
    "./node_modules/rxjs/_esm2015/internal/operators/skipLast.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "skipLast", function () {
      return _internal_operators_skipLast__WEBPACK_IMPORTED_MODULE_74__["skipLast"];
    });
    /* harmony import */


    var _internal_operators_skipUntil__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(
    /*! ../internal/operators/skipUntil */
    "./node_modules/rxjs/_esm2015/internal/operators/skipUntil.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "skipUntil", function () {
      return _internal_operators_skipUntil__WEBPACK_IMPORTED_MODULE_75__["skipUntil"];
    });
    /* harmony import */


    var _internal_operators_skipWhile__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(
    /*! ../internal/operators/skipWhile */
    "./node_modules/rxjs/_esm2015/internal/operators/skipWhile.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "skipWhile", function () {
      return _internal_operators_skipWhile__WEBPACK_IMPORTED_MODULE_76__["skipWhile"];
    });
    /* harmony import */


    var _internal_operators_startWith__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(
    /*! ../internal/operators/startWith */
    "./node_modules/rxjs/_esm2015/internal/operators/startWith.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "startWith", function () {
      return _internal_operators_startWith__WEBPACK_IMPORTED_MODULE_77__["startWith"];
    });
    /* harmony import */


    var _internal_operators_subscribeOn__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(
    /*! ../internal/operators/subscribeOn */
    "./node_modules/rxjs/_esm2015/internal/operators/subscribeOn.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "subscribeOn", function () {
      return _internal_operators_subscribeOn__WEBPACK_IMPORTED_MODULE_78__["subscribeOn"];
    });
    /* harmony import */


    var _internal_operators_switchAll__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(
    /*! ../internal/operators/switchAll */
    "./node_modules/rxjs/_esm2015/internal/operators/switchAll.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "switchAll", function () {
      return _internal_operators_switchAll__WEBPACK_IMPORTED_MODULE_79__["switchAll"];
    });
    /* harmony import */


    var _internal_operators_switchMap__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(
    /*! ../internal/operators/switchMap */
    "./node_modules/rxjs/_esm2015/internal/operators/switchMap.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "switchMap", function () {
      return _internal_operators_switchMap__WEBPACK_IMPORTED_MODULE_80__["switchMap"];
    });
    /* harmony import */


    var _internal_operators_switchMapTo__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(
    /*! ../internal/operators/switchMapTo */
    "./node_modules/rxjs/_esm2015/internal/operators/switchMapTo.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "switchMapTo", function () {
      return _internal_operators_switchMapTo__WEBPACK_IMPORTED_MODULE_81__["switchMapTo"];
    });
    /* harmony import */


    var _internal_operators_take__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(
    /*! ../internal/operators/take */
    "./node_modules/rxjs/_esm2015/internal/operators/take.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "take", function () {
      return _internal_operators_take__WEBPACK_IMPORTED_MODULE_82__["take"];
    });
    /* harmony import */


    var _internal_operators_takeLast__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(
    /*! ../internal/operators/takeLast */
    "./node_modules/rxjs/_esm2015/internal/operators/takeLast.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "takeLast", function () {
      return _internal_operators_takeLast__WEBPACK_IMPORTED_MODULE_83__["takeLast"];
    });
    /* harmony import */


    var _internal_operators_takeUntil__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(
    /*! ../internal/operators/takeUntil */
    "./node_modules/rxjs/_esm2015/internal/operators/takeUntil.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "takeUntil", function () {
      return _internal_operators_takeUntil__WEBPACK_IMPORTED_MODULE_84__["takeUntil"];
    });
    /* harmony import */


    var _internal_operators_takeWhile__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(
    /*! ../internal/operators/takeWhile */
    "./node_modules/rxjs/_esm2015/internal/operators/takeWhile.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "takeWhile", function () {
      return _internal_operators_takeWhile__WEBPACK_IMPORTED_MODULE_85__["takeWhile"];
    });
    /* harmony import */


    var _internal_operators_tap__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(
    /*! ../internal/operators/tap */
    "./node_modules/rxjs/_esm2015/internal/operators/tap.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "tap", function () {
      return _internal_operators_tap__WEBPACK_IMPORTED_MODULE_86__["tap"];
    });
    /* harmony import */


    var _internal_operators_throttle__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(
    /*! ../internal/operators/throttle */
    "./node_modules/rxjs/_esm2015/internal/operators/throttle.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "throttle", function () {
      return _internal_operators_throttle__WEBPACK_IMPORTED_MODULE_87__["throttle"];
    });
    /* harmony import */


    var _internal_operators_throttleTime__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(
    /*! ../internal/operators/throttleTime */
    "./node_modules/rxjs/_esm2015/internal/operators/throttleTime.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "throttleTime", function () {
      return _internal_operators_throttleTime__WEBPACK_IMPORTED_MODULE_88__["throttleTime"];
    });
    /* harmony import */


    var _internal_operators_throwIfEmpty__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(
    /*! ../internal/operators/throwIfEmpty */
    "./node_modules/rxjs/_esm2015/internal/operators/throwIfEmpty.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "throwIfEmpty", function () {
      return _internal_operators_throwIfEmpty__WEBPACK_IMPORTED_MODULE_89__["throwIfEmpty"];
    });
    /* harmony import */


    var _internal_operators_timeInterval__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(
    /*! ../internal/operators/timeInterval */
    "./node_modules/rxjs/_esm2015/internal/operators/timeInterval.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "timeInterval", function () {
      return _internal_operators_timeInterval__WEBPACK_IMPORTED_MODULE_90__["timeInterval"];
    });
    /* harmony import */


    var _internal_operators_timeout__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(
    /*! ../internal/operators/timeout */
    "./node_modules/rxjs/_esm2015/internal/operators/timeout.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "timeout", function () {
      return _internal_operators_timeout__WEBPACK_IMPORTED_MODULE_91__["timeout"];
    });
    /* harmony import */


    var _internal_operators_timeoutWith__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(
    /*! ../internal/operators/timeoutWith */
    "./node_modules/rxjs/_esm2015/internal/operators/timeoutWith.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "timeoutWith", function () {
      return _internal_operators_timeoutWith__WEBPACK_IMPORTED_MODULE_92__["timeoutWith"];
    });
    /* harmony import */


    var _internal_operators_timestamp__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(
    /*! ../internal/operators/timestamp */
    "./node_modules/rxjs/_esm2015/internal/operators/timestamp.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "timestamp", function () {
      return _internal_operators_timestamp__WEBPACK_IMPORTED_MODULE_93__["timestamp"];
    });
    /* harmony import */


    var _internal_operators_toArray__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(
    /*! ../internal/operators/toArray */
    "./node_modules/rxjs/_esm2015/internal/operators/toArray.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "toArray", function () {
      return _internal_operators_toArray__WEBPACK_IMPORTED_MODULE_94__["toArray"];
    });
    /* harmony import */


    var _internal_operators_window__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(
    /*! ../internal/operators/window */
    "./node_modules/rxjs/_esm2015/internal/operators/window.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "window", function () {
      return _internal_operators_window__WEBPACK_IMPORTED_MODULE_95__["window"];
    });
    /* harmony import */


    var _internal_operators_windowCount__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(
    /*! ../internal/operators/windowCount */
    "./node_modules/rxjs/_esm2015/internal/operators/windowCount.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "windowCount", function () {
      return _internal_operators_windowCount__WEBPACK_IMPORTED_MODULE_96__["windowCount"];
    });
    /* harmony import */


    var _internal_operators_windowTime__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(
    /*! ../internal/operators/windowTime */
    "./node_modules/rxjs/_esm2015/internal/operators/windowTime.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "windowTime", function () {
      return _internal_operators_windowTime__WEBPACK_IMPORTED_MODULE_97__["windowTime"];
    });
    /* harmony import */


    var _internal_operators_windowToggle__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(
    /*! ../internal/operators/windowToggle */
    "./node_modules/rxjs/_esm2015/internal/operators/windowToggle.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "windowToggle", function () {
      return _internal_operators_windowToggle__WEBPACK_IMPORTED_MODULE_98__["windowToggle"];
    });
    /* harmony import */


    var _internal_operators_windowWhen__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(
    /*! ../internal/operators/windowWhen */
    "./node_modules/rxjs/_esm2015/internal/operators/windowWhen.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "windowWhen", function () {
      return _internal_operators_windowWhen__WEBPACK_IMPORTED_MODULE_99__["windowWhen"];
    });
    /* harmony import */


    var _internal_operators_withLatestFrom__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(
    /*! ../internal/operators/withLatestFrom */
    "./node_modules/rxjs/_esm2015/internal/operators/withLatestFrom.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "withLatestFrom", function () {
      return _internal_operators_withLatestFrom__WEBPACK_IMPORTED_MODULE_100__["withLatestFrom"];
    });
    /* harmony import */


    var _internal_operators_zip__WEBPACK_IMPORTED_MODULE_101__ = __webpack_require__(
    /*! ../internal/operators/zip */
    "./node_modules/rxjs/_esm2015/internal/operators/zip.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "zip", function () {
      return _internal_operators_zip__WEBPACK_IMPORTED_MODULE_101__["zip"];
    });
    /* harmony import */


    var _internal_operators_zipAll__WEBPACK_IMPORTED_MODULE_102__ = __webpack_require__(
    /*! ../internal/operators/zipAll */
    "./node_modules/rxjs/_esm2015/internal/operators/zipAll.js");
    /* harmony reexport (safe) */


    __webpack_require__.d(__webpack_exports__, "zipAll", function () {
      return _internal_operators_zipAll__WEBPACK_IMPORTED_MODULE_102__["zipAll"];
    }); //# sourceMappingURL=index.js.map

    /***/

  },

  /***/
  "./node_modules/tslib/tslib.es6.js":
  /*!*****************************************!*\
    !*** ./node_modules/tslib/tslib.es6.js ***!
    \*****************************************/

  /*! exports provided: __extends, __assign, __rest, __decorate, __param, __metadata, __awaiter, __generator, __exportStar, __values, __read, __spread, __spreadArrays, __await, __asyncGenerator, __asyncDelegator, __asyncValues, __makeTemplateObject, __importStar, __importDefault, __classPrivateFieldGet, __classPrivateFieldSet */

  /***/
  function node_modulesTslibTslibEs6Js(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__extends", function () {
      return __extends;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__assign", function () {
      return _assign;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__rest", function () {
      return __rest;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__decorate", function () {
      return __decorate;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__param", function () {
      return __param;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__metadata", function () {
      return __metadata;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__awaiter", function () {
      return __awaiter;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__generator", function () {
      return __generator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__exportStar", function () {
      return __exportStar;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__values", function () {
      return __values;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__read", function () {
      return __read;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__spread", function () {
      return __spread;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__spreadArrays", function () {
      return __spreadArrays;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__await", function () {
      return __await;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__asyncGenerator", function () {
      return __asyncGenerator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__asyncDelegator", function () {
      return __asyncDelegator;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__asyncValues", function () {
      return __asyncValues;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__makeTemplateObject", function () {
      return __makeTemplateObject;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__importStar", function () {
      return __importStar;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__importDefault", function () {
      return __importDefault;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__classPrivateFieldGet", function () {
      return __classPrivateFieldGet;
    });
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "__classPrivateFieldSet", function () {
      return __classPrivateFieldSet;
    });
    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0
    
    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.
    
    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    /* global Reflect, Promise */


    var _extendStatics = function extendStatics(d, b) {
      _extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };

      return _extendStatics(d, b);
    };

    function __extends(d, b) {
      _extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var _assign = function __assign() {
      _assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];

          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }

        return t;
      };

      return _assign.apply(this, arguments);
    };

    function __rest(s, e) {
      var t = {};

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    }

    function __decorate(decorators, target, key, desc) {
      var c = arguments.length,
          r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
          d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
      return function (target, key) {
        decorator(target, key, paramIndex);
      };
    }

    function __metadata(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        });
      }

      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }

        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }

        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }

        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    }

    function __generator(thisArg, body) {
      var _ = {
        label: 0,
        sent: function sent() {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      },
          f,
          y,
          t,
          g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;

      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }

      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");

        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }

        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    }

    function __exportStar(m, exports) {
      for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
      var s = typeof Symbol === "function" && Symbol.iterator,
          m = s && o[s],
          i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function next() {
          if (o && i >= o.length) o = void 0;
          return {
            value: o && o[i++],
            done: !o
          };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o),
          r,
          ar = [],
          e;

      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = {
          error: error
        };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }

      return ar;
    }

    function __spread() {
      for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));

      return ar;
    }

    function __spreadArrays() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;

      for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];

      return r;
    }

    ;

    function __await(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []),
          i,
          q = [];
      return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
        return this;
      }, i;

      function verb(n) {
        if (g[n]) i[n] = function (v) {
          return new Promise(function (a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
      }

      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }

      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }

      function fulfill(value) {
        resume("next", value);
      }

      function reject(value) {
        resume("throw", value);
      }

      function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
      }
    }

    function __asyncDelegator(o) {
      var i, p;
      return i = {}, verb("next"), verb("throw", function (e) {
        throw e;
      }), verb("return"), i[Symbol.iterator] = function () {
        return this;
      }, i;

      function verb(n, f) {
        i[n] = o[n] ? function (v) {
          return (p = !p) ? {
            value: __await(o[n](v)),
            done: n === "return"
          } : f ? f(v) : v;
        } : f;
      }
    }

    function __asyncValues(o) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator],
          i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
        return this;
      }, i);

      function verb(n) {
        i[n] = o[n] && function (v) {
          return new Promise(function (resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }

      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function (v) {
          resolve({
            value: v,
            done: d
          });
        }, reject);
      }
    }

    function __makeTemplateObject(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", {
          value: raw
        });
      } else {
        cooked.raw = raw;
      }

      return cooked;
    }

    ;

    function __importStar(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
      result.default = mod;
      return result;
    }

    function __importDefault(mod) {
      return mod && mod.__esModule ? mod : {
        default: mod
      };
    }

    function __classPrivateFieldGet(receiver, privateMap) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
      }

      return privateMap.get(receiver);
    }

    function __classPrivateFieldSet(receiver, privateMap, value) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
      }

      privateMap.set(receiver, value);
      return value;
    }
    /***/

  },

  /***/
  "./node_modules/zone.js/dist/zone-evergreen.js":
  /*!*****************************************************!*\
    !*** ./node_modules/zone.js/dist/zone-evergreen.js ***!
    \*****************************************************/

  /*! no static exports found */

  /***/
  function node_modulesZoneJsDistZoneEvergreenJs(module, exports) {
    /**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    const Zone$1 = function (global) {
      const performance = global['performance'];

      function mark(name) {
        performance && performance['mark'] && performance['mark'](name);
      }

      function performanceMeasure(name, label) {
        performance && performance['measure'] && performance['measure'](name, label);
      }

      mark('Zone');
      const checkDuplicate = global['__zone_symbol__forceDuplicateZoneCheck'] === true;

      if (global['Zone']) {
        // if global['Zone'] already exists (maybe zone.js was already loaded or
        // some other lib also registered a global object named Zone), we may need
        // to throw an error, but sometimes user may not want this error.
        // For example,
        // we have two web pages, page1 includes zone.js, page2 doesn't.
        // and the 1st time user load page1 and page2, everything work fine,
        // but when user load page2 again, error occurs because global['Zone'] already exists.
        // so we add a flag to let user choose whether to throw this error or not.
        // By default, if existing Zone is from zone.js, we will not throw the error.
        if (checkDuplicate || typeof global['Zone'].__symbol__ !== 'function') {
          throw new Error('Zone already loaded.');
        } else {
          return global['Zone'];
        }
      }

      class Zone {
        constructor(parent, zoneSpec) {
          this._parent = parent;
          this._name = zoneSpec ? zoneSpec.name || 'unnamed' : '<root>';
          this._properties = zoneSpec && zoneSpec.properties || {};
          this._zoneDelegate = new ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);
        }

        static assertZonePatched() {
          if (global['Promise'] !== patches['ZoneAwarePromise']) {
            throw new Error('Zone.js has detected that ZoneAwarePromise `(window|global).Promise` ' + 'has been overwritten.\n' + 'Most likely cause is that a Promise polyfill has been loaded ' + 'after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. ' + 'If you must load one, do so before loading zone.js.)');
          }
        }

        static get root() {
          let zone = Zone.current;

          while (zone.parent) {
            zone = zone.parent;
          }

          return zone;
        }

        static get current() {
          return _currentZoneFrame.zone;
        }

        static get currentTask() {
          return _currentTask;
        }

        static __load_patch(name, fn) {
          if (patches.hasOwnProperty(name)) {
            if (checkDuplicate) {
              throw Error('Already loaded patch: ' + name);
            }
          } else if (!global['__Zone_disable_' + name]) {
            const perfName = 'Zone:' + name;
            mark(perfName);
            patches[name] = fn(global, Zone, _api);
            performanceMeasure(perfName, perfName);
          }
        }

        get parent() {
          return this._parent;
        }

        get name() {
          return this._name;
        }

        get(key) {
          const zone = this.getZoneWith(key);
          if (zone) return zone._properties[key];
        }

        getZoneWith(key) {
          let current = this;

          while (current) {
            if (current._properties.hasOwnProperty(key)) {
              return current;
            }

            current = current._parent;
          }

          return null;
        }

        fork(zoneSpec) {
          if (!zoneSpec) throw new Error('ZoneSpec required!');
          return this._zoneDelegate.fork(this, zoneSpec);
        }

        wrap(callback, source) {
          if (typeof callback !== 'function') {
            throw new Error('Expecting function got: ' + callback);
          }

          const _callback = this._zoneDelegate.intercept(this, callback, source);

          const zone = this;
          return function () {
            return zone.runGuarded(_callback, this, arguments, source);
          };
        }

        run(callback, applyThis, applyArgs, source) {
          _currentZoneFrame = {
            parent: _currentZoneFrame,
            zone: this
          };

          try {
            return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
          } finally {
            _currentZoneFrame = _currentZoneFrame.parent;
          }
        }

        runGuarded(callback, applyThis = null, applyArgs, source) {
          _currentZoneFrame = {
            parent: _currentZoneFrame,
            zone: this
          };

          try {
            try {
              return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);
            } catch (error) {
              if (this._zoneDelegate.handleError(this, error)) {
                throw error;
              }
            }
          } finally {
            _currentZoneFrame = _currentZoneFrame.parent;
          }
        }

        runTask(task, applyThis, applyArgs) {
          if (task.zone != this) {
            throw new Error('A task can only be run in the zone of creation! (Creation: ' + (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');
          } // https://github.com/angular/zone.js/issues/778, sometimes eventTask
          // will run in notScheduled(canceled) state, we should not try to
          // run such kind of task but just return


          if (task.state === notScheduled && (task.type === eventTask || task.type === macroTask)) {
            return;
          }

          const reEntryGuard = task.state != running;
          reEntryGuard && task._transitionTo(running, scheduled);
          task.runCount++;
          const previousTask = _currentTask;
          _currentTask = task;
          _currentZoneFrame = {
            parent: _currentZoneFrame,
            zone: this
          };

          try {
            if (task.type == macroTask && task.data && !task.data.isPeriodic) {
              task.cancelFn = undefined;
            }

            try {
              return this._zoneDelegate.invokeTask(this, task, applyThis, applyArgs);
            } catch (error) {
              if (this._zoneDelegate.handleError(this, error)) {
                throw error;
              }
            }
          } finally {
            // if the task's state is notScheduled or unknown, then it has already been cancelled
            // we should not reset the state to scheduled
            if (task.state !== notScheduled && task.state !== unknown) {
              if (task.type == eventTask || task.data && task.data.isPeriodic) {
                reEntryGuard && task._transitionTo(scheduled, running);
              } else {
                task.runCount = 0;

                this._updateTaskCount(task, -1);

                reEntryGuard && task._transitionTo(notScheduled, running, notScheduled);
              }
            }

            _currentZoneFrame = _currentZoneFrame.parent;
            _currentTask = previousTask;
          }
        }

        scheduleTask(task) {
          if (task.zone && task.zone !== this) {
            // check if the task was rescheduled, the newZone
            // should not be the children of the original zone
            let newZone = this;

            while (newZone) {
              if (newZone === task.zone) {
                throw Error("can not reschedule task to ".concat(this.name, " which is descendants of the original zone ").concat(task.zone.name));
              }

              newZone = newZone.parent;
            }
          }

          task._transitionTo(scheduling, notScheduled);

          const zoneDelegates = [];
          task._zoneDelegates = zoneDelegates;
          task._zone = this;

          try {
            task = this._zoneDelegate.scheduleTask(this, task);
          } catch (err) {
            // should set task's state to unknown when scheduleTask throw error
            // because the err may from reschedule, so the fromState maybe notScheduled
            task._transitionTo(unknown, scheduling, notScheduled); // TODO: @JiaLiPassion, should we check the result from handleError?


            this._zoneDelegate.handleError(this, err);

            throw err;
          }

          if (task._zoneDelegates === zoneDelegates) {
            // we have to check because internally the delegate can reschedule the task.
            this._updateTaskCount(task, 1);
          }

          if (task.state == scheduling) {
            task._transitionTo(scheduled, scheduling);
          }

          return task;
        }

        scheduleMicroTask(source, callback, data, customSchedule) {
          return this.scheduleTask(new ZoneTask(microTask, source, callback, data, customSchedule, undefined));
        }

        scheduleMacroTask(source, callback, data, customSchedule, customCancel) {
          return this.scheduleTask(new ZoneTask(macroTask, source, callback, data, customSchedule, customCancel));
        }

        scheduleEventTask(source, callback, data, customSchedule, customCancel) {
          return this.scheduleTask(new ZoneTask(eventTask, source, callback, data, customSchedule, customCancel));
        }

        cancelTask(task) {
          if (task.zone != this) throw new Error('A task can only be cancelled in the zone of creation! (Creation: ' + (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');

          task._transitionTo(canceling, scheduled, running);

          try {
            this._zoneDelegate.cancelTask(this, task);
          } catch (err) {
            // if error occurs when cancelTask, transit the state to unknown
            task._transitionTo(unknown, canceling);

            this._zoneDelegate.handleError(this, err);

            throw err;
          }

          this._updateTaskCount(task, -1);

          task._transitionTo(notScheduled, canceling);

          task.runCount = 0;
          return task;
        }

        _updateTaskCount(task, count) {
          const zoneDelegates = task._zoneDelegates;

          if (count == -1) {
            task._zoneDelegates = null;
          }

          for (let i = 0; i < zoneDelegates.length; i++) {
            zoneDelegates[i]._updateTaskCount(task.type, count);
          }
        }

      }

      Zone.__symbol__ = __symbol__;
      const DELEGATE_ZS = {
        name: '',
        onHasTask: (delegate, _, target, hasTaskState) => delegate.hasTask(target, hasTaskState),
        onScheduleTask: (delegate, _, target, task) => delegate.scheduleTask(target, task),
        onInvokeTask: (delegate, _, target, task, applyThis, applyArgs) => delegate.invokeTask(target, task, applyThis, applyArgs),
        onCancelTask: (delegate, _, target, task) => delegate.cancelTask(target, task)
      };

      class ZoneDelegate {
        constructor(zone, parentDelegate, zoneSpec) {
          this._taskCounts = {
            'microTask': 0,
            'macroTask': 0,
            'eventTask': 0
          };
          this.zone = zone;
          this._parentDelegate = parentDelegate;
          this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);
          this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);
          this._forkCurrZone = zoneSpec && (zoneSpec.onFork ? this.zone : parentDelegate.zone);
          this._interceptZS = zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);
          this._interceptDlgt = zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);
          this._interceptCurrZone = zoneSpec && (zoneSpec.onIntercept ? this.zone : parentDelegate.zone);
          this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);
          this._invokeDlgt = zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);
          this._invokeCurrZone = zoneSpec && (zoneSpec.onInvoke ? this.zone : parentDelegate.zone);
          this._handleErrorZS = zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);
          this._handleErrorDlgt = zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);
          this._handleErrorCurrZone = zoneSpec && (zoneSpec.onHandleError ? this.zone : parentDelegate.zone);
          this._scheduleTaskZS = zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);
          this._scheduleTaskDlgt = zoneSpec && (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);
          this._scheduleTaskCurrZone = zoneSpec && (zoneSpec.onScheduleTask ? this.zone : parentDelegate.zone);
          this._invokeTaskZS = zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);
          this._invokeTaskDlgt = zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);
          this._invokeTaskCurrZone = zoneSpec && (zoneSpec.onInvokeTask ? this.zone : parentDelegate.zone);
          this._cancelTaskZS = zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);
          this._cancelTaskDlgt = zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);
          this._cancelTaskCurrZone = zoneSpec && (zoneSpec.onCancelTask ? this.zone : parentDelegate.zone);
          this._hasTaskZS = null;
          this._hasTaskDlgt = null;
          this._hasTaskDlgtOwner = null;
          this._hasTaskCurrZone = null;
          const zoneSpecHasTask = zoneSpec && zoneSpec.onHasTask;
          const parentHasTask = parentDelegate && parentDelegate._hasTaskZS;

          if (zoneSpecHasTask || parentHasTask) {
            // If we need to report hasTask, than this ZS needs to do ref counting on tasks. In such
            // a case all task related interceptors must go through this ZD. We can't short circuit it.
            this._hasTaskZS = zoneSpecHasTask ? zoneSpec : DELEGATE_ZS;
            this._hasTaskDlgt = parentDelegate;
            this._hasTaskDlgtOwner = this;
            this._hasTaskCurrZone = zone;

            if (!zoneSpec.onScheduleTask) {
              this._scheduleTaskZS = DELEGATE_ZS;
              this._scheduleTaskDlgt = parentDelegate;
              this._scheduleTaskCurrZone = this.zone;
            }

            if (!zoneSpec.onInvokeTask) {
              this._invokeTaskZS = DELEGATE_ZS;
              this._invokeTaskDlgt = parentDelegate;
              this._invokeTaskCurrZone = this.zone;
            }

            if (!zoneSpec.onCancelTask) {
              this._cancelTaskZS = DELEGATE_ZS;
              this._cancelTaskDlgt = parentDelegate;
              this._cancelTaskCurrZone = this.zone;
            }
          }
        }

        fork(targetZone, zoneSpec) {
          return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) : new Zone(targetZone, zoneSpec);
        }

        intercept(targetZone, callback, source) {
          return this._interceptZS ? this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source) : callback;
        }

        invoke(targetZone, callback, applyThis, applyArgs, source) {
          return this._invokeZS ? this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source) : callback.apply(applyThis, applyArgs);
        }

        handleError(targetZone, error) {
          return this._handleErrorZS ? this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error) : true;
        }

        scheduleTask(targetZone, task) {
          let returnTask = task;

          if (this._scheduleTaskZS) {
            if (this._hasTaskZS) {
              returnTask._zoneDelegates.push(this._hasTaskDlgtOwner);
            }

            returnTask = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task);
            if (!returnTask) returnTask = task;
          } else {
            if (task.scheduleFn) {
              task.scheduleFn(task);
            } else if (task.type == microTask) {
              scheduleMicroTask(task);
            } else {
              throw new Error('Task is missing scheduleFn.');
            }
          }

          return returnTask;
        }

        invokeTask(targetZone, task, applyThis, applyArgs) {
          return this._invokeTaskZS ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs) : task.callback.apply(applyThis, applyArgs);
        }

        cancelTask(targetZone, task) {
          let value;

          if (this._cancelTaskZS) {
            value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);
          } else {
            if (!task.cancelFn) {
              throw Error('Task is not cancelable');
            }

            value = task.cancelFn(task);
          }

          return value;
        }

        hasTask(targetZone, isEmpty) {
          // hasTask should not throw error so other ZoneDelegate
          // can still trigger hasTask callback
          try {
            this._hasTaskZS && this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);
          } catch (err) {
            this.handleError(targetZone, err);
          }
        }

        _updateTaskCount(type, count) {
          const counts = this._taskCounts;
          const prev = counts[type];
          const next = counts[type] = prev + count;

          if (next < 0) {
            throw new Error('More tasks executed then were scheduled.');
          }

          if (prev == 0 || next == 0) {
            const isEmpty = {
              microTask: counts['microTask'] > 0,
              macroTask: counts['macroTask'] > 0,
              eventTask: counts['eventTask'] > 0,
              change: type
            };
            this.hasTask(this.zone, isEmpty);
          }
        }

      }

      class ZoneTask {
        constructor(type, source, callback, options, scheduleFn, cancelFn) {
          this._zone = null;
          this.runCount = 0;
          this._zoneDelegates = null;
          this._state = 'notScheduled';
          this.type = type;
          this.source = source;
          this.data = options;
          this.scheduleFn = scheduleFn;
          this.cancelFn = cancelFn;
          this.callback = callback;
          const self = this; // TODO: @JiaLiPassion options should have interface

          if (type === eventTask && options && options.useG) {
            this.invoke = ZoneTask.invokeTask;
          } else {
            this.invoke = function () {
              return ZoneTask.invokeTask.call(global, self, this, arguments);
            };
          }
        }

        static invokeTask(task, target, args) {
          if (!task) {
            task = this;
          }

          _numberOfNestedTaskFrames++;

          try {
            task.runCount++;
            return task.zone.runTask(task, target, args);
          } finally {
            if (_numberOfNestedTaskFrames == 1) {
              drainMicroTaskQueue();
            }

            _numberOfNestedTaskFrames--;
          }
        }

        get zone() {
          return this._zone;
        }

        get state() {
          return this._state;
        }

        cancelScheduleRequest() {
          this._transitionTo(notScheduled, scheduling);
        }

        _transitionTo(toState, fromState1, fromState2) {
          if (this._state === fromState1 || this._state === fromState2) {
            this._state = toState;

            if (toState == notScheduled) {
              this._zoneDelegates = null;
            }
          } else {
            throw new Error("".concat(this.type, " '").concat(this.source, "': can not transition to '").concat(toState, "', expecting state '").concat(fromState1, "'").concat(fromState2 ? ' or \'' + fromState2 + '\'' : '', ", was '").concat(this._state, "'."));
          }
        }

        toString() {
          if (this.data && typeof this.data.handleId !== 'undefined') {
            return this.data.handleId.toString();
          } else {
            return Object.prototype.toString.call(this);
          }
        } // add toJSON method to prevent cyclic error when
        // call JSON.stringify(zoneTask)


        toJSON() {
          return {
            type: this.type,
            state: this.state,
            source: this.source,
            zone: this.zone.name,
            runCount: this.runCount
          };
        }

      } //////////////////////////////////////////////////////
      //////////////////////////////////////////////////////
      ///  MICROTASK QUEUE
      //////////////////////////////////////////////////////
      //////////////////////////////////////////////////////


      const symbolSetTimeout = __symbol__('setTimeout');

      const symbolPromise = __symbol__('Promise');

      const symbolThen = __symbol__('then');

      let _microTaskQueue = [];
      let _isDrainingMicrotaskQueue = false;
      let nativeMicroTaskQueuePromise;

      function scheduleMicroTask(task) {
        // if we are not running in any task, and there has not been anything scheduled
        // we must bootstrap the initial task creation by manually scheduling the drain
        if (_numberOfNestedTaskFrames === 0 && _microTaskQueue.length === 0) {
          // We are not running in Task, so we need to kickstart the microtask queue.
          if (!nativeMicroTaskQueuePromise) {
            if (global[symbolPromise]) {
              nativeMicroTaskQueuePromise = global[symbolPromise].resolve(0);
            }
          }

          if (nativeMicroTaskQueuePromise) {
            let nativeThen = nativeMicroTaskQueuePromise[symbolThen];

            if (!nativeThen) {
              // native Promise is not patchable, we need to use `then` directly
              // issue 1078
              nativeThen = nativeMicroTaskQueuePromise['then'];
            }

            nativeThen.call(nativeMicroTaskQueuePromise, drainMicroTaskQueue);
          } else {
            global[symbolSetTimeout](drainMicroTaskQueue, 0);
          }
        }

        task && _microTaskQueue.push(task);
      }

      function drainMicroTaskQueue() {
        if (!_isDrainingMicrotaskQueue) {
          _isDrainingMicrotaskQueue = true;

          while (_microTaskQueue.length) {
            const queue = _microTaskQueue;
            _microTaskQueue = [];

            for (let i = 0; i < queue.length; i++) {
              const task = queue[i];

              try {
                task.zone.runTask(task, null, null);
              } catch (error) {
                _api.onUnhandledError(error);
              }
            }
          }

          _api.microtaskDrainDone();

          _isDrainingMicrotaskQueue = false;
        }
      } //////////////////////////////////////////////////////
      //////////////////////////////////////////////////////
      ///  BOOTSTRAP
      //////////////////////////////////////////////////////
      //////////////////////////////////////////////////////


      const NO_ZONE = {
        name: 'NO ZONE'
      };
      const notScheduled = 'notScheduled',
            scheduling = 'scheduling',
            scheduled = 'scheduled',
            running = 'running',
            canceling = 'canceling',
            unknown = 'unknown';
      const microTask = 'microTask',
            macroTask = 'macroTask',
            eventTask = 'eventTask';
      const patches = {};
      const _api = {
        symbol: __symbol__,
        currentZoneFrame: () => _currentZoneFrame,
        onUnhandledError: noop,
        microtaskDrainDone: noop,
        scheduleMicroTask: scheduleMicroTask,
        showUncaughtError: () => !Zone[__symbol__('ignoreConsoleErrorUncaughtError')],
        patchEventTarget: () => [],
        patchOnProperties: noop,
        patchMethod: () => noop,
        bindArguments: () => [],
        patchThen: () => noop,
        patchMacroTask: () => noop,
        setNativePromise: NativePromise => {
          // sometimes NativePromise.resolve static function
          // is not ready yet, (such as core-js/es6.promise)
          // so we need to check here.
          if (NativePromise && typeof NativePromise.resolve === 'function') {
            nativeMicroTaskQueuePromise = NativePromise.resolve(0);
          }
        },
        patchEventPrototype: () => noop,
        isIEOrEdge: () => false,
        getGlobalObjects: () => undefined,
        ObjectDefineProperty: () => noop,
        ObjectGetOwnPropertyDescriptor: () => undefined,
        ObjectCreate: () => undefined,
        ArraySlice: () => [],
        patchClass: () => noop,
        wrapWithCurrentZone: () => noop,
        filterProperties: () => [],
        attachOriginToPatched: () => noop,
        _redefineProperty: () => noop,
        patchCallbacks: () => noop
      };
      let _currentZoneFrame = {
        parent: null,
        zone: new Zone(null, null)
      };
      let _currentTask = null;
      let _numberOfNestedTaskFrames = 0;

      function noop() {}

      function __symbol__(name) {
        return '__zone_symbol__' + name;
      }

      performanceMeasure('Zone', 'Zone');
      return global['Zone'] = Zone;
    }(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    Zone.__load_patch('ZoneAwarePromise', (global, Zone, api) => {
      const ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      const ObjectDefineProperty = Object.defineProperty;

      function readableObjectToString(obj) {
        if (obj && obj.toString === Object.prototype.toString) {
          const className = obj.constructor && obj.constructor.name;
          return (className ? className : '') + ': ' + JSON.stringify(obj);
        }

        return obj ? obj.toString() : Object.prototype.toString.call(obj);
      }

      const __symbol__ = api.symbol;
      const _uncaughtPromiseErrors = [];

      const symbolPromise = __symbol__('Promise');

      const symbolThen = __symbol__('then');

      const creationTrace = '__creationTrace__';

      api.onUnhandledError = e => {
        if (api.showUncaughtError()) {
          const rejection = e && e.rejection;

          if (rejection) {
            console.error('Unhandled Promise rejection:', rejection instanceof Error ? rejection.message : rejection, '; Zone:', e.zone.name, '; Task:', e.task && e.task.source, '; Value:', rejection, rejection instanceof Error ? rejection.stack : undefined);
          } else {
            console.error(e);
          }
        }
      };

      api.microtaskDrainDone = () => {
        while (_uncaughtPromiseErrors.length) {
          while (_uncaughtPromiseErrors.length) {
            const uncaughtPromiseError = _uncaughtPromiseErrors.shift();

            try {
              uncaughtPromiseError.zone.runGuarded(() => {
                throw uncaughtPromiseError;
              });
            } catch (error) {
              handleUnhandledRejection(error);
            }
          }
        }
      };

      const UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL = __symbol__('unhandledPromiseRejectionHandler');

      function handleUnhandledRejection(e) {
        api.onUnhandledError(e);

        try {
          const handler = Zone[UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL];

          if (handler && typeof handler === 'function') {
            handler.call(this, e);
          }
        } catch (err) {}
      }

      function isThenable(value) {
        return value && value.then;
      }

      function forwardResolution(value) {
        return value;
      }

      function forwardRejection(rejection) {
        return ZoneAwarePromise.reject(rejection);
      }

      const symbolState = __symbol__('state');

      const symbolValue = __symbol__('value');

      const symbolFinally = __symbol__('finally');

      const symbolParentPromiseValue = __symbol__('parentPromiseValue');

      const symbolParentPromiseState = __symbol__('parentPromiseState');

      const source = 'Promise.then';
      const UNRESOLVED = null;
      const RESOLVED = true;
      const REJECTED = false;
      const REJECTED_NO_CATCH = 0;

      function makeResolver(promise, state) {
        return v => {
          try {
            resolvePromise(promise, state, v);
          } catch (err) {
            resolvePromise(promise, false, err);
          } // Do not return value or you will break the Promise spec.

        };
      }

      const once = function once() {
        let wasCalled = false;
        return function wrapper(wrappedFunction) {
          return function () {
            if (wasCalled) {
              return;
            }

            wasCalled = true;
            wrappedFunction.apply(null, arguments);
          };
        };
      };

      const TYPE_ERROR = 'Promise resolved with itself';

      const CURRENT_TASK_TRACE_SYMBOL = __symbol__('currentTaskTrace'); // Promise Resolution


      function resolvePromise(promise, state, value) {
        const onceWrapper = once();

        if (promise === value) {
          throw new TypeError(TYPE_ERROR);
        }

        if (promise[symbolState] === UNRESOLVED) {
          // should only get value.then once based on promise spec.
          let then = null;

          try {
            if (typeof value === 'object' || typeof value === 'function') {
              then = value && value.then;
            }
          } catch (err) {
            onceWrapper(() => {
              resolvePromise(promise, false, err);
            })();
            return promise;
          } // if (value instanceof ZoneAwarePromise) {


          if (state !== REJECTED && value instanceof ZoneAwarePromise && value.hasOwnProperty(symbolState) && value.hasOwnProperty(symbolValue) && value[symbolState] !== UNRESOLVED) {
            clearRejectedNoCatch(value);
            resolvePromise(promise, value[symbolState], value[symbolValue]);
          } else if (state !== REJECTED && typeof then === 'function') {
            try {
              then.call(value, onceWrapper(makeResolver(promise, state)), onceWrapper(makeResolver(promise, false)));
            } catch (err) {
              onceWrapper(() => {
                resolvePromise(promise, false, err);
              })();
            }
          } else {
            promise[symbolState] = state;
            const queue = promise[symbolValue];
            promise[symbolValue] = value;

            if (promise[symbolFinally] === symbolFinally) {
              // the promise is generated by Promise.prototype.finally
              if (state === RESOLVED) {
                // the state is resolved, should ignore the value
                // and use parent promise value
                promise[symbolState] = promise[symbolParentPromiseState];
                promise[symbolValue] = promise[symbolParentPromiseValue];
              }
            } // record task information in value when error occurs, so we can
            // do some additional work such as render longStackTrace


            if (state === REJECTED && value instanceof Error) {
              // check if longStackTraceZone is here
              const trace = Zone.currentTask && Zone.currentTask.data && Zone.currentTask.data[creationTrace];

              if (trace) {
                // only keep the long stack trace into error when in longStackTraceZone
                ObjectDefineProperty(value, CURRENT_TASK_TRACE_SYMBOL, {
                  configurable: true,
                  enumerable: false,
                  writable: true,
                  value: trace
                });
              }
            }

            for (let i = 0; i < queue.length;) {
              scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);
            }

            if (queue.length == 0 && state == REJECTED) {
              promise[symbolState] = REJECTED_NO_CATCH;

              try {
                // try to print more readable error log
                throw new Error('Uncaught (in promise): ' + readableObjectToString(value) + (value && value.stack ? '\n' + value.stack : ''));
              } catch (err) {
                const error = err;
                error.rejection = value;
                error.promise = promise;
                error.zone = Zone.current;
                error.task = Zone.currentTask;

                _uncaughtPromiseErrors.push(error);

                api.scheduleMicroTask(); // to make sure that it is running
              }
            }
          }
        } // Resolving an already resolved promise is a noop.


        return promise;
      }

      const REJECTION_HANDLED_HANDLER = __symbol__('rejectionHandledHandler');

      function clearRejectedNoCatch(promise) {
        if (promise[symbolState] === REJECTED_NO_CATCH) {
          // if the promise is rejected no catch status
          // and queue.length > 0, means there is a error handler
          // here to handle the rejected promise, we should trigger
          // windows.rejectionhandled eventHandler or nodejs rejectionHandled
          // eventHandler
          try {
            const handler = Zone[REJECTION_HANDLED_HANDLER];

            if (handler && typeof handler === 'function') {
              handler.call(this, {
                rejection: promise[symbolValue],
                promise: promise
              });
            }
          } catch (err) {}

          promise[symbolState] = REJECTED;

          for (let i = 0; i < _uncaughtPromiseErrors.length; i++) {
            if (promise === _uncaughtPromiseErrors[i].promise) {
              _uncaughtPromiseErrors.splice(i, 1);
            }
          }
        }
      }

      function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {
        clearRejectedNoCatch(promise);
        const promiseState = promise[symbolState];
        const delegate = promiseState ? typeof onFulfilled === 'function' ? onFulfilled : forwardResolution : typeof onRejected === 'function' ? onRejected : forwardRejection;
        zone.scheduleMicroTask(source, () => {
          try {
            const parentPromiseValue = promise[symbolValue];
            const isFinallyPromise = chainPromise && symbolFinally === chainPromise[symbolFinally];

            if (isFinallyPromise) {
              // if the promise is generated from finally call, keep parent promise's state and value
              chainPromise[symbolParentPromiseValue] = parentPromiseValue;
              chainPromise[symbolParentPromiseState] = promiseState;
            } // should not pass value to finally callback


            const value = zone.run(delegate, undefined, isFinallyPromise && delegate !== forwardRejection && delegate !== forwardResolution ? [] : [parentPromiseValue]);
            resolvePromise(chainPromise, true, value);
          } catch (error) {
            // if error occurs, should always return this error
            resolvePromise(chainPromise, false, error);
          }
        }, chainPromise);
      }

      const ZONE_AWARE_PROMISE_TO_STRING = 'function ZoneAwarePromise() { [native code] }';

      class ZoneAwarePromise {
        constructor(executor) {
          const promise = this;

          if (!(promise instanceof ZoneAwarePromise)) {
            throw new Error('Must be an instanceof Promise.');
          }

          promise[symbolState] = UNRESOLVED;
          promise[symbolValue] = []; // queue;

          try {
            executor && executor(makeResolver(promise, RESOLVED), makeResolver(promise, REJECTED));
          } catch (error) {
            resolvePromise(promise, false, error);
          }
        }

        static toString() {
          return ZONE_AWARE_PROMISE_TO_STRING;
        }

        static resolve(value) {
          return resolvePromise(new this(null), RESOLVED, value);
        }

        static reject(error) {
          return resolvePromise(new this(null), REJECTED, error);
        }

        static race(values) {
          let resolve;
          let reject;
          let promise = new this((res, rej) => {
            resolve = res;
            reject = rej;
          });

          function onResolve(value) {
            resolve(value);
          }

          function onReject(error) {
            reject(error);
          }

          for (let value of values) {
            if (!isThenable(value)) {
              value = this.resolve(value);
            }

            value.then(onResolve, onReject);
          }

          return promise;
        }

        static all(values) {
          let resolve;
          let reject;
          let promise = new this((res, rej) => {
            resolve = res;
            reject = rej;
          }); // Start at 2 to prevent prematurely resolving if .then is called immediately.

          let unresolvedCount = 2;
          let valueIndex = 0;
          const resolvedValues = [];

          for (let value of values) {
            if (!isThenable(value)) {
              value = this.resolve(value);
            }

            const curValueIndex = valueIndex;
            value.then(value => {
              resolvedValues[curValueIndex] = value;
              unresolvedCount--;

              if (unresolvedCount === 0) {
                resolve(resolvedValues);
              }
            }, reject);
            unresolvedCount++;
            valueIndex++;
          } // Make the unresolvedCount zero-based again.


          unresolvedCount -= 2;

          if (unresolvedCount === 0) {
            resolve(resolvedValues);
          }

          return promise;
        }

        get [Symbol.toStringTag]() {
          return 'Promise';
        }

        then(onFulfilled, onRejected) {
          const chainPromise = new this.constructor(null);
          const zone = Zone.current;

          if (this[symbolState] == UNRESOLVED) {
            this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);
          } else {
            scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);
          }

          return chainPromise;
        }

        catch(onRejected) {
          return this.then(null, onRejected);
        }

        finally(onFinally) {
          const chainPromise = new this.constructor(null);
          chainPromise[symbolFinally] = symbolFinally;
          const zone = Zone.current;

          if (this[symbolState] == UNRESOLVED) {
            this[symbolValue].push(zone, chainPromise, onFinally, onFinally);
          } else {
            scheduleResolveOrReject(this, zone, chainPromise, onFinally, onFinally);
          }

          return chainPromise;
        }

      } // Protect against aggressive optimizers dropping seemingly unused properties.
      // E.g. Closure Compiler in advanced mode.


      ZoneAwarePromise['resolve'] = ZoneAwarePromise.resolve;
      ZoneAwarePromise['reject'] = ZoneAwarePromise.reject;
      ZoneAwarePromise['race'] = ZoneAwarePromise.race;
      ZoneAwarePromise['all'] = ZoneAwarePromise.all;
      const NativePromise = global[symbolPromise] = global['Promise'];

      const ZONE_AWARE_PROMISE = Zone.__symbol__('ZoneAwarePromise');

      let desc = ObjectGetOwnPropertyDescriptor(global, 'Promise');

      if (!desc || desc.configurable) {
        desc && delete desc.writable;
        desc && delete desc.value;

        if (!desc) {
          desc = {
            configurable: true,
            enumerable: true
          };
        }

        desc.get = function () {
          // if we already set ZoneAwarePromise, use patched one
          // otherwise return native one.
          return global[ZONE_AWARE_PROMISE] ? global[ZONE_AWARE_PROMISE] : global[symbolPromise];
        };

        desc.set = function (NewNativePromise) {
          if (NewNativePromise === ZoneAwarePromise) {
            // if the NewNativePromise is ZoneAwarePromise
            // save to global
            global[ZONE_AWARE_PROMISE] = NewNativePromise;
          } else {
            // if the NewNativePromise is not ZoneAwarePromise
            // for example: after load zone.js, some library just
            // set es6-promise to global, if we set it to global
            // directly, assertZonePatched will fail and angular
            // will not loaded, so we just set the NewNativePromise
            // to global[symbolPromise], so the result is just like
            // we load ES6 Promise before zone.js
            global[symbolPromise] = NewNativePromise;

            if (!NewNativePromise.prototype[symbolThen]) {
              patchThen(NewNativePromise);
            }

            api.setNativePromise(NewNativePromise);
          }
        };

        ObjectDefineProperty(global, 'Promise', desc);
      }

      global['Promise'] = ZoneAwarePromise;

      const symbolThenPatched = __symbol__('thenPatched');

      function patchThen(Ctor) {
        const proto = Ctor.prototype;
        const prop = ObjectGetOwnPropertyDescriptor(proto, 'then');

        if (prop && (prop.writable === false || !prop.configurable)) {
          // check Ctor.prototype.then propertyDescriptor is writable or not
          // in meteor env, writable is false, we should ignore such case
          return;
        }

        const originalThen = proto.then; // Keep a reference to the original method.

        proto[symbolThen] = originalThen;

        Ctor.prototype.then = function (onResolve, onReject) {
          const wrapped = new ZoneAwarePromise((resolve, reject) => {
            originalThen.call(this, resolve, reject);
          });
          return wrapped.then(onResolve, onReject);
        };

        Ctor[symbolThenPatched] = true;
      }

      api.patchThen = patchThen;

      function zoneify(fn) {
        return function () {
          let resultPromise = fn.apply(this, arguments);

          if (resultPromise instanceof ZoneAwarePromise) {
            return resultPromise;
          }

          let ctor = resultPromise.constructor;

          if (!ctor[symbolThenPatched]) {
            patchThen(ctor);
          }

          return resultPromise;
        };
      }

      if (NativePromise) {
        patchThen(NativePromise);
        const fetch = global['fetch'];

        if (typeof fetch == 'function') {
          global[api.symbol('fetch')] = fetch;
          global['fetch'] = zoneify(fetch);
        }
      } // This is not part of public API, but it is useful for tests, so we expose it.


      Promise[Zone.__symbol__('uncaughtPromiseErrors')] = _uncaughtPromiseErrors;
      return ZoneAwarePromise;
    });
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * Suppress closure compiler errors about unknown 'Zone' variable
     * @fileoverview
     * @suppress {undefinedVars,globalThis,missingRequire}
     */
    // issue #989, to reduce bundle size, use short name

    /** Object.getOwnPropertyDescriptor */


    const ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    /** Object.defineProperty */

    const ObjectDefineProperty = Object.defineProperty;
    /** Object.getPrototypeOf */

    const ObjectGetPrototypeOf = Object.getPrototypeOf;
    /** Object.create */

    const ObjectCreate = Object.create;
    /** Array.prototype.slice */

    const ArraySlice = Array.prototype.slice;
    /** addEventListener string const */

    const ADD_EVENT_LISTENER_STR = 'addEventListener';
    /** removeEventListener string const */

    const REMOVE_EVENT_LISTENER_STR = 'removeEventListener';
    /** zoneSymbol addEventListener */

    const ZONE_SYMBOL_ADD_EVENT_LISTENER = Zone.__symbol__(ADD_EVENT_LISTENER_STR);
    /** zoneSymbol removeEventListener */


    const ZONE_SYMBOL_REMOVE_EVENT_LISTENER = Zone.__symbol__(REMOVE_EVENT_LISTENER_STR);
    /** true string const */


    const TRUE_STR = 'true';
    /** false string const */

    const FALSE_STR = 'false';
    /** __zone_symbol__ string const */

    const ZONE_SYMBOL_PREFIX = '__zone_symbol__';

    function wrapWithCurrentZone(callback, source) {
      return Zone.current.wrap(callback, source);
    }

    function scheduleMacroTaskWithCurrentZone(source, callback, data, customSchedule, customCancel) {
      return Zone.current.scheduleMacroTask(source, callback, data, customSchedule, customCancel);
    }

    const zoneSymbol = Zone.__symbol__;
    const isWindowExists = typeof window !== 'undefined';
    const internalWindow = isWindowExists ? window : undefined;

    const _global = isWindowExists && internalWindow || typeof self === 'object' && self || global;

    const REMOVE_ATTRIBUTE = 'removeAttribute';
    const NULL_ON_PROP_VALUE = [null];

    function bindArguments(args, source) {
      for (let i = args.length - 1; i >= 0; i--) {
        if (typeof args[i] === 'function') {
          args[i] = wrapWithCurrentZone(args[i], source + '_' + i);
        }
      }

      return args;
    }

    function patchPrototype(prototype, fnNames) {
      const source = prototype.constructor['name'];

      for (let i = 0; i < fnNames.length; i++) {
        const name = fnNames[i];
        const delegate = prototype[name];

        if (delegate) {
          const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, name);

          if (!isPropertyWritable(prototypeDesc)) {
            continue;
          }

          prototype[name] = (delegate => {
            const patched = function patched() {
              return delegate.apply(this, bindArguments(arguments, source + '.' + name));
            };

            attachOriginToPatched(patched, delegate);
            return patched;
          })(delegate);
        }
      }
    }

    function isPropertyWritable(propertyDesc) {
      if (!propertyDesc) {
        return true;
      }

      if (propertyDesc.writable === false) {
        return false;
      }

      return !(typeof propertyDesc.get === 'function' && typeof propertyDesc.set === 'undefined');
    }

    const isWebWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope; // Make sure to access `process` through `_global` so that WebPack does not accidentally browserify
    // this code.

    const isNode = !('nw' in _global) && typeof _global.process !== 'undefined' && {}.toString.call(_global.process) === '[object process]';
    const isBrowser = !isNode && !isWebWorker && !!(isWindowExists && internalWindow['HTMLElement']); // we are in electron of nw, so we are both browser and nodejs
    // Make sure to access `process` through `_global` so that WebPack does not accidentally browserify
    // this code.

    const isMix = typeof _global.process !== 'undefined' && {}.toString.call(_global.process) === '[object process]' && !isWebWorker && !!(isWindowExists && internalWindow['HTMLElement']);
    const zoneSymbolEventNames = {};

    const wrapFn = function wrapFn(event) {
      // https://github.com/angular/zone.js/issues/911, in IE, sometimes
      // event will be undefined, so we need to use window.event
      event = event || _global.event;

      if (!event) {
        return;
      }

      let eventNameSymbol = zoneSymbolEventNames[event.type];

      if (!eventNameSymbol) {
        eventNameSymbol = zoneSymbolEventNames[event.type] = zoneSymbol('ON_PROPERTY' + event.type);
      }

      const target = this || event.target || _global;
      const listener = target[eventNameSymbol];
      let result;

      if (isBrowser && target === internalWindow && event.type === 'error') {
        // window.onerror have different signiture
        // https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onerror#window.onerror
        // and onerror callback will prevent default when callback return true
        const errorEvent = event;
        result = listener && listener.call(this, errorEvent.message, errorEvent.filename, errorEvent.lineno, errorEvent.colno, errorEvent.error);

        if (result === true) {
          event.preventDefault();
        }
      } else {
        result = listener && listener.apply(this, arguments);

        if (result != undefined && !result) {
          event.preventDefault();
        }
      }

      return result;
    };

    function patchProperty(obj, prop, prototype) {
      let desc = ObjectGetOwnPropertyDescriptor(obj, prop);

      if (!desc && prototype) {
        // when patch window object, use prototype to check prop exist or not
        const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, prop);

        if (prototypeDesc) {
          desc = {
            enumerable: true,
            configurable: true
          };
        }
      } // if the descriptor not exists or is not configurable
      // just return


      if (!desc || !desc.configurable) {
        return;
      }

      const onPropPatchedSymbol = zoneSymbol('on' + prop + 'patched');

      if (obj.hasOwnProperty(onPropPatchedSymbol) && obj[onPropPatchedSymbol]) {
        return;
      } // A property descriptor cannot have getter/setter and be writable
      // deleting the writable and value properties avoids this error:
      //
      // TypeError: property descriptors must not specify a value or be writable when a
      // getter or setter has been specified


      delete desc.writable;
      delete desc.value;
      const originalDescGet = desc.get;
      const originalDescSet = desc.set; // substr(2) cuz 'onclick' -> 'click', etc

      const eventName = prop.substr(2);
      let eventNameSymbol = zoneSymbolEventNames[eventName];

      if (!eventNameSymbol) {
        eventNameSymbol = zoneSymbolEventNames[eventName] = zoneSymbol('ON_PROPERTY' + eventName);
      }

      desc.set = function (newValue) {
        // in some of windows's onproperty callback, this is undefined
        // so we need to check it
        let target = this;

        if (!target && obj === _global) {
          target = _global;
        }

        if (!target) {
          return;
        }

        let previousValue = target[eventNameSymbol];

        if (previousValue) {
          target.removeEventListener(eventName, wrapFn);
        } // issue #978, when onload handler was added before loading zone.js
        // we should remove it with originalDescSet


        if (originalDescSet) {
          originalDescSet.apply(target, NULL_ON_PROP_VALUE);
        }

        if (typeof newValue === 'function') {
          target[eventNameSymbol] = newValue;
          target.addEventListener(eventName, wrapFn, false);
        } else {
          target[eventNameSymbol] = null;
        }
      }; // The getter would return undefined for unassigned properties but the default value of an
      // unassigned property is null


      desc.get = function () {
        // in some of windows's onproperty callback, this is undefined
        // so we need to check it
        let target = this;

        if (!target && obj === _global) {
          target = _global;
        }

        if (!target) {
          return null;
        }

        const listener = target[eventNameSymbol];

        if (listener) {
          return listener;
        } else if (originalDescGet) {
          // result will be null when use inline event attribute,
          // such as <button onclick="func();">OK</button>
          // because the onclick function is internal raw uncompiled handler
          // the onclick will be evaluated when first time event was triggered or
          // the property is accessed, https://github.com/angular/zone.js/issues/525
          // so we should use original native get to retrieve the handler
          let value = originalDescGet && originalDescGet.call(this);

          if (value) {
            desc.set.call(this, value);

            if (typeof target[REMOVE_ATTRIBUTE] === 'function') {
              target.removeAttribute(prop);
            }

            return value;
          }
        }

        return null;
      };

      ObjectDefineProperty(obj, prop, desc);
      obj[onPropPatchedSymbol] = true;
    }

    function patchOnProperties(obj, properties, prototype) {
      if (properties) {
        for (let i = 0; i < properties.length; i++) {
          patchProperty(obj, 'on' + properties[i], prototype);
        }
      } else {
        const onProperties = [];

        for (const prop in obj) {
          if (prop.substr(0, 2) == 'on') {
            onProperties.push(prop);
          }
        }

        for (let j = 0; j < onProperties.length; j++) {
          patchProperty(obj, onProperties[j], prototype);
        }
      }
    }

    const originalInstanceKey = zoneSymbol('originalInstance'); // wrap some native API on `window`

    function patchClass(className) {
      const OriginalClass = _global[className];
      if (!OriginalClass) return; // keep original class in global

      _global[zoneSymbol(className)] = OriginalClass;

      _global[className] = function () {
        const a = bindArguments(arguments, className);

        switch (a.length) {
          case 0:
            this[originalInstanceKey] = new OriginalClass();
            break;

          case 1:
            this[originalInstanceKey] = new OriginalClass(a[0]);
            break;

          case 2:
            this[originalInstanceKey] = new OriginalClass(a[0], a[1]);
            break;

          case 3:
            this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]);
            break;

          case 4:
            this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]);
            break;

          default:
            throw new Error('Arg list too long.');
        }
      }; // attach original delegate to patched function


      attachOriginToPatched(_global[className], OriginalClass);
      const instance = new OriginalClass(function () {});
      let prop;

      for (prop in instance) {
        // https://bugs.webkit.org/show_bug.cgi?id=44721
        if (className === 'XMLHttpRequest' && prop === 'responseBlob') continue;

        (function (prop) {
          if (typeof instance[prop] === 'function') {
            _global[className].prototype[prop] = function () {
              return this[originalInstanceKey][prop].apply(this[originalInstanceKey], arguments);
            };
          } else {
            ObjectDefineProperty(_global[className].prototype, prop, {
              set: function set(fn) {
                if (typeof fn === 'function') {
                  this[originalInstanceKey][prop] = wrapWithCurrentZone(fn, className + '.' + prop); // keep callback in wrapped function so we can
                  // use it in Function.prototype.toString to return
                  // the native one.

                  attachOriginToPatched(this[originalInstanceKey][prop], fn);
                } else {
                  this[originalInstanceKey][prop] = fn;
                }
              },
              get: function get() {
                return this[originalInstanceKey][prop];
              }
            });
          }
        })(prop);
      }

      for (prop in OriginalClass) {
        if (prop !== 'prototype' && OriginalClass.hasOwnProperty(prop)) {
          _global[className][prop] = OriginalClass[prop];
        }
      }
    }

    function copySymbolProperties(src, dest) {
      if (typeof Object.getOwnPropertySymbols !== 'function') {
        return;
      }

      const symbols = Object.getOwnPropertySymbols(src);
      symbols.forEach(symbol => {
        const desc = Object.getOwnPropertyDescriptor(src, symbol);
        Object.defineProperty(dest, symbol, {
          get: function get() {
            return src[symbol];
          },
          set: function set(value) {
            if (desc && (!desc.writable || typeof desc.set !== 'function')) {
              // if src[symbol] is not writable or not have a setter, just return
              return;
            }

            src[symbol] = value;
          },
          enumerable: desc ? desc.enumerable : true,
          configurable: desc ? desc.configurable : true
        });
      });
    }

    let shouldCopySymbolProperties = false;

    function patchMethod(target, name, patchFn) {
      let proto = target;

      while (proto && !proto.hasOwnProperty(name)) {
        proto = ObjectGetPrototypeOf(proto);
      }

      if (!proto && target[name]) {
        // somehow we did not find it, but we can see it. This happens on IE for Window properties.
        proto = target;
      }

      const delegateName = zoneSymbol(name);
      let delegate = null;

      if (proto && !(delegate = proto[delegateName])) {
        delegate = proto[delegateName] = proto[name]; // check whether proto[name] is writable
        // some property is readonly in safari, such as HtmlCanvasElement.prototype.toBlob

        const desc = proto && ObjectGetOwnPropertyDescriptor(proto, name);

        if (isPropertyWritable(desc)) {
          const patchDelegate = patchFn(delegate, delegateName, name);

          proto[name] = function () {
            return patchDelegate(this, arguments);
          };

          attachOriginToPatched(proto[name], delegate);

          if (shouldCopySymbolProperties) {
            copySymbolProperties(delegate, proto[name]);
          }
        }
      }

      return delegate;
    } // TODO: @JiaLiPassion, support cancel task later if necessary


    function patchMacroTask(obj, funcName, metaCreator) {
      let setNative = null;

      function scheduleTask(task) {
        const data = task.data;

        data.args[data.cbIdx] = function () {
          task.invoke.apply(this, arguments);
        };

        setNative.apply(data.target, data.args);
        return task;
      }

      setNative = patchMethod(obj, funcName, delegate => function (self, args) {
        const meta = metaCreator(self, args);

        if (meta.cbIdx >= 0 && typeof args[meta.cbIdx] === 'function') {
          return scheduleMacroTaskWithCurrentZone(meta.name, args[meta.cbIdx], meta, scheduleTask);
        } else {
          // cause an error by calling it directly.
          return delegate.apply(self, args);
        }
      });
    }

    function attachOriginToPatched(patched, original) {
      patched[zoneSymbol('OriginalDelegate')] = original;
    }

    let isDetectedIEOrEdge = false;
    let ieOrEdge = false;

    function isIE() {
      try {
        const ua = internalWindow.navigator.userAgent;

        if (ua.indexOf('MSIE ') !== -1 || ua.indexOf('Trident/') !== -1) {
          return true;
        }
      } catch (error) {}

      return false;
    }

    function isIEOrEdge() {
      if (isDetectedIEOrEdge) {
        return ieOrEdge;
      }

      isDetectedIEOrEdge = true;

      try {
        const ua = internalWindow.navigator.userAgent;

        if (ua.indexOf('MSIE ') !== -1 || ua.indexOf('Trident/') !== -1 || ua.indexOf('Edge/') !== -1) {
          ieOrEdge = true;
        }
      } catch (error) {}

      return ieOrEdge;
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    // override Function.prototype.toString to make zone.js patched function
    // look like native function


    Zone.__load_patch('toString', global => {
      // patch Func.prototype.toString to let them look like native
      const originalFunctionToString = Function.prototype.toString;
      const ORIGINAL_DELEGATE_SYMBOL = zoneSymbol('OriginalDelegate');
      const PROMISE_SYMBOL = zoneSymbol('Promise');
      const ERROR_SYMBOL = zoneSymbol('Error');

      const newFunctionToString = function toString() {
        if (typeof this === 'function') {
          const originalDelegate = this[ORIGINAL_DELEGATE_SYMBOL];

          if (originalDelegate) {
            if (typeof originalDelegate === 'function') {
              return originalFunctionToString.call(originalDelegate);
            } else {
              return Object.prototype.toString.call(originalDelegate);
            }
          }

          if (this === Promise) {
            const nativePromise = global[PROMISE_SYMBOL];

            if (nativePromise) {
              return originalFunctionToString.call(nativePromise);
            }
          }

          if (this === Error) {
            const nativeError = global[ERROR_SYMBOL];

            if (nativeError) {
              return originalFunctionToString.call(nativeError);
            }
          }
        }

        return originalFunctionToString.call(this);
      };

      newFunctionToString[ORIGINAL_DELEGATE_SYMBOL] = originalFunctionToString;
      Function.prototype.toString = newFunctionToString; // patch Object.prototype.toString to let them look like native

      const originalObjectToString = Object.prototype.toString;
      const PROMISE_OBJECT_TO_STRING = '[object Promise]';

      Object.prototype.toString = function () {
        if (this instanceof Promise) {
          return PROMISE_OBJECT_TO_STRING;
        }

        return originalObjectToString.call(this);
      };
    });
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * @fileoverview
     * @suppress {missingRequire}
     */


    let passiveSupported = false;

    if (typeof window !== 'undefined') {
      try {
        const options = Object.defineProperty({}, 'passive', {
          get: function get() {
            passiveSupported = true;
          }
        });
        window.addEventListener('test', options, options);
        window.removeEventListener('test', options, options);
      } catch (err) {
        passiveSupported = false;
      }
    } // an identifier to tell ZoneTask do not create a new invoke closure


    const OPTIMIZED_ZONE_EVENT_TASK_DATA = {
      useG: true
    };
    const zoneSymbolEventNames$1 = {};
    const globalSources = {};
    const EVENT_NAME_SYMBOL_REGX = /^__zone_symbol__(\w+)(true|false)$/;
    const IMMEDIATE_PROPAGATION_SYMBOL = '__zone_symbol__propagationStopped';

    function patchEventTarget(_global, apis, patchOptions) {
      const ADD_EVENT_LISTENER = patchOptions && patchOptions.add || ADD_EVENT_LISTENER_STR;
      const REMOVE_EVENT_LISTENER = patchOptions && patchOptions.rm || REMOVE_EVENT_LISTENER_STR;
      const LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.listeners || 'eventListeners';
      const REMOVE_ALL_LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.rmAll || 'removeAllListeners';
      const zoneSymbolAddEventListener = zoneSymbol(ADD_EVENT_LISTENER);
      const ADD_EVENT_LISTENER_SOURCE = '.' + ADD_EVENT_LISTENER + ':';
      const PREPEND_EVENT_LISTENER = 'prependListener';
      const PREPEND_EVENT_LISTENER_SOURCE = '.' + PREPEND_EVENT_LISTENER + ':';

      const invokeTask = function invokeTask(task, target, event) {
        // for better performance, check isRemoved which is set
        // by removeEventListener
        if (task.isRemoved) {
          return;
        }

        const delegate = task.callback;

        if (typeof delegate === 'object' && delegate.handleEvent) {
          // create the bind version of handleEvent when invoke
          task.callback = event => delegate.handleEvent(event);

          task.originalDelegate = delegate;
        } // invoke static task.invoke


        task.invoke(task, target, [event]);
        const options = task.options;

        if (options && typeof options === 'object' && options.once) {
          // if options.once is true, after invoke once remove listener here
          // only browser need to do this, nodejs eventEmitter will cal removeListener
          // inside EventEmitter.once
          const delegate = task.originalDelegate ? task.originalDelegate : task.callback;
          target[REMOVE_EVENT_LISTENER].call(target, event.type, delegate, options);
        }
      }; // global shared zoneAwareCallback to handle all event callback with capture = false


      const globalZoneAwareCallback = function globalZoneAwareCallback(event) {
        // https://github.com/angular/zone.js/issues/911, in IE, sometimes
        // event will be undefined, so we need to use window.event
        event = event || _global.event;

        if (!event) {
          return;
        } // event.target is needed for Samsung TV and SourceBuffer
        // || global is needed https://github.com/angular/zone.js/issues/190


        const target = this || event.target || _global;
        const tasks = target[zoneSymbolEventNames$1[event.type][FALSE_STR]];

        if (tasks) {
          // invoke all tasks which attached to current target with given event.type and capture = false
          // for performance concern, if task.length === 1, just invoke
          if (tasks.length === 1) {
            invokeTask(tasks[0], target, event);
          } else {
            // https://github.com/angular/zone.js/issues/836
            // copy the tasks array before invoke, to avoid
            // the callback will remove itself or other listener
            const copyTasks = tasks.slice();

            for (let i = 0; i < copyTasks.length; i++) {
              if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {
                break;
              }

              invokeTask(copyTasks[i], target, event);
            }
          }
        }
      }; // global shared zoneAwareCallback to handle all event callback with capture = true


      const globalZoneAwareCaptureCallback = function globalZoneAwareCaptureCallback(event) {
        // https://github.com/angular/zone.js/issues/911, in IE, sometimes
        // event will be undefined, so we need to use window.event
        event = event || _global.event;

        if (!event) {
          return;
        } // event.target is needed for Samsung TV and SourceBuffer
        // || global is needed https://github.com/angular/zone.js/issues/190


        const target = this || event.target || _global;
        const tasks = target[zoneSymbolEventNames$1[event.type][TRUE_STR]];

        if (tasks) {
          // invoke all tasks which attached to current target with given event.type and capture = false
          // for performance concern, if task.length === 1, just invoke
          if (tasks.length === 1) {
            invokeTask(tasks[0], target, event);
          } else {
            // https://github.com/angular/zone.js/issues/836
            // copy the tasks array before invoke, to avoid
            // the callback will remove itself or other listener
            const copyTasks = tasks.slice();

            for (let i = 0; i < copyTasks.length; i++) {
              if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {
                break;
              }

              invokeTask(copyTasks[i], target, event);
            }
          }
        }
      };

      function patchEventTargetMethods(obj, patchOptions) {
        if (!obj) {
          return false;
        }

        let useGlobalCallback = true;

        if (patchOptions && patchOptions.useG !== undefined) {
          useGlobalCallback = patchOptions.useG;
        }

        const validateHandler = patchOptions && patchOptions.vh;
        let checkDuplicate = true;

        if (patchOptions && patchOptions.chkDup !== undefined) {
          checkDuplicate = patchOptions.chkDup;
        }

        let returnTarget = false;

        if (patchOptions && patchOptions.rt !== undefined) {
          returnTarget = patchOptions.rt;
        }

        let proto = obj;

        while (proto && !proto.hasOwnProperty(ADD_EVENT_LISTENER)) {
          proto = ObjectGetPrototypeOf(proto);
        }

        if (!proto && obj[ADD_EVENT_LISTENER]) {
          // somehow we did not find it, but we can see it. This happens on IE for Window properties.
          proto = obj;
        }

        if (!proto) {
          return false;
        }

        if (proto[zoneSymbolAddEventListener]) {
          return false;
        }

        const eventNameToString = patchOptions && patchOptions.eventNameToString; // a shared global taskData to pass data for scheduleEventTask
        // so we do not need to create a new object just for pass some data

        const taskData = {};
        const nativeAddEventListener = proto[zoneSymbolAddEventListener] = proto[ADD_EVENT_LISTENER];
        const nativeRemoveEventListener = proto[zoneSymbol(REMOVE_EVENT_LISTENER)] = proto[REMOVE_EVENT_LISTENER];
        const nativeListeners = proto[zoneSymbol(LISTENERS_EVENT_LISTENER)] = proto[LISTENERS_EVENT_LISTENER];
        const nativeRemoveAllListeners = proto[zoneSymbol(REMOVE_ALL_LISTENERS_EVENT_LISTENER)] = proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER];
        let nativePrependEventListener;

        if (patchOptions && patchOptions.prepend) {
          nativePrependEventListener = proto[zoneSymbol(patchOptions.prepend)] = proto[patchOptions.prepend];
        }

        function checkIsPassive(task) {
          if (!passiveSupported && typeof taskData.options !== 'boolean' && typeof taskData.options !== 'undefined' && taskData.options !== null) {
            // options is a non-null non-undefined object
            // passive is not supported
            // don't pass options as object
            // just pass capture as a boolean
            task.options = !!taskData.options.capture;
            taskData.options = task.options;
          }
        }

        const customScheduleGlobal = function customScheduleGlobal(task) {
          // if there is already a task for the eventName + capture,
          // just return, because we use the shared globalZoneAwareCallback here.
          if (taskData.isExisting) {
            return;
          }

          checkIsPassive(task);
          return nativeAddEventListener.call(taskData.target, taskData.eventName, taskData.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, taskData.options);
        };

        const customCancelGlobal = function customCancelGlobal(task) {
          // if task is not marked as isRemoved, this call is directly
          // from Zone.prototype.cancelTask, we should remove the task
          // from tasksList of target first
          if (!task.isRemoved) {
            const symbolEventNames = zoneSymbolEventNames$1[task.eventName];
            let symbolEventName;

            if (symbolEventNames) {
              symbolEventName = symbolEventNames[task.capture ? TRUE_STR : FALSE_STR];
            }

            const existingTasks = symbolEventName && task.target[symbolEventName];

            if (existingTasks) {
              for (let i = 0; i < existingTasks.length; i++) {
                const existingTask = existingTasks[i];

                if (existingTask === task) {
                  existingTasks.splice(i, 1); // set isRemoved to data for faster invokeTask check

                  task.isRemoved = true;

                  if (existingTasks.length === 0) {
                    // all tasks for the eventName + capture have gone,
                    // remove globalZoneAwareCallback and remove the task cache from target
                    task.allRemoved = true;
                    task.target[symbolEventName] = null;
                  }

                  break;
                }
              }
            }
          } // if all tasks for the eventName + capture have gone,
          // we will really remove the global event callback,
          // if not, return


          if (!task.allRemoved) {
            return;
          }

          return nativeRemoveEventListener.call(task.target, task.eventName, task.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, task.options);
        };

        const customScheduleNonGlobal = function customScheduleNonGlobal(task) {
          checkIsPassive(task);
          return nativeAddEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);
        };

        const customSchedulePrepend = function customSchedulePrepend(task) {
          return nativePrependEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);
        };

        const customCancelNonGlobal = function customCancelNonGlobal(task) {
          return nativeRemoveEventListener.call(task.target, task.eventName, task.invoke, task.options);
        };

        const customSchedule = useGlobalCallback ? customScheduleGlobal : customScheduleNonGlobal;
        const customCancel = useGlobalCallback ? customCancelGlobal : customCancelNonGlobal;

        const compareTaskCallbackVsDelegate = function compareTaskCallbackVsDelegate(task, delegate) {
          const typeOfDelegate = typeof delegate;
          return typeOfDelegate === 'function' && task.callback === delegate || typeOfDelegate === 'object' && task.originalDelegate === delegate;
        };

        const compare = patchOptions && patchOptions.diff ? patchOptions.diff : compareTaskCallbackVsDelegate;

        const blackListedEvents = Zone[Zone.__symbol__('BLACK_LISTED_EVENTS')];

        const makeAddListener = function makeAddListener(nativeListener, addSource, customScheduleFn, customCancelFn, returnTarget = false, prepend = false) {
          return function () {
            const target = this || _global;
            const eventName = arguments[0];
            let delegate = arguments[1];

            if (!delegate) {
              return nativeListener.apply(this, arguments);
            }

            if (isNode && eventName === 'uncaughtException') {
              // don't patch uncaughtException of nodejs to prevent endless loop
              return nativeListener.apply(this, arguments);
            } // don't create the bind delegate function for handleEvent
            // case here to improve addEventListener performance
            // we will create the bind delegate when invoke


            let isHandleEvent = false;

            if (typeof delegate !== 'function') {
              if (!delegate.handleEvent) {
                return nativeListener.apply(this, arguments);
              }

              isHandleEvent = true;
            }

            if (validateHandler && !validateHandler(nativeListener, delegate, target, arguments)) {
              return;
            }

            const options = arguments[2];

            if (blackListedEvents) {
              // check black list
              for (let i = 0; i < blackListedEvents.length; i++) {
                if (eventName === blackListedEvents[i]) {
                  return nativeListener.apply(this, arguments);
                }
              }
            }

            let capture;
            let once = false;

            if (options === undefined) {
              capture = false;
            } else if (options === true) {
              capture = true;
            } else if (options === false) {
              capture = false;
            } else {
              capture = options ? !!options.capture : false;
              once = options ? !!options.once : false;
            }

            const zone = Zone.current;
            const symbolEventNames = zoneSymbolEventNames$1[eventName];
            let symbolEventName;

            if (!symbolEventNames) {
              // the code is duplicate, but I just want to get some better performance
              const falseEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + FALSE_STR;
              const trueEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + TRUE_STR;
              const symbol = ZONE_SYMBOL_PREFIX + falseEventName;
              const symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;
              zoneSymbolEventNames$1[eventName] = {};
              zoneSymbolEventNames$1[eventName][FALSE_STR] = symbol;
              zoneSymbolEventNames$1[eventName][TRUE_STR] = symbolCapture;
              symbolEventName = capture ? symbolCapture : symbol;
            } else {
              symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
            }

            let existingTasks = target[symbolEventName];
            let isExisting = false;

            if (existingTasks) {
              // already have task registered
              isExisting = true;

              if (checkDuplicate) {
                for (let i = 0; i < existingTasks.length; i++) {
                  if (compare(existingTasks[i], delegate)) {
                    // same callback, same capture, same event name, just return
                    return;
                  }
                }
              }
            } else {
              existingTasks = target[symbolEventName] = [];
            }

            let source;
            const constructorName = target.constructor['name'];
            const targetSource = globalSources[constructorName];

            if (targetSource) {
              source = targetSource[eventName];
            }

            if (!source) {
              source = constructorName + addSource + (eventNameToString ? eventNameToString(eventName) : eventName);
            } // do not create a new object as task.data to pass those things
            // just use the global shared one


            taskData.options = options;

            if (once) {
              // if addEventListener with once options, we don't pass it to
              // native addEventListener, instead we keep the once setting
              // and handle ourselves.
              taskData.options.once = false;
            }

            taskData.target = target;
            taskData.capture = capture;
            taskData.eventName = eventName;
            taskData.isExisting = isExisting;
            const data = useGlobalCallback ? OPTIMIZED_ZONE_EVENT_TASK_DATA : undefined; // keep taskData into data to allow onScheduleEventTask to access the task information

            if (data) {
              data.taskData = taskData;
            }

            const task = zone.scheduleEventTask(source, delegate, data, customScheduleFn, customCancelFn); // should clear taskData.target to avoid memory leak
            // issue, https://github.com/angular/angular/issues/20442

            taskData.target = null; // need to clear up taskData because it is a global object

            if (data) {
              data.taskData = null;
            } // have to save those information to task in case
            // application may call task.zone.cancelTask() directly


            if (once) {
              options.once = true;
            }

            if (!(!passiveSupported && typeof task.options === 'boolean')) {
              // if not support passive, and we pass an option object
              // to addEventListener, we should save the options to task
              task.options = options;
            }

            task.target = target;
            task.capture = capture;
            task.eventName = eventName;

            if (isHandleEvent) {
              // save original delegate for compare to check duplicate
              task.originalDelegate = delegate;
            }

            if (!prepend) {
              existingTasks.push(task);
            } else {
              existingTasks.unshift(task);
            }

            if (returnTarget) {
              return target;
            }
          };
        };

        proto[ADD_EVENT_LISTENER] = makeAddListener(nativeAddEventListener, ADD_EVENT_LISTENER_SOURCE, customSchedule, customCancel, returnTarget);

        if (nativePrependEventListener) {
          proto[PREPEND_EVENT_LISTENER] = makeAddListener(nativePrependEventListener, PREPEND_EVENT_LISTENER_SOURCE, customSchedulePrepend, customCancel, returnTarget, true);
        }

        proto[REMOVE_EVENT_LISTENER] = function () {
          const target = this || _global;
          const eventName = arguments[0];
          const options = arguments[2];
          let capture;

          if (options === undefined) {
            capture = false;
          } else if (options === true) {
            capture = true;
          } else if (options === false) {
            capture = false;
          } else {
            capture = options ? !!options.capture : false;
          }

          const delegate = arguments[1];

          if (!delegate) {
            return nativeRemoveEventListener.apply(this, arguments);
          }

          if (validateHandler && !validateHandler(nativeRemoveEventListener, delegate, target, arguments)) {
            return;
          }

          const symbolEventNames = zoneSymbolEventNames$1[eventName];
          let symbolEventName;

          if (symbolEventNames) {
            symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];
          }

          const existingTasks = symbolEventName && target[symbolEventName];

          if (existingTasks) {
            for (let i = 0; i < existingTasks.length; i++) {
              const existingTask = existingTasks[i];

              if (compare(existingTask, delegate)) {
                existingTasks.splice(i, 1); // set isRemoved to data for faster invokeTask check

                existingTask.isRemoved = true;

                if (existingTasks.length === 0) {
                  // all tasks for the eventName + capture have gone,
                  // remove globalZoneAwareCallback and remove the task cache from target
                  existingTask.allRemoved = true;
                  target[symbolEventName] = null;
                }

                existingTask.zone.cancelTask(existingTask);

                if (returnTarget) {
                  return target;
                }

                return;
              }
            }
          } // issue 930, didn't find the event name or callback
          // from zone kept existingTasks, the callback maybe
          // added outside of zone, we need to call native removeEventListener
          // to try to remove it.


          return nativeRemoveEventListener.apply(this, arguments);
        };

        proto[LISTENERS_EVENT_LISTENER] = function () {
          const target = this || _global;
          const eventName = arguments[0];
          const listeners = [];
          const tasks = findEventTasks(target, eventNameToString ? eventNameToString(eventName) : eventName);

          for (let i = 0; i < tasks.length; i++) {
            const task = tasks[i];
            let delegate = task.originalDelegate ? task.originalDelegate : task.callback;
            listeners.push(delegate);
          }

          return listeners;
        };

        proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER] = function () {
          const target = this || _global;
          const eventName = arguments[0];

          if (!eventName) {
            const keys = Object.keys(target);

            for (let i = 0; i < keys.length; i++) {
              const prop = keys[i];
              const match = EVENT_NAME_SYMBOL_REGX.exec(prop);
              let evtName = match && match[1]; // in nodejs EventEmitter, removeListener event is
              // used for monitoring the removeListener call,
              // so just keep removeListener eventListener until
              // all other eventListeners are removed

              if (evtName && evtName !== 'removeListener') {
                this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, evtName);
              }
            } // remove removeListener listener finally


            this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, 'removeListener');
          } else {
            const symbolEventNames = zoneSymbolEventNames$1[eventName];

            if (symbolEventNames) {
              const symbolEventName = symbolEventNames[FALSE_STR];
              const symbolCaptureEventName = symbolEventNames[TRUE_STR];
              const tasks = target[symbolEventName];
              const captureTasks = target[symbolCaptureEventName];

              if (tasks) {
                const removeTasks = tasks.slice();

                for (let i = 0; i < removeTasks.length; i++) {
                  const task = removeTasks[i];
                  let delegate = task.originalDelegate ? task.originalDelegate : task.callback;
                  this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);
                }
              }

              if (captureTasks) {
                const removeTasks = captureTasks.slice();

                for (let i = 0; i < removeTasks.length; i++) {
                  const task = removeTasks[i];
                  let delegate = task.originalDelegate ? task.originalDelegate : task.callback;
                  this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);
                }
              }
            }
          }

          if (returnTarget) {
            return this;
          }
        }; // for native toString patch


        attachOriginToPatched(proto[ADD_EVENT_LISTENER], nativeAddEventListener);
        attachOriginToPatched(proto[REMOVE_EVENT_LISTENER], nativeRemoveEventListener);

        if (nativeRemoveAllListeners) {
          attachOriginToPatched(proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER], nativeRemoveAllListeners);
        }

        if (nativeListeners) {
          attachOriginToPatched(proto[LISTENERS_EVENT_LISTENER], nativeListeners);
        }

        return true;
      }

      let results = [];

      for (let i = 0; i < apis.length; i++) {
        results[i] = patchEventTargetMethods(apis[i], patchOptions);
      }

      return results;
    }

    function findEventTasks(target, eventName) {
      const foundTasks = [];

      for (let prop in target) {
        const match = EVENT_NAME_SYMBOL_REGX.exec(prop);
        let evtName = match && match[1];

        if (evtName && (!eventName || evtName === eventName)) {
          const tasks = target[prop];

          if (tasks) {
            for (let i = 0; i < tasks.length; i++) {
              foundTasks.push(tasks[i]);
            }
          }
        }
      }

      return foundTasks;
    }

    function patchEventPrototype(global, api) {
      const Event = global['Event'];

      if (Event && Event.prototype) {
        api.patchMethod(Event.prototype, 'stopImmediatePropagation', delegate => function (self, args) {
          self[IMMEDIATE_PROPAGATION_SYMBOL] = true; // we need to call the native stopImmediatePropagation
          // in case in some hybrid application, some part of
          // application will be controlled by zone, some are not

          delegate && delegate.apply(self, args);
        });
      }
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    function patchCallbacks(api, target, targetName, method, callbacks) {
      const symbol = Zone.__symbol__(method);

      if (target[symbol]) {
        return;
      }

      const nativeDelegate = target[symbol] = target[method];

      target[method] = function (name, opts, options) {
        if (opts && opts.prototype) {
          callbacks.forEach(function (callback) {
            const source = "".concat(targetName, ".").concat(method, "::") + callback;
            const prototype = opts.prototype;

            if (prototype.hasOwnProperty(callback)) {
              const descriptor = api.ObjectGetOwnPropertyDescriptor(prototype, callback);

              if (descriptor && descriptor.value) {
                descriptor.value = api.wrapWithCurrentZone(descriptor.value, source);

                api._redefineProperty(opts.prototype, callback, descriptor);
              } else if (prototype[callback]) {
                prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);
              }
            } else if (prototype[callback]) {
              prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);
            }
          });
        }

        return nativeDelegate.call(target, name, opts, options);
      };

      api.attachOriginToPatched(target[method], nativeDelegate);
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /*
     * This is necessary for Chrome and Chrome mobile, to enable
     * things like redefining `createdCallback` on an element.
     */


    const zoneSymbol$1 = Zone.__symbol__;

    const _defineProperty = Object[zoneSymbol$1('defineProperty')] = Object.defineProperty;

    const _getOwnPropertyDescriptor = Object[zoneSymbol$1('getOwnPropertyDescriptor')] = Object.getOwnPropertyDescriptor;

    const _create = Object.create;
    const unconfigurablesKey = zoneSymbol$1('unconfigurables');

    function propertyPatch() {
      Object.defineProperty = function (obj, prop, desc) {
        if (isUnconfigurable(obj, prop)) {
          throw new TypeError('Cannot assign to read only property \'' + prop + '\' of ' + obj);
        }

        const originalConfigurableFlag = desc.configurable;

        if (prop !== 'prototype') {
          desc = rewriteDescriptor(obj, prop, desc);
        }

        return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);
      };

      Object.defineProperties = function (obj, props) {
        Object.keys(props).forEach(function (prop) {
          Object.defineProperty(obj, prop, props[prop]);
        });
        return obj;
      };

      Object.create = function (obj, proto) {
        if (typeof proto === 'object' && !Object.isFrozen(proto)) {
          Object.keys(proto).forEach(function (prop) {
            proto[prop] = rewriteDescriptor(obj, prop, proto[prop]);
          });
        }

        return _create(obj, proto);
      };

      Object.getOwnPropertyDescriptor = function (obj, prop) {
        const desc = _getOwnPropertyDescriptor(obj, prop);

        if (desc && isUnconfigurable(obj, prop)) {
          desc.configurable = false;
        }

        return desc;
      };
    }

    function _redefineProperty(obj, prop, desc) {
      const originalConfigurableFlag = desc.configurable;
      desc = rewriteDescriptor(obj, prop, desc);
      return _tryDefineProperty(obj, prop, desc, originalConfigurableFlag);
    }

    function isUnconfigurable(obj, prop) {
      return obj && obj[unconfigurablesKey] && obj[unconfigurablesKey][prop];
    }

    function rewriteDescriptor(obj, prop, desc) {
      // issue-927, if the desc is frozen, don't try to change the desc
      if (!Object.isFrozen(desc)) {
        desc.configurable = true;
      }

      if (!desc.configurable) {
        // issue-927, if the obj is frozen, don't try to set the desc to obj
        if (!obj[unconfigurablesKey] && !Object.isFrozen(obj)) {
          _defineProperty(obj, unconfigurablesKey, {
            writable: true,
            value: {}
          });
        }

        if (obj[unconfigurablesKey]) {
          obj[unconfigurablesKey][prop] = true;
        }
      }

      return desc;
    }

    function _tryDefineProperty(obj, prop, desc, originalConfigurableFlag) {
      try {
        return _defineProperty(obj, prop, desc);
      } catch (error) {
        if (desc.configurable) {
          // In case of errors, when the configurable flag was likely set by rewriteDescriptor(), let's
          // retry with the original flag value
          if (typeof originalConfigurableFlag == 'undefined') {
            delete desc.configurable;
          } else {
            desc.configurable = originalConfigurableFlag;
          }

          try {
            return _defineProperty(obj, prop, desc);
          } catch (error) {
            let descJson = null;

            try {
              descJson = JSON.stringify(desc);
            } catch (error) {
              descJson = desc.toString();
            }

            console.log("Attempting to configure '".concat(prop, "' with descriptor '").concat(descJson, "' on object '").concat(obj, "' and got error, giving up: ").concat(error));
          }
        } else {
          throw error;
        }
      }
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * @fileoverview
     * @suppress {globalThis}
     */


    const globalEventHandlersEventNames = ['abort', 'animationcancel', 'animationend', 'animationiteration', 'auxclick', 'beforeinput', 'blur', 'cancel', 'canplay', 'canplaythrough', 'change', 'compositionstart', 'compositionupdate', 'compositionend', 'cuechange', 'click', 'close', 'contextmenu', 'curechange', 'dblclick', 'drag', 'dragend', 'dragenter', 'dragexit', 'dragleave', 'dragover', 'drop', 'durationchange', 'emptied', 'ended', 'error', 'focus', 'focusin', 'focusout', 'gotpointercapture', 'input', 'invalid', 'keydown', 'keypress', 'keyup', 'load', 'loadstart', 'loadeddata', 'loadedmetadata', 'lostpointercapture', 'mousedown', 'mouseenter', 'mouseleave', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'mousewheel', 'orientationchange', 'pause', 'play', 'playing', 'pointercancel', 'pointerdown', 'pointerenter', 'pointerleave', 'pointerlockchange', 'mozpointerlockchange', 'webkitpointerlockerchange', 'pointerlockerror', 'mozpointerlockerror', 'webkitpointerlockerror', 'pointermove', 'pointout', 'pointerover', 'pointerup', 'progress', 'ratechange', 'reset', 'resize', 'scroll', 'seeked', 'seeking', 'select', 'selectionchange', 'selectstart', 'show', 'sort', 'stalled', 'submit', 'suspend', 'timeupdate', 'volumechange', 'touchcancel', 'touchmove', 'touchstart', 'touchend', 'transitioncancel', 'transitionend', 'waiting', 'wheel'];
    const documentEventNames = ['afterscriptexecute', 'beforescriptexecute', 'DOMContentLoaded', 'freeze', 'fullscreenchange', 'mozfullscreenchange', 'webkitfullscreenchange', 'msfullscreenchange', 'fullscreenerror', 'mozfullscreenerror', 'webkitfullscreenerror', 'msfullscreenerror', 'readystatechange', 'visibilitychange', 'resume'];
    const windowEventNames = ['absolutedeviceorientation', 'afterinput', 'afterprint', 'appinstalled', 'beforeinstallprompt', 'beforeprint', 'beforeunload', 'devicelight', 'devicemotion', 'deviceorientation', 'deviceorientationabsolute', 'deviceproximity', 'hashchange', 'languagechange', 'message', 'mozbeforepaint', 'offline', 'online', 'paint', 'pageshow', 'pagehide', 'popstate', 'rejectionhandled', 'storage', 'unhandledrejection', 'unload', 'userproximity', 'vrdisplyconnected', 'vrdisplaydisconnected', 'vrdisplaypresentchange'];
    const htmlElementEventNames = ['beforecopy', 'beforecut', 'beforepaste', 'copy', 'cut', 'paste', 'dragstart', 'loadend', 'animationstart', 'search', 'transitionrun', 'transitionstart', 'webkitanimationend', 'webkitanimationiteration', 'webkitanimationstart', 'webkittransitionend'];
    const mediaElementEventNames = ['encrypted', 'waitingforkey', 'msneedkey', 'mozinterruptbegin', 'mozinterruptend'];
    const ieElementEventNames = ['activate', 'afterupdate', 'ariarequest', 'beforeactivate', 'beforedeactivate', 'beforeeditfocus', 'beforeupdate', 'cellchange', 'controlselect', 'dataavailable', 'datasetchanged', 'datasetcomplete', 'errorupdate', 'filterchange', 'layoutcomplete', 'losecapture', 'move', 'moveend', 'movestart', 'propertychange', 'resizeend', 'resizestart', 'rowenter', 'rowexit', 'rowsdelete', 'rowsinserted', 'command', 'compassneedscalibration', 'deactivate', 'help', 'mscontentzoom', 'msmanipulationstatechanged', 'msgesturechange', 'msgesturedoubletap', 'msgestureend', 'msgesturehold', 'msgesturestart', 'msgesturetap', 'msgotpointercapture', 'msinertiastart', 'mslostpointercapture', 'mspointercancel', 'mspointerdown', 'mspointerenter', 'mspointerhover', 'mspointerleave', 'mspointermove', 'mspointerout', 'mspointerover', 'mspointerup', 'pointerout', 'mssitemodejumplistitemremoved', 'msthumbnailclick', 'stop', 'storagecommit'];
    const webglEventNames = ['webglcontextrestored', 'webglcontextlost', 'webglcontextcreationerror'];
    const formEventNames = ['autocomplete', 'autocompleteerror'];
    const detailEventNames = ['toggle'];
    const frameEventNames = ['load'];
    const frameSetEventNames = ['blur', 'error', 'focus', 'load', 'resize', 'scroll', 'messageerror'];
    const marqueeEventNames = ['bounce', 'finish', 'start'];
    const XMLHttpRequestEventNames = ['loadstart', 'progress', 'abort', 'error', 'load', 'progress', 'timeout', 'loadend', 'readystatechange'];
    const IDBIndexEventNames = ['upgradeneeded', 'complete', 'abort', 'success', 'error', 'blocked', 'versionchange', 'close'];
    const websocketEventNames = ['close', 'error', 'open', 'message'];
    const workerEventNames = ['error', 'message'];
    const eventNames = globalEventHandlersEventNames.concat(webglEventNames, formEventNames, detailEventNames, documentEventNames, windowEventNames, htmlElementEventNames, ieElementEventNames);

    function filterProperties(target, onProperties, ignoreProperties) {
      if (!ignoreProperties || ignoreProperties.length === 0) {
        return onProperties;
      }

      const tip = ignoreProperties.filter(ip => ip.target === target);

      if (!tip || tip.length === 0) {
        return onProperties;
      }

      const targetIgnoreProperties = tip[0].ignoreProperties;
      return onProperties.filter(op => targetIgnoreProperties.indexOf(op) === -1);
    }

    function patchFilteredProperties(target, onProperties, ignoreProperties, prototype) {
      // check whether target is available, sometimes target will be undefined
      // because different browser or some 3rd party plugin.
      if (!target) {
        return;
      }

      const filteredProperties = filterProperties(target, onProperties, ignoreProperties);
      patchOnProperties(target, filteredProperties, prototype);
    }

    function propertyDescriptorPatch(api, _global) {
      if (isNode && !isMix) {
        return;
      }

      if (Zone[api.symbol('patchEvents')]) {
        // events are already been patched by legacy patch.
        return;
      }

      const supportsWebSocket = typeof WebSocket !== 'undefined';
      const ignoreProperties = _global['__Zone_ignore_on_properties']; // for browsers that we can patch the descriptor:  Chrome & Firefox

      if (isBrowser) {
        const internalWindow = window;
        const ignoreErrorProperties = isIE ? [{
          target: internalWindow,
          ignoreProperties: ['error']
        }] : []; // in IE/Edge, onProp not exist in window object, but in WindowPrototype
        // so we need to pass WindowPrototype to check onProp exist or not

        patchFilteredProperties(internalWindow, eventNames.concat(['messageerror']), ignoreProperties ? ignoreProperties.concat(ignoreErrorProperties) : ignoreProperties, ObjectGetPrototypeOf(internalWindow));
        patchFilteredProperties(Document.prototype, eventNames, ignoreProperties);

        if (typeof internalWindow['SVGElement'] !== 'undefined') {
          patchFilteredProperties(internalWindow['SVGElement'].prototype, eventNames, ignoreProperties);
        }

        patchFilteredProperties(Element.prototype, eventNames, ignoreProperties);
        patchFilteredProperties(HTMLElement.prototype, eventNames, ignoreProperties);
        patchFilteredProperties(HTMLMediaElement.prototype, mediaElementEventNames, ignoreProperties);
        patchFilteredProperties(HTMLFrameSetElement.prototype, windowEventNames.concat(frameSetEventNames), ignoreProperties);
        patchFilteredProperties(HTMLBodyElement.prototype, windowEventNames.concat(frameSetEventNames), ignoreProperties);
        patchFilteredProperties(HTMLFrameElement.prototype, frameEventNames, ignoreProperties);
        patchFilteredProperties(HTMLIFrameElement.prototype, frameEventNames, ignoreProperties);
        const HTMLMarqueeElement = internalWindow['HTMLMarqueeElement'];

        if (HTMLMarqueeElement) {
          patchFilteredProperties(HTMLMarqueeElement.prototype, marqueeEventNames, ignoreProperties);
        }

        const Worker = internalWindow['Worker'];

        if (Worker) {
          patchFilteredProperties(Worker.prototype, workerEventNames, ignoreProperties);
        }
      }

      const XMLHttpRequest = _global['XMLHttpRequest'];

      if (XMLHttpRequest) {
        // XMLHttpRequest is not available in ServiceWorker, so we need to check here
        patchFilteredProperties(XMLHttpRequest.prototype, XMLHttpRequestEventNames, ignoreProperties);
      }

      const XMLHttpRequestEventTarget = _global['XMLHttpRequestEventTarget'];

      if (XMLHttpRequestEventTarget) {
        patchFilteredProperties(XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype, XMLHttpRequestEventNames, ignoreProperties);
      }

      if (typeof IDBIndex !== 'undefined') {
        patchFilteredProperties(IDBIndex.prototype, IDBIndexEventNames, ignoreProperties);
        patchFilteredProperties(IDBRequest.prototype, IDBIndexEventNames, ignoreProperties);
        patchFilteredProperties(IDBOpenDBRequest.prototype, IDBIndexEventNames, ignoreProperties);
        patchFilteredProperties(IDBDatabase.prototype, IDBIndexEventNames, ignoreProperties);
        patchFilteredProperties(IDBTransaction.prototype, IDBIndexEventNames, ignoreProperties);
        patchFilteredProperties(IDBCursor.prototype, IDBIndexEventNames, ignoreProperties);
      }

      if (supportsWebSocket) {
        patchFilteredProperties(WebSocket.prototype, websocketEventNames, ignoreProperties);
      }
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    Zone.__load_patch('util', (global, Zone, api) => {
      api.patchOnProperties = patchOnProperties;
      api.patchMethod = patchMethod;
      api.bindArguments = bindArguments;
      api.patchMacroTask = patchMacroTask; // In earlier version of zone.js (<0.9.0), we use env name `__zone_symbol__BLACK_LISTED_EVENTS` to
      // define which events will not be patched by `Zone.js`.
      // In newer version (>=0.9.0), we change the env name to `__zone_symbol__UNPATCHED_EVENTS` to keep
      // the name consistent with angular repo.
      // The  `__zone_symbol__BLACK_LISTED_EVENTS` is deprecated, but it is still be supported for
      // backwards compatibility.

      const SYMBOL_BLACK_LISTED_EVENTS = Zone.__symbol__('BLACK_LISTED_EVENTS');

      const SYMBOL_UNPATCHED_EVENTS = Zone.__symbol__('UNPATCHED_EVENTS');

      if (global[SYMBOL_UNPATCHED_EVENTS]) {
        global[SYMBOL_BLACK_LISTED_EVENTS] = global[SYMBOL_UNPATCHED_EVENTS];
      }

      if (global[SYMBOL_BLACK_LISTED_EVENTS]) {
        Zone[SYMBOL_BLACK_LISTED_EVENTS] = Zone[SYMBOL_UNPATCHED_EVENTS] = global[SYMBOL_BLACK_LISTED_EVENTS];
      }

      api.patchEventPrototype = patchEventPrototype;
      api.patchEventTarget = patchEventTarget;
      api.isIEOrEdge = isIEOrEdge;
      api.ObjectDefineProperty = ObjectDefineProperty;
      api.ObjectGetOwnPropertyDescriptor = ObjectGetOwnPropertyDescriptor;
      api.ObjectCreate = ObjectCreate;
      api.ArraySlice = ArraySlice;
      api.patchClass = patchClass;
      api.wrapWithCurrentZone = wrapWithCurrentZone;
      api.filterProperties = filterProperties;
      api.attachOriginToPatched = attachOriginToPatched;
      api._redefineProperty = _redefineProperty;
      api.patchCallbacks = patchCallbacks;

      api.getGlobalObjects = () => ({
        globalSources,
        zoneSymbolEventNames: zoneSymbolEventNames$1,
        eventNames,
        isBrowser,
        isMix,
        isNode,
        TRUE_STR,
        FALSE_STR,
        ZONE_SYMBOL_PREFIX,
        ADD_EVENT_LISTENER_STR,
        REMOVE_EVENT_LISTENER_STR
      });
    });
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * @fileoverview
     * @suppress {missingRequire}
     */


    const taskSymbol = zoneSymbol('zoneTask');

    function patchTimer(window, setName, cancelName, nameSuffix) {
      let setNative = null;
      let clearNative = null;
      setName += nameSuffix;
      cancelName += nameSuffix;
      const tasksByHandleId = {};

      function scheduleTask(task) {
        const data = task.data;

        function timer() {
          try {
            task.invoke.apply(this, arguments);
          } finally {
            // issue-934, task will be cancelled
            // even it is a periodic task such as
            // setInterval
            if (!(task.data && task.data.isPeriodic)) {
              if (typeof data.handleId === 'number') {
                // in non-nodejs env, we remove timerId
                // from local cache
                delete tasksByHandleId[data.handleId];
              } else if (data.handleId) {
                // Node returns complex objects as handleIds
                // we remove task reference from timer object
                data.handleId[taskSymbol] = null;
              }
            }
          }
        }

        data.args[0] = timer;
        data.handleId = setNative.apply(window, data.args);
        return task;
      }

      function clearTask(task) {
        return clearNative(task.data.handleId);
      }

      setNative = patchMethod(window, setName, delegate => function (self, args) {
        if (typeof args[0] === 'function') {
          const options = {
            isPeriodic: nameSuffix === 'Interval',
            delay: nameSuffix === 'Timeout' || nameSuffix === 'Interval' ? args[1] || 0 : undefined,
            args: args
          };
          const task = scheduleMacroTaskWithCurrentZone(setName, args[0], options, scheduleTask, clearTask);

          if (!task) {
            return task;
          } // Node.js must additionally support the ref and unref functions.


          const handle = task.data.handleId;

          if (typeof handle === 'number') {
            // for non nodejs env, we save handleId: task
            // mapping in local cache for clearTimeout
            tasksByHandleId[handle] = task;
          } else if (handle) {
            // for nodejs env, we save task
            // reference in timerId Object for clearTimeout
            handle[taskSymbol] = task;
          } // check whether handle is null, because some polyfill or browser
          // may return undefined from setTimeout/setInterval/setImmediate/requestAnimationFrame


          if (handle && handle.ref && handle.unref && typeof handle.ref === 'function' && typeof handle.unref === 'function') {
            task.ref = handle.ref.bind(handle);
            task.unref = handle.unref.bind(handle);
          }

          if (typeof handle === 'number' || handle) {
            return handle;
          }

          return task;
        } else {
          // cause an error by calling it directly.
          return delegate.apply(window, args);
        }
      });
      clearNative = patchMethod(window, cancelName, delegate => function (self, args) {
        const id = args[0];
        let task;

        if (typeof id === 'number') {
          // non nodejs env.
          task = tasksByHandleId[id];
        } else {
          // nodejs env.
          task = id && id[taskSymbol]; // other environments.

          if (!task) {
            task = id;
          }
        }

        if (task && typeof task.type === 'string') {
          if (task.state !== 'notScheduled' && (task.cancelFn && task.data.isPeriodic || task.runCount === 0)) {
            if (typeof id === 'number') {
              delete tasksByHandleId[id];
            } else if (id) {
              id[taskSymbol] = null;
            } // Do not cancel already canceled functions


            task.zone.cancelTask(task);
          }
        } else {
          // cause an error by calling it directly.
          delegate.apply(window, args);
        }
      });
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    function patchCustomElements(_global, api) {
      const {
        isBrowser,
        isMix
      } = api.getGlobalObjects();

      if (!isBrowser && !isMix || !_global['customElements'] || !('customElements' in _global)) {
        return;
      }

      const callbacks = ['connectedCallback', 'disconnectedCallback', 'adoptedCallback', 'attributeChangedCallback'];
      api.patchCallbacks(api, _global.customElements, 'customElements', 'define', callbacks);
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */


    function eventTargetPatch(_global, api) {
      if (Zone[api.symbol('patchEventTarget')]) {
        // EventTarget is already patched.
        return;
      }

      const {
        eventNames,
        zoneSymbolEventNames,
        TRUE_STR,
        FALSE_STR,
        ZONE_SYMBOL_PREFIX
      } = api.getGlobalObjects(); //  predefine all __zone_symbol__ + eventName + true/false string

      for (let i = 0; i < eventNames.length; i++) {
        const eventName = eventNames[i];
        const falseEventName = eventName + FALSE_STR;
        const trueEventName = eventName + TRUE_STR;
        const symbol = ZONE_SYMBOL_PREFIX + falseEventName;
        const symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;
        zoneSymbolEventNames[eventName] = {};
        zoneSymbolEventNames[eventName][FALSE_STR] = symbol;
        zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;
      }

      const EVENT_TARGET = _global['EventTarget'];

      if (!EVENT_TARGET || !EVENT_TARGET.prototype) {
        return;
      }

      api.patchEventTarget(_global, [EVENT_TARGET && EVENT_TARGET.prototype]);
      return true;
    }

    function patchEvent(global, api) {
      api.patchEventPrototype(global, api);
    }
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /**
     * @fileoverview
     * @suppress {missingRequire}
     */


    Zone.__load_patch('legacy', global => {
      const legacyPatch = global[Zone.__symbol__('legacyPatch')];

      if (legacyPatch) {
        legacyPatch();
      }
    });

    Zone.__load_patch('timers', global => {
      const set = 'set';
      const clear = 'clear';
      patchTimer(global, set, clear, 'Timeout');
      patchTimer(global, set, clear, 'Interval');
      patchTimer(global, set, clear, 'Immediate');
    });

    Zone.__load_patch('requestAnimationFrame', global => {
      patchTimer(global, 'request', 'cancel', 'AnimationFrame');
      patchTimer(global, 'mozRequest', 'mozCancel', 'AnimationFrame');
      patchTimer(global, 'webkitRequest', 'webkitCancel', 'AnimationFrame');
    });

    Zone.__load_patch('blocking', (global, Zone) => {
      const blockingMethods = ['alert', 'prompt', 'confirm'];

      for (let i = 0; i < blockingMethods.length; i++) {
        const name = blockingMethods[i];
        patchMethod(global, name, (delegate, symbol, name) => {
          return function (s, args) {
            return Zone.current.run(delegate, global, args, name);
          };
        });
      }
    });

    Zone.__load_patch('EventTarget', (global, Zone, api) => {
      patchEvent(global, api);
      eventTargetPatch(global, api); // patch XMLHttpRequestEventTarget's addEventListener/removeEventListener

      const XMLHttpRequestEventTarget = global['XMLHttpRequestEventTarget'];

      if (XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype) {
        api.patchEventTarget(global, [XMLHttpRequestEventTarget.prototype]);
      }

      patchClass('MutationObserver');
      patchClass('WebKitMutationObserver');
      patchClass('IntersectionObserver');
      patchClass('FileReader');
    });

    Zone.__load_patch('on_property', (global, Zone, api) => {
      propertyDescriptorPatch(api, global);
      propertyPatch();
    });

    Zone.__load_patch('customElements', (global, Zone, api) => {
      patchCustomElements(global, api);
    });

    Zone.__load_patch('XHR', (global, Zone) => {
      // Treat XMLHttpRequest as a macrotask.
      patchXHR(global);
      const XHR_TASK = zoneSymbol('xhrTask');
      const XHR_SYNC = zoneSymbol('xhrSync');
      const XHR_LISTENER = zoneSymbol('xhrListener');
      const XHR_SCHEDULED = zoneSymbol('xhrScheduled');
      const XHR_URL = zoneSymbol('xhrURL');
      const XHR_ERROR_BEFORE_SCHEDULED = zoneSymbol('xhrErrorBeforeScheduled');

      function patchXHR(window) {
        const XMLHttpRequest = window['XMLHttpRequest'];

        if (!XMLHttpRequest) {
          // XMLHttpRequest is not available in service worker
          return;
        }

        const XMLHttpRequestPrototype = XMLHttpRequest.prototype;

        function findPendingTask(target) {
          return target[XHR_TASK];
        }

        let oriAddListener = XMLHttpRequestPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];
        let oriRemoveListener = XMLHttpRequestPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];

        if (!oriAddListener) {
          const XMLHttpRequestEventTarget = window['XMLHttpRequestEventTarget'];

          if (XMLHttpRequestEventTarget) {
            const XMLHttpRequestEventTargetPrototype = XMLHttpRequestEventTarget.prototype;
            oriAddListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];
            oriRemoveListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
          }
        }

        const READY_STATE_CHANGE = 'readystatechange';
        const SCHEDULED = 'scheduled';

        function scheduleTask(task) {
          const data = task.data;
          const target = data.target;
          target[XHR_SCHEDULED] = false;
          target[XHR_ERROR_BEFORE_SCHEDULED] = false; // remove existing event listener

          const listener = target[XHR_LISTENER];

          if (!oriAddListener) {
            oriAddListener = target[ZONE_SYMBOL_ADD_EVENT_LISTENER];
            oriRemoveListener = target[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];
          }

          if (listener) {
            oriRemoveListener.call(target, READY_STATE_CHANGE, listener);
          }

          const newListener = target[XHR_LISTENER] = () => {
            if (target.readyState === target.DONE) {
              // sometimes on some browsers XMLHttpRequest will fire onreadystatechange with
              // readyState=4 multiple times, so we need to check task state here
              if (!data.aborted && target[XHR_SCHEDULED] && task.state === SCHEDULED) {
                // check whether the xhr has registered onload listener
                // if that is the case, the task should invoke after all
                // onload listeners finish.
                const loadTasks = target['__zone_symbol__loadfalse'];

                if (loadTasks && loadTasks.length > 0) {
                  const oriInvoke = task.invoke;

                  task.invoke = function () {
                    // need to load the tasks again, because in other
                    // load listener, they may remove themselves
                    const loadTasks = target['__zone_symbol__loadfalse'];

                    for (let i = 0; i < loadTasks.length; i++) {
                      if (loadTasks[i] === task) {
                        loadTasks.splice(i, 1);
                      }
                    }

                    if (!data.aborted && task.state === SCHEDULED) {
                      oriInvoke.call(task);
                    }
                  };

                  loadTasks.push(task);
                } else {
                  task.invoke();
                }
              } else if (!data.aborted && target[XHR_SCHEDULED] === false) {
                // error occurs when xhr.send()
                target[XHR_ERROR_BEFORE_SCHEDULED] = true;
              }
            }
          };

          oriAddListener.call(target, READY_STATE_CHANGE, newListener);
          const storedTask = target[XHR_TASK];

          if (!storedTask) {
            target[XHR_TASK] = task;
          }

          sendNative.apply(target, data.args);
          target[XHR_SCHEDULED] = true;
          return task;
        }

        function placeholderCallback() {}

        function clearTask(task) {
          const data = task.data; // Note - ideally, we would call data.target.removeEventListener here, but it's too late
          // to prevent it from firing. So instead, we store info for the event listener.

          data.aborted = true;
          return abortNative.apply(data.target, data.args);
        }

        const openNative = patchMethod(XMLHttpRequestPrototype, 'open', () => function (self, args) {
          self[XHR_SYNC] = args[2] == false;
          self[XHR_URL] = args[1];
          return openNative.apply(self, args);
        });
        const XMLHTTPREQUEST_SOURCE = 'XMLHttpRequest.send';
        const fetchTaskAborting = zoneSymbol('fetchTaskAborting');
        const fetchTaskScheduling = zoneSymbol('fetchTaskScheduling');
        const sendNative = patchMethod(XMLHttpRequestPrototype, 'send', () => function (self, args) {
          if (Zone.current[fetchTaskScheduling] === true) {
            // a fetch is scheduling, so we are using xhr to polyfill fetch
            // and because we already schedule macroTask for fetch, we should
            // not schedule a macroTask for xhr again
            return sendNative.apply(self, args);
          }

          if (self[XHR_SYNC]) {
            // if the XHR is sync there is no task to schedule, just execute the code.
            return sendNative.apply(self, args);
          } else {
            const options = {
              target: self,
              url: self[XHR_URL],
              isPeriodic: false,
              args: args,
              aborted: false
            };
            const task = scheduleMacroTaskWithCurrentZone(XMLHTTPREQUEST_SOURCE, placeholderCallback, options, scheduleTask, clearTask);

            if (self && self[XHR_ERROR_BEFORE_SCHEDULED] === true && !options.aborted && task.state === SCHEDULED) {
              // xhr request throw error when send
              // we should invoke task instead of leaving a scheduled
              // pending macroTask
              task.invoke();
            }
          }
        });
        const abortNative = patchMethod(XMLHttpRequestPrototype, 'abort', () => function (self, args) {
          const task = findPendingTask(self);

          if (task && typeof task.type == 'string') {
            // If the XHR has already completed, do nothing.
            // If the XHR has already been aborted, do nothing.
            // Fix #569, call abort multiple times before done will cause
            // macroTask task count be negative number
            if (task.cancelFn == null || task.data && task.data.aborted) {
              return;
            }

            task.zone.cancelTask(task);
          } else if (Zone.current[fetchTaskAborting] === true) {
            // the abort is called from fetch polyfill, we need to call native abort of XHR.
            return abortNative.apply(self, args);
          } // Otherwise, we are trying to abort an XHR which has not yet been sent, so there is no
          // task
          // to cancel. Do nothing.

        });
      }
    });

    Zone.__load_patch('geolocation', global => {
      /// GEO_LOCATION
      if (global['navigator'] && global['navigator'].geolocation) {
        patchPrototype(global['navigator'].geolocation, ['getCurrentPosition', 'watchPosition']);
      }
    });

    Zone.__load_patch('PromiseRejectionEvent', (global, Zone) => {
      // handle unhandled promise rejection
      function findPromiseRejectionHandler(evtName) {
        return function (e) {
          const eventTasks = findEventTasks(global, evtName);
          eventTasks.forEach(eventTask => {
            // windows has added unhandledrejection event listener
            // trigger the event listener
            const PromiseRejectionEvent = global['PromiseRejectionEvent'];

            if (PromiseRejectionEvent) {
              const evt = new PromiseRejectionEvent(evtName, {
                promise: e.promise,
                reason: e.rejection
              });
              eventTask.invoke(evt);
            }
          });
        };
      }

      if (global['PromiseRejectionEvent']) {
        Zone[zoneSymbol('unhandledPromiseRejectionHandler')] = findPromiseRejectionHandler('unhandledrejection');
        Zone[zoneSymbol('rejectionHandledHandler')] = findPromiseRejectionHandler('rejectionhandled');
      }
    });
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */

    /***/

  },

  /***/
  "./node_modules/zone.js/dist/zone-legacy.js":
  /*!**************************************************!*\
    !*** ./node_modules/zone.js/dist/zone-legacy.js ***!
    \**************************************************/

  /*! no static exports found */

  /***/
  function node_modulesZoneJsDistZoneLegacyJs(module, exports, __webpack_require__) {
    /**
    * @license
    * Copyright Google Inc. All Rights Reserved.
    *
    * Use of this source code is governed by an MIT-style license that can be
    * found in the LICENSE file at https://angular.io/license
    */
    (function (global, factory) {
      true ? factory() : undefined;
    })(this, function () {
      'use strict';
      /**
       * @license
       * Copyright Google Inc. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      function eventTargetLegacyPatch(_global, api) {
        var _a = api.getGlobalObjects(),
            eventNames = _a.eventNames,
            globalSources = _a.globalSources,
            zoneSymbolEventNames = _a.zoneSymbolEventNames,
            TRUE_STR = _a.TRUE_STR,
            FALSE_STR = _a.FALSE_STR,
            ZONE_SYMBOL_PREFIX = _a.ZONE_SYMBOL_PREFIX;

        var WTF_ISSUE_555 = 'Anchor,Area,Audio,BR,Base,BaseFont,Body,Button,Canvas,Content,DList,Directory,Div,Embed,FieldSet,Font,Form,Frame,FrameSet,HR,Head,Heading,Html,IFrame,Image,Input,Keygen,LI,Label,Legend,Link,Map,Marquee,Media,Menu,Meta,Meter,Mod,OList,Object,OptGroup,Option,Output,Paragraph,Pre,Progress,Quote,Script,Select,Source,Span,Style,TableCaption,TableCell,TableCol,Table,TableRow,TableSection,TextArea,Title,Track,UList,Unknown,Video';
        var NO_EVENT_TARGET = 'ApplicationCache,EventSource,FileReader,InputMethodContext,MediaController,MessagePort,Node,Performance,SVGElementInstance,SharedWorker,TextTrack,TextTrackCue,TextTrackList,WebKitNamedFlow,Window,Worker,WorkerGlobalScope,XMLHttpRequest,XMLHttpRequestEventTarget,XMLHttpRequestUpload,IDBRequest,IDBOpenDBRequest,IDBDatabase,IDBTransaction,IDBCursor,DBIndex,WebSocket'.split(',');
        var EVENT_TARGET = 'EventTarget';
        var apis = [];
        var isWtf = _global['wtf'];
        var WTF_ISSUE_555_ARRAY = WTF_ISSUE_555.split(',');

        if (isWtf) {
          // Workaround for: https://github.com/google/tracing-framework/issues/555
          apis = WTF_ISSUE_555_ARRAY.map(function (v) {
            return 'HTML' + v + 'Element';
          }).concat(NO_EVENT_TARGET);
        } else if (_global[EVENT_TARGET]) {
          apis.push(EVENT_TARGET);
        } else {
          // Note: EventTarget is not available in all browsers,
          // if it's not available, we instead patch the APIs in the IDL that inherit from EventTarget
          apis = NO_EVENT_TARGET;
        }

        var isDisableIECheck = _global['__Zone_disable_IE_check'] || false;
        var isEnableCrossContextCheck = _global['__Zone_enable_cross_context_check'] || false;
        var ieOrEdge = api.isIEOrEdge();
        var ADD_EVENT_LISTENER_SOURCE = '.addEventListener:';
        var FUNCTION_WRAPPER = '[object FunctionWrapper]';
        var BROWSER_TOOLS = 'function __BROWSERTOOLS_CONSOLE_SAFEFUNC() { [native code] }'; //  predefine all __zone_symbol__ + eventName + true/false string

        for (var i = 0; i < eventNames.length; i++) {
          var eventName = eventNames[i];
          var falseEventName = eventName + FALSE_STR;
          var trueEventName = eventName + TRUE_STR;
          var symbol = ZONE_SYMBOL_PREFIX + falseEventName;
          var symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;
          zoneSymbolEventNames[eventName] = {};
          zoneSymbolEventNames[eventName][FALSE_STR] = symbol;
          zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;
        } //  predefine all task.source string


        for (var i = 0; i < WTF_ISSUE_555.length; i++) {
          var target = WTF_ISSUE_555_ARRAY[i];
          var targets = globalSources[target] = {};

          for (var j = 0; j < eventNames.length; j++) {
            var eventName = eventNames[j];
            targets[eventName] = target + ADD_EVENT_LISTENER_SOURCE + eventName;
          }
        }

        var checkIEAndCrossContext = function checkIEAndCrossContext(nativeDelegate, delegate, target, args) {
          if (!isDisableIECheck && ieOrEdge) {
            if (isEnableCrossContextCheck) {
              try {
                var testString = delegate.toString();

                if (testString === FUNCTION_WRAPPER || testString == BROWSER_TOOLS) {
                  nativeDelegate.apply(target, args);
                  return false;
                }
              } catch (error) {
                nativeDelegate.apply(target, args);
                return false;
              }
            } else {
              var testString = delegate.toString();

              if (testString === FUNCTION_WRAPPER || testString == BROWSER_TOOLS) {
                nativeDelegate.apply(target, args);
                return false;
              }
            }
          } else if (isEnableCrossContextCheck) {
            try {
              delegate.toString();
            } catch (error) {
              nativeDelegate.apply(target, args);
              return false;
            }
          }

          return true;
        };

        var apiTypes = [];

        for (var i = 0; i < apis.length; i++) {
          var type = _global[apis[i]];
          apiTypes.push(type && type.prototype);
        } // vh is validateHandler to check event handler
        // is valid or not(for security check)


        api.patchEventTarget(_global, apiTypes, {
          vh: checkIEAndCrossContext
        });
        Zone[api.symbol('patchEventTarget')] = !!_global[EVENT_TARGET];
        return true;
      }
      /**
       * @license
       * Copyright Google Inc. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      // we have to patch the instance since the proto is non-configurable


      function apply(api, _global) {
        var _a = api.getGlobalObjects(),
            ADD_EVENT_LISTENER_STR = _a.ADD_EVENT_LISTENER_STR,
            REMOVE_EVENT_LISTENER_STR = _a.REMOVE_EVENT_LISTENER_STR;

        var WS = _global.WebSocket; // On Safari window.EventTarget doesn't exist so need to patch WS add/removeEventListener
        // On older Chrome, no need since EventTarget was already patched

        if (!_global.EventTarget) {
          api.patchEventTarget(_global, [WS.prototype]);
        }

        _global.WebSocket = function (x, y) {
          var socket = arguments.length > 1 ? new WS(x, y) : new WS(x);
          var proxySocket;
          var proxySocketProto; // Safari 7.0 has non-configurable own 'onmessage' and friends properties on the socket instance

          var onmessageDesc = api.ObjectGetOwnPropertyDescriptor(socket, 'onmessage');

          if (onmessageDesc && onmessageDesc.configurable === false) {
            proxySocket = api.ObjectCreate(socket); // socket have own property descriptor 'onopen', 'onmessage', 'onclose', 'onerror'
            // but proxySocket not, so we will keep socket as prototype and pass it to
            // patchOnProperties method

            proxySocketProto = socket;
            [ADD_EVENT_LISTENER_STR, REMOVE_EVENT_LISTENER_STR, 'send', 'close'].forEach(function (propName) {
              proxySocket[propName] = function () {
                var args = api.ArraySlice.call(arguments);

                if (propName === ADD_EVENT_LISTENER_STR || propName === REMOVE_EVENT_LISTENER_STR) {
                  var eventName = args.length > 0 ? args[0] : undefined;

                  if (eventName) {
                    var propertySymbol = Zone.__symbol__('ON_PROPERTY' + eventName);

                    socket[propertySymbol] = proxySocket[propertySymbol];
                  }
                }

                return socket[propName].apply(socket, args);
              };
            });
          } else {
            // we can patch the real socket
            proxySocket = socket;
          }

          api.patchOnProperties(proxySocket, ['close', 'error', 'message', 'open'], proxySocketProto);
          return proxySocket;
        };

        var globalWebSocket = _global['WebSocket'];

        for (var prop in WS) {
          globalWebSocket[prop] = WS[prop];
        }
      }
      /**
       * @license
       * Copyright Google Inc. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * @fileoverview
       * @suppress {globalThis}
       */


      function propertyDescriptorLegacyPatch(api, _global) {
        var _a = api.getGlobalObjects(),
            isNode = _a.isNode,
            isMix = _a.isMix;

        if (isNode && !isMix) {
          return;
        }

        if (!canPatchViaPropertyDescriptor(api, _global)) {
          var supportsWebSocket = typeof WebSocket !== 'undefined'; // Safari, Android browsers (Jelly Bean)

          patchViaCapturingAllTheEvents(api);
          api.patchClass('XMLHttpRequest');

          if (supportsWebSocket) {
            apply(api, _global);
          }

          Zone[api.symbol('patchEvents')] = true;
        }
      }

      function canPatchViaPropertyDescriptor(api, _global) {
        var _a = api.getGlobalObjects(),
            isBrowser = _a.isBrowser,
            isMix = _a.isMix;

        if ((isBrowser || isMix) && !api.ObjectGetOwnPropertyDescriptor(HTMLElement.prototype, 'onclick') && typeof Element !== 'undefined') {
          // WebKit https://bugs.webkit.org/show_bug.cgi?id=134364
          // IDL interface attributes are not configurable
          var desc = api.ObjectGetOwnPropertyDescriptor(Element.prototype, 'onclick');
          if (desc && !desc.configurable) return false; // try to use onclick to detect whether we can patch via propertyDescriptor
          // because XMLHttpRequest is not available in service worker

          if (desc) {
            api.ObjectDefineProperty(Element.prototype, 'onclick', {
              enumerable: true,
              configurable: true,
              get: function get() {
                return true;
              }
            });
            var div = document.createElement('div');
            var result = !!div.onclick;
            api.ObjectDefineProperty(Element.prototype, 'onclick', desc);
            return result;
          }
        }

        var XMLHttpRequest = _global['XMLHttpRequest'];

        if (!XMLHttpRequest) {
          // XMLHttpRequest is not available in service worker
          return false;
        }

        var ON_READY_STATE_CHANGE = 'onreadystatechange';
        var XMLHttpRequestPrototype = XMLHttpRequest.prototype;
        var xhrDesc = api.ObjectGetOwnPropertyDescriptor(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE); // add enumerable and configurable here because in opera
        // by default XMLHttpRequest.prototype.onreadystatechange is undefined
        // without adding enumerable and configurable will cause onreadystatechange
        // non-configurable
        // and if XMLHttpRequest.prototype.onreadystatechange is undefined,
        // we should set a real desc instead a fake one

        if (xhrDesc) {
          api.ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, {
            enumerable: true,
            configurable: true,
            get: function get() {
              return true;
            }
          });
          var req = new XMLHttpRequest();
          var result = !!req.onreadystatechange; // restore original desc

          api.ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, xhrDesc || {});
          return result;
        } else {
          var SYMBOL_FAKE_ONREADYSTATECHANGE_1 = api.symbol('fake');
          api.ObjectDefineProperty(XMLHttpRequestPrototype, ON_READY_STATE_CHANGE, {
            enumerable: true,
            configurable: true,
            get: function get() {
              return this[SYMBOL_FAKE_ONREADYSTATECHANGE_1];
            },
            set: function set(value) {
              this[SYMBOL_FAKE_ONREADYSTATECHANGE_1] = value;
            }
          });
          var req = new XMLHttpRequest();

          var detectFunc = function detectFunc() {};

          req.onreadystatechange = detectFunc;
          var result = req[SYMBOL_FAKE_ONREADYSTATECHANGE_1] === detectFunc;
          req.onreadystatechange = null;
          return result;
        }
      } // Whenever any eventListener fires, we check the eventListener target and all parents
      // for `onwhatever` properties and replace them with zone-bound functions
      // - Chrome (for now)


      function patchViaCapturingAllTheEvents(api) {
        var eventNames = api.getGlobalObjects().eventNames;
        var unboundKey = api.symbol('unbound');

        var _loop_1 = function _loop_1(i) {
          var property = eventNames[i];
          var onproperty = 'on' + property;
          self.addEventListener(property, function (event) {
            var elt = event.target,
                bound,
                source;

            if (elt) {
              source = elt.constructor['name'] + '.' + onproperty;
            } else {
              source = 'unknown.' + onproperty;
            }

            while (elt) {
              if (elt[onproperty] && !elt[onproperty][unboundKey]) {
                bound = api.wrapWithCurrentZone(elt[onproperty], source);
                bound[unboundKey] = elt[onproperty];
                elt[onproperty] = bound;
              }

              elt = elt.parentElement;
            }
          }, true);
        };

        for (var i = 0; i < eventNames.length; i++) {
          _loop_1(i);
        }
      }
      /**
       * @license
       * Copyright Google Inc. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */


      function registerElementPatch(_global, api) {
        var _a = api.getGlobalObjects(),
            isBrowser = _a.isBrowser,
            isMix = _a.isMix;

        if (!isBrowser && !isMix || !('registerElement' in _global.document)) {
          return;
        }

        var callbacks = ['createdCallback', 'attachedCallback', 'detachedCallback', 'attributeChangedCallback'];
        api.patchCallbacks(api, document, 'Document', 'registerElement', callbacks);
      }
      /**
       * @license
       * Copyright Google Inc. All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * @fileoverview
       * @suppress {missingRequire}
       */


      (function (_global) {
        _global['__zone_symbol__legacyPatch'] = function () {
          var Zone = _global['Zone'];

          Zone.__load_patch('registerElement', function (global, Zone, api) {
            registerElementPatch(global, api);
          });

          Zone.__load_patch('EventTargetLegacy', function (global, Zone, api) {
            eventTargetLegacyPatch(global, api);
            propertyDescriptorLegacyPatch(api, global);
          });
        };
      })(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);
    });
    /***/

  },

  /***/
  "./src/environments/environment.ts":
  /*!*****************************************!*\
    !*** ./src/environments/environment.ts ***!
    \*****************************************/

  /*! exports provided: environment */

  /***/
  function srcEnvironmentsEnvironmentTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony export (binding) */


    __webpack_require__.d(__webpack_exports__, "environment", function () {
      return environment;
    });
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js"); // This file can be replaced during build by using the `fileReplacements` array.
    // `ng build --prod` replaces `environment.ts` with `environment.prod.ts`.
    // The list of file replacements can be found in `angular.json`.


    const environment = {
      production: true,
      apiUrl: 'https://pte.alchemistacademy.com.au',
      // apiUrl :'http://134.122.17.133:7001',
      // apiUrl :'http://161.35.115.208:7001',  //server
      enableDebug: false
    };
    /*
     * For easier debugging in development mode, you can import the following file
     * to ignore zone related error stack frames such as `zone.run`, `zoneDelegate.invokeTask`.
     *
     * This import should be commented out in production mode because it will have a negative impact
     * on performance if an error is thrown.
     */
    // import 'zone.js/dist/zone-error';  // Included with Angular CLI.

    /***/
  },

  /***/
  "./src/polyfills.ts":
  /*!**************************!*\
    !*** ./src/polyfills.ts ***!
    \**************************/

  /*! no exports provided */

  /***/
  function srcPolyfillsTs(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);
    /* harmony import */


    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
    /*! tslib */
    "./node_modules/tslib/tslib.es6.js");
    /* harmony import */


    var _angular_localize_init__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
    /*! @angular/localize/init */
    "./node_modules/@angular/localize/fesm2015/init.js");
    /* harmony import */


    var _angular_localize_init__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_angular_localize_init__WEBPACK_IMPORTED_MODULE_1__);
    /* harmony import */


    var zone_js_dist_zone__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
    /*! zone.js/dist/zone */
    "./node_modules/zone.js/dist/zone-evergreen.js");
    /* harmony import */


    var zone_js_dist_zone__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(zone_js_dist_zone__WEBPACK_IMPORTED_MODULE_2__);
    /* harmony import */


    var jquery__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
    /*! jquery */
    "./node_modules/jquery/dist/jquery.js");
    /* harmony import */


    var jquery__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_3__);
    /* harmony import */


    var _environments_environment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
    /*! @environments/environment */
    "./src/environments/environment.ts");
    /* harmony import */


    var _angular_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
    /*! @angular/core */
    "./node_modules/@angular/core/fesm2015/core.js");
    /***************************************************************************************************
     * Load `$localize` onto the global scope - used if i18n tags appear in Angular templates.
     */

    /**
     * This file includes polyfills needed by Angular and is loaded before the app.
     * You can add your own extra polyfills to this file.
     *
     * This file is divided into 2 sections:
     *   1. Browser polyfills. These are applied before loading ZoneJS and are sorted by browsers.
     *   2. Application imports. Files imported after ZoneJS that should be loaded before your main
     *      file.
     *
     * The current setup is for so-called "evergreen" browsers; the last versions of browsers that
     * automatically update themselves. This includes Safari >= 10, Chrome >= 55 (including Opera),
     * Edge >= 13 on the desktop, and iOS 10 and Chrome on mobile.
     *
     * Learn more in https://angular.io/guide/browser-support
     */

    /***************************************************************************************************
     * BROWSER POLYFILLS
     */

    /** IE10 and IE11 requires the following for NgClass support on SVG elements */
    // import 'classlist.js';  // Run `npm install --save classlist.js`.

    /**
     * Web Animations `@angular/platform-browser/animations`
     * Only required if AnimationBuilder is used within the application and using IE/Edge or Safari.
     * Standard animation support in Angular DOES NOT require any polyfills (as of Angular 6.0).
     */
    // import 'web-animations-js';  // Run `npm install --save web-animations-js`.

    /**
     * By default, zone.js will patch all possible macroTask and DomEvents
     * user can disable parts of macroTask/DomEvents patch by setting following flags
     * because those flags need to be set before `zone.js` being loaded, and webpack
     * will put import in the top of bundle, so user need to create a separate file
     * in this directory (for example: zone-flags.ts), and put the following flags
     * into that file, and then add the following code before importing zone.js.
     * import './zone-flags.ts';
     *
     * The flags allowed in zone-flags.ts are listed here.
     *
     * The following flags will work for all browsers.
     *
     * (window as any).__Zone_disable_requestAnimationFrame = true; // disable patch requestAnimationFrame
     * (window as any).__Zone_disable_on_property = true; // disable patch onProperty such as onclick
     * (window as any).__zone_symbol__UNPATCHED_EVENTS = ['scroll', 'mousemove']; // disable patch specified eventNames
     *
     *  in IE/Edge developer tools, the addEventListener will also be wrapped by zone.js
     *  with the following flag, it will bypass `zone.js` patch for IE/Edge
     *
     *  (window as any).__Zone_enable_cross_context_check = true;
     *
     */

    /***************************************************************************************************
     * Zone JS is required by default for Angular itself.
     */
    // Included with Angular CLI.


    window['jQuery'] = jquery__WEBPACK_IMPORTED_MODULE_3__;
    window['$'] = jquery__WEBPACK_IMPORTED_MODULE_3__;

    if (_environments_environment__WEBPACK_IMPORTED_MODULE_4__["environment"].production) {
      Object(_angular_core__WEBPACK_IMPORTED_MODULE_5__["enableProdMode"])(); // HACK: Don't log to console in production environment.

      if (window) {
        window.console.log = window.console.warn = window.console.info = function () {// Don't log anything.
        };
      }
    }
    /***************************************************************************************************
     * APPLICATION IMPORTS
     */

    /***/

  },

  /***/
  1:
  /*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
    !*** multi ./node_modules/@angular-devkit/build-angular/src/angular-cli-files/models/es5-polyfills.js zone.js/dist/zone-legacy ./node_modules/@angular-devkit/build-angular/src/angular-cli-files/models/jit-polyfills.js ./node_modules/@angular-devkit/build-angular/src/angular-cli-files/models/es5-jit-polyfills.js ./src/polyfills.ts ***!
    \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************/

  /*! no static exports found */

  /***/
  function _(module, exports, __webpack_require__) {
    __webpack_require__(
    /*! /Users/zunezune/development/angularProject/PTE/pteFrontend/node_modules/@angular-devkit/build-angular/src/angular-cli-files/models/es5-polyfills.js */
    "./node_modules/@angular-devkit/build-angular/src/angular-cli-files/models/es5-polyfills.js");

    __webpack_require__(
    /*! zone.js/dist/zone-legacy */
    "./node_modules/zone.js/dist/zone-legacy.js");

    __webpack_require__(
    /*! /Users/zunezune/development/angularProject/PTE/pteFrontend/node_modules/@angular-devkit/build-angular/src/angular-cli-files/models/jit-polyfills.js */
    "./node_modules/@angular-devkit/build-angular/src/angular-cli-files/models/jit-polyfills.js");

    __webpack_require__(
    /*! /Users/zunezune/development/angularProject/PTE/pteFrontend/node_modules/@angular-devkit/build-angular/src/angular-cli-files/models/es5-jit-polyfills.js */
    "./node_modules/@angular-devkit/build-angular/src/angular-cli-files/models/es5-jit-polyfills.js");

    module.exports = __webpack_require__(
    /*! /Users/zunezune/development/angularProject/PTE/pteFrontend/src/polyfills.ts */
    "./src/polyfills.ts");
    /***/
  }
}, [[1, "runtime"]]]);
//# sourceMappingURL=polyfills-es5.js.map